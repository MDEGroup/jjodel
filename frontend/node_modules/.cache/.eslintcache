[{"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\index.tsx":"1","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\App.tsx":"2","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\joiner\\index.ts":"3","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\alert\\Alert.tsx":"4","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\loader\\Loader.tsx":"5","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\pathChecker\\PathChecker.tsx":"6","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\ExternalLibraries.tsx":"7","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\Tooltip.tsx":"8","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\common\\libraries\\prj_json2xml.js":"9","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\common\\libraries\\prj_xml2json.js":"10","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\joiner\\classes.ts":"11","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\joiner\\types.ts":"12","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\joiner\\proxy.ts":"13","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\redux\\reducer\\reducer.ts":"14","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\joiner\\ExecuteOnRead.ts":"15","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\common\\UObj.ts":"16","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\common\\Log.ts":"17","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\common\\Defaults.ts":"18","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\common\\Geom.ts":"19","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\common\\Uhtml.ts":"20","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\api\\data.ts":"21","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\redux\\createStore.ts":"22","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\redux\\action\\action.ts":"23","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\redux\\selectors\\selectors.ts":"24","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\common\\U.tsx":"25","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\common\\DV.tsx":"26","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\redux\\store.tsx":"27","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\model\\classes\\L.ts":"28","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\model\\classes\\D.ts":"29","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\view\\viewPoint\\viewpoint.ts":"30","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\graph\\graphElement\\GraphDragHandler.ts":"31","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\joiner\\components.tsx":"32","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\index.ts":"33","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\index.ts":"34","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\common\\UX.tsx":"35","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\model\\logicWrapper\\LModelElement.tsx":"36","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\debugtools\\debug.tsx":"37","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\ocl\\ocl.tsx":"38","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\model\\dataStructure\\GraphDataElements.tsx":"39","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\view\\viewElement\\view.tsx":"40","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\graph\\graphElement\\sharedTypes\\sharedTypes.tsx":"41","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\common\\Dummy.ts":"42","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\data\\storage.ts":"43","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\common\\SimpleTree.ts":"44","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\collaborative\\Collaborative.ts":"45","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\DSL\\DSL.ts":"46","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\redux\\VersionFixer.ts":"47","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\iot\\IoT.ts":"48","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\redux\\defaults\\views.ts":"49","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\graph\\graphElement\\graphElement.tsx":"50","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\Input.tsx":"51","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\Selector.tsx":"52","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\Account.tsx":"53","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\AllProjects.tsx":"54","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\Auth.tsx":"55","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\Project.tsx":"56","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\Updates.tsx":"57","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\Dashboard.tsx":"58","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\LeftBar.tsx":"59","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\Project.tsx":"60","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\Navbar.tsx":"61","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\BottomBar.tsx":"62","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\Aliases.tsx":"63","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\GenericInput.tsx":"64","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\Try.tsx":"65","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\ControlPanel.tsx":"66","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\Overlap.tsx":"67","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\Control.tsx":"68","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\Archive.tsx":"69","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\Measurable.tsx":"70","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\Community.tsx":"71","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\Profile.tsx":"72","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\Settings.tsx":"73","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\Notes.tsx":"74","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\Recent.tsx":"75","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\Error.tsx":"76","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\Templates.tsx":"77","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\News.tsx":"78","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\UsersInfo.tsx":"79","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\ProjectsInfo.tsx":"80","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\graph\\vertex\\Vertex.tsx":"81","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\graph\\damedges\\damedge.tsx":"82","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\graph\\vertex\\Shapes.tsx":"83","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\graph\\defaultNode\\DefaultNode.tsx":"84","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\graph\\graph\\graphContainer.tsx":"85","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\logger\\DataOutput.tsx":"86","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\logger\\loggerComponent.tsx":"87","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\api\\persistance\\index.ts":"88","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\SizeInput.tsx":"89","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\cards\\Cards.tsx":"90","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\menu\\Menu.tsx":"91","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\catalog\\Catalog.tsx":"92","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\abstract\\DockManager.ts":"93","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\about\\About.tsx":"94","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\topbar\\undoredocomponent.tsx":"95","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\api\\persistance\\admin.ts":"96","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\abstract\\tabs\\TabDataMaker.tsx":"97","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\languages\\index.ts":"98","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\api\\persistance\\projects.ts":"99","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\api\\persistance\\users.ts":"100","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\api\\persistance\\auth.ts":"101","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\topbar\\SaveManager.ts":"102","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\abstract\\Dock.tsx":"103","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\hooks\\useQuery.ts":"104","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\popups\\index.ts":"105","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\commandbar\\CommandBar.tsx":"106","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\icons\\Icons.tsx":"107","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\collaborative\\CollaborativeAttacher.tsx":"108","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\LatestUpdates.tsx":"109","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\Edit\\Edit.tsx":"110","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\data\\api.ts":"111","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\abstract\\tabs\\MetamodelTab.tsx":"112","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\abstract\\tabs\\ModelTab.tsx":"113","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\languages\\Ocl.tsx":"114","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\languages\\Jsx.tsx":"115","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\languages\\Js.tsx":"116","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\PermissionModelTab.tsx":"117","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\popups\\Model.tsx":"118","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\popups\\Metamodel.tsx":"119","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\abstract\\tabs\\ModelsSummaryTab.tsx":"120","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\Broker.tsx":"121","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\NodeEditor.tsx":"122","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\dock\\MyRcDock.tsx":"123","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\metrics\\Metrics.tsx":"124","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\contextMenu\\ContextMenu.tsx":"125","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\toolbar\\ToolBar.tsx":"126","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\languages\\Javascript.tsx":"127","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\index.ts":"128","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\Empty.tsx":"129","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\dock\\MyDock.tsx":"130","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\ModellingIcon.tsx":"131","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\model\\logicWrapper\\index.ts":"132","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\Collaborative.tsx":"133","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\NestedView.tsx":"134","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\MetaData.tsx":"135","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\Info.tsx":"136","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\Logger.tsx":"137","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\Settings.tsx":"138","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\Console.tsx":"139","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\Skeleton.tsx":"140","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\api\\memorec\\index.ts":"141","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\ViewData.tsx":"142","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\Tree.tsx":"143","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\data\\ComponentsTab.tsx":"144","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\data\\PermissionViewpointTab.tsx":"145","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\data\\PermissionViewTab.tsx":"146","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\data\\PaletteData.tsx":"147","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\data\\GenericNodeData.tsx":"148","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\data\\CustomData.tsx":"149","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\data\\TemplateData.tsx":"150","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\data\\InfoData.tsx":"151","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\tooltip\\MyTooltip.tsx":"152","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\Color.tsx":"153","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\data\\EdgePointData.tsx":"154","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\data\\EdgeData.tsx":"155","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\data\\FieldData.tsx":"156","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\data\\GraphData.tsx":"157","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\FunctionComponent.tsx":"158","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\data\\NodeData.tsx":"159","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\widgets\\Widgets.tsx":"160","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\alert\\Dialog.tsx":"161","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\logo.tsx":"162","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\common\\libraries\\projectModified.ts":"163","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\MTM.tsx":"164"},{"size":725,"mtime":1738290096843,"results":"165","hashOfConfig":"166"},{"size":6723,"mtime":1741744097120,"results":"167","hashOfConfig":"166"},{"size":12017,"mtime":1739244859586,"results":"168","hashOfConfig":"166"},{"size":2667,"mtime":1739235522320,"results":"169","hashOfConfig":"166"},{"size":583,"mtime":1738290096680,"results":"170","hashOfConfig":"166"},{"size":520,"mtime":1738290096701,"results":"171","hashOfConfig":"166"},{"size":822,"mtime":1741490917141,"results":"172","hashOfConfig":"166"},{"size":11289,"mtime":1741490626461,"results":"173","hashOfConfig":"166"},{"size":1524,"mtime":1738290096552,"results":"174","hashOfConfig":"166"},{"size":6369,"mtime":1738290096554,"results":"175","hashOfConfig":"166"},{"size":182887,"mtime":1741882121282,"results":"176","hashOfConfig":"166"},{"size":10123,"mtime":1738290096861,"results":"177","hashOfConfig":"166"},{"size":23838,"mtime":1738290096857,"results":"178","hashOfConfig":"166"},{"size":66422,"mtime":1742011573928,"results":"179","hashOfConfig":"166"},{"size":4961,"mtime":1739235522429,"results":"180","hashOfConfig":"166"},{"size":9529,"mtime":1739844886252,"results":"181","hashOfConfig":"166"},{"size":10071,"mtime":1741827759173,"results":"182","hashOfConfig":"166"},{"size":1670,"mtime":1738290096531,"results":"183","hashOfConfig":"166"},{"size":57742,"mtime":1741147898729,"results":"184","hashOfConfig":"166"},{"size":1234,"mtime":1738290096544,"results":"185","hashOfConfig":"166"},{"size":62293,"mtime":1741531970871,"results":"186","hashOfConfig":"166"},{"size":357,"mtime":1738290096950,"results":"187","hashOfConfig":"166"},{"size":31753,"mtime":1738290096950,"results":"188","hashOfConfig":"166"},{"size":41416,"mtime":1741836283866,"results":"189","hashOfConfig":"166"},{"size":145789,"mtime":1742013710810,"results":"190","hashOfConfig":"166"},{"size":32385,"mtime":1742008515908,"results":"191","hashOfConfig":"166"},{"size":21004,"mtime":1742003890329,"results":"192","hashOfConfig":"166"},{"size":341,"mtime":1738290096864,"results":"193","hashOfConfig":"166"},{"size":514,"mtime":1738290096863,"results":"194","hashOfConfig":"166"},{"size":2365,"mtime":1738290097087,"results":"195","hashOfConfig":"166"},{"size":1505,"mtime":1738290096821,"results":"196","hashOfConfig":"166"},{"size":4575,"mtime":1738290096852,"results":"197","hashOfConfig":"166"},{"size":653,"mtime":1738290096944,"results":"198","hashOfConfig":"166"},{"size":186,"mtime":1738290096931,"results":"199","hashOfConfig":"166"},{"size":25678,"mtime":1741829112163,"results":"200","hashOfConfig":"166"},{"size":362759,"mtime":1741576665866,"results":"201","hashOfConfig":"166"},{"size":8477,"mtime":1738290096717,"results":"202","hashOfConfig":"166"},{"size":10417,"mtime":1741873320091,"results":"203","hashOfConfig":"166"},{"size":161743,"mtime":1741885506724,"results":"204","hashOfConfig":"166"},{"size":86512,"mtime":1741490488594,"results":"205","hashOfConfig":"166"},{"size":9569,"mtime":1741743750555,"results":"206","hashOfConfig":"166"},{"size":8811,"mtime":1740024910791,"results":"207","hashOfConfig":"166"},{"size":886,"mtime":1739235522414,"results":"208","hashOfConfig":"166"},{"size":5395,"mtime":1738290096538,"results":"209","hashOfConfig":"166"},{"size":292,"mtime":1738290096570,"results":"210","hashOfConfig":"166"},{"size":2011,"mtime":1738290096520,"results":"211","hashOfConfig":"166"},{"size":11920,"mtime":1738290096948,"results":"212","hashOfConfig":"166"},{"size":173,"mtime":1738290096845,"results":"213","hashOfConfig":"166"},{"size":25355,"mtime":1738290096952,"results":"214","hashOfConfig":"166"},{"size":78349,"mtime":1742013710846,"results":"215","hashOfConfig":"166"},{"size":25600,"mtime":1741874553684,"results":"216","hashOfConfig":"166"},{"size":7815,"mtime":1739235522361,"results":"217","hashOfConfig":"166"},{"size":9651,"mtime":1739235522591,"results":"218","hashOfConfig":"166"},{"size":5224,"mtime":1740619196662,"results":"219","hashOfConfig":"166"},{"size":31683,"mtime":1739800898768,"results":"220","hashOfConfig":"166"},{"size":5812,"mtime":1740712786332,"results":"221","hashOfConfig":"166"},{"size":9772,"mtime":1739235522610,"results":"222","hashOfConfig":"166"},{"size":20293,"mtime":1741493047734,"results":"223","hashOfConfig":"166"},{"size":9554,"mtime":1739235522623,"results":"224","hashOfConfig":"166"},{"size":11059,"mtime":1739235522629,"results":"225","hashOfConfig":"166"},{"size":29294,"mtime":1741491134451,"results":"226","hashOfConfig":"166"},{"size":3290,"mtime":1739235522614,"results":"227","hashOfConfig":"166"},{"size":578,"mtime":1738290096636,"results":"228","hashOfConfig":"166"},{"size":13671,"mtime":1741875618642,"results":"229","hashOfConfig":"166"},{"size":9890,"mtime":1738290096668,"results":"230","hashOfConfig":"166"},{"size":810,"mtime":1738290096639,"results":"231","hashOfConfig":"166"},{"size":2707,"mtime":1738290096653,"results":"232","hashOfConfig":"166"},{"size":8290,"mtime":1738290096639,"results":"233","hashOfConfig":"166"},{"size":326,"mtime":1738290096890,"results":"234","hashOfConfig":"166"},{"size":27944,"mtime":1738290096650,"results":"235","hashOfConfig":"166"},{"size":332,"mtime":1738290096894,"results":"236","hashOfConfig":"166"},{"size":1273,"mtime":1738290096900,"results":"237","hashOfConfig":"166"},{"size":329,"mtime":1738290096905,"results":"238","hashOfConfig":"166"},{"size":10129,"mtime":1738290096899,"results":"239","hashOfConfig":"166"},{"size":3153,"mtime":1738290096904,"results":"240","hashOfConfig":"166"},{"size":125,"mtime":1738290096897,"results":"241","hashOfConfig":"166"},{"size":10159,"mtime":1738290096906,"results":"242","hashOfConfig":"166"},{"size":328,"mtime":1738290096898,"results":"243","hashOfConfig":"166"},{"size":945,"mtime":1738290096909,"results":"244","hashOfConfig":"166"},{"size":1110,"mtime":1738290096902,"results":"245","hashOfConfig":"166"},{"size":27571,"mtime":1741743790536,"results":"246","hashOfConfig":"166"},{"size":5597,"mtime":1738290096798,"results":"247","hashOfConfig":"166"},{"size":12251,"mtime":1738290096831,"results":"248","hashOfConfig":"166"},{"size":9443,"mtime":1741743219166,"results":"249","hashOfConfig":"166"},{"size":4713,"mtime":1738290096818,"results":"250","hashOfConfig":"166"},{"size":4963,"mtime":1738290096682,"results":"251","hashOfConfig":"166"},{"size":13580,"mtime":1740522455639,"results":"252","hashOfConfig":"166"},{"size":144,"mtime":1738290096527,"results":"253","hashOfConfig":"166"},{"size":6162,"mtime":1738290096660,"results":"254","hashOfConfig":"166"},{"size":2165,"mtime":1739235522643,"results":"255","hashOfConfig":"166"},{"size":3137,"mtime":1739235522676,"results":"256","hashOfConfig":"166"},{"size":7181,"mtime":1739235522656,"results":"257","hashOfConfig":"166"},{"size":864,"mtime":1738290096560,"results":"258","hashOfConfig":"166"},{"size":2012,"mtime":1739235522636,"results":"259","hashOfConfig":"166"},{"size":17127,"mtime":1741491091904,"results":"260","hashOfConfig":"166"},{"size":854,"mtime":1738290096526,"results":"261","hashOfConfig":"166"},{"size":923,"mtime":1738290096566,"results":"262","hashOfConfig":"166"},{"size":148,"mtime":1738290096615,"results":"263","hashOfConfig":"166"},{"size":8911,"mtime":1741490554906,"results":"264","hashOfConfig":"166"},{"size":2611,"mtime":1739235522262,"results":"265","hashOfConfig":"166"},{"size":1080,"mtime":1739674741958,"results":"266","hashOfConfig":"166"},{"size":8318,"mtime":1739764234305,"results":"267","hashOfConfig":"166"},{"size":6656,"mtime":1741831139369,"results":"268","hashOfConfig":"166"},{"size":276,"mtime":1738290096842,"results":"269","hashOfConfig":"166"},{"size":82,"mtime":1738290096940,"results":"270","hashOfConfig":"166"},{"size":4193,"mtime":1739235522330,"results":"271","hashOfConfig":"166"},{"size":6488,"mtime":1740885769728,"results":"272","hashOfConfig":"166"},{"size":1419,"mtime":1738290096572,"results":"273","hashOfConfig":"166"},{"size":910,"mtime":1738290096916,"results":"274","hashOfConfig":"166"},{"size":23162,"mtime":1739235522620,"results":"275","hashOfConfig":"166"},{"size":1771,"mtime":1738290096715,"results":"276","hashOfConfig":"166"},{"size":3532,"mtime":1740023410122,"results":"277","hashOfConfig":"166"},{"size":2725,"mtime":1740024262056,"results":"278","hashOfConfig":"166"},{"size":4091,"mtime":1741875618613,"results":"279","hashOfConfig":"166"},{"size":7351,"mtime":1741875618626,"results":"280","hashOfConfig":"166"},{"size":6214,"mtime":1741875618591,"results":"281","hashOfConfig":"166"},{"size":2209,"mtime":1738290096606,"results":"282","hashOfConfig":"166"},{"size":2310,"mtime":1738290096939,"results":"283","hashOfConfig":"166"},{"size":1891,"mtime":1738290096938,"results":"284","hashOfConfig":"166"},{"size":4044,"mtime":1741491430029,"results":"285","hashOfConfig":"166"},{"size":4379,"mtime":1738290096595,"results":"286","hashOfConfig":"166"},{"size":12429,"mtime":1741874801034,"results":"287","hashOfConfig":"166"},{"size":25322,"mtime":1740922104887,"results":"288","hashOfConfig":"166"},{"size":11650,"mtime":1739235522403,"results":"289","hashOfConfig":"166"},{"size":13863,"mtime":1739235522337,"results":"290","hashOfConfig":"166"},{"size":17699,"mtime":1741831988067,"results":"291","hashOfConfig":"166"},{"size":6865,"mtime":1738290096612,"results":"292","hashOfConfig":"166"},{"size":309,"mtime":1738290096610,"results":"293","hashOfConfig":"166"},{"size":304,"mtime":1738290096598,"results":"294","hashOfConfig":"166"},{"size":21692,"mtime":1738290096582,"results":"295","hashOfConfig":"166"},{"size":2658,"mtime":1738290096651,"results":"296","hashOfConfig":"166"},{"size":928,"mtime":1738290096883,"results":"297","hashOfConfig":"166"},{"size":4041,"mtime":1739235522343,"results":"298","hashOfConfig":"166"},{"size":13239,"mtime":1741875618545,"results":"299","hashOfConfig":"166"},{"size":2349,"mtime":1738290096602,"results":"300","hashOfConfig":"166"},{"size":25790,"mtime":1740841900247,"results":"301","hashOfConfig":"166"},{"size":13420,"mtime":1740578380159,"results":"302","hashOfConfig":"166"},{"size":1797,"mtime":1738290096607,"results":"303","hashOfConfig":"166"},{"size":27443,"mtime":1741830247970,"results":"304","hashOfConfig":"166"},{"size":1484,"mtime":1738290096608,"results":"305","hashOfConfig":"166"},{"size":2391,"mtime":1738290096524,"results":"306","hashOfConfig":"166"},{"size":5512,"mtime":1738290096620,"results":"307","hashOfConfig":"166"},{"size":11171,"mtime":1741829615826,"results":"308","hashOfConfig":"166"},{"size":1216,"mtime":1738290096621,"results":"309","hashOfConfig":"166"},{"size":2425,"mtime":1738290096631,"results":"310","hashOfConfig":"166"},{"size":2707,"mtime":1738290096630,"results":"311","hashOfConfig":"166"},{"size":45736,"mtime":1741875618578,"results":"312","hashOfConfig":"166"},{"size":2608,"mtime":1738290096625,"results":"313","hashOfConfig":"166"},{"size":5188,"mtime":1741875618493,"results":"314","hashOfConfig":"166"},{"size":2588,"mtime":1741875618602,"results":"315","hashOfConfig":"166"},{"size":6014,"mtime":1741875618665,"results":"316","hashOfConfig":"166"},{"size":1427,"mtime":1738290096706,"results":"317","hashOfConfig":"166"},{"size":6403,"mtime":1741875618654,"results":"318","hashOfConfig":"166"},{"size":2210,"mtime":1738290096624,"results":"319","hashOfConfig":"166"},{"size":2166,"mtime":1738290096622,"results":"320","hashOfConfig":"166"},{"size":2654,"mtime":1738290096625,"results":"321","hashOfConfig":"166"},{"size":1437,"mtime":1738290096626,"results":"322","hashOfConfig":"166"},{"size":17629,"mtime":1741875618517,"results":"323","hashOfConfig":"166"},{"size":5226,"mtime":1741874801049,"results":"324","hashOfConfig":"166"},{"size":2285,"mtime":1738290096713,"results":"325","hashOfConfig":"166"},{"size":2795,"mtime":1739235522322,"results":"326","hashOfConfig":"166"},{"size":975,"mtime":1739540532618,"results":"327","hashOfConfig":"166"},{"size":559,"mtime":1739764171299,"results":"328","hashOfConfig":"166"},{"size":9048,"mtime":1740445390678,"results":"329","hashOfConfig":"166"},{"filePath":"330","messages":"331","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},"cto063",{"filePath":"333","messages":"334","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"335","messages":"336","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"337","messages":"338","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"339","messages":"340","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"341","messages":"342","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"343","usedDeprecatedRules":"332"},{"filePath":"344","messages":"345","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"346","messages":"347","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"348","messages":"349","errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"350","usedDeprecatedRules":"351"},{"filePath":"352","messages":"353","errorCount":0,"fatalErrorCount":0,"warningCount":16,"fixableErrorCount":0,"fixableWarningCount":0,"source":"354","usedDeprecatedRules":"351"},{"filePath":"355","messages":"356","errorCount":0,"fatalErrorCount":0,"warningCount":17,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"357","messages":"358","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"359","messages":"360","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"361","usedDeprecatedRules":"332"},{"filePath":"362","messages":"363","errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"364","messages":"365","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"366","messages":"367","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"368","messages":"369","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"370","messages":"371","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"372","messages":"373","errorCount":0,"fatalErrorCount":0,"warningCount":24,"fixableErrorCount":0,"fixableWarningCount":0,"source":"374","usedDeprecatedRules":"332"},{"filePath":"375","messages":"376","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"377","messages":"378","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"379","usedDeprecatedRules":"332"},{"filePath":"380","messages":"381","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"382","messages":"383","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"384","messages":"385","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"386","messages":"387","errorCount":0,"fatalErrorCount":0,"warningCount":43,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"388","messages":"389","errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"390","messages":"391","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"392","messages":"393","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"394","messages":"395","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"396","messages":"397","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"398","messages":"399","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"400","messages":"401","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"402","messages":"403","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"404","messages":"405","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"406","messages":"407","errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"408","messages":"409","errorCount":0,"fatalErrorCount":0,"warningCount":21,"fixableErrorCount":0,"fixableWarningCount":5,"source":"410","usedDeprecatedRules":"332"},{"filePath":"411","messages":"412","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"413","messages":"414","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"415","messages":"416","errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"417","messages":"418","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"419","messages":"420","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"421","usedDeprecatedRules":"332"},{"filePath":"422","messages":"423","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"424","usedDeprecatedRules":"332"},{"filePath":"425","messages":"426","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"427","messages":"428","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"429","usedDeprecatedRules":"332"},{"filePath":"430","messages":"431","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"432","messages":"433","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"434","messages":"435","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"436","messages":"437","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"438","messages":"439","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"440","messages":"441","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"442","messages":"443","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"444","messages":"445","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"446","usedDeprecatedRules":"332"},{"filePath":"447","messages":"448","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"449","messages":"450","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"451","usedDeprecatedRules":"332"},{"filePath":"452","messages":"453","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"454","usedDeprecatedRules":"332"},{"filePath":"455","messages":"456","errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"457","usedDeprecatedRules":"332"},{"filePath":"458","messages":"459","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"460","usedDeprecatedRules":"332"},{"filePath":"461","messages":"462","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"463","usedDeprecatedRules":"332"},{"filePath":"464","messages":"465","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"466","usedDeprecatedRules":"332"},{"filePath":"467","messages":"468","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"469","usedDeprecatedRules":"332"},{"filePath":"470","messages":"471","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"472","usedDeprecatedRules":"332"},{"filePath":"473","messages":"474","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"475","usedDeprecatedRules":"332"},{"filePath":"476","messages":"477","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"478","messages":"479","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"480","messages":"481","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"482","usedDeprecatedRules":"332"},{"filePath":"483","messages":"484","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"485","messages":"486","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"487","messages":"488","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"489","usedDeprecatedRules":"332"},{"filePath":"490","messages":"491","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"492","messages":"493","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"494","usedDeprecatedRules":"332"},{"filePath":"495","messages":"496","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"497","messages":"498","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"499","usedDeprecatedRules":"332"},{"filePath":"500","messages":"501","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"502","messages":"503","errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"504","usedDeprecatedRules":"332"},{"filePath":"505","messages":"506","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"507","usedDeprecatedRules":"332"},{"filePath":"508","messages":"509","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"510","messages":"511","errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"512","usedDeprecatedRules":"332"},{"filePath":"513","messages":"514","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"515","messages":"516","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"517","messages":"518","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"519","messages":"520","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"521","usedDeprecatedRules":"332"},{"filePath":"522","messages":"523","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"524","usedDeprecatedRules":"332"},{"filePath":"525","messages":"526","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"527","usedDeprecatedRules":"332"},{"filePath":"528","messages":"529","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"530","usedDeprecatedRules":"332"},{"filePath":"531","messages":"532","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"533","usedDeprecatedRules":"332"},{"filePath":"534","messages":"535","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"536","usedDeprecatedRules":"332"},{"filePath":"537","messages":"538","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"539","messages":"540","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"541","messages":"542","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"543","usedDeprecatedRules":"332"},{"filePath":"544","messages":"545","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"546","messages":"547","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"548","messages":"549","errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"550","usedDeprecatedRules":"332"},{"filePath":"551","messages":"552","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"553","messages":"554","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"555","usedDeprecatedRules":"332"},{"filePath":"556","messages":"557","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"558","usedDeprecatedRules":"332"},{"filePath":"559","messages":"560","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"561","messages":"562","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"563","messages":"564","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"565","messages":"566","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"567","messages":"568","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"569","messages":"570","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"571","messages":"572","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"573","usedDeprecatedRules":"332"},{"filePath":"574","messages":"575","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"576","messages":"577","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"578","messages":"579","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"580","messages":"581","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"582","usedDeprecatedRules":"332"},{"filePath":"583","messages":"584","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"585","usedDeprecatedRules":"332"},{"filePath":"586","messages":"587","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"588","usedDeprecatedRules":"332"},{"filePath":"589","messages":"590","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"591","messages":"592","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"593","messages":"594","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"595","messages":"596","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"597","usedDeprecatedRules":"332"},{"filePath":"598","messages":"599","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"600","messages":"601","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"602","messages":"603","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"604","messages":"605","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"606","messages":"607","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"608","messages":"609","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"610","messages":"611","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"612","messages":"613","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"614","messages":"615","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"616","messages":"617","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"618","messages":"619","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"620","messages":"621","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"622","messages":"623","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"624","messages":"625","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"626","messages":"627","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"628","messages":"629","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"630","messages":"631","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"632","messages":"633","errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"634","usedDeprecatedRules":"332"},{"filePath":"635","messages":"636","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"637","usedDeprecatedRules":"332"},{"filePath":"638","messages":"639","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"640","messages":"641","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"642","usedDeprecatedRules":"332"},{"filePath":"643","messages":"644","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"645","messages":"646","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"647","messages":"648","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"649","messages":"650","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"651","messages":"652","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"653","messages":"654","errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"655","messages":"656","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"657","messages":"658","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"659","messages":"660","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"661","messages":"662","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"663","messages":"664","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"665","messages":"666","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"667","messages":"668","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"669","messages":"670","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"671","messages":"672","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"673","messages":"674","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"675","messages":"676","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"677","messages":"678","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"679","messages":"680","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"681","messages":"682","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"683","messages":"684","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"685","messages":"686","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"687","messages":"688","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"689","messages":"690","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"691","messages":"692","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"693","messages":"694","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"695","messages":"696","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"697","messages":"698","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"699","messages":"700","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"701","messages":"702","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},{"filePath":"703","messages":"704","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"332"},"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\index.tsx",[],["705","706"],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\App.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\joiner\\index.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\alert\\Alert.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\loader\\Loader.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\pathChecker\\PathChecker.tsx",["707"],"import {useLocation} from \"react-router-dom\";\r\nimport {useEffect, useState} from \"react\";\r\nimport {U} from \"../../joiner\";\r\n\r\ntype Props = {};\r\nfunction PathChecker(props: Props) {\r\n    const {pathname} = useLocation();\r\n    const [renders, setRenders] = useState(0);\r\n\r\n    useEffect(() => {\r\n        const newRenders = renders + 1;\r\n        if(/*pathname === '/project' && */newRenders > 1) U.resetState();\r\n        setRenders(newRenders);\r\n    }, [pathname]);\r\n\r\n    return(<></>);\r\n}\r\n\r\nexport default PathChecker;\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\ExternalLibraries.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\Tooltip.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\common\\libraries\\prj_json2xml.js",["708","709","710","711","712","713"],"/*\tThis work is licensed under Creative Commons GNU LGPL License.\r\n\r\n\tLicense: http://creativecommons.org/licenses/LGPL/2.1/\r\n   Version: 0.9\r\n\tAuthor:  Stefan Goessner/2006\r\n\tWeb:     http://goessner.net/ \r\n*/\r\nexport function json2xml(o, tab/*string, string*/) {\r\n   var toXml = function(v, name, ind) {\r\n      var xml = \"\";\r\n      if (v instanceof Array) {\r\n         for (var i=0, n=v.length; i<n; i++)\r\n            xml += ind + toXml(v[i], name, ind+\"\\t\") + \"\\n\";\r\n      }\r\n      else if (typeof(v) == \"object\") {\r\n         var hasChild = false;\r\n         xml += ind + \"<\" + name;\r\n         for (var m in v) {\r\n            if (m.charAt(0) == \"@\")\r\n               xml += \" \" + m.substr(1) + \"=\\\"\" + v[m].toString() + \"\\\"\";\r\n            else\r\n               hasChild = true;\r\n         }\r\n         xml += hasChild ? \">\" : \"/>\";\r\n         if (hasChild) {\r\n            for (var m in v) {\r\n               if (m == \"#text\")\r\n                  xml += v[m];\r\n               else if (m == \"#cdata\")\r\n                  xml += \"<![CDATA[\" + v[m] + \"]]>\";\r\n               else if (m.charAt(0) != \"@\")\r\n                  xml += toXml(v[m], m, ind+\"\\t\");\r\n            }\r\n            xml += (xml.charAt(xml.length-1)==\"\\n\"?ind:\"\") + \"</\" + name + \">\";\r\n         }\r\n      }\r\n      else {\r\n         xml += ind + \"<\" + name + \">\" + v.toString() +  \"</\" + name + \">\";\r\n      }\r\n      return xml;\r\n   }, xml=\"\";\r\n   for (var m in o)\r\n      xml += toXml(o[m], m, \"\");\r\n   return tab ? xml.replace(/\\t/g, tab) : xml.replace(/\\t|\\n/g, \"\");\r\n}\r\n",["714","715"],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\common\\libraries\\prj_xml2json.js",["716","717","718","719","720","721","722","723","724","725","726","727","728","729","730","731"],"/*\tThis work is licensed under Creative Commons GNU LGPL License.\r\n\r\n\tLicense: http://creativecommons.org/licenses/LGPL/2.1/\r\n   Version: 0.9\r\n\tAuthor:  Stefan Goessner/2006\r\n\tWeb:     http://goessner.net/\r\n*/\r\nvar X = {\r\n   toObj: function(xml) {\r\n      var o = {};\r\n      if (xml.nodeType==1) {   // element node ..\r\n         if (xml.attributes.length)   // element with attributes  ..\r\n            for (var i=0; i<xml.attributes.length; i++)\r\n               o[\"@\"+xml.attributes[i].nodeName] = (xml.attributes[i].nodeValue||\"\").toString(); // dam: qua parsa attribs\r\n         if (xml.firstChild) { // element has child nodes ..\r\n            var textChild=0, cdataChild=0, hasElementChild=false;\r\n            for (var n=xml.firstChild; n; n=n.nextSibling) {\r\n               if (n.nodeType==1) hasElementChild = true;\r\n               else if (n.nodeType==3 && n.nodeValue.match(/[^ \\f\\n\\r\\t\\v]/)) textChild++; // non-whitespace text\r\n               else if (n.nodeType==4) cdataChild++; // cdata section node\r\n            }\r\n            if (hasElementChild) {\r\n               if (textChild < 2 && cdataChild < 2) { // structured element with evtl. a single text or/and cdata node ..\r\n                  X.removeWhite(xml);\r\n                  for (var n=xml.firstChild; n; n=n.nextSibling) {\r\n                     if (n.nodeType == 3)  // text node\r\n                        o[\"#text\"] = X.escape(n.nodeValue);\r\n                     else if (n.nodeType == 4)  // cdata node\r\n                        o[\"#cdata\"] = X.escape(n.nodeValue);\r\n                     else if (o[n.nodeName]) {  // multiple occurence of element ..\r\n                        if (o[n.nodeName] instanceof Array)\r\n                           o[n.nodeName][o[n.nodeName].length] = X.toObj(n);\r\n                        else\r\n                           o[n.nodeName] = [o[n.nodeName], X.toObj(n)];\r\n                     }\r\n                     else  // first occurence of element..\r\n                        o[n.nodeName] = X.toObj(n); // damiano: qua parsa sottonodi\r\n                  }\r\n               }\r\n               else { // mixed content\r\n                  if (!xml.attributes.length)\r\n                     o = X.escape(X.innerXml(xml));\r\n                  else\r\n                     o[\"#text\"] = X.escape(X.innerXml(xml));\r\n               }\r\n            }\r\n            else if (textChild) { // pure text\r\n               if (!xml.attributes.length)\r\n                  o = X.escape(X.innerXml(xml));\r\n               else\r\n                  o[\"#text\"] = X.escape(X.innerXml(xml));\r\n            }\r\n            else if (cdataChild) { // cdata\r\n               if (cdataChild > 1)\r\n                  o = X.escape(X.innerXml(xml));\r\n               else\r\n                  for (var n=xml.firstChild; n; n=n.nextSibling)\r\n                     o[\"#cdata\"] = X.escape(n.nodeValue);\r\n            }\r\n         }\r\n         if (!xml.attributes.length && !xml.firstChild) o = null;\r\n      }\r\n      else if (xml.nodeType==9) { // document.node\r\n         o = X.toObj(xml.documentElement);\r\n      }\r\n      else alert(\"unhandled node type: \" + xml.nodeType);\r\n      return o;\r\n   },\r\n   toJson: function(o, name, ind) {\r\n      var json = name ? (\"\\\"\"+name+\"\\\"\") : \"\";\r\n      if (o instanceof Array) {\r\n         for (var i=0,n=o.length; i<n; i++)\r\n            o[i] = X.toJson(o[i], \"\", ind+\"\\t\");\r\n         json += (name?\":[\":\"[\") + (o.length > 1 ? (\"\\n\"+ind+\"\\t\"+o.join(\",\\n\"+ind+\"\\t\")+\"\\n\"+ind) : o.join(\"\")) + \"]\";\r\n      }\r\n      else if (o == null)\r\n         json += (name&&\":\") + \"null\";\r\n      else if (typeof(o) == \"object\") {\r\n         var arr = [];\r\n         for (var m in o)\r\n            arr[arr.length] = X.toJson(o[m], m, ind+\"\\t\");\r\n         json += (name?\":{\":\"{\") + (arr.length > 1 ? (\"\\n\"+ind+\"\\t\"+arr.join(\",\\n\"+ind+\"\\t\")+\"\\n\"+ind) : arr.join(\"\")) + \"}\";\r\n      }\r\n      else if (typeof(o) == \"string\")\r\n         json += (name&&\":\") + \"\\\"\" + o.toString() + \"\\\"\";\r\n      else\r\n         json += (name&&\":\") + o.toString();\r\n      return json;\r\n   },\r\n   innerXml: function(node) {\r\n      var s = \"\"\r\n      if (\"innerHTML\" in node)\r\n         s = node.innerHTML;\r\n      else {\r\n         var asXml = function(n) {\r\n            var s = \"\";\r\n            if (n.nodeType == 1) {\r\n               s += \"<\" + n.nodeName;\r\n               for (var i=0; i<n.attributes.length;i++)\r\n                  s += \" \" + n.attributes[i].nodeName + \"=\\\"\" + (n.attributes[i].nodeValue||\"\").toString() + \"\\\"\";\r\n               if (n.firstChild) {\r\n                  s += \">\";\r\n                  for (var c=n.firstChild; c; c=c.nextSibling)\r\n                     s += asXml(c);\r\n                  s += \"</\"+n.nodeName+\">\";\r\n               }\r\n               else\r\n                  s += \"/>\";\r\n            }\r\n            else if (n.nodeType == 3)\r\n               s += n.nodeValue;\r\n            else if (n.nodeType == 4)\r\n               s += \"<![CDATA[\" + n.nodeValue + \"]]>\";\r\n            return s;\r\n         };\r\n         for (var c=node.firstChild; c; c=c.nextSibling)\r\n            s += asXml(c);\r\n      }\r\n      return s;\r\n   },\r\n   escape: function(txt) {\r\n      return txt.replace(/[\\\\]/g, \"\\\\\\\\\")\r\n          .replace(/[\\\"]/g, '\\\\\"')\r\n          .replace(/[\\n]/g, '\\\\n')\r\n          .replace(/[\\r]/g, '\\\\r');\r\n   },\r\n   removeWhite: function(e) {\r\n      e.normalize();\r\n      for (var n = e.firstChild; n; ) {\r\n         if (n.nodeType == 3) {  // text node\r\n            if (!n.nodeValue.match(/[^ \\f\\n\\r\\t\\v]/)) { // pure whitespace text node\r\n               var nxt = n.nextSibling;\r\n               e.removeChild(n);\r\n               n = nxt;\r\n            }\r\n            else\r\n               n = n.nextSibling;\r\n         }\r\n         else if (n.nodeType == 1) {  // element node\r\n            X.removeWhite(n);\r\n            n = n.nextSibling;\r\n         }\r\n         else                      // any other node\r\n            n = n.nextSibling;\r\n      }\r\n      return e;\r\n   }\r\n};\r\nexport function xml2json(xml, tab = '    '/*XML_DOM, string*/) {\r\n   if (xml.nodeType == 9) // document node\r\n      xml = xml.documentElement;\r\n   var json = X.toJson(X.toObj(X.removeWhite(xml)), xml.nodeName, \"\\t\");\r\n   return \"{\\n\" + tab + (tab ? json.replace(/\\t/g, tab) : json.replace(/\\t|\\n/g, \"\")) + \"\\n}\";\r\n}\r\nexport function xml2jsonobj(xml, tab= '    '){\r\n   return X.toObj(X.removeWhite(xml));\r\n}\r\n// damiano: i needX.toObj(X.removeWhite(xml))\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\joiner\\classes.ts",["732","733","734","735","736","737","738","739","740","741","742","743","744","745","746","747","748"],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\joiner\\types.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\joiner\\proxy.ts",["749"],"import type {DocString, DtoL, DtoW, GObject, Proxyfied, WPointerTargetable,} from \"../joiner\";\r\nimport {\r\n    ABORT,\r\n    Dictionary,\r\n    DModelElement,\r\n    DPointerTargetable,\r\n    JsType,\r\n    LModelElement,\r\n    Log,\r\n    LPointerTargetable,\r\n    Pointer,\r\n    RuntimeAccessible,\r\n    RuntimeAccessibleClass,\r\n    SetFieldAction,\r\n    SetRootFieldAction,\r\n    U\r\n} from \"../joiner\";\r\n\r\ntype NotAConcatenation = null;\r\ntype ERROR = \"_Type_Error_\";\r\n\r\n// (DX extends DUser ? LUser : (DX extends DPointerTargetable ? LPointerTargetable : (ERROR))\r\n// (DX extends DUser ? LUser : (DX extends DPointerTargetable ? LPointerTargetable : (           WViewElement\r\n//\r\n// (IN extends WViewElement ? LViewElement : (IN extends WViewTransientProperties ? LWiewTransientProperties : (ERROR)))\r\n// ))\r\n// type WtoL<WX extends WPointerTargetable> ='';\r\n\r\n@RuntimeAccessible('LogicContext')\r\nexport class LogicContext<\r\n    DX extends GObject = DModelElement,\r\n    LX = DtoL<DX>,\r\n    // PF extends MyProxyHandler<DX> = MyProxyHandler<DX>,\r\n    WX = DtoW<DX>\r\n    > extends RuntimeAccessibleClass{\r\n    public proxyObject: LX;\r\n    public data: DX;// & GObject;\r\n    public write: WX;\r\n    constructor(proxyObject: LX, data: DX) {\r\n        super();\r\n        this.className = (this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name;\r\n        this.data = data;\r\n        this.proxyObject = proxyObject;\r\n        this.write = proxyObject as any;\r\n    }\r\n    /*\r\n        saveToRedux(propkey: \"keyof data\" | string, val: \"typeof data[path]\" | any): void { // todo: ask non stackoverflow\r\n            // todo, put data in redux store, path is \"obj1.obj2.obj3...\" might replace it with a path funciton that return the foremost nested object container\r\n            if (!propkey) {\r\n                // todo: set whole object instead of a property\r\n            }\r\n        }*/\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(RuntimeAccessibleClass, LogicContext);\r\n@RuntimeAccessible('MapLogicContext')\r\nexport class MapLogicContext extends LogicContext<GObject, LPointerTargetable, WPointerTargetable> {\r\n    data: GObject;\r\n    path: string;\r\n    subMaps: string[];\r\n    constructor(proxy: LPointerTargetable, data: GObject, path: string, subMaps: string[] = []) {\r\n        super(proxy, data);\r\n        // this.proxyfyFunction = proxyfyFunction;\r\n        this.proxyObject = proxy;\r\n        this.data = data;\r\n        this.path = path;\r\n        this.subMaps = subMaps;\r\n        this.className = (this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name;\r\n    }\r\n}\r\nRuntimeAccessibleClass.set_extend(LogicContext, MapLogicContext);\r\n\r\n@RuntimeAccessible('MyProxyHandler')\r\nexport abstract class MyProxyHandler<T extends GObject> extends RuntimeAccessibleClass implements ProxyHandler<T>{\r\n    s: string = 'set_';\r\n    g: string = 'get_';\r\n    /*get(target: T, p: string | number | symbol, proxyitself: Proxyfied<T>): boolean {\r\n        switch (p) {\r\n            case '_isProxy': return true;\r\n            case 'init': return (this as any).init;\r\n            case 'init0': return (this as any).init0;\r\n            default: throw new Error('proxy get must be overridden, called for key: ' + (p as string));\r\n        }}*/\r\n    set(target: T, p: string | number | symbol, value: any, proxyitself: Proxyfied<T>): boolean { throw new Error('proxy set must be overridden'); }\r\n    deleteProperty(target: T, p: string | symbol): boolean { throw new Error('proxy delete must be overridden'); }\r\n\r\n    ownKeys(target: T): ArrayLike<string | symbol>{\r\n        // return Object.getOwnPropertyNames(target);\r\n        console.log(\"ownkeys trap 1\", {thiss:this, target})\r\n        console.log(\"ownkeys trap 2\", {thiss:this, target, ret:Reflect.ownKeys(target)});\r\n        return Reflect.ownKeys(target);\r\n    }\r\n    /// proxy methods not used\r\n    /* setPrototypeOf(target: T, v: object | null): boolean { ?? }\r\n    apply(target: T, thisArg: any, argArray: any[]): any { }\r\n    defineProperty(target: T, p: string | symbol, attributes: PropertyDescriptor): boolean { }\r\n    construct(target: T, argArray: any[], newTarget: Function): object { }\r\n    getOwnPropertyDescriptor(target: T, p: string | symbol): PropertyDescriptor | undefined { }\r\n    has(target: T, p: string | symbol): boolean { return p in target; }\r\n    getPrototypeOf(target: T): object | null { }\r\n    isExtensible(target: T): boolean { }\r\n    preventExtensions(target: T): boolean { }*/\r\n\r\n    static wrap<D extends RuntimeAccessibleClass, L extends LPointerTargetable = LPointerTargetable, CAN_THROW extends boolean = false,\r\n        RET extends CAN_THROW extends true ? L : L | undefined  = CAN_THROW extends true ? L : L>\r\n    (data: D | Pointer | undefined | null, baseObjInLookup?: DPointerTargetable, path: string = '', canThrow: CAN_THROW = false as CAN_THROW): RET{\r\n\r\n//    static wrap<D extends RuntimeAccessibleClass, L extends LPointerTargetable, RET extends boolean = false>\r\n//        (data: D | Pointer<DViewElement>, baseObjInLookup?: DPointerTargetable, path: string = '', canthrow: RET = false as RET): RET {\r\n        return DPointerTargetable.wrap(data, baseObjInLookup, path) as RET; }\r\n\r\n    static isProxy(data: GObject): boolean { return data?.__isProxy || false; }\r\n}\r\nRuntimeAccessibleClass.set_extend(RuntimeAccessibleClass, MyProxyHandler);\r\nexport type GetPath<T = GObject> = T;\r\n/*\r\n* handling proxy += and proxy -=\r\n*\r\n* will become var = var + add; which will call Symbol.getPrimitive\r\nconsole.log(+obj2);     // 10        — hint is \"number\"         NaN with +array with multiple vals, +array[0] with array of size 1, NaN with functions & objects\r\nconsole.log(`${obj2}`); // \"hello\"   — hint is \"string\"         array => array.join(','), object => \"[object Object]\", function => function.toString() whole func definition with body code\r\nconsole.log(obj2 + \"\"); // \"true\"    — hint is \"default\"        array, object, function => same as with hint \"string\"\r\n*\r\n* */\r\n\r\n// NB: lclass.extends += somepointer will become: lclass.extends = lclass.extends + somepointer;\r\n// array + string will cause getPrimitive(\"default\") to array, then .join(',') on it, and finally and toString() to be called on all array members.\r\n// so pointers cannot include \",\" char and toString() must return a pointer to keep lclass.extends += somepointer as a valid expression;\r\n// -= will call getPrimitive(\"number\") which will result in array -> NaN, so NaN = NaN - pointer and cannot be done.\r\n// or maybe it can because if getPrimitive fails it calls toString as fallback, and viceversa\r\n\r\n@RuntimeAccessible('GetPathHandler')\r\nclass GetPathHandler<T extends GObject> extends MyProxyHandler<T>{\r\n    public static __asCalls: boolean = false;\r\n    public static __asArray: boolean = false;\r\n    public static __nested: boolean = true;\r\n    private strbuilder: string = '';\r\n    private array: (string | number | symbol)[] = [];\r\n    private calls: (GObject<'parameters of get calls'>)[] = [];\r\n\r\n    public constructor() { super(); }\r\n\r\n    get(targetObj: T, propKey: keyof T | string, proxyitself: Proxyfied<T>): any {\r\n        // console.log('GetPathHandler', {targetObj, propKey, proxyitself});\r\n        if (propKey === \"start\") { this.strbuilder = ''; this.array = []; }\r\n        if (propKey === '$') {\r\n            const ret = GetPathHandler.__asCalls ? this.calls : (GetPathHandler.__asArray ? this.array : this.strbuilder);\r\n            this.array = [];\r\n            this.strbuilder = '';\r\n            return ret; }\r\n        this.array.push(propKey);\r\n        this.calls.push(arguments);\r\n        if (propKey === Symbol.toPrimitive) {\r\n            console.log(\"toprimitive\");\r\n            return (...a: any)=> {console.log(\"toprimitive called with parameters\", a); }\r\n        }\r\n        if (!GetPathHandler.__asArray && !GetPathHandler.__asCalls) {\r\n            if (typeof propKey === \"symbol\") { this.strbuilder += propKey.toString(); }\r\n            else {\r\n                // Giordano: add ignore for webpack\r\n                //@ts-ignore\r\n                this.strbuilder += (this.strbuilder ? '.' : '') + propKey;\r\n            }\r\n        }\r\n        return GetPathHandler.__nested ? proxyitself : {};\r\n    }\r\n\r\n    set(target: T, p: string | number | symbol, value: any, proxyitself: Proxyfied<T>): boolean {\r\n        switch(p){\r\n            case '__asArray':\r\n            case '__asCalls':\r\n            case '__nested':\r\n                (GetPathHandler as any)[p] = value;\r\n                return true;\r\n            default:\r\n                throw new Error('getPath proxy cannot be written');\r\n        }\r\n    }\r\n}\r\nRuntimeAccessibleClass.set_extend(MyProxyHandler, GetPathHandler);\r\n@RuntimeAccessible('TargetableProxyHandler')\r\nexport class TargetableProxyHandler<ME extends GObject = DModelElement, LE extends LPointerTargetable = LModelElement> extends MyProxyHandler<ME> {\r\n// permette di fare cose tipo: user.name_surname che ritorna la concatenazione di nome e cognome anche se il campo name_surname non esiste.\r\n    lg: LE & GObject; // to disable type check easily and access 'set_' + varname dynamically\r\n    l: LE;\r\n    d: ME;\r\n    additionalPath: string;\r\n\r\n    public baseObjInLookup: DPointerTargetable;\r\n    static childKeys: Dictionary<string, true> = {'$': true, '@': true};\r\n\r\n    constructor(d: ME, baseObjInLookup?: DPointerTargetable, additionalPath: string = '', l?: LE) {\r\n        super();\r\n        this.d = d;\r\n        if (!l) {\r\n            l = RuntimeAccessibleClass.get(d.className)?.logic?.singleton as LE;\r\n            Log.exDev(!l, 'Trying to wrap class without singleton or logic mapped: ' + d.className, { object: d, className: d.className })\r\n        }\r\n        this.baseObjInLookup = baseObjInLookup || d as any;\r\n        this.additionalPath = additionalPath;\r\n        this.l = l as LE;\r\n        this.lg = this.l;\r\n        this.className = (this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name;\r\n    }\r\n\r\n    // damiano todo: this does not work\r\n    private concatenableHandler(targetObj: ME, propKey: number | string | symbol, proxyitself: Proxyfied<ME>): NotAConcatenation | any[] | string {\r\n        //console.log(\"concatenableHandler 1\", {targetObj, propKey, proxyitself});\r\n        if (propKey in targetObj)  return null as NotAConcatenation;\r\n        const propKeyStr: null | string = U.asString(propKey, null);\r\n        let _index: number = propKeyStr ? propKeyStr.indexOf('_') : -1;\r\n        //console.log(\"concatenableHandler 2\", {targetObj, propKey, propKeyStr, proxyitself, _index});\r\n        if (_index < 0) return null as NotAConcatenation;\r\n\r\n        let isConcatenable = true;\r\n        let ret: any[] = (propKey as string).split('_').map( (subKey: string) => {\r\n            //console.log(\"concatenableHandler 3.0\", {targetObj, subKey, propKeyStr, proxyitself});\r\n            // se trovo multipli ___ li tratto come spazi aggiuntivi invece che come proprietà '' che ritornano undefined, così posso fare name___surname --> \"damiano   di vincenzo\"\r\n            let val: any = subKey === '' ? ' ' : this.get(targetObj, subKey, proxyitself);\r\n            isConcatenable = isConcatenable && JsType.isPrimitive(val);\r\n            return val;\r\n        });\r\n        //console.log(\"concatenableHandler 4\", {targetObj, propKey, propKeyStr, proxyitself, ret, isConcatenable});\r\n        return isConcatenable ? ret.join(' ') : ret; }\r\n\r\n    public get(targetObj: ME, propKey: string | symbol, proxyitself: Proxyfied<ME>): any {\r\n        let ret;\r\n        let isError = false;\r\n        // console.error('_proxy get PRE:', {targetObj, propKey, proxyitself, arguments});\r\n        try { ret = this.get0(targetObj, propKey, proxyitself); } catch(e) { ret = e; isError = true;}\r\n\r\n        // if (isError) throw ret;\r\n        // console.error('_proxy get POST:', {targetObj, propKey, ret, isError});\r\n        return ret;\r\n    }\r\n\r\n    public get0(targetObj: ME, propKey: string | symbol, proxyitself: Proxyfied<ME>): any {\r\n        // console.log('proxy keysearch', {propKey, targetObj, l: this.l, proxyitself, d: this.d});\r\n        let canThrowErrors = true;\r\n\r\n        switch(typeof propKey) {\r\n            case \"symbol\":\r\n                propKey = String(propKey);\r\n                // console.log('get symbol', {propKey});\r\n                switch (propKey) {\r\n                    default: Log.exDevv('unexpected symbol in proxy getter:', propKey); break;\r\n                    case 'Symbol(Symbol.toStringTag)': propKey = 'toString'; break; //return (()=>\"[Proxy]\");\r\n                    case \"Symbol(Symbol.toPrimitive)\": propKey = 'toPrimitive'; break;\r\n                }\r\n                break;\r\n            // case \"number\": return null;\r\n        }\r\n\r\n        switch (propKey) {\r\n            case '__l': return this.l;\r\n            case '__d': return this.d;\r\n            case 'inspect': // node.js util\r\n            case \"r\":\r\n            case \"_refresh\":\r\n            case \"_reload\": return LPointerTargetable.wrap(targetObj.id);\r\n            case '__Raw':\r\n            case '__raw': return targetObj;\r\n            case '__serialize': return JSON.stringify(targetObj);\r\n            case '__isproxy':\r\n            case '__isProxy': return true;\r\n            case '__random': return Math.random();\r\n            case 'editCount':\r\n            case 'clonedcounter':\r\n            case 'clonedCounter':\r\n                return targetObj.clonedCounter || 0;\r\n            case '$$typeof':\r\n            case \"typeName\":\r\n                return this.d.className;\r\n            case 'parent': propKey = 'father'; break;\r\n        }\r\n        if (propKey[0] === \"_\" && propKey.indexOf(\"__info_of__\")===0) {\r\n            return (this.l as GObject)[propKey];\r\n        }\r\n\r\n\r\n        // check if exist directly in D.key, L.key or through a get_key\r\n        if (propKey in this.l || propKey in this.d || (this.l as GObject)[this.g + (propKey as string)]) {\r\n            // todo: il LogicContext passato come parametro risulta nell'autocompletion editor automaticamente generato, come passo un parametro senza passargli il parametro? uso arguments senza dichiararlo?\r\n            if (typeof propKey !== 'symbol' && this.g + propKey in this.lg) return this.lg[this.g + propKey](new LogicContext(proxyitself as any, targetObj));\r\n\r\n\r\n\r\n            // if specific custom getter exist\r\n            if (typeof propKey !== 'symbol' && this.g + propKey in this.lg) {\r\n                let getterMethod: Function = this.lg[this.g + propKey]; // || this.defaultGetter;\r\n                // console.log(\"gets method\", {getterMethod, lg:this.lg, thiss: this});\r\n                if (getterMethod) return getterMethod(new LogicContext(proxyitself as any, targetObj));\r\n            }\r\n\r\n        }\r\n        // @ts-ignore\r\n        //console.trace(\"proxy $getter 2\", {targetObj, n:targetObj.name, propKey, l:this.lg, dg:this.lg._defaultGetter});\r\n\r\n\r\n        // if custom generic getter exist\r\n        // @ts-ignore\r\n        if (this.lg._defaultGetter) return this.lg._defaultGetter(new LogicContext(proxyitself as any, targetObj), propKey);\r\n\r\n        // if property do not exist, try a concatenation\r\n        /*let concatenationTentative = null;\r\n        try {concatenationTentative = this.concatenableHandler(targetObj, propKey, proxyitself); } catch(e) {}\r\n        if (concatenationTentative !== null) return concatenationTentative;\r\n        */\r\n        Log.e(canThrowErrors, 'GET property \"'+ (propKey as any)+ '\" do not exist in object of type \"' + U.getType(this.l) + \" DType:\" +  U.getType(this.d), {data: targetObj});\r\n        return undefined;\r\n        // todo: credo che con espressioni sui tipi siano tipizzabili tutti i return di proprietà note eccetto quelle ottenute per concatenazione.\r\n    }\r\n\r\n    public defaultGetter(targetObj: ME, key: string, proxyitself: Proxyfied<ME>): any {\r\n        if (!targetObj) return targetObj;\r\n        if (!targetObj._subMaps || !targetObj._subMaps[key]) return (targetObj as Dictionary)[key];\r\n        // if is a nexted subobject\r\n        let context: MapLogicContext = new MapLogicContext(proxyitself as any, targetObj, key, []);\r\n        let retRaw: Dictionary = this.lg[this.s + key]\r\n        return MapProxyHandler.mapWrap((targetObj as Dictionary)[key], targetObj as any, this.additionalPath + '.' + key)\r\n    }\r\n\r\n    public defaultSetter(targetObj: DPointerTargetable, propKey: string, value: any, proxyitself?: Proxyfied<ME>): boolean {\r\n        SetFieldAction.new(targetObj, propKey as any, value);\r\n        return true;\r\n    }\r\n\r\n    public set(targetObj: ME, propKey: string | symbol, value: any, proxyitself?: Proxyfied<ME>): boolean {\r\n        // console.error('_proxy set PRE:', {targetObj, propKey, value, proxyitself, arguments});\r\n        // if (propKey in this.l || propKey in this.d || (this.l as GObject)[this.s + (propKey as string)] || (this.l as GObject)[(propKey as string)]) {\r\n\r\n        if ((this.d as GObject).__readonly && propKey !== '__readonly') {\r\n            //todo if there is a transaction open i should throw exception?\r\n            if(ABORT()){\r\n                Log.ee('Transaction aborted because an object is readonly:', this.d);\r\n            }\r\n            return true;\r\n        }\r\n        switch (typeof propKey) {\r\n            case \"symbol\":\r\n                propKey = String(propKey);\r\n                Log.exDevv('unexpected symbol in proxy setter:', propKey);\r\n                break;\r\n            default: break;\r\n        }\r\n\r\n        switch (propKey) {\r\n            case 'parent': propKey = 'father'; break;\r\n        }\r\n\r\n        if (propKey in this.l || propKey in this.d || (this.l as GObject)[this.s + (propKey as string)]) {\r\n            // todo: il LogicContext passato come parametro risulta nell'autocompletion editor automaticamente generato, come passo un parametro senza passargli il parametro? uso arguments senza dichiararlo?\r\n            if (typeof propKey !== 'symbol' && this.s + propKey in this.lg) {\r\n                this.lg[this.s + propKey](value, new LogicContext(proxyitself as any, targetObj));\r\n                return true;\r\n            }\r\n\r\n\r\n            // se esiste la proprietà ma non esiste il setter?\r\n            // Log.eDevv(\"dev error: property exist but setter does not: \", propKey, this);\r\n            // return false;\r\n        }\r\n        // if property do not exist\r\n\r\n        // if custom generic setter exist\r\n        // @ts-ignore private property\r\n        if (this.lg._defaultSetter) { // @ts-ignore private property\r\n            this.lg._defaultSetter(value, new LogicContext(proxyitself as any, targetObj), propKey);\r\n            return true;\r\n        }\r\n        /*if (enableFallbackSetter && typeof (propKey === \"string\") && ((propKey as string)[0] === '_' || (propKey as string).indexOf('tmp') > 0)) {\r\n            return this.defaultSetter(targetObj as any as DPointerTargetable, propKey as string, value, proxyitself);\r\n            // new SetFieldAction(new LogicContext(proxyitself as any, targetObj).data as any, propKey as string, value); return true;\r\n        }*/\r\n        let canThrowErrors = true;\r\n        Log.ex(canThrowErrors,'SET property \"set_' + (propKey as any) + '\" do not exist in object of type \"' + U.getType(this.l) + \" DType:\" +  U.getType(this.l), {'this': this, targetObj});\r\n        return false; }\r\n    /*      problema: ogni oggetto deve avere multipli puntatori, quando ne modifico uno devo modificarli tutti, come tengo traccia?\r\n            ipotesi 1: lo memorizzo in un solo posto (store.idlookup) e uso Pointer<type, lb, ub> che è una stringa che simula un puntatore\r\n            problema 1: se fornisco l'intero store ai componenti si aggiornano ad ogni singola modifica, se estraggo i campi interesasti le stringhe puntatore sono invariate ma il contenuto puntato è cambiato e il componente non lo sa...\r\n            problemone 2: non so a quali proprietà dello store devo abbonarmi, devo leggere sempre tutto lo store?\r\n            !!!!! soluzione 2?: dovrei dichiarare le variabili a cui mi abbono, salvarle nello stato e precaricarle tramite mapStateToProps*/\r\n\r\n    public deleteProperty(target: ME, key: string | symbol, proxyItself?: Proxyfied<any>): boolean {\r\n        if (typeof key === \"symbol\") return false;\r\n        this.set(target, key, undefined, proxyItself);\r\n        delete target[key];\r\n        return true; }\r\n\r\n    private mergedObject(target: ME): GObject{\r\n        let ret: GObject = {...target}; // U.arrayMergeInPlace(Object.keys(target), Object.keys(this.l).filter(k => k.indexOf('set_') !== 0 && k.indexOf('get_') !== 0));\r\n        for (let k in this.l) {\r\n            if (!(k in ret) && k.lastIndexOf('get_', 4) !== 0 && k.lastIndexOf('set_', 4) !== 0) ret[k] = true;\r\n        }\r\n        return ret;\r\n    }\r\n    ownKeys(target: ME): ArrayLike<string | symbol>{\r\n        const ret: GObject = this.mergedObject(target);\r\n        // ret = Reflect.ownKeys(ret);\r\n        return Reflect.ownKeys(ret);\r\n    }\r\n\r\n    // has(target: ME, p: string | symbol): boolean { return p in this.mergedObject(target); }\r\n    has(target: ME, p: string | symbol): boolean { return (p in target) || (p in this.l); }\r\n\r\n    /*\r\n    apply(target: DModelElement, thisArg: any, argArray: any[]): any {\r\n        // will i ever use it? dovrei pasare una funzione invece di una classe, quindi in questo caso credo wrappi solo il costruttore\r\n    }*/\r\n}\r\nRuntimeAccessibleClass.set_extend(MyProxyHandler, TargetableProxyHandler);\r\n@RuntimeAccessible('MapProxyHandler')\r\nexport class MapProxyHandler extends TargetableProxyHandler<Dictionary, LPointerTargetable> {\r\n    // todo: sposta alcune funzioni da TargetableProxy a MyProxy e fai estendere direttamente MyProxy a questa classe\r\n    public subMapKeys: Dictionary<string, any | Dictionary<DocString<'nested map keys'>>>;\r\n\r\n    constructor(d: Dictionary, baseObjInLookup: DPointerTargetable, additionalPath: string = '', subMapKeys: Dictionary<string, any | Dictionary<DocString<'nested map keys'>>> = {}) {\r\n        super(d, baseObjInLookup, additionalPath, LPointerTargetable.singleton);\r\n        this.subMapKeys = subMapKeys;\r\n    }\r\n\r\n    get(target: Dictionary, key: string | number | symbol, proxyitself: Proxyfied<Dictionary>): any {\r\n        if (typeof key === \"symbol\") return this.d[key as any];\r\n        let val: any = this.d[key];\r\n        if (key in this.subMapKeys && !(key in target)) { Log.exx('property not found in dictionary', {target, key, thiss:this, proxyitself, submapkeys: this.subMapKeys}); return undefined; }\r\n        if (key in this.subMapKeys) {\r\n            this.additionalPath += '.';\r\n            return MapProxyHandler.mapWrap( this.d, this.baseObjInLookup, this.additionalPath, this.subMapKeys[key]);\r\n            Log.exDevv('todo: wrap sub-map', {thiss: this});\r\n        }\r\n        return target[key as string]; }\r\n\r\n    set(target: Dictionary, key: string | number | symbol, value: any, proxyitself: Proxyfied<Dictionary>): boolean {\r\n        if (typeof key === \"symbol\") { Log.exx('cannot set a symbol in dictionary', {target, key, value, proxyitself}); return false; }\r\n        SetRootFieldAction.new(this.additionalPath + '.' + key, value, '',false)\r\n        return true;\r\n    }\r\n\r\n    public deleteProperty(target: Dictionary, key: string | symbol, proxyItself?: Proxyfied<any>): boolean {\r\n        if (typeof key === \"symbol\") return false;\r\n        this.set(target, key, undefined, proxyItself);\r\n        delete target[key];\r\n        return true; }\r\n}\r\nRuntimeAccessibleClass.set_extend(MyProxyHandler, MapProxyHandler);\r\n// 15-20 min + 5 di domande entro il 1° ottobre, discussione 10-12 ottobre\r\nexport const getPath: GetPath = new Proxy( {}, new GetPathHandler());\r\n(window as any).getPath = getPath;\r\n// usage: pathstring = ((getPath as DType).some.path.to.follow as any).$; // = \"some.path.to.follow\" with compilation-time validation\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\redux\\reducer\\reducer.ts",["750","751","752","753","754","755","756","757","758","759","760"],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\joiner\\ExecuteOnRead.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\common\\UObj.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\common\\Log.ts",["761"],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\common\\Defaults.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\common\\Geom.ts",["762","763","764","765","766","767","768","769","770","771","772","773","774","775","776","777","778","779","780","781","782","783","784","785"],"import {GObject, Temporary, TODO, U} from \"../joiner\";\r\nimport {DPointerTargetable, RuntimeAccessible, windoww, Log, RuntimeAccessibleClass, Dictionary} from \"../joiner\";\r\nimport React from \"react\";\r\nimport {radian} from \"../joiner/types\";\r\n\r\n@RuntimeAccessible('IPoint')\r\nexport abstract class IPoint extends RuntimeAccessibleClass {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public x!: number;\r\n    public y!: number;\r\n\r\n    // @ts-ignore static getM is not null but must be declared nullable to achieve subclass mixing\r\n    // public static getM? = function(firstPt: IPoint, secondPt: IPoint): number { return (firstPt.y - secondPt.y) / (firstPt.x - secondPt.x); }\r\n    public static getM(firstPt: IPoint, secondPt: IPoint): number { return (firstPt.y - secondPt.y) / (firstPt.x - secondPt.x); }\r\n    public static getQ(firstPt: IPoint, secondPt: IPoint, m?: number): number {\r\n        if (m === undefined) m = IPoint.getM(firstPt, secondPt);\r\n        return firstPt.y - (m * firstPt.x);\r\n    }\r\n\r\n    public constructor(x: number = 0, y: number = 0) {\r\n        super(); // super('dwc');\r\n        IPoint.init_constructor(this, x, y);\r\n    }\r\n\r\n    static init_constructor(thiss: GObject, x: any = 0, y: any = 0, ...a: any): void {\r\n        thiss.id = \"POINT_\" + (DPointerTargetable.maxID++) + \"_\" + new Date().getTime();\r\n        thiss.className = thiss.constructor.name;\r\n        if (x === null || x === undefined) thiss.x = undefined as Temporary;\r\n        else if (isNaN(+x)) { thiss.x = 0; }\r\n        else thiss.x = +x;\r\n        if (y === null || y === undefined) thiss.y = undefined as Temporary;\r\n        else if (isNaN(+y)) { thiss.y = 0; }\r\n        else thiss.y = +y;\r\n        thiss.className = this.cname;\r\n    }\r\n\r\n\r\n    static printDiff(s1: SizeLike, s2: SizeLike) {\r\n        return ISize.printDiff(s1, s2, true);\r\n    }\r\n    public raw(): {x: number, y: number} { return {x: this.x, y: this.y}; }\r\n\r\n    public toString(letters: boolean=true, separator: string = \" \"): string {\r\n        if (letters) return  JSON.stringify({x:this.x, y: this.y});\r\n        else return this.x + separator + this.y + separator;\r\n    }\r\n    public clone(other: { x: number, y: number }): this { this.x = other.x; this.y = other.y; return this; }\r\n\r\n    protected abstract new(): this;\r\n    abstract toSize(w: number, h?: number): ISize;\r\n    public duplicate(): this { const ret = this.new(); ret.clone(this); return ret; }\r\n\r\n    public distanceFromPoint(tentativeEnd: IPoint, skipSqrt: boolean = false): number {\r\n        let d_pow2 = (this.x - tentativeEnd.x)**2 + (this.y - tentativeEnd.y)**2;\r\n        return skipSqrt ? d_pow2 : Math.sqrt(d_pow2);\r\n        // return this.subtract(tentativeEnd, true).absolute();\r\n    }\r\n\r\n    public subtract(p2: { x?: number, y?: number }, newInstance: boolean): this {\r\n        Log.e(!p2, 'subtract argument must be a valid point: ', p2);\r\n        let p1: this;\r\n        if (!newInstance) { p1 = this; } else { p1 = this.duplicate(); }\r\n        if (p2.x !== undefined) p1.x -= p2.x;\r\n        if (p2.y !== undefined) p1.y -= p2.y;\r\n        return p1; }\r\n\r\n    public add(p2: { x?: number, y?: number }, newInstance: boolean): this {\r\n        Log.e(!p2, 'add argument must be a valid point: ', p2);\r\n        let p1: this;\r\n        if (!newInstance) { p1 = this; } else { p1 = this.duplicate(); }\r\n        if (p2.x !== undefined) p1.x += p2.x;\r\n        if (p2.y !== undefined) p1.y += p2.y;\r\n        return p1; }\r\n\r\n    public addAll(p: IPoint[], newInstance: boolean): this {\r\n        let i;\r\n        let p0: this;\r\n        if (!newInstance) { p0 = this; } else { p0 = this.duplicate(); }\r\n        for (i = 0; i < p.length; i++) { p0.add(p[i], true); }\r\n        return p0; }\r\n\r\n    public subtractAll(p: this[], newInstance: boolean): this {\r\n        let i;\r\n        let p0: this;\r\n        if (!newInstance) { p0 = this; } else { p0 = this.duplicate(); }\r\n        for (i = 0; i < p.length; i++) { p0.subtract(p[i], true); }\r\n        return p0; }\r\n\r\n    public multiply(pt: {x?: number, y?: number} | number, newInstance: boolean = false): this {\r\n        let ret: this = (newInstance ? this.duplicate() : this);\r\n        if (typeof pt === \"number\") {\r\n            ret.x *= pt;\r\n            ret.y *= pt;\r\n        }\r\n        else {\r\n            if (pt.x !== undefined) ret.x *= pt.x;\r\n            if (pt.y !== undefined) ret.y *= pt.y;\r\n        }\r\n        return ret; }\r\n\r\n    public divide(pt: Partial<this> | number, newInstance: boolean = false): this {\r\n        let ret = (newInstance ? this.duplicate() : this);\r\n        if (typeof pt === \"number\") {\r\n            ret.x /= pt;\r\n            ret.y /= pt;\r\n        }\r\n        else {\r\n            ret.x /= pt.x as number;\r\n            ret.y /= pt.y as number;\r\n        }\r\n        return ret; }\r\n\r\n    public multiplyScalar(scalar: number, newInstance: boolean): this {\r\n        Log.e(isNaN(+scalar), 'IPoint.multiply()', 'scalar argument must be a valid number: ', scalar);\r\n        let p1: this;\r\n        if (!newInstance) { p1 = this; } else { p1 = this.duplicate(); }\r\n        p1.x *= scalar;\r\n        p1.y *= scalar;\r\n        return p1; }\r\n\r\n    public divideScalar(scalar: number, newInstance: boolean): this {\r\n        Log.e(isNaN(+scalar), 'IPoint.divide()', 'scalar argument must be a valid number: ', scalar);\r\n        let p1: this;\r\n        if (!newInstance) { p1 = this; } else { p1 = this.duplicate(); }\r\n        p1.x /= scalar;\r\n        p1.y /= scalar;\r\n        return p1; }\r\n\r\n    public isInTheMiddleOf(firstPt: this, secondPt: this, tolleranza: number): boolean {\r\n        const rectangle: Size = Size.fromPoints(firstPt, secondPt);\r\n        const tolleranzaX = tolleranza; // actually should be cos * arctan(m);\r\n        const tolleranzaY = tolleranza; // actually should be sin * arctan(m);\r\n        if (this.x < rectangle.x - tolleranzaX || this.x > rectangle.x + rectangle.w + tolleranzaX) { return false; }\r\n        if (this.y < rectangle.y - tolleranzaX || this.y > rectangle.y + rectangle.h + tolleranzaY) { return false; }\r\n        // const m = IPoint.getM(firstPt, secondPt);\r\n        // const q = IPoint.getQ(firstPt, secondPt);\r\n        const lineDistance = this.distanceFromLine(firstPt, secondPt);\r\n        // console.log('distance:', lineDistance, ', this:', this, ', p1:', firstPt, ', p2:', secondPt);\r\n        return lineDistance <= tolleranza; }\r\n\r\n    public distanceFromLine(p1: IPoint, p2: IPoint): number {\r\n        const top: number =\r\n            + (p2.y - p1.y) * this.x\r\n            - (p2.x - p1.x) * this.y\r\n            + p2.x * p1.y\r\n            - p1.x * p2.y;\r\n        const bot =\r\n            (p2.y - p1.y) * (p2.y - p1.y) +\r\n            (p2.x - p1.x) * (p2.x - p1.x);\r\n        return Math.abs(top) / Math.sqrt(bot);  }\r\n\r\n    public equals(pt: {x:number, y:number}, tolleranzaX: number = 0, tolleranzaY: number = 0): boolean {\r\n        if (pt === null) { return false; }\r\n        return Math.abs(this.x - pt.x) <= tolleranzaX && Math.abs(this.y - pt.y) <= tolleranzaY; }\r\n\r\n    public moveOnNearestBorder(startVertexSize: ISize, clone: boolean, graph: TODO/*IGraph*/, debug: boolean = true): IPoint {\r\n        const pt: IPoint = clone ? this.duplicate() : this;\r\n        const tl: IPoint = startVertexSize.tl();\r\n        const tr: IPoint = startVertexSize.tr();\r\n        const bl: IPoint = startVertexSize.bl();\r\n        const br: IPoint = startVertexSize.br();\r\n        const L: number = pt.distanceFromLine(tl, bl);\r\n        const R: number = pt.distanceFromLine(tr, br);\r\n        const T: number = pt.distanceFromLine(tl, tr);\r\n        const B: number = pt.distanceFromLine(bl, br);\r\n        const min: number = Math.min(L, R, T, B);\r\n        if (min === L) { pt.x = tl.x; }\r\n        if (min === R) { pt.x = tr.x; }\r\n        if (min === T) { pt.y = tr.y; }\r\n        if (min === B) { pt.y = br.y; }\r\n        if (debug && graph && pt instanceof GraphPoint) { graph.markg(pt, false, 'purple'); }\r\n        return pt; }\r\n\r\n    public getM(pt2: IPoint): number { return IPoint.getM?.(this, pt2) as unknown as number; }\r\n\r\n    public degreeWith(pt2: IPoint, toRadians: boolean): number {\r\n        const directionVector: IPoint = this.subtract(pt2, true);\r\n        const ret: number = Math.atan2(directionVector.y, directionVector.x);\r\n        return toRadians ? ret : windoww.U.RadToDegree(ret); }\r\n\r\n    public absolute(): number { return Math.sqrt(this.x * this.x + this.y * this.y); }\r\n    public set(x: number, y: number) { this.x = x; this.y = y; }\r\n\r\n    // move the point by a vector with direction and distance (module)\r\n    move(rad: radian /*in radians!*/, distance: number, clone:boolean = true): this{\r\n        let pt = clone ? this.duplicate() : this;\r\n        pt.x += distance * Math.cos(rad);\r\n        pt.y += distance * Math.sin(rad);\r\n        return pt;\r\n    }\r\n\r\n    static stringify(ptlike: {x?:number, y?:number}): string {\r\n        if (!ptlike) return ptlike;\r\n        let str: string[];\r\n        return '('+U.cropNum(ptlike.x||0)+', '+U.cropNum(ptlike.y||0)+')';\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('GraphPoint')\r\nexport class GraphPoint extends IPoint{\r\n    private dontmixwithPoint: any;\r\n    public static fromEvent(e: JQuery.ClickEvent | JQuery.MouseMoveEvent | JQuery.MouseUpEvent | JQuery.MouseDownEvent | JQuery.MouseEnterEvent | JQuery.MouseLeaveEvent | JQuery.MouseEventBase)\r\n        : GraphPoint | null {\r\n        if (!e) { return null; }\r\n        const p: Point = new Point(e.pageX, e.pageY);\r\n        const g: any = null;\r\n        throw new Error(\"todo: const g: IGraph = Status.status.getActiveModel().graph;\");\r\n        return g.toGraphCoord(p); }\r\n\r\n    protected new(): this { return new GraphPoint() as this;}\r\n    public toSize(w: number, h?: number): GraphSize {\r\n        return new GraphSize(this.x, this.y, w, (h === undefined) ? w : h);\r\n    }\r\n\r\n}\r\n\r\n\r\n@RuntimeAccessible('Point')\r\nexport class Point extends IPoint{\r\n    private dontmixwithGPoint: any;\r\n    /// https://stackoverflow.com/questions/6073505/what-is-the-difference-between-screenx-y-clientx-y-and-pagex-y\r\n    public static fromEvent(e: JQuery.ClickEvent | JQuery.MouseMoveEvent | JQuery.MouseUpEvent | JQuery.MouseDownEvent\r\n        | JQuery.MouseEnterEvent | JQuery.MouseLeaveEvent | JQuery.MouseEventBase | React.MouseEvent)\r\n        : Point {\r\n        const p: Point = new Point(e.pageX, e.pageY);\r\n        return p; }\r\n\r\n    protected new(): this { return new Point() as this;}\r\n    public toSize(w: number, h?: number): Size {\r\n        return new Size(this.x, this.y, w, (h === undefined) ? w : h);\r\n    }\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(RuntimeAccessibleClass, IPoint);\r\nRuntimeAccessibleClass.set_extend(IPoint, GraphPoint);\r\nRuntimeAccessibleClass.set_extend(IPoint, Point);\r\n\r\n@RuntimeAccessible('ISize')\r\nexport abstract class ISize<PT extends IPoint = IPoint> extends RuntimeAccessibleClass {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public x!: number;\r\n    public y!: number;\r\n    public w!: number;\r\n    public h!: number;\r\n    public constructor(x: number = 0, y: number = 0, w: number = 0, h: number = 0) {\r\n        super(); // super('dwc');\r\n        // do not override any fields from the DPointerTargetable, otherwise the ! in the override will reinizialize the attribute\r\n        // erasing the value set in super or in the functions called by the constructor as side effect (static_init called from constructor will be overridden too)\r\n        // if need to override types, build the \"new\" static function like in DModelElement\r\n        ISize.init_constructor(this, x, y, w, h);\r\n    }\r\n\r\n\r\n    static printDiff(s1: SizeLike, s2: SizeLike, asPoints:boolean = false, maxDigits:number = 5) {\r\n        s1 = {...s1, w: s1.w ?? s1.width, h: s1.h ?? s1.height};\r\n        s1.x = s1.x ?? s2.x;\r\n        s1.y = s1.y ?? s2.y;\r\n        s2 = {...s2, w: s2.w ?? s2.width, h: s2.h ?? s2.height};\r\n        if (!asPoints) {\r\n            s1.w = s1.w ?? s2.w;\r\n            s1.h = s1.h ?? s2.h;\r\n        }\r\n        let s1coords: (number | string)[] = [];\r\n        s1coords.push(!U.isNumber(s1.x) ? '' : U.cropNum(s1.x, maxDigits));\r\n        s1coords.push(!U.isNumber(s1.y) ? ',' : ', '+U.cropNum(s1.y, maxDigits));\r\n        if (!asPoints) {\r\n            s1coords.push(!U.isNumber(s1.w) ? ',' : ', '+U.cropNum(s1.w, maxDigits));\r\n            s1coords.push(!U.isNumber(s1.h) ? ',' : ', '+U.cropNum(s1.h, maxDigits));\r\n        }\r\n        let s2coords: (number | string)[] = [];\r\n        s2coords.push(s2.x === s1.x || !U.isNumber(s2.x) ? '' : U.cropNum(s2.x, maxDigits));\r\n        s2coords.push(s2.y === s1.y || !U.isNumber(s2.y) ? ',' : ', '+U.cropNum(s2.y, maxDigits));\r\n        if (!asPoints) {\r\n            s2coords.push(s2.w === s1.w || !U.isNumber(s2.w) ? ',' : ', '+U.cropNum(s2.w, maxDigits));\r\n            s2coords.push(s2.h === s1.h || !U.isNumber(s2.h) ? ',' : ', '+U.cropNum(s2.h, maxDigits));\r\n        }\r\n\r\n        // → 🡲\r\n        return `(`+s1coords.join('')+`)🡲(`+s2coords.join('')+`)`;\r\n    }\r\n    static stringify(ptlike: {x?:number, y?:number, w?:number, h?:number, width?:number, height?:number}): string {\r\n        if (!ptlike) return ptlike as any;\r\n        let str: string[] = [];\r\n        if (ptlike.x && !isNaN(ptlike.x)|| ptlike.x === 0) str.push('x:'+U.cropNum(ptlike.x));\r\n        if (ptlike.y && !isNaN(ptlike.y)|| ptlike.y === 0) str.push('y:'+U.cropNum(ptlike.y));\r\n        if (ptlike.w && !isNaN(ptlike.w)|| ptlike.w === 0) str.push('w:'+U.cropNum(ptlike.w));\r\n        if (ptlike.h && !isNaN(ptlike.h)|| ptlike.h === 0) str.push('h:'+U.cropNum(ptlike.h));\r\n        if (ptlike.width && !isNaN(ptlike.width) || ptlike.width === 0) str.push('W:'+U.cropNum(ptlike.width));\r\n        if (ptlike.height && !isNaN(ptlike.height) || ptlike.height === 0) str.push('H:'+U.cropNum(ptlike.height));\r\n        // if (str.length === 0) return '{}';\r\n        return '{'+str.join(', ')+'}';\r\n    }\r\n\r\n    static init_constructor(thiss: GObject, x: any = 0, y: any = 0, w: any = 0, h: any = 0, ...a: any): void {\r\n        thiss.id = \"SIZE_\" + (DPointerTargetable.maxID++) + \"_\" + new Date().getTime();\r\n        thiss.className = (thiss.constructor as typeof RuntimeAccessibleClass).cname;\r\n        if (x === null || x === undefined) thiss.x = undefined as Temporary;\r\n        else if (isNaN(+x)) { thiss.x = 0; }\r\n        else thiss.x = +x;\r\n        if (y === null || y === undefined) thiss.y = undefined as Temporary;\r\n        else if (isNaN(+y)) { thiss.y = 0; }\r\n        else thiss.y = +y;\r\n        if (w === null || w === undefined) thiss.w = undefined as Temporary;\r\n        else if (isNaN(+w)) { thiss.w = 0; }\r\n        else thiss.w = +w;\r\n        if (h === null || h === undefined) thiss.h = undefined as Temporary;\r\n        else if (isNaN(+h)) { thiss.h = 0; }\r\n        else thiss.h = +h;\r\n        thiss.className = this.cname; }\r\n\r\n    public toString(letters: boolean=true, separator: string = \" \"): string {\r\n        if (letters) return JSON.stringify({x: this.x, y: this.y, w: this.w, h: this.h});\r\n        else return this.x + separator + this.y + separator + this.w + separator + this.h;\r\n    }\r\n\r\n    public set(x?: number, y?: number, w?: number, h?: number): void {\r\n        if (x !== undefined) (this.x = +x);\r\n        if (y !== undefined) (this.y = +y);\r\n        if (w !== undefined) (this.w = +w);\r\n        if (h !== undefined) (this.h = +h);\r\n    }\r\n\r\n    protected abstract makePoint(x: number, y: number): PT;\r\n    protected abstract new(...args:any): this;\r\n    public clone(json: this): this { this.x = json.x; this.y = json.y; this.w = json.w; this.h = json.h; return this; }\r\n    public duplicate(): this { return this.new().clone(this); }\r\n\r\n    public add(pt2: number | {x?:number, y?:number, w?:number, h?:number}, newInstance?: boolean): this {\r\n        let thiss = newInstance ? this.duplicate() : this;\r\n        if (typeof pt2 === \"number\") { thiss.x += pt2; thiss.y += pt2; thiss.w += pt2; thiss.h += pt2; return thiss; }\r\n        if (pt2.x !== undefined) thiss.x += pt2.x;\r\n        if (pt2.y !== undefined) thiss.y += pt2.y;\r\n        if (pt2.w !== undefined) thiss.w += pt2.w;\r\n        if (pt2.h !== undefined) thiss.h += pt2.h;\r\n        return thiss; }\r\n\r\n    public subtract(pt2: number | {x?:number, y?:number, w?:number, h?:number}, newInstance?: boolean): this {\r\n        let thiss = newInstance ? this.duplicate() : this;\r\n        if (typeof pt2 === \"number\") { thiss.x -= pt2; thiss.y -= pt2; thiss.w -= pt2; thiss.h -= pt2; return thiss; }\r\n        if (pt2.x !== undefined) thiss.x -= pt2.x;\r\n        if (pt2.y !== undefined) thiss.y -= pt2.y;\r\n        if (pt2.w !== undefined) thiss.w -= pt2.w;\r\n        if (pt2.h !== undefined) thiss.h -= pt2.h;\r\n        return thiss; }\r\n\r\n    public multiply(pt2: number | {x?:number, y?:number, w?:number, h?:number}, newInstance?: boolean): this {\r\n        let thiss = newInstance ? this.duplicate() : this;\r\n        if (typeof pt2 === \"number\") { thiss.x *= pt2; thiss.y *= pt2; thiss.w *= pt2; thiss.h *= pt2; return thiss; }\r\n        if (pt2.x !== undefined) thiss.x *= pt2.x;\r\n        if (pt2.y !== undefined) thiss.y *= pt2.y;\r\n        if (pt2.w !== undefined) thiss.w *= pt2.w;\r\n        if (pt2.h !== undefined) thiss.h *= pt2.h;\r\n        return thiss; }\r\n\r\n    public divide(pt2: number | {x?:number, y?:number, w?:number, h?:number}, newInstance?: boolean): this {\r\n        let thiss = newInstance ? this.duplicate() : this;\r\n        if (typeof pt2 === \"number\") { thiss.x /= pt2; thiss.y /= pt2; thiss.w /= pt2; thiss.h /= pt2; return thiss; }\r\n        if (pt2.x !== undefined) thiss.x /= pt2.x;\r\n        if (pt2.y !== undefined) thiss.y /= pt2.y;\r\n        if (pt2.w !== undefined) thiss.w /= pt2.w;\r\n        if (pt2.h !== undefined) thiss.h /= pt2.h;\r\n        return thiss; }\r\n\r\n\r\n    public tl(): PT {     return this.makePoint(   this.x,                 this.y             ); }\r\n    public tr(): PT {     return this.makePoint(this.x + this.w,        this.y             ); }\r\n    public bl(): PT {     return this.makePoint(   this.x,              this.y + this.h    ); }\r\n    public br(): PT {     return this.makePoint(this.x + this.w,     this.y + this.h    ); }\r\n    public center(): PT { return this.makePoint(this.x + this.w / 2, this.y + this.h / 2); }\r\n    public relativePoint(xPercent: number, yPercent: number): PT { return this.makePoint(this.x + this.w * xPercent, this.y + this.h * yPercent); }\r\n    public equals(size: this): boolean { return this.x === size.x && this.y === size.y && this.w === size.w && this.h === size.h; }\r\n\r\n    /// field-wise Math.min()\r\n    public min(minSize: this, clone: boolean): this {\r\n        const ret: this = clone ? this.new() : this;\r\n        if (!isNaN(minSize.x) && ret.x < minSize.x) { ret.x = minSize.x; }\r\n        if (!isNaN(minSize.y) && ret.y < minSize.y) { ret.y = minSize.y; }\r\n        if (!isNaN(minSize.w) && ret.w < minSize.w) { ret.w = minSize.w; }\r\n        if (!isNaN(minSize.h) && ret.h < minSize.h) { ret.h = minSize.h; }\r\n        return ret; }\r\n    public max(maxSize: this, clone: boolean): this {\r\n        const ret: this = clone ? this.new() : this;\r\n        if (!isNaN(maxSize.x) && ret.x > maxSize.x) { ret.x = maxSize.x; }\r\n        if (!isNaN(maxSize.y) && ret.y > maxSize.y) { ret.y = maxSize.y; }\r\n        if (!isNaN(maxSize.w) && ret.w > maxSize.w) { ret.w = maxSize.w; }\r\n        if (!isNaN(maxSize.h) && ret.h > maxSize.h) { ret.h = maxSize.h; }\r\n        return ret; }\r\n\r\n    public intersection(size: this): this | null {\r\n        if (!size) return null;\r\n        // anche \"isinside\"\r\n        let startx, starty, endx, endy;\r\n        startx = Math.max(this.x, size.x);\r\n        starty = Math.max(this.y, size.y);\r\n        endx = Math.min(this.x + this.w, size.x + size.w);\r\n        endy = Math.min(this.y + this.h, size.y + size.h);\r\n        const intersection: this = this.new();\r\n        // intersection.set(0, 0, 0, 0);\r\n        intersection.x = startx;\r\n        intersection.y = starty;\r\n        intersection.w = endx - startx;\r\n        intersection.h = endy - starty;\r\n        const doesintersect: boolean = intersection.w > 0 && intersection.h > 0;\r\n        return (doesintersect) ? intersection: null; }\r\n\r\n    public contains(pt: PT): boolean {\r\n        return  pt.x >= this.x && pt.x <= this.x + this.w && pt.y >= this.y && pt.y <= this.y + this.h; }\r\n\r\n    public isOverlapping(size2: this): boolean { return !!this.intersection(size2); }\r\n    public isOverlappingAnyOf(sizes: this[]): boolean {\r\n        if (!sizes) return false;\r\n        for (let size of sizes) { if (this.isOverlapping(size)) return true; }\r\n        return false;\r\n    }\r\n\r\n    public multiplyPoint(other: PT, newInstance: boolean): this {\r\n        const ret: this = newInstance ? this.new() : this;\r\n        ret.x *= other.x;\r\n        ret.w *= other.x;\r\n        ret.y *= other.y;\r\n        ret.h *= other.y;\r\n        return ret; }\r\n\r\n    public dividePoint(other: PT, newInstance: boolean): this {\r\n        const ret: this = newInstance ? this.new() : this;\r\n        ret.x /= other.x;\r\n        ret.w /= other.x;\r\n        ret.y /= other.y;\r\n        ret.h /= other.y;\r\n        return ret; }\r\n\r\n    public boundary(size2: this): void {\r\n        /*let minx, maxx, miny, maxy;\r\n        if (size2.y < this.y) { miny = size2.y; /*maxy = this.y;* / } else { miny = this.y; /*maxy = size2.y;* / }\r\n        if (size2.x < this.x) { minx = size2.y; /*maxx = this.x;* / } else { minx = this.x; /*maxy = size2.x;* / }\r\n        if (size2.y + size2.h < this.y + this.h) maxy = this.y + this.h; else maxy = size2.y + size2.h;\r\n        if (size2.x + size2.w < this.x + this.w) maxx = this.x + this.w; else maxx = size2.x + size2.w;\r\n        */\r\n        this.h = (size2.y + size2.h > this.y + this.h ? size2.y + size2.h : this.y + this.h); // -miny\r\n        this.w = (size2.x + size2.w > this.x + this.w ? size2.x + size2.w : this.x + this.w); // -minx\r\n        if (this.y < size2.y) this.y = size2.y;\r\n        if (this.x < size2.x) this.x = size2.x;\r\n        this.h -= this.y;\r\n        this.w -= this.x;\r\n    }\r\n}\r\ntype SizeLike = {x?: number, y?: number, w?: number, h?:number, width?: number, height?: number}\r\ntype PointLike = {x?: number, y?: number}\r\n\r\n@RuntimeAccessible('Size')\r\nexport class Size extends ISize<Point> {\r\n    static subclasses: any[] = [];\r\n    private static sizeofvar: HTMLElement;\r\n    private static $sizeofvar: JQuery<HTMLElement>;\r\n    private dontMixWithGraphSize: any;\r\n\r\n    /**\r\n     * measure a node size\r\n     * @param {Element} element0 - the emelemnt to measure;\r\n     * @param {boolean} sizePostTransform - includes css transform instructions for computing his size. like transform: scale(1.5)\r\n     * */\r\n    public static of(element0: Element, sizePostTransform: boolean = true): Size {\r\n        let element: HTMLElement = element0 as HTMLElement;\r\n        if (element as unknown === document) {\r\n            Log.ww('trying to measure document, rerouted to measuring body.');\r\n            element = document.body as any;\r\n        }\r\n        const $element = $(element);\r\n        Log.ex(!element || element.tagName === 'foreignObject', 'sizeof()', 'SvgForeignElementObject have a bug with size, measure a child instead.', element);\r\n        let tmp;\r\n        let size: Size;\r\n        if (!Size.sizeofvar) {\r\n            Size.sizeofvar = document.createElement('div');\r\n            document.body.append(Size.sizeofvar); }\r\n\r\n        const isOrphan = element.parentNode === null;\r\n        // var visible = element.style.display !== 'none';\r\n        // var visible = $element.is(\":visible\"); crea bug quando un elemento è teoricamente visibile ma orfano\r\n        const ancestors =  windoww.U.ancestorArray(element);\r\n        const displayStyles: string[] = ancestors.map( (e: HTMLElement) => e?.style?.display);\r\n        if (isOrphan) { Size.sizeofvar.append(element); }\r\n        // show all and saveToDB visibility to restore it later\r\n        for (let i = 0; i < ancestors.length; i++) { // document has undefined style\r\n            displayStyles[i] = ancestors[i]?.style?.display;\r\n            if (displayStyles[i] === 'none' || (displayStyles[i] === '' && getComputedStyle(ancestors[i]).display === 'none')) { ancestors[i].style.display = 'block' }\r\n        }\r\n        // size = new Size(tmp.left, tmp.top, 0, 0);\r\n        let rect = element.getBoundingClientRect();\r\n        size = new Size(0, 0, 0, 0);\r\n\r\n        let win = (element.ownerDocument?.defaultView || window);\r\n        size.x = rect.left + win.scrollX;\r\n        size.y = rect.top + win.scrollY;\r\n        if (sizePostTransform) {\r\n            size.w = rect.width;\r\n            size.h = rect.height;\r\n        }\r\n        else {\r\n            size.w = element.offsetWidth; // element.scrollWidth;\r\n            size.h = element.offsetHeight;\r\n        }\r\n        // restore visibility\r\n        for (let i = 0; i < ancestors.length; i++) {\r\n            if (displayStyles[i] === ancestors[i].style?.display) continue;\r\n            if (displayStyles[i]) ancestors[i].style.display = displayStyles[i];\r\n            else ancestors[i].style.removeProperty('display');\r\n        }\r\n        if (isOrphan) {  windoww.U.clear(Size.sizeofvar); }\r\n        // Status.status.getActiveModel().graph.markS(size, false);\r\n        return size;\r\n    }\r\n\r\n    public static fromPoints(firstPt: IPoint, secondPt: IPoint): Size {\r\n        const minX = Math.min(firstPt.x, secondPt.x);\r\n        const maxX = Math.max(firstPt.x, secondPt.x);\r\n        const minY = Math.min(firstPt.y, secondPt.y);\r\n        const maxY = Math.max(firstPt.y, secondPt.y);\r\n        return new Size(minX, minY, maxX - minX, maxY - minY); }\r\n\r\n    protected makePoint(x: number, y: number): Point { return new Point(x, y); }\r\n    protected new(...args:any): this { return new Size(...args) as this; }\r\n}\r\n@RuntimeAccessible('GraphSize')\r\nexport class GraphSize extends ISize<GraphPoint> {\r\n    private dontMixWithSize: any;\r\n\r\n    public static fromPoints(firstPt: GraphPoint, secondPt: GraphPoint): GraphSize {\r\n        const minX = Math.min(firstPt.x, secondPt.x);\r\n        const maxX = Math.max(firstPt.x, secondPt.x);\r\n        const minY = Math.min(firstPt.y, secondPt.y);\r\n        const maxY = Math.max(firstPt.y, secondPt.y);\r\n        return new GraphSize(minX, minY, maxX - minX, maxY - minY); }\r\n\r\n    // both pt and targetPt are readonly-safe parameters\r\n    public static closestIntersection(size: GraphSize, pt: GraphPoint/*segment start*/, targetPt: GraphPoint/*segment end*/, gridAlign?: GraphPoint, m0?:number, q0?:number): GraphPoint | undefined {\r\n        // let pt: GraphPoint = pt0.duplicate();\r\n        const m = m0 || GraphPoint.getM(targetPt, pt);\r\n        const q = q0 || GraphPoint.getQ(targetPt, pt);\r\n        // console.log(\"closestIntersection()\", {size, pt0, targetPt, m, q});\r\n        // let mrecalc = GraphPoint.getM(targetPt, pt);\r\n        // if (mrecalc !== m) console.error('closestIntersection err', {size, pt, targetPt, mrecalc, m, q, mcorrect: mrecalc == m, qcorrect: GraphPoint.getQ(targetPt, pt) === q})\r\n        // else  console.log('closestIntersection 0', {size, pt, targetPt, m, q, mcorrect: mrecalc == m, mrecalc, qcorrect: GraphPoint.getQ(targetPt, pt) === q})\r\n        // if perfectly vertical line\r\n        if (U.isInfinite(m)) {\r\n            // top center\r\n            if (Math.abs(targetPt.y - size.y) <= Math.abs(targetPt.y - size.y - size.h)) return new GraphPoint(pt.x, size.y);\r\n            // bottom center\r\n            else return new GraphPoint(pt.x, size.y + size.h);\r\n        }\r\n        let tl = size.tl(), tr = size.tr(),\r\n            bl = size.bl(), br = size.br();\r\n        let allowT: boolean, allowB: boolean,\r\n            allowL: boolean, allowR: boolean;\r\n        /*let distanceT: number = Number.POSITIVE_INFINITY, distanceB: number = Number.POSITIVE_INFINITY,\r\n            distanceL: number = Number.POSITIVE_INFINITY, distanceR: number = Number.POSITIVE_INFINITY;*/\r\n        let intersectionT: GraphPoint | undefined, intersectionB: GraphPoint | undefined,\r\n            intersectionL: GraphPoint | undefined, intersectionR: GraphPoint | undefined;\r\n\r\n\r\n        allowT = Geom.isNumberBetween(tl.y, bl.y, targetPt.y);\r\n        allowB = Geom.isNumberBetween(bl.y, tl.y, targetPt.y);\r\n        allowL = Geom.isNumberBetween(tl.x, tr.x, targetPt.x);\r\n        allowR = Geom.isNumberBetween(tr.x, tl.x, targetPt.x);\r\n        // console.log(\"closestIntersection pt0\", {size, targetPt, pt0:pt0.raw(), gridAlign,\r\n        //     corners:{tl:tl.raw(), tr:tr.raw(), bl:bl.raw(), br:br.raw()}, allows:{allowT, allowB, allowL, allowR}});\r\n        console.log(\"closestIntersection 1\", {isInternal:!(allowT || allowB || allowL || allowR), allowT, allowB, allowL, allowR});\r\n        if (!(allowT || allowB || allowL || allowR)) return undefined; // point is internal to size\r\n        if (allowT) intersectionT = Geom.lineToSegmentIntersection(tl, tr, q, m); else\r\n        if (allowB) intersectionB = Geom.lineToSegmentIntersection(bl, br, q, m); // NOT else, (T|B) AND (L|R) can happen, or just 1 or 0 of those.\r\n        if (allowL) intersectionL = Geom.lineToSegmentIntersection(tl, bl, q, m); else\r\n        if (allowR) intersectionR = Geom.lineToSegmentIntersection(tr, br, q, m);\r\n\r\n        console.log(\"closestIntersection 2\", {intersectionT, intersectionB, intersectionL, intersectionR});\r\n        // only 1 intersection can happen\r\n        return intersectionT || intersectionB || intersectionL || intersectionR;\r\n    }\r\n    public static closestIntersection_old(size: GraphSize, prevPt: GraphPoint, pt0: GraphPoint, gridAlign?: GraphPoint): GraphPoint | null {\r\n        let ret = GraphSize.closestIntersection0(size, prevPt, pt0, gridAlign) as any;\r\n        // Log.exDev(!Geom.isOnEdge(ret, size), 'ClosestIntersection failed. not on Vertex edge.', {ret, size, prevPt, pt0, gridAlign});\r\n        return ret;\r\n    }\r\n    private static closestIntersection0(vertexGSize: GraphSize, prevPt: GraphPoint, pt0: GraphPoint, gridAlign?: GraphPoint): GraphPoint | null {\r\n        let pt: GraphPoint | null = pt0.duplicate();\r\n        const m = GraphPoint.getM(prevPt, pt) as number;\r\n        const q = GraphPoint.getQ(prevPt, pt) as number;\r\n        // U.pe( Math.abs((pt.y - m * pt.x) - (prevPt.y - m * prevPt.x)) > .001, 'wrong math in Q:', (pt.y - m * pt.x), ' vs ', (prevPt.y - m * prevPt.x));\r\n        /*const isL = prevPt.x < pt.x;\r\n    const isT = prevPt.y < pt.y;\r\n    const isR = !isL;\r\n    const isB = !isT; */\r\n        if (U.isInfinite(m)) { // bottom middle\r\n            return new GraphPoint(vertexGSize.x + vertexGSize.w / 2, vertexGSize.y + vertexGSize.h); }\r\n        // console.log('pt:', pt, 'm:', m, 'q:', q);\r\n        let L: GraphPoint | null = new GraphPoint(0, 0);\r\n        let T: GraphPoint | null = new GraphPoint(0, 0);\r\n        let R: GraphPoint | null = new GraphPoint(0, 0);\r\n        let B: GraphPoint | null = new GraphPoint(0, 0);\r\n        L.x = vertexGSize.x;\r\n        L.y = m * L.x + q;\r\n        R.x = vertexGSize.x + vertexGSize.w;\r\n        R.y = m * R.x + q;\r\n        T.y = vertexGSize.y;\r\n        T.x = (T.y - q) / m;\r\n        B.y = vertexGSize.y + vertexGSize.h;\r\n        B.x = (B.y - q) / m;\r\n        // prendo solo il compreso pt ~ prevPt (escludo così il \"pierce\" sulla faccia opposta), prendo il più vicino al centro.\r\n        // console.log('4 possibili punti di intersezione (LTBR):', L, T, B, R);\r\n        /* this.owner.mark(this.owner.toHtmlCoord(T), true, 'blue');\r\n    this.owner.mark(this.owner.toHtmlCoord(B), false, 'violet');\r\n    this.owner.mark(this.owner.toHtmlCoord(L), false, 'red');\r\n    this.owner.mark(this.owner.toHtmlCoord(R), false, 'orange');*/\r\n        console.log(\"intersect pt1:\", {T, B, L, R});\r\n        if ( (B.x >= pt.x && B.x <= prevPt.x) || (B.x >= prevPt.x && B.x <= pt.x) ) { } else { B = null; }\r\n        if ( (T.x >= pt.x && T.x <= prevPt.x) || (T.x >= prevPt.x && T.x <= pt.x) ) { } else { T = null; }\r\n        if ( (L.y >= pt.y && L.y <= prevPt.y) || (L.y >= prevPt.y && L.y <= pt.y) ) { } else { L = null; }\r\n        if ( (R.y >= pt.y && R.y <= prevPt.y) || (R.y >= prevPt.y && R.y <= pt.y) ) { } else { R = null; }\r\n        console.log(\"intersect pt2:\", {T, B, L, R});\r\n        function closestmix(pt: GraphPoint, closest: GraphPoint, segStart: GraphPoint, segEnd: GraphPoint, mode: \"TB\" | \"LR\"): void {\r\n            // changes pt\r\n            pt.x = closest.x; pt.y = closest.y; return;\r\n            let main: \"x\" | \"y\", sub: \"x\" | \"y\";\r\n            if (mode === \"TB\") { main = \"y\"; sub = \"x\"; } else { main = \"x\"; sub = \"y\"; }\r\n            pt[main] = closest[main];\r\n            // if T[sub] is inside the top segment, take T[sub], otherwise closest between size.tl[sub] and size.tr[sub]\r\n            // pt[sub] = Math.max(segStart[sub], Math.min(segStart[sub], closest[sub]));\r\n            if (closest[sub] <= segEnd[sub] && closest[sub] >= segStart[sub]) pt[sub] = closest[sub];\r\n            else if (Math.abs(closest[sub]-segEnd[sub]) < Math.abs(closest[sub]-segStart[sub])) pt[sub] = segEnd[sub];\r\n            else pt[sub] = segStart[sub];\r\n        }\r\n        function closestmix2(pt: GraphPoint, closest: GraphPoint, segStart: GraphPoint, segEnd: GraphPoint, mode: \"TB\" | \"LR\"): void {\r\n            // changes closest\r\n            let main: \"x\" | \"y\", sub: \"x\" | \"y\";\r\n            if (mode === \"TB\") { main = \"y\"; sub = \"x\"; } else { main = \"x\"; sub = \"y\"; }\r\n            // closest[main] = pt[main];\r\n            // if T[sub] is inside the top segment, take T[sub], otherwise closest between size.tl[sub] and size.tr[sub]\r\n            // pt[sub] = Math.max(segStart[sub], Math.min(segStart[sub], closest[sub]));\r\n            if (closest[sub] <= segEnd[sub] && closest[sub] >= segStart[sub]) {/*no-op*/}\r\n            else if (Math.abs(closest[sub]-segEnd[sub]) < Math.abs(closest[sub]-segStart[sub])) closest[sub] = segEnd[sub];\r\n            else closest[sub] = segStart[sub];\r\n        }\r\n        console.log(\"intersect pt2.5:\");\r\n        try{\r\n            if(T) closestmix2(pt, T, vertexGSize.tl(), vertexGSize.tr(), \"TB\");\r\n            if(B) closestmix2(pt, B, vertexGSize.bl(), vertexGSize.br(), \"TB\");\r\n            if(R) closestmix2(pt, R, vertexGSize.tr(), vertexGSize.br(), \"LR\");\r\n            if(L) closestmix2(pt, L, vertexGSize.tl(), vertexGSize.bl(), \"LR\");\r\n        } catch(e){ console.error(\"intersect error\",e)}\r\n        // console.log('superstiti step1: (LTBR):', L, T, B, R);\r\n        console.log(\"intersect pt2.9:\");\r\n        const vicinanzaT = !T ? Number.POSITIVE_INFINITY : ((T.x - pt.x) * (T.x - pt.x)) + ((T.y - pt.y) * (T.y - pt.y));\r\n        const vicinanzaB = !B ? Number.POSITIVE_INFINITY : ((B.x - pt.x) * (B.x - pt.x)) + ((B.y - pt.y) * (B.y - pt.y));\r\n        const vicinanzaL = !L ? Number.POSITIVE_INFINITY : ((L.x - pt.x) * (L.x - pt.x)) + ((L.y - pt.y) * (L.y - pt.y));\r\n        const vicinanzaR = !R ? Number.POSITIVE_INFINITY : ((R.x - pt.x) * (R.x - pt.x)) + ((R.y - pt.y) * (R.y - pt.y));\r\n        const closest = Math.min(vicinanzaT, vicinanzaB, vicinanzaL, vicinanzaR);\r\n        console.log(\"intersect pt3:\", {vicinanzaT, vicinanzaB, vicinanzaL, vicinanzaR, closest});\r\n\r\n        // console.log( 'closest:', closest);\r\n        // succede quando pt e prevPt sono entrambi all'interno del rettangolo del vertice.\r\n        // L'edge non è visibile e il valore ritornato è irrilevante.\r\n\r\n        if (closest === Number.POSITIVE_INFINITY) {\r\n            console.error('x01 case +inf, this case should not be possible', {closest, T, B, L, R, vertexGSize, prevPt, pt0});\r\n            /* top center */\r\n            pt = vertexGSize.tl();\r\n            pt.x += vertexGSize.w / 2; } else\r\n        if (closest === Number.NEGATIVE_INFINITY) {\r\n            console.error('x01 case -inf, this case should not be possible', {closest, T, B, L, R, vertexGSize, prevPt, pt0});\r\n            /* bottom center */\r\n            pt = vertexGSize.br();\r\n            pt.x -= vertexGSize.w / 2; } else\r\n        if (closest === vicinanzaT && T) {\r\n            closestmix(pt, T as any, vertexGSize.tl(), vertexGSize.tr(), \"TB\");\r\n            /*pt.y = T.y;\r\n            // if T.x is inside the top segment, take T.x, otherwise closest between size.tl.x and size.tr.x\r\n            if ((T.x <= tr.x && T.x >= tl.x)) pt.x = T.x;\r\n            else if (Math.abs(T.x-tr.x) < Math.abs(T.x-tl.x)) pt.x = tr.x;\r\n            else pt.x = tl.x;*/\r\n        }\r\n        if (closest === vicinanzaB) { closestmix(pt, B as any, vertexGSize.bl(), vertexGSize.br(), \"TB\"); } else\r\n        if (closest === vicinanzaR) { closestmix(pt, R as any, vertexGSize.tr(), vertexGSize.br(), \"LR\"); } else\r\n        if (closest === vicinanzaL) { closestmix(pt, L as any, vertexGSize.tl(), vertexGSize.bl(), \"LR\"); }\r\n\r\n        if (!gridAlign) { return pt; }\r\n        if (!pt) return null;\r\n        if (gridAlign.x && (pt === T || pt === B || isNaN(closest))) {\r\n            const floorX: number = Math.floor(pt.x / gridAlign.x) * gridAlign.x;\r\n            const ceilX: number = Math.ceil(pt.x / gridAlign.x) * gridAlign.x;\r\n            let closestX;\r\n            let farthestX;\r\n            if (Math.abs(floorX - pt.x) < Math.abs(ceilX - pt.x)) {\r\n                closestX = floorX; farthestX = ceilX;\r\n            } else { closestX = ceilX; farthestX = floorX; }\r\n\r\n            // todo: possibile causa del bug che non allinea punti fake a punti reali. nel calcolo realPT questo non viene fatto.\r\n            // if closest grid intersection is inside the vertex.\r\n            if (closestX >= vertexGSize.x && closestX <= vertexGSize.x + vertexGSize.w) { pt.x = closestX; } else\r\n                // if 2° closer grid intersection is inside the vertex.\r\n            if (closestX >= vertexGSize.x && closestX <= vertexGSize.x + vertexGSize.w) { pt.x = farthestX;\r\n                // if no intersection are inside the vertex (ignore grid)\r\n            } else { /* do nothing */ }\r\n        } else if (gridAlign.y && (pt === L || pt === R)) {\r\n            const floorY: number = Math.floor(pt.y / gridAlign.y) * gridAlign.y;\r\n            const ceilY: number = Math.ceil(pt.y / gridAlign.y) * gridAlign.y;\r\n            let closestY;\r\n            let farthestY;\r\n            if (Math.abs(floorY - pt.y) < Math.abs(ceilY - pt.y)) {\r\n                closestY = floorY; farthestY = ceilY;\r\n            } else { closestY = ceilY; farthestY = floorY; }\r\n\r\n            // if closest grid intersection is inside the vertex.\r\n            if (closestY >= vertexGSize.y && closestY <= vertexGSize.y + vertexGSize.h) { pt.y = closestY; } else\r\n                // if 2° closer grid intersection is inside the vertex.\r\n            if (closestY >= vertexGSize.y && closestY <= vertexGSize.y + vertexGSize.h) { pt.y = farthestY;\r\n                // if no intersection are inside the vertex (ignore grid)\r\n            } else { /* do nothing */ }\r\n        }\r\n        return pt; }\r\n\r\n\r\n    protected new(...args: any): this { return new GraphSize(...args) as this; }\r\n    protected makePoint(x: number, y: number): GraphPoint { return new GraphPoint(x, y) as GraphPoint; }\r\n\r\n    closestPoint(pt: GraphPoint): GraphPoint { return Geom.closestPoint(this, pt); }\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(RuntimeAccessibleClass, ISize);\r\nRuntimeAccessibleClass.set_extend(ISize, Size);\r\nRuntimeAccessibleClass.set_extend(ISize, GraphSize);\r\n\r\n\r\n\r\nexport type PositionStrTypes =\r\n    \"top\" | \"bottom\" | \"left\" | \"right\" | \"\" | // '' = x&y center, undefined = top\r\n    \"top right\" | \"top left\" | \"bottom left\" | \"bottom right\" |\r\n    \"right top\" | \"left top\" | \"left bottom\" | \"right bottom\" |\r\n    \"t\" | \"b\" | \"l\" | \"r\" |\r\n    \"tl\" | \"tr\" | \"bl\" | \"br\" |\r\n    \"lt\" | \"rt\" | \"lb\" | \"rb\";\r\n\r\n@RuntimeAccessible('PositionStr')\r\nexport class PositionStr{\r\n    public static cname = 'PositionStr';\r\n\r\n    x: -1 | 0 | 1; // left, centered, right\r\n    y: -1 | 0 | 1;\r\n    constructor(x?: PositionStr['x'], y? :PositionStr['y']){\r\n        this.x = x ?? 0;\r\n        this.y = y ?? -1;\r\n    }\r\n    toString(): PositionStrTypes{\r\n        return PositionStr.toPosString(this);\r\n    }\r\n    invert(x = true, y = true): this {\r\n        if (x) this.x = -this.x as 1|0|-1;\r\n        if (y) this.y = -this.y as 1|0|-1;\r\n        return this;\r\n    }\r\n    public static toPosString(o: PositionStr): PositionStrTypes{\r\n        let s: string;\r\n        if (o.y === -1) s = 't';\r\n        else if (o.y === 1) s = 'b';\r\n        else s = '';\r\n\r\n        if (o.x === -1) s += 'l';\r\n        else if (o.x === 1) s += 'r';\r\n        // else s = +'';\r\n        // if (!s) return \"c\";\r\n        return s as PositionStrTypes;\r\n    }\r\n    public static fromPosString(position?: PositionStrTypes): PositionStr{\r\n        let ret = new PositionStr(0, 0);\r\n        let posarr = (position ?? 't').split(' '); // .map(s=>s[0]);\r\n        for (let p of posarr)\r\n            switch (p) {\r\n                default:\r\n                case \"t\": case \"top\":                       ret.y = -1; break;\r\n                case \"b\": case \"bottom\":                    ret.y =  1; break;\r\n                case \"l\": case \"left\":                      ret.x = -1; break;\r\n                case \"r\": case \"right\":                     ret.x =  1; break;\r\n                case \"tl\": case \"lt\": case \"top left\":      ret.y = -1; ret.x = -1; break;\r\n                case \"tr\": case \"rt\": case \"top right\":     ret.y = -1; ret.x =  1; break;\r\n                case '': case 'c':                          ret.x =  0; ret.y =  0; break;\r\n                case \"bl\": case \"lb\": case \"bottom left\":   ret.y =  1; ret.x = -1; break;\r\n                case \"br\": case \"rb\": case \"bottom right\":  ret.y =  1; ret.x =  1; break;\r\n            }\r\n        return ret;\r\n    }\r\n    public static invertPosStr(pos?: PositionStrTypes): PositionStrTypes{\r\n        return PositionStr.fromPosString(pos).invert().toString() as any;\r\n    }\r\n\r\n    private static toFullLabelSingle(position: string | \"\" | \"c\" | \"t\" | \"b\" | \"l\" | \"r\"): \"top\" | \"bottom\" | \"left\" | \"right\" | \"center\" {\r\n        switch (position?.trim()[0]){\r\n            case 'c': case '': return 'center';\r\n            case 't': return 'top';\r\n            default: if (position.trim() === '') return 'center'; return 'bottom';\r\n            case 'b': return 'bottom';\r\n            case 'l': return 'left';\r\n            case 'r': return 'right';\r\n        }\r\n    }\r\n    // tl -> top left\r\n    static toSeparateFullLabels(position?: PositionStrTypes): string {\r\n        let pos = (position ?? 'b').trim();\r\n\r\n        if (pos.length === 2) {\r\n            return PositionStr.toFullLabelSingle(pos[0]) + ' ' + PositionStr.toFullLabelSingle(pos[1]);\r\n        } else if (pos.indexOf(' ')) { return pos.split(' ').map(s => PositionStr.toFullLabelSingle(s as any)).join(' '); }\r\n        else return PositionStr.toFullLabelSingle(pos[0]);\r\n        return \"\";\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('Geom')\r\nexport class Geom extends RuntimeAccessibleClass {\r\n\r\n    static markings: Dictionary<string, HTMLElement> = {};\r\n    static unmark(key: string): boolean{\r\n        if (!Geom.markings[key]) return false;\r\n        let e = Geom.markings[key];\r\n        U.removeFromDom(e);\r\n        delete Geom.markings[key];\r\n        return true;\r\n    }\r\n    static markPt(key: string, pt: Point, color?: string, label?: string): HTMLElement{ return Geom.mark(key, pt.x, pt.y, 1, 1, color, label); }\r\n    static markSize(key: string, pt: Size, color?: string, label?: string): HTMLElement{ return Geom.mark(key, pt.x, pt.y, pt.w??1, pt.h??1, color, label); }\r\n    static mark(key: string, x: number, y: number, w: number=1, h: number=1, color: string='red', label: string=''): HTMLElement{\r\n        if (Geom.markings[key]) Geom.unmark(key);\r\n        let e: HTMLElement;\r\n        let pre = '<div class=\"debug-mark\" data-key=\"'+key+'\" data-label=\"'+label+'\" style=\"position: absolute; z-index:99999; left:'+x+'px; top:'+y+'px; width: '+w+'px; height: '+h+'px;';\r\n        let post = '\"/>';\r\n        if (w + h > 2) {\r\n            e = U.toHtml(pre+'border-radius:0; background: transparent;'+post) as HTMLElement;\r\n        }\r\n        else {\r\n            e = U.toHtml(pre+'border-radius:100%; background: '+color+'; outline: 1px solid '+color+'; outline-offset: 5px;'+post) as HTMLElement;\r\n        }\r\n        document.body.append(e);\r\n        Geom.markings[key] = e;\r\n        return e;\r\n    }\r\n    // warning: nodes from other iframes will say are not instance from Element of the current frame, in that case need duck typing.\r\n    public static isHtmlNode(element: any): element is Element {\r\n        return element instanceof Element || element instanceof HTMLDocument || element instanceof SVGElement;\r\n    }\r\n\r\n\r\n    static isPositiveZero(m: number): boolean {\r\n        if (!!Object.is) { return Object.is(m, +0); }\r\n        return (1 / m === Number.POSITIVE_INFINITY); }\r\n\r\n    static isNegativeZero(m: number): boolean {\r\n        if (!!Object.is) { return Object.is(m, -0); }\r\n        return (1 / m === Number.NEGATIVE_INFINITY); }\r\n\r\n    static TanToRadian(n: number): number { return Geom.DegreeToRad(Geom.TanToDegree(n)); }\r\n    static TanToDegree(n: number): number {\r\n        if (Geom.isPositiveZero(n)) { return 0; }\r\n        if (n === Number.POSITIVE_INFINITY) { return 90; }\r\n        if (Geom.isNegativeZero(n)) { return 180; }\r\n        if (n === Number.NEGATIVE_INFINITY) { return 270; }\r\n        return Geom.RadToDegree((window as any).Math.atan(n)); }\r\n\r\n    static RadToDegree(radians: number): number { return Geom.radToDeg(radians); }\r\n    static DegreeToRad(degree: number): number { return Geom.degToRad(degree); }\r\n    static radToDeg(radians: number): number { return radians * (180 / Math.PI); }\r\n    static degToRad(degree: number): number { return degree * (Math.PI / 180); }\r\n\r\n\r\n\r\n    private static GeomTolerance = 0; // 0.001;\r\n    static isOnEdge(pt: GraphPoint, shape: GraphSize, tolerance: number = Geom.GeomTolerance): boolean {\r\n        return Geom.isOnHorizontalEdges(pt, shape, tolerance) || Geom.isOnVerticalEdges(pt, shape, tolerance); }\r\n\r\n    static isOnVerticalEdges(pt: GraphPoint, shape: GraphSize, tolerance: number = Geom.GeomTolerance): boolean {\r\n        return Geom.isOnLeftEdge(pt, shape, tolerance) || Geom.isOnRightEdge(pt, shape, tolerance); }\r\n\r\n    static isOnHorizontalEdges(pt: GraphPoint, shape: GraphSize, tolerance: number = Geom.GeomTolerance): boolean {\r\n        return Geom.isOnTopEdge(pt, shape, tolerance) || Geom.isOnBottomEdge(pt, shape, tolerance); }\r\n\r\n    static isOnRightEdge(pt: GraphPoint, shape: GraphSize, tolerance: number = Geom.GeomTolerance): boolean {\r\n        if (!pt || !shape) { return false; }\r\n        if (tolerance) return Math.abs(pt.x - (shape.x + shape.w)) < tolerance\r\n            && ( pt.y - shape.y > tolerance && pt.y - (shape.y + shape.h) < tolerance);\r\n        return (pt.x === shape.x + shape.w) && (pt.y >= shape.y && pt.y <= shape.y + shape.h);\r\n    }\r\n\r\n    static isOnLeftEdge(pt: GraphPoint, shape: GraphSize, tolerance: number = Geom.GeomTolerance): boolean {\r\n        if (!pt || !shape) { return false; }\r\n        if (tolerance) return Math.abs(pt.x - shape.x) < tolerance\r\n            && (pt.y - shape.y > tolerance && pt.y - (shape.y + shape.h) < tolerance);\r\n        return (pt.x === shape.x) && (pt.y >= shape.y && pt.y <= shape.y + shape.h);\r\n    }\r\n\r\n    static isOnTopEdge(pt: GraphPoint, shape: GraphSize, tolerance: number = Geom.GeomTolerance): boolean {\r\n        if (!pt || !shape) { return false; }\r\n        if (tolerance) return Math.abs(pt.y - shape.y) < tolerance\r\n            && (pt.x - shape.x > tolerance && pt.x - (shape.x + shape.w) < tolerance);\r\n        return (pt.y === shape.y) && (pt.x >= shape.x && pt.x <= shape.x + shape.w);\r\n    }\r\n\r\n    static isOnBottomEdge(pt: GraphPoint, shape: GraphSize, tolerance?: number): boolean {\r\n        if (!pt || !shape) { return false; }\r\n        if (tolerance) return Math.abs(pt.y - shape.y + shape.h) < tolerance\r\n            && (pt.x - shape.x > tolerance && pt.x - (shape.x + shape.w) < tolerance);\r\n        return (pt.y === shape.y + shape.h) && (pt.x >= shape.x && pt.x <= shape.x + shape.w);\r\n    }\r\n\r\n    static closestPoint(size: GraphSize, pt: GraphPoint): GraphPoint {\r\n        let top_closest = Geom.closestPointToSegment(size.tl(), size.tr(), pt);\r\n        let bot_closest = Geom.closestPointToSegment(size.bl(), size.br(), pt);\r\n        let left_closest = Geom.closestPointToSegment(size.tl(), size.bl(), pt);\r\n        let right_closest = Geom.closestPointToSegment(size.tr(), size.br(), pt);\r\n\r\n        let top_distance = top_closest.distanceFromPoint(pt, false);\r\n        let bot_distance = bot_closest.distanceFromPoint(pt, false);\r\n        let left_distance = left_closest.distanceFromPoint(pt, false);\r\n        let right_distance = right_closest.distanceFromPoint(pt, false);\r\n\r\n        let min_distance = Math.min(top_distance, bot_distance, left_distance, right_distance);\r\n        if (min_distance === top_distance) return top_closest;\r\n        if (min_distance === bot_distance) return bot_closest;\r\n        if (min_distance === left_distance) return left_closest;\r\n        return right_closest;\r\n    }\r\n    static isMinusZero(number: number) {return 1/number == -Infinity;}\r\n    static closestPointToSegment(segStart: GraphPoint, segEnd:GraphPoint, pt: GraphPoint): GraphPoint{\r\n        // 1) find equation of line passing for start, end.\r\n        // 2) then find all perpendicular lines, then the perpendicular line that pass through pt\r\n        // 3) find intersection between Line(s,e) and line of point 2.\r\n        // 4A) IF intersection is part of segment(s,e) that is closest.\r\n        // 4B) ELSE, one of the 2 extremes of the segment is closest.\r\n\r\n        let x_intersect: number, y_intersect: number;\r\n        let s = segStart;\r\n        let e = segEnd;\r\n        let mse = (e.y - s.y) / (e.x - s.x);\r\n        if (mse === Number.POSITIVE_INFINITY || mse === Number.NEGATIVE_INFINITY) {\r\n            // s and e are both on the same y vertical line (same x)      // new GraphPoint(segStart.x, pt.y);\r\n            x_intersect = segStart.x;\r\n            y_intersect = pt.y;\r\n            // 1), 2), 3) all done shortcut\r\n        } else if (mse === 0 || Geom.isNegativeZero(mse)) {\r\n            // s and e are both on the same x horizontal line (same y)    // new GraphPoint(pt.x, segStart.y);\r\n            x_intersect = pt.x;\r\n            y_intersect = segStart.y\r\n            // 1), 2), 3) all done shortcut\r\n        }\r\n        else {\r\n            let q = s.y - mse*s.x; // y = mx + q           q = y-mx\r\n            // 1) done\r\n            let pmse = -1/mse; // perpendicular to mse\r\n            let pq = pt.y - pmse*pt.x;\r\n            // 2) done\r\n            //  m1 * x + q1 = y    -->   m1 * x + q1 = m2 * x + q2    -->    (m1-m2)x = q2-q1      -->     x=(q2-q1)/(m1-m2)\r\n            x_intersect = (pq-q)/(mse-pmse);\r\n            y_intersect = mse*(x_intersect) + q; //  y = mx +q\r\n            // 3) done\r\n        }\r\n\r\n        let maxX: number, minX: number;\r\n        let maxY: number, minY: number;\r\n        if (s.x > e.x) { maxX = s.x; minX = e.x; } else {  maxX = e.x; minX = s.x; }\r\n        if (s.y > e.y) { maxY = s.y; minY = e.y; } else {  maxY = e.y; minY = s.y; }\r\n        if (x_intersect >= minX && x_intersect <= maxX && y_intersect >= minY && y_intersect <= maxY) return new GraphPoint(x_intersect, y_intersect);\r\n        // 4A) IF done\r\n\r\n        let sdist = (s.x - x_intersect)**2 + (s.y - y_intersect)**2;  // actual distance is sqrt() of this, but i just need to find closest, not correct distance.\r\n        let edist = (e.x - x_intersect)**2 + (e.y - y_intersect)**2;\r\n        return (sdist < edist) ? new GraphPoint(s.x, s.y) : new GraphPoint(e.x, e.y);\r\n        // 4B) ELSE done\r\n    }\r\n\r\n    // @param: lineX = only required if m === (+-)infinite, is the X coord where the vertical line lies.\r\n    static lineToSegmentIntersection(segStart: GraphPoint, segEnd: GraphPoint, q: number, m: number, lineX?: number): GraphPoint | undefined {\r\n        let lineIsVertical = m === Number.POSITIVE_INFINITY || m === Number.NEGATIVE_INFINITY;\r\n        let lineIsHorizontal = +m === 0; // unary plus operator is required because: +(-0)  === 0, but not sure if -0 === 0\r\n        let isNaNm = isNaN(m);\r\n        let isNaNq = isNaN(q);\r\n        Log.eDev(isNaNm && isNaNq || isNaNm && !isNaNq, 'Error in Geom lineSegmentIntersection, m and q are not coherent', {m, q});\r\n        Log.w((isNaNm || isNaNq) && lineX === undefined, 'Error in Geom lineSegmentIntersection, m is infinite and no points were provided', {m, q});\r\n        if (segStart.x === segEnd.x){ // vertical segment |\r\n            if (lineIsVertical) {\r\n                if (lineX !== undefined && lineX === segStart.x) return new GraphPoint(lineX, (segStart.y + segEnd.y)/2); // complete overlap of segment and line, i take middle\r\n                return undefined; // parallel vertical segment-line\r\n            } else { // vertical segment, skewed or horizontal line\r\n                let y = m*segStart.x + q;\r\n                if (Geom.isNumberBetween(y, segStart.y, segEnd.y)) return new GraphPoint(segStart.x, y);\r\n                else return undefined;\r\n            }\r\n        }\r\n        else if (segStart.y === segEnd.y) { // horizontal segment -------------------\r\n            if (lineIsVertical) {\r\n                if (lineX !== undefined && Geom.isNumberBetween(lineX, segStart.x, segEnd.x)) return new GraphPoint(lineX, segStart.y); // perpendicular and intersecating\r\n                return undefined; // perpendicular but outside segment width\r\n            }\r\n            else if (lineIsHorizontal) { // horizontal line\r\n                if (Geom.isNumberBetween(q, segStart.y, segEnd.y)) return new GraphPoint((segStart.x + segEnd.x), q); // complete overlap of segment and line, i take middle\r\n                return undefined; // parallel horizontal line-segment\r\n            } else {\r\n                let x = (segStart.y-q)/m;\r\n                if (Geom.isNumberBetween(x, segStart.x, segEnd.x)) return new GraphPoint(x, segStart.y);\r\n                else return undefined;\r\n            }\r\n        }\r\n\r\n        let m2 = segStart.getM(segEnd);\r\n        let q2 = IPoint.getQ(segStart, segEnd);\r\n        // NB: at this point m2 cannot be infinite | -infinite, but can be -0, m can be anything\r\n        if (+m === +m2) {\r\n            if (+q === +q2) return segStart; // line and segment coincident\r\n            return undefined; // parallel\r\n        }\r\n        let intersect: GraphPoint | undefined;\r\n        if (U.isInfinite(m)) {\r\n            if (lineX !== undefined) intersect = new GraphPoint(lineX, m2*lineX + q2);\r\n            return undefined;\r\n        } else {\r\n            intersect = Geom.lineToLineIntersection(m, q, m2, q2, undefined);\r\n        }\r\n        if (intersect && Geom.isNumberBetween(intersect.x, segStart.x, segEnd.x) && Geom.isNumberBetween(intersect.y, segStart.y, segEnd.y)) return intersect;\r\n        else return undefined;\r\n    }\r\n\r\n    static isNumberBetween(target: number, s: number, e: number): boolean {\r\n        let max = Math.max(s, e);\r\n        let min = Math.min(s, e);\r\n        return target >= min && target <= max; }\r\n\r\n\r\n    // NB invalid if any of the lines are verytical, in which case need to take the X of the vertical line (xVertical) and intersection is: new Point(xVertical, m_otherLine * xVertical + q_otherLine)\r\n    private static lineToLineIntersection(m: number, q: number, m2: number, q2: number, retIfInvalid: any, retIfParallel: any = undefined, retIfCoincident: any = undefined): undefined | GraphPoint {\r\n\r\n        if (+m === +m2 || U.isInfinite(m) && U.isInfinite(m2)) {\r\n            if (+q === +q2 || U.isInfinite(q) && U.isInfinite(q2)) return retIfCoincident; // line and segment coincident\r\n            return retIfParallel; // parallel\r\n        }\r\n\r\n        if (m === Number.POSITIVE_INFINITY || m === Number.NEGATIVE_INFINITY || m2 === Number.POSITIVE_INFINITY || m2 === Number.NEGATIVE_INFINITY) {\r\n            // m or m2 are a vertical line, Q must be invalid too and i don't have a single point of the line.\r\n            // it's actually infinite possible vertical parallel lines.\r\n            return retIfInvalid;\r\n        }\r\n        /*\r\n            y = mx + q\r\n            y = nx + w\r\n            -->\r\n            mx + q = nx + w\r\n            -->\r\n            mx - nx = w - q\r\n            -->\r\n            x (m - n) = w - q\r\n            -->\r\n            x = (w - q)/(m - n)\r\n        */\r\n        let x = (q2-q)/(m-m2);\r\n        return new GraphPoint(x, m*x+q); }\r\n    // @param start, end: are for determining direction. every m is a line that can be seen in 2 direction\r\n    static mToRad(m: number, start: GraphPoint, end: GraphPoint): number {\r\n        let rad: number;\r\n        if (start.x === end.x) {\r\n            rad = (start.y < end.y) ? Math.PI * 3/2 :  Math.PI / 2;\r\n        } else {\r\n            // console.log(\"rad diagonal\", {base:  Math.atan(m), add: start.x > end.x, sx: start.x, ex: end.x});\r\n            rad = Math.atan(m) + (start.x > end.x ? 0 : Math.PI);\r\n        }\r\n        return rad; }\r\n\r\n    // intersect a rectangle with a line or segment (if end parameter is specified)\r\n    // @return: [0, 2] intersections\r\n    static lineToSizeIntersection_TODO(size: GraphSize, m: number, startLine: GraphPoint, endIfSegment?: GraphPoint): [] | [GraphPoint] | [GraphPoint, GraphPoint] {\r\n         // todo: use GraphSize.closestIntersection which is close. it is size-segment returning only the closest intersection\r\n        return [];\r\n    }\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(RuntimeAccessibleClass, Geom);\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\common\\Uhtml.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\api\\data.ts",["786","787","788","789"],"import type {\r\n    Json,\r\n    Pointer,\r\n    GObject,\r\n    Dictionary,\r\n    DocString} from \"../joiner\";\r\nimport {\r\n    Log,\r\n    DModelElement,\r\n    DModel,\r\n    LModel,\r\n    DValue,\r\n    LValue,\r\n    DObject,\r\n    LObject,\r\n    DEnumerator,\r\n    DEnumLiteral,\r\n    DAttribute,\r\n    LAttribute,\r\n    DReference,\r\n    LReference,\r\n    DClassifier,\r\n    DClass,\r\n    LClass,\r\n    DParameter,\r\n    DOperation,\r\n    DPackage,\r\n    LPackage,\r\n    DTypedElement,\r\n    LTypedElement,\r\n    DAnnotation,\r\n    AttribETypes,\r\n    U,\r\n    CreateElementAction,\r\n    Selectors,\r\n    PointedBy,\r\n    LPointerTargetable,\r\n    windoww,\r\n    SetRootFieldAction,\r\n    Constructors,\r\n    store,\r\n    SetFieldAction,\r\n    DPointerTargetable, ShortAttribETypes, toLongEType, DState, Debug\r\n} from \"../joiner\";\r\nimport {DefaultEClasses, ShortDefaultEClasses, toLongEClass} from \"../common/U\";\r\n\r\ntype RET<T = boolean> = T | Promise<T>;\r\ntype Ret = RET;\r\n\r\nclass SavePack{\r\n    model: string;\r\n    vertexpos: string;\r\n    view: string;\r\n    constructor(model: string='', vertexpos: string='', view:string='') {\r\n        this.model = model;\r\n        this.vertexpos = vertexpos;\r\n        this.view = view;\r\n    }\r\n}\r\n\r\ntype JsonSavePack = {[key in keyof SavePack]: Json | null }\r\n\r\n\r\nexport abstract class IStorage{\r\n    static get():IStorage { return Log.exx(\"IStorage.get (static) should be overridden\"); }\r\n    public prefix: string;\r\n    public autosave: boolean;\r\n    constructor(prefix: string, autosave: boolean) {\r\n        this.prefix = prefix;\r\n        this.autosave = autosave;\r\n    }\r\n\r\n\r\n    public del(key: string | number): boolean{\r\n        let isOverwrite = this.get(key) !== null;\r\n        this.set(key, '');\r\n        return isOverwrite; }\r\n    public abstract set(key: string | number, val: string | any): RET;\r\n    get<T extends boolean>(key: string | number, parse: T = false as any): T extends false ? null | string : null | any{ return Log.exx(\"IStorage.get should be overridden\"); }\r\n\r\n    protected serialize(val: any): string { // serialize\r\n        try { return JSON.stringify(val); } catch(e){ return \"\"+val; }\r\n    }\r\n    protected deserialize(val: string): any{ // de-serialize\r\n        try { return JSON.parse(val); } catch(e){ return val; }\r\n    }\r\n    protected set0(val: any): string { return this.serialize(val); }\r\n    protected get0(val: any): string { return this.deserialize(val); }\r\n    protected parse(val: any): string { return this.deserialize(val); }\r\n}\r\n\r\nexport class LocalStorage extends IStorage{\r\n    public static get():LocalStorage {return new LocalStorage(\"_j\", true); }\r\n    private constructor (prefix: string, autosave: boolean) { super(prefix, autosave); }\r\n\r\n    private static KeyList= {lastOpenedModel: \"lastOpenedModel\",lastOpenedView: \"lastOpenedView\",lastOpenedPosition: \"lastOpenedPosition\",}\r\n\r\n\r\n    get<T extends boolean>(key: string | number, parse: T = false as any): T extends false ? null | string : null | any{\r\n        let val = localStorage.getItem(this.prefix+key);\r\n        return parse ? this.parse(val) : val;\r\n    }\r\n\r\n    set(key?: string | number, val?: string | any): boolean {\r\n        val = this.serialize(val);\r\n        // let isOverwrite = localStorage.getItem(this.prefix+key);\r\n        localStorage.set(this.prefix+key, val);\r\n        return true;\r\n    }\r\n\r\n\r\n    public getLastOpened(modelNumber: 1 | 2): SavePack {\r\n        let modelname = \"m\" + modelNumber + \"_\";\r\n        const ret: SavePack = new SavePack();\r\n        ret.model = this.get(modelname + LocalStorage.KeyList.lastOpenedModel, false) || '';\r\n        ret.view = this.get(modelNumber + LocalStorage.KeyList.lastOpenedView, false) || '';\r\n        ret.vertexpos = this.get(modelNumber + LocalStorage.KeyList.lastOpenedPosition, false) || '';\r\n        return ret; }\r\n\r\n    public deleteLastOpened(modelNumber: 1 | 2): void { this.setLastOpened(modelNumber, '', '', ''); }\r\n\r\n    public setLastOpened(modelNumber: 1 | 2, model: string = '', view: string = '', vertex: string = ''): void {\r\n        let modelname = \"m\" + modelNumber + \"_\";\r\n        if (model) this.set(modelname + LocalStorage.KeyList.lastOpenedModel, model);\r\n        else this.del(modelname +  LocalStorage.KeyList.lastOpenedModel);\r\n        if (view) this.set(modelname + LocalStorage.KeyList.lastOpenedView, view);\r\n        else this.del(modelname +  LocalStorage.KeyList.lastOpenedView);\r\n        if (vertex) this.set(modelname + LocalStorage.KeyList.lastOpenedPosition, vertex);\r\n        else this.del(modelname +  LocalStorage.KeyList.lastOpenedPosition); }\r\n\r\n\r\n}\r\n\r\nexport class EcoreParser{\r\n    static supportedEcoreVersions = [\"http://www.eclipse.org/emf/2002/Ecore\"];\r\n    static prefix:string = '@';\r\n\r\n    static parse(ecorejson: GObject | string | null, isMetamodel: boolean, filename: string | undefined, persist: boolean = true): DModelElement[]{\r\n        if (!ecorejson) return [];\r\n        let parsedjson: GObject;\r\n        if (typeof ecorejson === \"string\") try { parsedjson = JSON.parse(ecorejson); } catch(e) { windoww.temp = ecorejson; Log.exx(\"error while parsing json:\", e, ecorejson.substring(0, 1000)); throw e; }\r\n        else parsedjson = ecorejson;\r\n        console.log(\"root parse\", {ecorejson, parsedjson});\r\n        // isMetamodel = !!parsedjson[ECoreRoot.ecoreEPackage];\r\n\r\n        Constructors.paused = true;\r\n        let parsedElements: DModelElement[] = isMetamodel ? EcoreParser.parseM2Model(parsedjson, filename) : EcoreParser.parseM1Model(parsedjson, undefined, filename);\r\n        console.warn(\"parse.result D\", parsedElements);\r\n        this.LinkAllNamesToIDs(parsedElements);\r\n        this.fixNamingConflicts(parsedElements);\r\n        Constructors.paused = false;\r\n        // if (persist) CreateElementAction.newBatch(parsedElements);\r\n        // update m1 object pointers (need them to be persistent to navigate .fathers and get ecore pointer strings using LObject)\r\n        this.fixObjectPointers(parsedElements); // updates dvalue.values from ecore reference to pointers.\r\n        Constructors.persist(parsedElements);\r\n\r\n        windoww.tmpparse = () => LPointerTargetable.wrapAll(parsedElements);\r\n\r\n        this.tempfix_untilopennewtabisdone(parsedElements, isMetamodel);\r\n\r\n        console.log('parsedElem', parsedElements)\r\n        return parsedElements;\r\n    }\r\n\r\n    private static fixObjectPointers(parsedElements: DModelElement[]): void {\r\n        let dobjects: DObject[] = parsedElements.filter(e=>e.className === DObject.cname) as any[];\r\n        let values: DValue[] = parsedElements.filter(e=>e.className === DValue.cname) as any[];\r\n        let lobjects: LObject[] = LPointerTargetable.fromArr(dobjects);\r\n        let m1pointermap: Dictionary<string, LObject> = { }; //    \"//@rootrefname.index@/refname.index/@....etc\"\r\n        for (let o of lobjects){ m1pointermap[o.ecorePointer()] = o; }\r\n        for (let v of values) {\r\n            if (v.isMirage) continue;\r\n            let modified = false;\r\n            let newvalues = v.values.map((e) => {\r\n                if (!m1pointermap[e as any]) return e;\r\n                modified = true;\r\n                console.log(\"m1 pointer resolved:\", {from:e, to:m1pointermap[e as any].id});\r\n                return m1pointermap[e as any].id;\r\n            });\r\n            if (!modified) continue;\r\n            //let lv: LValue = LPointerTargetable.from(v);\r\n            v.values = newvalues;\r\n        }\r\n\r\n    }\r\n    private static tempfix_untilopennewtabisdone(parsedElements: DModelElement[], isMetamodel: boolean) {\r\n        // replaces current model with parsed model. this needs to be removed to open a new tab later on.\r\n        let model: DModel = null as any;\r\n        for (let elem of parsedElements) { if (elem.className === DModel.cname) { model = elem as any; break; } }\r\n        SetRootFieldAction.new(isMetamodel ? \"m2models\" : \"m1models\", model.id, '+=', false); // it is pointer but no need to update pointedby's this time\r\n    }\r\n\r\n    // resolve eCore pointers to Jodel pointers and set the PointedBy\r\n    private static LinkAllNamesToIDs(parsedElements: DModelElement[]): void {\r\n        // todo: è post-parse che legga i nomi e assegni gli id aggiustando le references e extends settati by name. trova i campi temporanei cercando i @ts-ignore\r\n        // update mref, attribute, parameter type\r\n        // update operation exception\r\n        // replace those names with id's\r\n\r\n        let idMap: Dictionary<Pointer, DModelElement> = {};\r\n        let nameMap: Dictionary<string, DModelElement> = {};\r\n        let replacePrimitiveMap: Dictionary<string, DClassifier> = {};\r\n        let d_Estring: DClassifier = Selectors.getAllPrimitiveTypes()[1];\r\n        replacePrimitiveMap[AttribETypes.EString] = d_Estring;\r\n        // todo: do the same for all other primitives\r\n        let state: DState = store.getState();\r\n\r\n        // let longprefixlength = 'ecore:EDataType http://www.eclipse.org/emf/2002/Ecore'.length;\r\n        const typeprefix = \"#//\";\r\n        for (let shortkey in ShortAttribETypes) {\r\n            if (shortkey === ShortAttribETypes.EVoid) continue;\r\n            let shortetype: ShortAttribETypes = (ShortAttribETypes as GObject)[shortkey];\r\n            let longetype: AttribETypes = toLongEType(shortetype);\r\n            let dClassType: DClassifier = Selectors.getPrimitiveType(shortetype, state);\r\n            Log.exDev(!dClassType, \"missing primitive type: \" + shortkey, {shortkey, shortetype, longetype, dClassType, state});\r\n            // the correct one\r\n            replacePrimitiveMap[typeprefix + shortkey] = dClassType; // like \"#//EChar\"\r\n            // fallbacks for missing type instead of crash\r\n            if (!replacePrimitiveMap[shortkey]) replacePrimitiveMap[shortkey] = dClassType;\r\n            if (!replacePrimitiveMap[shortetype]) replacePrimitiveMap[shortetype] = dClassType;\r\n            if (!replacePrimitiveMap[longetype]) replacePrimitiveMap[longetype] = dClassType;\r\n        }\r\n        for (let shortkey in ShortDefaultEClasses) {\r\n            let shortetype: ShortDefaultEClasses = (ShortDefaultEClasses as GObject)[shortkey];\r\n            let longetype: DefaultEClasses = toLongEClass(shortetype);\r\n            let dClassType: DClassifier = Selectors.getDefaultEcoreClass(shortetype, state);\r\n            Log.exDev(!dClassType, \"missing ecore native class: \" + shortkey, {shortkey, shortetype, longetype, dClassType, state});\r\n\r\n            // the correct one\r\n            replacePrimitiveMap[longetype] = dClassType;\r\n            // fallbacks for missing type instead of crash\r\n            if (!replacePrimitiveMap[shortkey]) replacePrimitiveMap[shortkey] = dClassType;\r\n            if (!replacePrimitiveMap[shortetype]) replacePrimitiveMap[shortetype] = dClassType;\r\n            if (!replacePrimitiveMap[longetype]) replacePrimitiveMap[typeprefix + shortkey] = dClassType; // like \"#//EObject\"\r\n        }\r\n\r\n\r\n        for (let ecorename in replacePrimitiveMap) {\r\n            // duplicates are very likely becuase of fallback alias like \"EChar\", but they shouldn't override user-defined class EChar if it exist, so don't throw error.\r\n            if (idMap[replacePrimitiveMap[ecorename].id]) continue;\r\n            idMap[replacePrimitiveMap[ecorename].id] = replacePrimitiveMap[ecorename];\r\n        }\r\n\r\n        // let prereplace = (name: string) => name.replaceAll(\"#//\", \"\");\r\n        let replaceRules = [\"extends\", /*\"extendedBy\",*/ \"exceptions\", \"type\", \"values\"];\r\n        let dobj: GObject & DModelElement;\r\n\r\n        for (dobj of parsedElements) {\r\n            idMap[dobj.id] = dobj;\r\n            if (!dobj.name || dobj.className === DModel.cname) continue; // Model name can be reused internally\r\n            let name = (dobj as GObject).__fullname;\r\n            delete (dobj as GObject).__fullname;\r\n            if (dobj.className === DOperation.cname || dobj.className === DParameter.cname) {\r\n                // operation overload, in this case i create N separate operations, but all references will point to the last operation.\r\n                // empty on purpose, just avoid naming check\r\n            }\r\n                // todo: problem, uml.ecore have \"isComposite\" operation and attribute on sme class \"property\", so who is referenced by \"#//property/isComposite\" ??\r\n            // else Log.exDev(nameMap[typeprefix + name], \"found 2 elements with same name\", {nameMap, dobj, name, shortname: dobj.name, typeprefix});\r\n            else Log.w(!!nameMap[typeprefix + name], \"found 2 elements with same name\", {nameMap, new:dobj, old:nameMap[typeprefix + name], name, shortname: dobj.name, typeprefix});\r\n            nameMap[typeprefix + name] = dobj;\r\n            // nameMap[typeprefix + dobj.name] = dobj; // <eAnnotations source=\"subsets\" references=\"#//Activity/group\"/>\r\n        }\r\n\r\n        for (let replacekey of replaceRules){\r\n            for (dobj of parsedElements) {\r\n                let valtmp: string | string[] = dobj[replacekey] as string | string[];\r\n                if (valtmp === undefined) continue; // for missing properties in a d-object like looking for extends on a dmodel.\r\n                let values: string[]\r\n                let isArray = Array.isArray(valtmp);\r\n                if (isArray) {\r\n                    values = valtmp as string[];\r\n                    dobj[replacekey] = [];\r\n                }\r\n                else {\r\n                    values = [valtmp as string];\r\n                }\r\n                for (let value of values) {\r\n                    if (!value) continue;\r\n                    // console.log(\"fixalltypes\", {replacekey, dobj, value, values});\r\n                    let target: DModelElement = replacePrimitiveMap[value];\r\n                    if (!target) target = nameMap[value];\r\n                    if (!target && value.indexOf(\"ecore:EDataType\") === 0) {\r\n                        Log.ww('found unknown EDataType \"' + value + '\", remapping it to string');\r\n                        target = replacePrimitiveMap[AttribETypes.EString];\r\n                    }\r\n                    /*\r\n                    if (!target && value === \"ecore:EClass platform:/plugin/org.eclipse.emf.ecore/model/Ecore.ecore#//EObject\"){\r\n                        Log.ww('found type Object is not supported yet in metamodel, remapped to EString');\r\n                        target = replacePrimitiveMap[AttribETypes.EString];\r\n                    }*/\r\n                    // if (Pointers.isPointer(value)) { target = value;  if it happen to be a pointer it's a mistake in parser }\r\n                    // (value.indexOf(\"#//\") == 0) && console.log(\"attempt to replace primitive type to his id\", {target, dobj, replacekey, value, replacePrimitiveMap, nameMap, idMap, parsedElements});\r\n\r\n                    if (replacekey === \"extends\") {\r\n                        if (!target) continue;\r\n                        Log.ex(target.className !== DClass.cname, \"found a class attempting to extend an object that is not a class\", {target, dobj, replacePrimitiveMap, nameMap, idMap});\r\n                        (target as DClass).extendedBy.push((dobj as DClass).id);\r\n                    }\r\n                    Log.ex(!target, \"LinkAllNames() can't find type target:\", {value, nameMap, replacePrimitiveMap, dobj, replacekey});\r\n                    if (isArray) dobj[replacekey].push(target.id);\r\n                    else dobj[replacekey] = target.id;\r\n                }\r\n            }\r\n        }\r\n\r\n        // fix from ordinals to Pointer<DEnumLiteral>\r\n        function DfromPtr<T extends DPointerTargetable>(id: Pointer<T>|null|undefined): T{ return !id ? undefined as any : (DPointerTargetable.fromPointer(id, state)); }\r\n        function getLiteral(id: Pointer<DEnumerator>, ordinal: number): DEnumLiteral { return LPointerTargetable.fromD(DfromPtr(id))?.ordinals[ordinal]?.__raw; }\r\n        for (let elem of parsedElements) {\r\n            if (elem.className !== DValue.cname) continue;\r\n            let dval: DValue = elem as DValue;\r\n            let meta: DAttribute | DReference = DfromPtr(dval.instanceof as Pointer<DAttribute|DReference>);\r\n            if (!meta) continue;\r\n            let type: DEnumerator = DfromPtr(meta.type) as DEnumerator;\r\n            if (!type || type.className !== DEnumLiteral.cname) continue;\r\n            let mapper = (v: unknown): Pointer<DEnumLiteral> => {\r\n                if (typeof v !== \"number\") { Log.ee(\"found non-numeric value in a literal value.\", v, dval); return v as any; }\r\n                let l = getLiteral(type.id, v);\r\n                return l ? l.id : v as any;\r\n            }\r\n            dval.values = dval.values.map( mapper );\r\n        }\r\n\r\n        // finally: set all pointedby\r\n        for (let ptrkey of PointedBy.list) for(dobj of parsedElements) {\r\n            let valtmp: string | string[] = dobj[ptrkey] as string | string[];\r\n            let values: string[];\r\n            if (Array.isArray(valtmp)) {\r\n                values = valtmp as string[];\r\n            }\r\n            else {\r\n                if (valtmp === undefined) values = [];\r\n                // if (valtmp === \"modeltmp\") { dobj[ptrkey] = null; values = []; } // because model.father is null, but i want to error check others and let them crash if missing father\r\n                else values = [valtmp as string];\r\n            }\r\n            for (let value of values) {\r\n                if (!value) continue;\r\n                // errore: per operazione.type l'import mi restituisce puntatore a oggetto stringa, ma non è tra gli oggetti parsed\r\n                let target: DModelElement = idMap[value];\r\n                if (target) {\r\n                    target.pointedBy.push(PointedBy.new(\"idlookup.\" + dobj.id + \".\" + ptrkey));\r\n                } else {\r\n                    target = DfromPtr(value);\r\n                    console.log(\"fixalltypes\", {ptrkey, valtmp, dobj, value, values, target, idMap});\r\n                    if (!target) throw new Error(\"target undefined\");\r\n                    SetFieldAction.new(target, \"pointedBy\", PointedBy.new(\"idlookup.\" + dobj.id + \".\" + ptrkey),'+=', false);\r\n                }\r\n            }\r\n        }\r\n        // update superclasses\r\n        this.updateSuperClasses(parsedElements);\r\n    }\r\n\r\n    private static todoGetPrimitiveTypenope(type: AttribETypes.EString | string): Pointer<DClass, 1, 1, LClass> {\r\n        // akready fixed in LinkAllNamesToID\r\n        return 'todoGetPrimitiveType from parser';\r\n    }\r\n\r\n    private static updateSuperClasses(parsedElements: DModelElement[]): void {\r\n        // todo:3\r\n\r\n    }\r\n    private static fixNamingConflicts(parsedElements: DModelElement[]): void {\r\n        // todo:4 final\r\n    }\r\n\r\n    static parseM2Model(json: Json, filename: string | undefined): DModelElement[] {\r\n        let generated: DModelElement[] = [];\r\n        if (!json) { json = {}; }\r\n        let modelname = json[ECoreNamed.namee] as string;\r\n        if (!modelname && filename) {\r\n            let pos = filename.indexOf(\".\");\r\n            modelname = pos === -1 ? filename : filename.substring(0, pos); }\r\n        let dObject: DModel = DModel.new( modelname || \"imported_metamodel_1\", undefined, true, true);\r\n        console.log(\"made model\", json);\r\n        generated.push(dObject); // dObject.father = 'modeltmp' as any;\r\n        // const annotations: Json[] = this.getAnnotations(json); i set them on root package\r\n        // for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific  *** ///\r\n        // let defPackage: DPackage = DPackage.new(json)\r\n        EcoreParser.parseRootPackage(dObject, json, generated);\r\n        return generated;\r\n    }\r\n\r\n    static parseM2Model_old(json: Json, filename: string | undefined): DModelElement[] {\r\n        let generated: DModelElement[] = [];\r\n        if (!json) { json = {}; }\r\n        let modelname = json[ECoreNamed.namee] as string;\r\n        if (!modelname && filename) {\r\n            let pos = filename.indexOf(\".\");\r\n            modelname = pos === -1 ? filename : filename.substring(0, pos); }\r\n        let dObject: DModel = DModel.new( modelname || \"imported_metamodel_1\", undefined, true, true);\r\n        console.log(\"made model\", json);\r\n        generated.push(dObject); // dObject.father = 'modeltmp' as any;\r\n        /// *** specific  *** ///\r\n        const children = EcoreParser.getChildren(json);\r\n        const annotations = EcoreParser.getAnnotations(json);\r\n        // dObject.name = json[ECoreNamed.namee] as string || \"imported_metamodel_1\";\r\n        console.log(\"made model 2\", children, annotations);\r\n        for (let child of annotations) {\r\n            EcoreParser.parseDAnnotation(dObject, child, generated, 'aaaaaaaaaaaaaaaaaaaaaaaaaaaa');\r\n        }\r\n        console.log(\"made annotations\");\r\n        for (let child of children) {\r\n            EcoreParser.parseRootPackage(dObject, child, generated);\r\n        }\r\n        console.log(\"made packages\");\r\n        return generated;\r\n    }\r\n\r\n    static parseM1Model(json: Json, meta?: LModel, filename?: string): DModelElement[] {\r\n        let generated: DModelElement[] = [];\r\n        if (!json) { json = {}; }\r\n        /// *** specific  *** ///\r\n        // this.parseDObject(json, dObject, DModel,undefined, generated);\r\n        let allmodels: DModel[];\r\n        if (!meta && filename) {\r\n            allmodels = Selectors.getAll(DModel);\r\n            allmodels = allmodels.filter( (m) => m.name === filename);\r\n            meta = LPointerTargetable.fromD(allmodels[0]);\r\n        } else allmodels = [];\r\n\r\n        let xmlns =  EcoreParser.XMLinlineMarker + \"xmlns:\";\r\n        let ns: string | undefined = undefined as any;\r\n        function findns(key: string): false | string {\r\n            let pos = key.indexOf(\":\");\r\n            if (pos <= 0) return false;\r\n            return ns = key.substring(0, pos); // through namespace before the name of the root objects;\r\n            // additional method: through xmlns key\r\n            // if (key.indexOf(xmlns)) continue; // \"-xmlns:org.eclipse.example.modelname\": \"https://org/eclipse/example/modelname\",\r\n            // ns = key.substring(xmlns.length); break;\r\n        }\r\n        outerloop: for (let key0 in json) { // ns can be at most in sublevel 3, this is annoying but i need it at beginning of parsing\r\n            if (findns(key0)) break;\r\n            let val0 = json[key0];\r\n            if (typeof val0 === \"object\") for (let key1 in val0) {\r\n                if (findns(key0)) break outerloop;\r\n            }\r\n        }\r\n        if (ns && !meta) {\r\n            let allpkgs: LPackage[] = Selectors.getAll(DPackage, undefined, undefined, true, true);\r\n            let matchpkg: LPackage[] = allpkgs.filter( (d) => d.uri === ns);\r\n            meta = matchpkg[0]?.model;\r\n            // Log.exDev(!meta, \"metamodel not found: \", {ns, json, filename, allmodels, allpkgs, matchpkg}) // todo: after tests remove this check and allow shapeless models.\r\n        }\r\n\r\n        let modelname = '';\r\n        if (!modelname && filename) {\r\n            let pos = filename.indexOf(\".\");\r\n            modelname = (pos === -1 ? filename : filename.substring(0, pos)); }\r\n        let dObject: DModel = DModel.new( modelname || \"imported_model_1\", meta?.id, false, true);\r\n        console.log(\"made model\", json);\r\n        generated.push(dObject);\r\n\r\n        for (let key in json) {\r\n            switch(key) {\r\n                case ECoreObject.xmi_version: // this is only on roots\r\n                    Log.ex(json[key] !== \"2.0\",\"The only supported ecore version is \\\"2.0\\\", found instead: \\\"\"+json[key] +\"\\\"\");\r\n                    break;\r\n                // case ECoreObject.xmlnsecore:\r\n                case ECoreObject.xmlns_xmi:\r\n                    let expected = \"http://www.omg.org/XMI\";\r\n                    Log.ex(json[key] !== expected,\"Unexpected XMI schema. Should be \\\"\"+expected+\"\\\", found instead: \\\"\"+json[key] +\"\\\"\");\r\n                    break;\r\n                default: // a feature name\r\n                    let val = json[key];\r\n                    if (!val) continue;\r\n                    if (key.indexOf(xmlns) === 0) continue; // \"-xmlns:org.eclipse.example.modelname\": \"https://org/eclipse/example/modelname\",\r\n                    if (key[0] === EcoreParser.XMLinlineMarker) key = key.substring(EcoreParser.XMLinlineMarker.length);\r\n\r\n                    const namespacedclass: string = key;\r\n                    const mmclass: LClass | undefined = meta && meta.getClassByNameSpace(namespacedclass);\r\n                    if (!mmclass) console.log(\"failed to get mmclass\", {meta, key, mmclass})\r\n                    const roots_for_this_metaclass: Json[] = Array.isArray(val) ? val : [val]; // there might be N roots of class A, M of type B...\r\n                    for(let rootjson of roots_for_this_metaclass) {\r\n                        // DObject.new(mmclass.id, dObject.id, DModel, undefined, true)\r\n                        EcoreParser.parseDObject(rootjson, dObject, DModel, mmclass, generated);\r\n                    }\r\n            }\r\n        }\r\n        return generated;\r\n    }\r\n    /*\r\n    {\r\n      \"org.eclipse.example.bowling:League\": { <-- :classroot\r\n        \"-xmlns:xmi\": \"http://www.omg.org/XMI\",\r\n        \"-xmlns:org.eclipse.example.bowling\": \"https://org/eclipse/example/bowling\",\r\n        \"-xmi:version\": \"2.0\",\r\n        \"Players\": [\r\n          { \"-name\": \"tizio\" },\r\n          { \"-name\": \"asd\" }\r\n        ]\r\n      }\r\n    }\r\n    */\r\n\r\n\r\n    /// In Ecore parsing when you find a value list, it is possible to recover only the type for the meta-feature,<br>\r\n    /// but an array of Mammals might have some Whales, Pigs, etc mixed in. and you have to get the correct subclass for each\r\n    static getobjectmetaclass(json: Json, metaSuperClass: LClass): LClass {\r\n        return metaSuperClass; // todo: comment this and execute below\r\n        let subclasses: LClass[] | [] = !metaSuperClass ? [] : [metaSuperClass];\r\n        let subclasseshapes: Dictionary<Pointer<DClass>, {l: LClass } & Dictionary<DocString<\"feature name\">,  LTypedElement[\"type\"]/*feature type*/>> = {}\r\n        for (let sc of subclasses) {\r\n            subclasseshapes[sc.id] = {l: sc};\r\n            let row = subclasseshapes[sc.id];\r\n            for (let feat of sc.children) {\r\n                let lfeat: LTypedElement = feat as any;\r\n                let dfeat: DTypedElement = lfeat.__raw as any;\r\n                if (!dfeat.name || !dfeat.type) continue;\r\n                row[dfeat.name] = lfeat.type;\r\n            }\r\n        }\r\n        return this.findBestMatch(subclasseshapes, json);\r\n    }\r\n    static findBestMatch(\r\n        m2classes: Dictionary<Pointer<DClass>,  {l: LClass } & Dictionary<DocString<\"feature name\">, LTypedElement[\"type\"]>>,\r\n        json: Dictionary<DocString<\"feature name\">, any/*actual val instead of type*/>): LClass{\r\n        throw new Error(\"todo\");\r\n        return null as any;\r\n    }\r\n    static parseDObject(json: Json, parent: DModel | DValue, parentType: typeof DModel | typeof DValue, meta: LClass | undefined, generated: DModelElement[]): DModelElement[]{\r\n        if (!json) { json = {}; }\r\n        meta = meta && this.getobjectmetaclass(json, meta);\r\n        // let dObject: DObject = DObject.new(meta?.id, parent.id, parentType, json[\"name\"] as string || \"obj_1\");\r\n        // let data: Partial<DObject> = {};\r\n        let dObject: DObject = DObject.new(meta?.id, parent.id, parentType, json[\"name\"] as string || \"obj_1\");\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) {\r\n            if (parentType === DModel) (parent as DModel).objects.push(dObject.id);\r\n            else (parent as DValue).values.push(dObject.id);\r\n        }\r\n        console.log(\"made dobject\", {json, dObject, meta, metaname: meta?.name});\r\n        /// *** specific  *** ///\r\n        for (let key in json) {\r\n            switch(key) {\r\n                case ECoreObject.xmi_version: // this is only on roots\r\n                    Log.ex(json[key] !== \"2.0\",\"The only supported ecore version is \\\"2.0\\\", found instead: \\\"\"+json[key] +\"\\\"\");\r\n                    break;\r\n                // case ECoreObject.xmlnsecore:\r\n                case ECoreObject.xmlns_xmi:\r\n                    let expected = \"http://www.omg.org/XMI\";\r\n                    Log.ex(json[key] !== expected,\"Unexpected XMI schema. Should be \\\"\"+expected+\"\\\", found instead: \\\"\"+json[key] +\"\\\"\");\r\n                    break;\r\n                default: // a feature name\r\n                    let val = json[key];\r\n                    if (!val) continue;\r\n                    if (key[0] === EcoreParser.XMLinlineMarker) key = key.substring(1);\r\n                    if (key.indexOf(\"xmlns:\") === 0) continue; // \"-xmlns:org.eclipse.example.modelname\": \"https://org/eclipse/example/modelname\",\r\n                    let metafeature: LAttribute | LReference | undefined = meta && (meta as any)[\"@\"+key];\r\n                    console.log(\"feature meta\", {json, dObject, key, val, metafeature, classmeta: meta});\r\n                    let values: any[];\r\n                    if (Array.isArray(val)) values = val;\r\n                    else if (val as unknown === undefined) values = [];\r\n                    else values = [val];\r\n                    EcoreParser.parseDValue(key, values, dObject/*father*/, metafeature/*meta*/, generated);\r\n                // DValue.new(key, metafeature?.id, values, dObject, true, false);\r\n            }\r\n        }\r\n        return generated;\r\n    }\r\n\r\n    private static parseDValue(name:string | undefined, jsonvalues: any[], parent: DObject, meta: LAttribute | LReference | undefined, generated: DModelElement[]): DModelElement[] {\r\n        if (!jsonvalues) { jsonvalues = []; }\r\n        // let dObject: DObject = DObject.new(meta?.id, parent.id, parentType, json[\"name\"] as string || \"obj_1\");\r\n        console.log(\"DValue.new(meta ? undefined : name, meta?.id, jsonvalues, parent.id, true, false)\")\r\n        console.log(\"DValue.new(\", meta ? undefined : name, \",\",meta?.id, \",\",jsonvalues, \",\",parent.id);\r\n        let dValue: DValue = DValue.new(meta ? undefined : name, meta?.id, [], parent.id, true, false);\r\n        generated.push(dValue); dValue.father = parent.id;\r\n        parent.features.push(dValue.id);\r\n        console.log(\"made dValue\", {jsonvalues, dValue, meta, metaname: meta?.name});\r\n        if (meta && meta.className === DAttribute.cname) { dValue.values = jsonvalues; return generated; }\r\n\r\n        for (let v of jsonvalues) {\r\n            if (typeof v !== \"object\") { dValue.values.push(v); continue; }\r\n            // let subdObject: DObject = DObject.new((meta as LReference)?.type.id, parent.id, DValue, undefined);\r\n            // generated.push(subdObject);\r\n            EcoreParser.parseDObject(v, dValue, DValue, (meta as LReference)?.type, generated);\r\n        }\r\n        return generated;\r\n    }\r\n\r\n    static parseDAnnotation(parent: DModelElement, json: Json, generated: DModelElement[], fullnamePrefix: string): DModelElement[] {\r\n        return []; // todo\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        let dObject: DAnnotation = DAnnotation.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        (dObject as any).name = this.read(json, ECoreNamed.namee, undefined);\r\n        dObject.father = parent.id;\r\n        if (parent) parent.annotations.push(dObject.id);\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        (dObject as GObject).__fullname = undefined; // fullnamePrefix + \"/\" + (dObject as any).name; // if annotation is not named (and it shouldn't) i don't wanna override container name\r\n        /// *** specific  *** ///\r\n        let key: string;\r\n        for (key in json){\r\n            const value = json[key];\r\n            switch (key) { //todo\r\n                default: Log.exx('unexpected field in EAnnotation:  ' + key + ' => |' + value + '|', {key, value, json}); break;\r\n                // case ECoreAnnotation.annotations: break; // todo: enable, yes annotations can have annotations\r\n                case ECoreAnnotation.details: break;\r\n                case ECoreAnnotation.references: break;\r\n                case ECoreAnnotation.source: break;\r\n            }\r\n        }\r\n        // annotation.referencesStr = this.read(json, ECoreAnnotation.source, '#/');\r\n        // annotation.name = this.read(json, ECoreAnnotation.name, 'EAnnotation_1');\r\n        // const details: Json[] = this.getDetails(json);\r\n        // for (let i = 0; i < details.length; i++) { new EAnnotationDetail(this, details[i]); }\r\n        return generated; }\r\n\r\n    static parseRootPackage(parent: DModel, json: Json, generated: DModelElement[]): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildren(json);\r\n\r\n        let dObject: DPackage = DPackage.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) parent.packages.push(dObject.id);\r\n\r\n        let version = (json[EcoreParser.prefix+\"xmlns:ecore\"] || '') as string;\r\n        // model.xmi = json[EcoreParser.prefix+\"xmlns:xmi\"]; // http://www.omg.org/XMI\r\n        // model.xsi = json[EcoreParser.prefix+\"xmlns:xsi\"]; // http://www.w3.org/2001/XMLSchema-instance\r\n        Log.ex(!EcoreParser.supportedEcoreVersions.includes(version), \"unsupported ecore version, must be one of:\" + EcoreParser.supportedEcoreVersions + \" found instead: \"+version);\r\n        dObject.name = this.read(json, ECoreNamed.namee, 'default');\r\n        // root package name is \"transparent\" and not applied in \"#//reference/paths/...\", if referenced i guess his name is \"#//\"\r\n        (dObject as GObject).__fullname = ''; // fullnamePrefix + \"/\" + dObject.name;\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific start *** ///\r\n        const subPackages: Json[] = this.getSubPackages(json);\r\n        dObject.uri = this.read(json, ECorePackage.nsURI, null);\r\n        dObject.prefix = this.read(json, ECorePackage.nsPrefix, null);\r\n        console.warn(\"parseRootPackage.children\", {childs, annotations, subPackages, dObject, generated});\r\n        // if (!parent.uri) parent.uri = dObject.uri;\r\n        // if (!parent.prefix) parent.prefix = dObject.prefix; // namespace\r\n        for (let child of childs) {\r\n            switch (child[ECoreClass.xsitype]) {\r\n                default: Log.exx('unexpected xsitype:', child[ECoreClass.xsitype], ' found in jsonfragment:', child, ', in json:', json, ' package:', dObject); break;\r\n                case 'ecore:EClass': this.parseDClass(dObject, child, generated, ''); break;\r\n                case 'ecore:EEnum': this.parseDEnum(dObject, child, generated, ''); break;\r\n            }\r\n        }\r\n        for (let child of subPackages) EcoreParser.parseSubPackage(dObject, child, generated, '');\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n    static parseSubPackage(parent: DPackage, json: Json, generated: DModelElement[], fullnamePrefix: string): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildren(json);\r\n        let dObject: DPackage = DPackage.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) parent.subpackages.push(dObject.id);\r\n        dObject.name = this.read(json, ECoreNamed.namee, 'subPackage_1');\r\n        (dObject as GObject).__fullname = fullnamePrefix + dObject.name;\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific start *** ///\r\n        dObject.uri = this.read(json, ECoreSubPackage.nsURI, null);\r\n        dObject.prefix = this.read(json, ECoreSubPackage.nsPrefix, null);\r\n        const subPackages: Json[] = this.getSubPackages(json);\r\n        console.warn(\"parseSubPackage.children\", {childs, annotations, subPackages, dObject, generated});\r\n        // if (!dObject.uri) dObject.uri = dObject.name + \".\" + parent.uri;\r\n        // if (!dObject.prefix) dObject.prefix = dObject.name + \".\" + parent.prefix; // namespace\r\n        for (let child of childs) {\r\n            switch (child[ECoreClass.xsitype]) {\r\n                default: Log.exx('unexpected xsitype:', child[ECoreClass.xsitype], ' found in jsonfragment:', child, ', in json:', json, ' package:', dObject); break;\r\n                case 'ecore:EClass': this.parseDClass(dObject, child, generated, (dObject as GObject).__fullname + \"/\"); break;\r\n                case 'ecore:EEnum': this.parseDEnum(dObject, child, generated, (dObject as GObject).__fullname + \"/\"); break;\r\n            }\r\n        }\r\n        for (let child of subPackages) EcoreParser.parseSubPackage(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n    static parseDClass(parent: DPackage, json: Json, generated: DModelElement[], fullnamePrefix: string): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        let dObject: DClass = DClass.new(\r\n            this.read(json, ECoreNamed.namee, 'Concept 1'),\r\n            undefined as any, undefined as any, undefined as any, undefined as any, undefined, parent.id,\r\n        );\r\n        generated.push(dObject);// dObject.father = parent.id;\r\n        //if (parent) parent.classifiers.push(dObject.id);\r\n        //dObject.name = this.read(json, ECoreNamed.namee, 'Class_1');\r\n        (dObject as GObject).__fullname = fullnamePrefix + dObject.name;\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific start *** ///\r\n        for (let key in json) {\r\n            switch (key) {\r\n                default: Log.exx('unexpected field in parseDClass() |' + key + '|', json); break;\r\n                case ECoreClass.eAnnotations:\r\n                case ECoreClass.instanceTypeName:\r\n                case ECoreClass.eSuperTypes:\r\n                case ECoreClass.xsitype:\r\n                case ECoreClass.eOperations:\r\n                case ECoreClass.eStructuralFeatures:\r\n                case ECoreClass.abstract:\r\n                case ECoreClass.interface:\r\n                case ECoreClass.namee: break; } }\r\n        dObject.instanceClassName = this.read(json, ECoreClass.instanceTypeName, '');\r\n        dObject.interface = this.read(json, ECoreClass.interface, 'false') === 'true';\r\n        dObject.abstract = this.read(json, ECoreClass.abstract, 'false') === 'true';\r\n        let tmps: string = this.read(json, ECoreClass.eSuperTypes, '');\r\n        dObject.extends = tmps.split(' ');\r\n        const features: Json[] = this.getChildren(json);\r\n        const functions: Json[] = this.getChildren(json, false, true);\r\n\r\n        for (let child of functions) this.parseDOperation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        for (let child of features) {\r\n            const xsiType = this.read(child, ECoreAttribute.xsitype);\r\n            switch (xsiType) {\r\n                default: Log.exx( 'unexpected xsi:type: ', xsiType, ' in feature:', child); break;\r\n                case 'ecore:EAttribute':\r\n                    this.parseDAttribute(dObject, child, generated, (dObject as GObject).__fullname + \"/\"); break;\r\n                case 'ecore:EReference':\r\n                    this.parseDReference(dObject, child, generated, (dObject as GObject).__fullname + \"/\"); break;\r\n            }\r\n        }\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n    static parseDEnum(parent: DPackage, json: Json, generated: DModelElement[], fullnamePrefix: string): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildren(json);\r\n        let dObject: DEnumerator = DEnumerator.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) parent.classifiers.push(dObject.id);\r\n        dObject.name = this.read(json, ECoreNamed.namee, 'Enum_1');\r\n        (dObject as GObject).__fullname = fullnamePrefix + dObject.name;\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific start *** ///\r\n        for (let key in json) {\r\n            const value = json[key];\r\n            switch (key) {\r\n                default: Log.exx('Enum.parse() unexpected key:', key, 'in json:', json); break;\r\n                case ECoreEnum.eAnnotations:\r\n                case ECoreEnum.xsitype: case ECoreNamed.namee: break;\r\n                case ECoreEnum.eLiterals: break;\r\n                case ECoreEnum.serializable: dObject.serializable = value === 'true'; break;\r\n                case ECoreEnum.instanceTypeName: dObject.instanceClassName = value + ''; break;\r\n            }\r\n        }\r\n        for (let child of childs) {\r\n            this.parseDEnumLiteral(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        }\r\n\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n\r\n\r\n    static parseDEnumLiteral(parent: DEnumerator, json: Json, generated: DModelElement[], fullnamePrefix: string): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildren(json);\r\n        let dObject: DEnumLiteral = DEnumLiteral.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) parent.literals.push(dObject.id);\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific start *** ///\r\n        dObject.value = +this.read(json, EcoreLiteral.value, Number.NEGATIVE_INFINITY);//vv4\r\n        dObject.literal = this.read(json, EcoreLiteral.literal, '');\r\n        dObject.name = this.read(json, ECoreNamed.namee,  dObject.literal || 'literal_1');\r\n        (dObject as GObject).__fullname = fullnamePrefix + dObject.name;\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n    static parseDAttribute(parent: DClass, json: Json, generated: DModelElement[], fullnamePrefix: string): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildren(json);\r\n        // done: old approach does not set pointedBy, i should set father and all pointers in .new() parameters\r\n        let dObject: DAttribute = DAttribute.new(\r\n            this.read(json, ECoreNamed.namee, 'attr_1'),\r\n            this.read(json, ECoreAttribute.eType, AttribETypes.EString),\r\n            parent.id,\r\n        );\r\n        generated.push(dObject);// dObject.father = parent.id;\r\n        // if (parent) parent.attributes.push(dObject.id);\r\n        //dObject.name = this.read(json, ECoreNamed.namee, 'attr_1');\r\n        (dObject as GObject).__fullname = fullnamePrefix + dObject.name;\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific start *** ///\r\n        dObject.lowerBound = +this.read(json, ECoreAttribute.lowerbound, 0);\r\n        dObject.upperBound = +this.read(json, ECoreAttribute.upperbound, 1);\r\n        //dObject.type = this.read(json, ECoreAttribute.eType, AttribETypes.EString);\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n    static parseDReference(parent: DClass, json: Json, generated: DModelElement[], fullnamePrefix: string): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildren(json);\r\n        let dObject: DReference = DReference.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) parent.references.push(dObject.id);\r\n        dObject.name = this.read(json, ECorePackage.namee, 'Ref_1');\r\n        (dObject as GObject).__fullname = fullnamePrefix + dObject.name;\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific start *** ///\r\n        dObject.composition = U.fromBoolString(this.read(json, ECoreReference.containment, false), false);\r\n        dObject.container = U.fromBoolString(this.read(json, ECoreReference.container, false), false);\r\n        dObject.lowerBound = +this.read(json, ECoreAttribute.lowerbound, 0);\r\n        dObject.upperBound = +this.read(json, ECoreAttribute.upperbound, 1);\r\n        dObject.type = this.read(json, ECoreReference.eType, this.getEcoreTypeName(parent));\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n    static parseDParameter(parent: DOperation, json: Json, generated: DModelElement[], fullnamePrefix: string): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildren(json);\r\n        let dObject: DParameter = DParameter.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) parent.parameters.push(dObject.id);\r\n        dObject.name = this.read(json, ECoreNamed.namee, 'arg1');\r\n        (dObject as GObject).__fullname = fullnamePrefix + dObject.name;\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific start *** ///\r\n        dObject.lowerBound = +this.read(json, ECoreAttribute.lowerbound, 0);\r\n        dObject.upperBound = +this.read(json, ECoreAttribute.upperbound, 1);\r\n        dObject.type = this.read(json, ECoreAttribute.eType, AttribETypes.EString);\r\n        dObject.ordered = U.fromBoolString(this.read(json, ECoreOperation.ordered, 'false'), false);\r\n        dObject.unique = U.fromBoolString(this.read(json, ECoreOperation.unique, 'false'), false);\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n    static parseDOperation(parent: DClass, json: Json, generated: DModelElement[], fullnamePrefix: string): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildren(json);\r\n        let dObject: DOperation = DOperation.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) parent.operations.push(dObject.id);\r\n        dObject.name = this.read(json, ECoreNamed.namee, 'operation_1');\r\n        (dObject as GObject).__fullname = fullnamePrefix + dObject.name;\r\n\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific start *** ///\r\n        dObject.lowerBound = +this.read(json, ECoreAttribute.lowerbound, 1);\r\n        dObject.upperBound = +this.read(json, ECoreAttribute.upperbound, 1);\r\n        dObject.type = this.read(json, ECoreAttribute.eType, AttribETypes.EString);\r\n        dObject.exceptions = [this.read(json, ECoreOperation.eexceptions, '')];\r\n        dObject.ordered = U.fromBoolString(this.read(json, ECoreOperation.ordered, 'false'));\r\n        dObject.unique = U.fromBoolString(this.read(json, ECoreOperation.unique, 'false'));\r\n        dObject.visibility = AccessModifier.package;\r\n        for (let child of childs) {\r\n            this.parseDParameter(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        }\r\n        /// *** specific end *** ///\r\n        return generated; }\r\n\r\n\r\n    /*\r\n    static parseTEMPLATE(parent: DSomething, json: Json, generated: DModelElement[], fullnamePrefix: string): DModelElement[] {\r\n        if (!generated) generated = [];\r\n        if (!json) { json = {}; }\r\n        const childs = this.getChildren(json);\r\n        let dObject: DSomething = DSomething.new();\r\n        generated.push(dObject); dObject.father = parent.id;\r\n        if (parent) parent.CHILDCOLLECTION.push(dObject.id);\r\n        dObject.name = this.read(json, ECoreNamed.namee, defaultNameTODO);\r\n        (dObject as GObject).__fullname = fullnamePrefix + dObject.name;\r\n        const annotations: Json[] = this.getAnnotations(json);\r\n        for (let child of annotations) EcoreParser.parseDAnnotation(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        /// *** specific start *** ///\r\n        for (let child of childs) {\r\n            this.parseDSOMETHING(dObject, child, generated, (dObject as GObject).__fullname + \"/\");\r\n        }\r\n        /// *** specific end *** ///\r\n        return generated; }*/\r\n\r\n\r\n\r\n\r\n\r\n    /////////////////////////////////// generic\r\n    static XMLinlineMarker: string = '@';\r\n    static classTypePrefix: string = '#//'\r\n    private static getSubPackages(thiss: Json): Json[] {\r\n        const ret: any = thiss[ECoreSubPackage.eSubpackages];\r\n        if (!ret || U.isEmptyObject(ret)) { return []; }\r\n        if (Array.isArray(ret)) { return ret; } else { return [ret]; } }\r\n\r\n    private static getAnnotations(thiss: Json): Json[] {\r\n        const ret: any = thiss[ECorePackage.eAnnotations];\r\n        if (!ret || U.isEmptyObject(ret)) { return []; }\r\n        if (Array.isArray(ret)) { return ret; } else { return [ret]; } }\r\n\r\n    private static getDetails(thiss: Json): Json[] {\r\n        const ret: any = thiss[ECoreAnnotation.details];\r\n        if (!ret || U.isEmptyObject(ret)) { return []; }\r\n        if (Array.isArray(ret)) { return ret; } else { return [ret]; } }\r\n\r\n    private static getChildren(thiss: Json, throwError: boolean = false, functions: boolean = false): Json[] {\r\n        if (!thiss && !throwError) { return []; }\r\n        const mod = thiss[ECoreRoot.ecoreEPackage];\r\n        const pkg = thiss[ECorePackage.eClassifiers];\r\n        const cla = thiss[functions ? ECoreClass.eOperations : ECoreClass.eStructuralFeatures];\r\n        const fun = thiss[ECoreOperation.eParameters];\r\n        const lit = thiss[ECoreEnum.eLiterals];\r\n\r\n        const ret: any = mod || pkg || cla || fun || lit;\r\n        /*if ( ret === undefined || ret === null ) {\r\n          if (thiss['@name'] !== undefined) { ret = thiss; } // if it's the root with only 1 child arrayless\r\n        }*/\r\n        Log.ex( throwError && !ret, 'getChildren() Failed: ', thiss, ret);\r\n        // console.log('ret = ', ret, ' === ', {}, ' ? ', (U.isEmptyObject(ret) ? [] : [ret]));\r\n        if (!ret || U.isEmptyObject(ret)) { return []; }\r\n        if (Array.isArray(ret)) { return ret; } else { return [ret]; }\r\n    }\r\n\r\n    private static read(json: Json, field: string, valueIfNotFound: any = 'read<T>()CanThrowError'): string {\r\n        let ret: any = json ? json[field] : null;\r\n        if (ret !== null && ret !== undefined && field.indexOf(this.XMLinlineMarker) !== -1) {\r\n            Log.ex(U.isObject(ret, false, false, true), 'inline value |' + field + '| must be primitive.', ret);\r\n            ret = U.multiReplaceAll('' + ret, ['&amp;', '&#38;', '&quot;'], ['&', '\\'', '\"']);\r\n        }\r\n        if ((ret === null || ret === undefined)) {\r\n            Log.ex(valueIfNotFound === 'read<T>()CanThrowError', 'this.read<',  '> failed: field[' + field + '], json: ', json);\r\n            return valueIfNotFound; }\r\n        return ret; }\r\n\r\n    static write(json: Json, field: string, val: string | any[]): string | any[] {\r\n        if (val !== null && field.indexOf(EcoreParser.XMLinlineMarker) !== -1) {\r\n            Log.ex(val !== '' + val, 'inline value |' + field + '| must be a string.', val);\r\n            val = U.multiReplaceAll(val as string, ['&', '\\'', '\"'], ['&amp;', '&#38;', '&quot;']);\r\n        }\r\n        else Log.ex(val !== '' + val || !U.isObject(val, true), 'primitive values should be inserted only inline in the xml:', field, val);\r\n        json[field] = val;\r\n        return val; }\r\n\r\n    private static getEcoreTypeName(parent: DClassifier): string {\r\n        if (parent.className === DEnumerator.cname || parent.className === DClass.cname) return this.classTypePrefix + this.name;\r\n        // return Type.classTypePrefix + parent.parent.name; problem: need L-object to navigate\r\n        return Log.exx(\"getEcoreTypeName failed\", parent);\r\n    }\r\n\r\n}\r\n\r\nexport enum AccessModifier {\r\n    public = 'public',\r\n    private = 'private',\r\n    protected = 'protected',\r\n    internal = 'internal',\r\n    package = 'package',\r\n    protectedinternal = 'protected internal',\r\n    protectedprivate = 'protected private', }\r\n\r\nexport class ECoreRoot {\r\n    static ecoreEPackage: string;\r\n}\r\n\r\nexport class ECoreAnnotation {\r\n    static source: string;\r\n    static references: string;\r\n    static details: string;}\r\n\r\nexport class ECoreNamed {\r\n    static namee: string; }\r\n\r\nexport class ECoreDetail {\r\n    static key: string;\r\n    static value: string; }\r\n\r\nexport class ECoreSubPackage { // <eSubpackages\r\n    static eSubpackages: string;\r\n    static eAnnotations: string;\r\n    static eClassifiers: string;\r\n    static nsURI: string;\r\n    static nsPrefix: string;\r\n    static namee: string;\r\n}\r\n\r\nexport class ECorePackage extends ECoreSubPackage {\r\n    static eAnnotations: string;\r\n    static eSubpackages: string;\r\n    static eClassifiers: string;\r\n    static xmlnsxmi: string;\r\n    static xmlnsxsi: string;\r\n    static xmiversion: string;\r\n    static xmlnsecore: string;\r\n    static nsURI: string;\r\n    static nsPrefix: string;\r\n    static namee: string;\r\n}\r\n\r\nexport class ECoreClass {\r\n    static eAnnotations: string;\r\n    static eStructuralFeatures: string;\r\n    static xsitype: string;\r\n    static namee: string;\r\n    static eOperations: string;\r\n    static instanceTypeName: string;\r\n    static eSuperTypes: string;\r\n    static abstract: string;\r\n    static interface: string;\r\n\r\n    // static defaultValue = EcoreParser.XMLinlineMarker + 'defaultValue';  // visualizzato in ecore ma mai salvato dentro il file. inutilizzato\r\n    // nelle classi, assume il valore di \"[name] = [NumericValue]\" senza le [] negli enum.\r\n}\r\n\r\nexport class ECoreEnum {\r\n    static eAnnotations: string;\r\n    static xsitype: string;\r\n    static namee: string;\r\n    static instanceTypeName: string;\r\n    static serializable: string;\r\n    static eLiterals: string;\r\n}\r\n\r\nexport class EcoreLiteral {\r\n    static eAnnotations: string;\r\n    static namee: string;\r\n    static value: string;\r\n    static literal: string;\r\n}\r\n\r\n\r\nexport class ECoreReference {\r\n    static eAnnotations: string;\r\n    static xsitype: string;\r\n    static eType: string;\r\n    static containment: string;\r\n    static container: string;\r\n    static upperbound: string;\r\n    static lowerbound: string;\r\n    static namee: string; }\r\n\r\nexport class ECoreAttribute {\r\n    static eAnnotations: string;\r\n    static xsitype: string;\r\n    static eType: string;\r\n    static namee: string;\r\n    static lowerbound: string;\r\n    static upperbound: string;\r\n}\r\n\r\nexport class ECoreOperation {\r\n    static eAnnotations: string;\r\n    static eType: string;\r\n    static eexceptions: string;\r\n    static upperBound: string;\r\n    static lowerBound: string;\r\n    static unique: string;\r\n    static ordered: string;\r\n    static namee: string;\r\n    static eParameters: string; }\r\n\r\nexport class ECoreParameter {\r\n    static eAnnotations: string;\r\n    static namee: string;\r\n    static ordered: string;\r\n    static unique: string;\r\n    static lowerBound: string;\r\n    static upperBound: string;\r\n    static eType: string;\r\n}\r\n\r\nexport class ECoreObject{\r\n    static xmlns_xmi: string;\r\n    static xmlns_uri: never; // \"-xmlns:org.eclipse.example.modelname\": \"https://org/eclipse/example/modelname\", <b>key is dynamic</b>\r\n    static xmi_version: string;\r\n}\r\nexport class XMIModel {\r\n    static type: string;\r\n    static namee: string; }\r\n\r\n\r\n///////////////\r\n\r\nECoreRoot.ecoreEPackage = 'ecore:EPackage'; // this is root tag but not in xml->json, just his attributes/childrens\r\nECoreNamed.namee = EcoreParser.XMLinlineMarker + 'name';\r\n\r\nECorePackage.eAnnotations = ECoreSubPackage.eAnnotations = ECoreClass.eAnnotations =\r\n    ECoreEnum.eAnnotations = EcoreLiteral.eAnnotations =  ECoreReference.eAnnotations =\r\n        ECoreAttribute.eAnnotations = ECoreOperation.eAnnotations = ECoreParameter.eAnnotations = 'eAnnotations';\r\n\r\nECoreAnnotation.source = EcoreParser.XMLinlineMarker + 'source';\r\nECoreAnnotation.references = EcoreParser.XMLinlineMarker + 'references'; // \"#/\" for target = package.\r\nECoreAnnotation.details = 'details'; // arr\r\nECoreDetail.key = EcoreParser.XMLinlineMarker + 'key'; // can have spaces\r\nECoreDetail.value = EcoreParser.XMLinlineMarker + 'value';\r\n\r\nECorePackage.eSubpackages = 'eSubpackages';\r\nECorePackage.eClassifiers = 'eClassifiers';\r\nECorePackage.xmlnsxmi = EcoreParser.XMLinlineMarker + 'xmlns:xmi'; // typical value: http://www.omg.org/XMI\r\nECorePackage.xmlnsxsi = EcoreParser.XMLinlineMarker + 'xmlns:xsi'; // typical value: http://www.w3.org/2001/XMLSchema-instance\r\nECorePackage.xmiversion = EcoreParser.XMLinlineMarker + 'xmi:version'; // typical value: \"2.0\"\r\nECorePackage.xmlnsecore = EcoreParser.XMLinlineMarker + 'xmlns:ecore';\r\nECorePackage.nsURI = EcoreParser.XMLinlineMarker + 'nsURI'; // typical value: \"http://org/eclipse/example/modelname\"\r\nECorePackage.nsPrefix = EcoreParser.XMLinlineMarker + 'nsPrefix'; // typical value: org.eclipse.example.modelname\r\nECorePackage.namee = EcoreParser.XMLinlineMarker + 'name';\r\n\r\nECoreSubPackage.eSubpackages = 'eSubpackages';\r\nECoreSubPackage.eClassifiers = 'eClassifiers';\r\nECoreSubPackage.nsURI = EcoreParser.XMLinlineMarker + 'nsURI'; // typical value: \"http://org/eclipse/example/modelname\"\r\nECoreSubPackage.nsPrefix = EcoreParser.XMLinlineMarker + 'nsPrefix'; // typical value: org.eclipse.example.modelname\r\nECoreSubPackage.namee = EcoreParser.XMLinlineMarker + 'name';\r\n\r\n\r\nECoreClass.eStructuralFeatures = 'eStructuralFeatures';\r\nECoreClass.eOperations = 'eOperations';\r\nECoreClass.xsitype = EcoreParser.XMLinlineMarker + 'xsi:type'; // \"ecore:EClass\"\r\nECoreClass.namee = ECorePackage.namee;\r\nECoreClass.eSuperTypes = EcoreParser.XMLinlineMarker + 'eSuperTypes'; // space separated: \"#name1 #name2\"...\r\nECoreClass.instanceTypeName = EcoreParser.XMLinlineMarker + 'instanceTypeName';  // raw str\r\nECoreClass.instanceTypeName = EcoreParser.XMLinlineMarker + 'instanceTypeName';\r\nECoreClass.abstract = EcoreParser.XMLinlineMarker + 'abstract'; // bool\r\nECoreClass.interface = EcoreParser.XMLinlineMarker + 'interface'; // bool\r\n\r\nECoreEnum.instanceTypeName = ECoreClass.instanceTypeName;\r\nECoreEnum.serializable = 'serializable'; // \"false\", \"true\"\r\nECoreEnum.xsitype = ECoreClass.xsitype; // \"ecore:EEnum\"\r\nECoreEnum.eLiterals = 'eLiterals';\r\nECoreEnum.namee = ECorePackage.namee;\r\n\r\nEcoreLiteral.literal = 'literal';\r\nEcoreLiteral.namee = ECorePackage.namee;\r\nEcoreLiteral.value = 'value'; // any integer (-inf, +inf), not null. limiti = a type int 32 bit? vv4\r\n\r\nECoreReference.xsitype = EcoreParser.XMLinlineMarker + 'xsi:type'; // \"ecore:EReference\"\r\nECoreReference.eType = EcoreParser.XMLinlineMarker + 'eType'; // \"#//Player\"\r\nECoreReference.containment = EcoreParser.XMLinlineMarker + 'containment'; // \"true\"\r\nECoreReference.upperbound = EcoreParser.XMLinlineMarker + 'upperBound'; // \"@1\"\r\nECoreReference.lowerbound = EcoreParser.XMLinlineMarker + 'lowerBound'; // does even exists?\r\nECoreReference.namee = EcoreParser.XMLinlineMarker + 'name';\r\n\r\nECoreAttribute.xsitype = EcoreParser.XMLinlineMarker + 'xsi:type'; // \"ecore:EAttribute\",\r\nECoreAttribute.eType = EcoreParser.XMLinlineMarker + 'eType'; // \"ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EString\"\r\nECoreAttribute.namee = EcoreParser.XMLinlineMarker + 'name';\r\nECoreAttribute.lowerbound = EcoreParser.XMLinlineMarker + 'lowerBound';\r\nECoreAttribute.upperbound = EcoreParser.XMLinlineMarker + 'upperBound';\r\n\r\n\r\nECoreOperation.eParameters = 'eParameters';\r\nECoreOperation.namee = EcoreParser.XMLinlineMarker + 'name'; // \"EExceptionNameCustom\",\r\nECoreOperation.ordered = EcoreParser.XMLinlineMarker + 'ordered'; // \"false\",\r\nECoreOperation.unique = EcoreParser.XMLinlineMarker + 'unique'; // \"false\",\r\nECoreOperation.lowerBound = EcoreParser.XMLinlineMarker + 'lowerBound'; // \"5\", ma che senso ha su una funzione?? è il return?\r\nECoreOperation.upperBound = EcoreParser.XMLinlineMarker + 'upperBound';\r\nECoreOperation.eType = EcoreParser.XMLinlineMarker + 'eType'; // \"#//Classname\",\r\nECoreOperation.eexceptions = EcoreParser.XMLinlineMarker + 'eExceptions';\r\n// \"#//ClassnameException1 #//ClassNameException2 (also custom classes) ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EInt\r\n\r\nECoreParameter.namee = EcoreParser.XMLinlineMarker + 'name';\r\nECoreParameter.ordered = EcoreParser.XMLinlineMarker + 'ordered'; // \"false\";\r\nECoreParameter.unique = EcoreParser.XMLinlineMarker + 'unique'; // \"false\"\r\nECoreParameter.lowerBound = EcoreParser.XMLinlineMarker + 'lowerBound'; // \"1\"\r\nECoreParameter.upperBound = EcoreParser.XMLinlineMarker + 'upperBound'; // \"2\"\r\nECoreParameter.eType = EcoreParser.XMLinlineMarker + 'eType'; // \"ecore:EDataType http://www.eclipse.org/emf/2002/Ecore#//EDoubl\r\n\r\nECoreObject.xmlns_xmi = EcoreParser.XMLinlineMarker + 'xmlns:xmi'; // \"http://www.omg.org/XMI\"\r\n// ECoreObject.xmlns_uri = EcoreParser.XMLinlineMarker + 'xmlns:org.eclipse.example.modelname'; // \"https://org/eclipse/example/modelname\"\r\nECoreObject.xmi_version = EcoreParser.XMLinlineMarker + 'xmi:version'; // \"2.0\"\r\n\r\nXMIModel.type = EcoreParser.XMLinlineMarker + 'type';\r\nXMIModel.namee = EcoreParser.XMLinlineMarker + 'name';\r\n\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\redux\\createStore.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\redux\\action\\action.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\redux\\selectors\\selectors.ts",["790","791","792"],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\common\\U.tsx",["793","794","795","796","797","798","799","800","801","802","803","804","805","806","807","808","809","810","811","812","813","814","815","816","817","818","819","820","821","822","823","824","825","826","827","828","829","830","831","832","833","834","835"],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\common\\DV.tsx",["836","837","838","839","840"],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\redux\\store.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\model\\classes\\L.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\model\\classes\\D.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\view\\viewPoint\\viewpoint.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\graph\\graphElement\\GraphDragHandler.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\joiner\\components.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\index.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\index.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\common\\UX.tsx",["841","842","843","844","845","846"],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\model\\logicWrapper\\LModelElement.tsx",["847","848","849","850","851","852","853","854","855","856","857","858","859","860","861","862","863","864","865","866","867"],"import {\r\n    LVoidVertex,\r\n    PackagePointers,\r\n    EdgePointers,\r\n    AnnotationPointers,\r\n    AttributePointers,\r\n    EnumPointers,\r\n    LiteralPointers,\r\n    OperationPointers,\r\n    ObjectPointers,\r\n    GraphPointers,\r\n    ParameterPointers,\r\n    ReferencePointers,\r\n    VertexPointers,\r\n    ModelPointers,\r\n    LtoD,\r\n    LVertex, LEdgePoint, LGraph, MultiSelectOptGroup, UX, Function2, Any, MultiSelectOption, windoww, Uobj,\r\n} from \"../../joiner\";\r\nimport {\r\n    Abstract,\r\n    ClassPointers,\r\n    Constructor,\r\n    Constructors,\r\n    Debug,\r\n    DEdge, DefaultNode,\r\n    Dictionary,\r\n    DocString,\r\n    DPointerTargetable,\r\n    DState,\r\n    DtoL,\r\n    getWParams,\r\n    GObject,\r\n    GraphSize,\r\n    Instantiable,\r\n    Leaf,\r\n    LEdge,\r\n    LGraphElement,\r\n    Log,\r\n    LogicContext,\r\n    LPointerTargetable,\r\n    Node,\r\n    Pack,\r\n    Pack1,\r\n    PackArr,\r\n    PointedBy,\r\n    Pointer,\r\n    Pointers,\r\n    RuntimeAccessible,\r\n    RuntimeAccessibleClass,\r\n    Selectors,\r\n    SetFieldAction, SetRootFieldAction,\r\n    ShortAttribETypes,\r\n    ShortAttribSuperTypes,\r\n    store,\r\n    TargetableProxyHandler,\r\n    L,\r\n    TRANSACTION,\r\n    U, Uarr\r\n} from \"../../joiner\";\r\nimport type {Info, Json, ObjectWithoutPointers, orArr, PrimitiveType, unArr} from \"../../joiner/types\";\r\n\r\nimport {\r\n    AccessModifier,\r\n    ECoreAnnotation,\r\n    ECoreAttribute,\r\n    ECoreClass,\r\n    ECoreEnum,\r\n    EcoreLiteral,\r\n    ECoreOperation,\r\n    ECorePackage,\r\n    EcoreParser,\r\n    ECoreReference,\r\n    ECoreRoot\r\n} from \"../../api/data\";\r\nimport {ValuePointers} from \"./PointerDefinitions\";\r\nimport {ShortDefaultEClasses} from \"../../common/U\";\r\nimport {transientProperties} from \"../../joiner/classes\";\r\nimport React, {ReactNode} from \"react\";\r\n\r\ntype outactions = {clear:(()=>void)[], set:(()=>void)[], immediatefire?: boolean};\r\n\r\n\r\n@Node\r\n@RuntimeAccessible('DModelElement')\r\nexport class DModelElement extends DPointerTargetable {\r\n    // static _super = DPointerTargetable;\r\n    // static logic: typeof LModelElement;\r\n    // static structure: typeof DModelElement;\r\n    // static singleton: LModelElement;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n\r\n    id!: Pointer<DModelElement, 1, 1, LModelElement>;\r\n    parent: Pointer<DModelElement, 0, 'N', LModelElement> = [];\r\n    father!: Pointer<DModelElement, 1, 1, LModelElement>;\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    // instances: Pointer<DModelElement, 0, 'N', LModelElement> = [];\r\n\r\n    public static new(): DModelElement {\r\n        Log.exx(\"DModelElement is abstract, cannot instantiate\");\r\n        return null as any;\r\n        //return new Constructors(new DModelElement('dwc')).DPointerTargetable().DModelElement().end();\r\n    }\r\n    public static new3(...a:any): DModelElement {\r\n        Log.exx(\"DModelElement is abstract, cannot instantiate\");\r\n        return null as any; }\r\n\r\n    static LFromHtml(target?: Element | null): LModelElement | undefined { return LPointerTargetable.fromPointer(DModelElement.PtrFromHtml(target) as Pointer); }\r\n    static DFromHtml(target?: Element | null): DModelElement | undefined { return DPointerTargetable.fromPointer(DModelElement.PtrFromHtml(target) as Pointer); }\r\n    static PtrFromHtml(target?: Element | null): Pointer<DModelElement> | undefined {\r\n        while (target) {\r\n            if ((target.attributes as any).dataid) return (target.attributes as any).dataid.value;\r\n            target = target.parentElement;\r\n        }\r\n        return undefined;\r\n    }\r\n}\r\n\r\n@Leaf\r\n@RuntimeAccessible('DAnnotationDetail')\r\nexport class DAnnotationDetail extends DPointerTargetable {\r\n    // todo\r\n}\r\n\r\n\r\n\r\n@Abstract\r\n@RuntimeAccessible('LModelElement')\r\nexport class LModelElement<Context extends LogicContext<DModelElement> = any, D extends DModelElement = DModelElement> extends LPointerTargetable {\r\n    // extends Mixin(DModelElement0, LPointerTargetable)\r\n    // static logic: typeof LModelElement;\r\n    // static structure: typeof DModelElement;\r\n\r\n    /* Alfonso */\r\n    static singleton: LModelElement;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    /*static ResolvePointer = resolvePointerFunction;\r\n    private static ResolvePointers? = resolvePointersFunction;\r\n    private resolvePointer<T extends DPointerTargetable = DPointerTargetable, LB extends number = 0, UB extends number = 0, RET extends LPointerTargetable = LPointerTargetable>(ptr: Pointer<T, LB, UB, RET>): RET | null {\r\n        return LModelElement.ResolvePointer(ptr); }\r\n    private resolvePointers<T extends DPointerTargetable = DPointerTargetable, LB extends number = 0, RET extends LPointerTargetable = LPointerTargetable>(ptr: Pointer<T, LB, 'N', RET>)\r\n        : (RET | null)[] { return resolvePointersFunction(ptr); }\r\n    */\r\n    public __raw!: DModelElement;\r\n    id!: Pointer<DModelElement, 1, 1, LModelElement>;\r\n    parent!: LModelElement[];\r\n    father!: LModelElement; // annotations can be children of everything. except them fathers are: Model, Package, Classifier(class+enum), Operation\r\n\r\n    private __info_of__father = {type: \"LModelElement\", txt:\"<a href=\\\"https://github.com/DamianoNaraku/jodel-react/wiki/LModelElement\\\"><span>The element containing this object.</span></a>\"};\r\n    public fatherList!: LModelElement[]; // chain of fathers going up recursively\r\n    annotations!: LAnnotation[];\r\n    children!: (LPackage | LClassifier | LTypedElement | LAnnotation | LObject | LValue)[];\r\n    __info_of__children__: Info = {type: \"LModelElement[]\", txt: <div>Merging of all the subelement collections (attributes, references, parameters...) except annotations</div>}\r\n    nodes!: LGraphElement[];\r\n    node!: LGraphElement | undefined;\r\n\r\n    // utilities to go up in the tree (singular names)\r\n    model!: LModel; // utility, follow father chain until get a Model parent or null\r\n    package!: LPackage | null;\r\n    class!: LClass | null;\r\n    enum!: LEnumerator | null;\r\n    operation!: LOperation | null;\r\n    subNodes!: LGraphElement[] | null;\r\n\r\n\r\n    property!: keyof DModelElement;\r\n    containers!: LNamedElement[]; // list of fathers until the model is reached.\r\n    //name?:string;\r\n\r\n\r\n    [key: `@${string}`]: LModelElement;\r\n    [key: `$${string}`]: LModelElement;\r\n\r\n    // protected _defaultGetter(c: Context, k: keyof Context[\"data\"]): any {}\r\n\r\n    protected _defaultGetter(c: Context, k: keyof any): any {\r\n        let targetObj = c.data;\r\n        let proxyitself = c.proxyObject;\r\n        // if not exist check for children names\r\n        if (typeof k === \"string\" && k !== \"children\" && (!(k in c.data) && !(k in this))) { // __info_of_children__\r\n            let lchildren: LPointerTargetable[];\r\n            try { lchildren = this.get_children(c); }\r\n            catch (e) { lchildren = []; }\r\n            // let dchildren: DPointerTargetable[] = lchildren.map<DPointerTargetable>(l => l.__raw as any);\r\n            let lc: GObject;\r\n            let pk: string;\r\n            if (TargetableProxyHandler.childKeys[k[0]]) { pk = k.substring(1); }\r\n            else pk = k;\r\n            if (Array.isArray(lchildren)) for (lc of lchildren) {\r\n                let n = lc?.name;\r\n                if (n && n.toLowerCase() === pk.toLowerCase()) return lc;\r\n            }\r\n        }\r\n        return super.__defaultGetter(c, k);\r\n    }\r\n\r\n    // this one must return true or the js engine throws an exception\r\n    protected _defaultSetter(val: any, c: GObject<Context>, k: string): true {\r\n        if (this._setterFor$stuff_canReturnFalse(val, c as any, k as any)) return true;\r\n        super._defaultSetter(val, c as any, k);\r\n        return true;\r\n    }\r\n    // this one must be able to return false because is called by DObject and DValue default setters and return type is checked\r\n    protected _setterFor$stuff_canReturnFalse(val: any, c: Context, k: keyof Context[\"data\"] & string): boolean {\r\n        // if (![\"@\", \"$\"].includes(k[0])) return false;\r\n        if (!TargetableProxyHandler.childKeys[k[0]]) return false;\r\n        let target: LPointerTargetable = (c.proxyObject as GObject)[k];\r\n        if (!target) return false;\r\n        let l;\r\n        let tClassName: string = target.className;\r\n\r\n        // messanger classNames (pass it to next sublevel)\r\n        navigationloop: while(true) {\r\n            switch (tClassName) {\r\n                default: break navigationloop;\r\n                case DPackage.cname:\r\n                case DClass.cname:\r\n                case DEnumerator.cname:\r\n                case DObject.cname:\r\n                    target = (target as LModelElement).children[0]; continue navigationloop;\r\n            }\r\n        }\r\n\r\n        // actiong classNames\r\n        switch (tClassName) {\r\n            default: Log.exx(\"default setter not supported for model element: \" + c.data.className, {c, k, val, target}); return false;\r\n            case DEnumLiteral.cname:\r\n                l = target as LEnumLiteral;\r\n                switch (typeof val){\r\n                    default: return false;\r\n                    case \"string\": l.literal = val; return true;\r\n                    case \"number\": l.ordinal = val; return true;\r\n                }\r\n                return false;\r\n            case DValue.cname:\r\n                // makes object.$x = 1      be equivalent to object.$x.value = 1 (or values if is arr)\r\n                l = target as LValue;\r\n                l.values = val;\r\n                return true;\r\n        }\r\n    }\r\n\r\n    fullname!:string;\r\n    protected get_fullName(context: Context): this[\"fullname\"] { return this.get_fullname(context); }\r\n    protected get_fullname(context: Context): this[\"fullname\"] {\r\n        const containers = this.get_containers(context).reverse();\r\n        // let sliceindex = (containers[0] as LModel).dependencies.length ? 1 : 0;\r\n        let fullname: string = containers.slice(0, containers.length).map(c => c.name).join('.');\r\n        return fullname;\r\n    }\r\n\r\n\r\n    protected _autofix_name(val: string, context: Context): string {\r\n        // NB: NON fare autofix di univocità nome tra i children o qualsiasi cosa dipendente dal contesto, questo potrebbe essere valido in alcuni modelli e invalido in altri e modificare un oggetto condiviso.\r\n        return val.replaceAll(/\\s/g, '_');\r\n    }\r\n\r\n    protected get_autofix_name(val: string, context: Context): (val: string) => string {\r\n        return (val: string) => this._autofix_name(val, context);\r\n    }\r\n\r\n    public autofix_name(val: string): string {\r\n        return this.wrongAccessMessage(\"autofix_name\");\r\n    }\r\n\r\n    public static M1Classes = ['DModel', 'DObject', 'DValue']; // Dstrudturalfeature in shapeless obj??\r\n    public static AbstractClasses = ['DModelElement', 'DNamedElement', '...'];\r\n    public static M2InstantiableClasses = ['DModel', 'DOperation', 'DClass', 'DReference', 'DAttribute'];\r\n    isM1!: (()=>boolean);\r\n    __info_of__isM1: Info = {type:'()=>boolean', txt:<div>Whether the element belong to the metamodel or the model.</div>}\r\n    get_isM1(c: Context): ()=>boolean {\r\n        // NB: if called with \"abstract classes\" like DModelElement, DTypedElement... responds they are in m2\r\n        return (() => (!(c.data as DModel).isMetamodel && LModelElement.M1Classes.includes(c.data.className)));\r\n    }\r\n    isM2!: (()=>boolean);\r\n    __info_of__isM2: Info = {type:'()=>boolean', txt:<div>Whether the element belong to the metamodel or the model.</div>}\r\n    get_isM2(c: Context): ()=>boolean { return (() => !(this.get_isM1(c))); }\r\n\r\n    isInstantiable!: boolean;\r\n    instantiable!: boolean;\r\n    __info_of__isInstantiable: Info = {type:'boolean', txt:<div>Whether the element type (DClass, DAttribute...) can produce an instance in the model.</div>}\r\n    get_isInstantiable(c: Context): boolean { return this.get_instantiable(c); }\r\n     get_instantiable(c: Context): boolean { return LModelElement.M2InstantiableClasses.includes(c.data.className); }\r\n\r\n    childNames!: string[];\r\n    __info_of__childNames: Info = {type: \"(json: object, instanceof?: LClass) => LObject\", txt: \"Array containing the names of all children subelements.\"};\r\n    get_childNames(c: Context): string[] { return this.get_children(c).map( (c: GObject<LModelElement>) => c.name).filter(c=>!!c) as string[]; }\r\n\r\n    public generateEcoreJson(loopDetectionloopDetectionObj: Dictionary<Pointer, DModelElement> = {}): Json {\r\n        throw new Error(\"cannot be called directly, should trigger getter. this is only for correct signature\");\r\n    }\r\n\r\n    private get_generateEcoreJson(context: Context): (loopdetectionobj: Dictionary<Pointer, DModelElement>) => Json {\r\n        return (loopdetectionobj) => this.generateEcoreJson_impl(context, loopdetectionobj);\r\n    }\r\n\r\n    protected generateEcoreJson_impl(context: Context, loopDetectionObj?: Dictionary<Pointer, DModelElement>): Json {\r\n        return Log.exDevv(\"generateEcoreJson() should be overridden\", context);\r\n    }\r\n\r\n    public duplicate(deep: boolean = true): this {\r\n        return this.cannotCall(((this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name) + \"duplicate() class is abstract\");\r\n    }\r\n\r\n    public addAnnotation(source?: DAnnotation[\"source\"], details?: DAnnotation[\"details\"]): DAnnotation {\r\n        return this.cannotCall(\"addAnnotation\");\r\n    }\r\n\r\n    protected get_addAnnotation(context: Context): this[\"addAnnotation\"] {\r\n        return (source?: DAnnotation[\"source\"], details?: DAnnotation[\"details\"]) => DAnnotation.new(source, details, context.data.id, true);\r\n    }\r\n\r\n    protected set_containers(): boolean {\r\n        return this.cannotSet('containers');\r\n    }\r\n\r\n    protected get_containers(context: Context): LModelElement[\"containers\"] {\r\n        let thiss: LModelElement = context.proxyObject;\r\n        const ret: LModelElement[] = [thiss];\r\n        while (true) {\r\n            thiss = thiss.father;\r\n            if (!thiss) break;\r\n            ret.push(thiss);\r\n        }\r\n        return ret as LNamedElement[];\r\n    }\r\n\r\n\r\n    protected get_namespace(context: Context): string {\r\n        throw new Error(\"?? get namespace ?? todo\");\r\n        return \"\";\r\n    }\r\n\r\n    protected get_subNodes(context: LogicContext<LClass>, includingthis: boolean = false): LGraphElement[] {\r\n        const lclass: LClass = context.proxyObject as any;\r\n        let $class = $('[data-dataid=\"' + context.data.id + '\"]');\r\n        let $subnodes = $class.find('[data-nodeid]');\r\n\r\n        function mapfunc(this: HTMLElement) {\r\n            return this.dataset.nodeid;\r\n        }\r\n\r\n        let nodehtmlarr: HTMLElement[] = $subnodes.toArray();\r\n        if (includingthis) nodehtmlarr.push($class[0]);\r\n        let nodeidarr: string[] = nodehtmlarr.map((html: HTMLElement) => html.dataset.nodeid) as string[];\r\n        let state = store.getState();\r\n        let dnodes = nodeidarr.map(id => state.idlookup[id]).filter((d) => !!d);\r\n        return dnodes.map(d => LPointerTargetable.wrap(d)) as any;\r\n    }\r\n\r\n\r\n    // name -> redux (es. DClass -> classs)\r\n    protected get_property(context: Context): this[\"property\"] {\r\n        return (context.data.className.substring(1) + \"s\").toLowerCase() as any;\r\n    }\r\n\r\n    protected targetRemoved(context: Context, field: keyof DPointerTargetable): void {\r\n        context.proxyObject.delete();\r\n    }\r\n\r\n\r\n    protected get_fatherList(context: Context): LModelElement[] {\r\n        let ret: LModelElement[] = [context.proxyObject];\r\n        let loopdetection: Dictionary<Pointer, boolean> = {};\r\n        loopdetection[context.data.id] = true;\r\n        let current = this.get_father(context);\r\n        while (current) {\r\n            if (loopdetection[current.id]) { console.error(\"found loop\", {loopdetection, ret, current}); return ret; }\r\n            loopdetection[current.id] = true;\r\n            ret.push(current);\r\n            current = current.father;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    // @ts-ignore\r\n    private get_until_parent<D extends Constructor, L extends DtoL<InstanceType<D>>>(l: LModelElement, d: DModelElement, father: typeof D): L | null {\r\n        while (true) {\r\n            // console.log('get_until_parent', {l, d, father}, {dname: d.className, fname: father.name});\r\n            if (d.className === (father.cname || father.name)) return l as L;\r\n            l = l.father;\r\n            let oldd = d;\r\n            d = l?.__raw;\r\n            if (oldd === d || !l) return null; // reached end of father chain (a model) without finding the desired parent.\r\n        }\r\n    }\r\n\r\n    __info_of__nodes:Info={type: 'LGraphElement[]', txt: \"Return all kind of graphic elements representing this modelElement currently displayed in the graph, including edges\"};\r\n    protected get_nodes(context: Context): this[\"nodes\"] {\r\n        return Object.values(transientProperties.modelElement[context.data.id]?.nodes || {}).filter(n=>n&&n.html);/*\r\n        const nodes: LGraphElement[] = [];\r\n        const nodeElements = $('[data-dataid=\"' + context.data.id + '\"]'); nope, this must become more efficient. when node is created set action to update data.nodes array? or to update a transient property (better)\r\n        for (let nodeElement of nodeElements) {\r\n            const nodeId = nodeElement.id;\r\n            if (nodeId) {\r\n                const lNode: LGraphElement | undefined = LPointerTargetable.wrap(nodeId);\r\n                if (lNode) nodes.push(lNode);\r\n            }\r\n        }\r\n        return nodes;*/\r\n    }\r\n\r\n    __info_of__node:Info={type: 'LGraphElement[]', txt: \"Return the latest updated node representing this ModelElement, including those not currently displayed in the graph.\"};\r\n    protected get_node(context: Context): this[\"node\"] {\r\n        return transientProperties.modelElement[context.data.id]?.node;\r\n        // const nodes = context.proxyObject.nodes;\r\n        // return nodes.filter( n => n.favoriteNode)[0] || nodes[0];\r\n    }\r\n    edges!: LEdge[];\r\n    edge!: LEdge;\r\n    __info_of__edges:Info={type: 'LEdge[]', txt: \"The subset of \\\"nodes\\\" containing only edges.\"};\r\n    __info_of__edge:Info={type: 'LEdge[]', txt: \"The first element of the collection edges\"};\r\n    protected get_edges(context: Context): this[\"edges\"] {\r\n        return this.get_nodes(context).filter( l => l.className?.includes('Edge')) as any;\r\n    }\r\n    protected get_edge(context: Context): this[\"edge\"] {\r\n        return this.get_nodes(context).find( l => l.className?.includes('Edge')) as any;\r\n    }\r\n    notEdges!: LGraphElement[];\r\n    notEdge!: LGraphElement;\r\n    __info_of__notEdges:Info={type: 'LGraphElement[]', txt: \"The subset of \\\"nodes\\\" excluding only edges.\"};\r\n    protected get_notEdges(context: Context): this[\"notEdges\"] {\r\n        return this.get_nodes(context).filter( l => !(l.className?.includes('Edge'))) as any;\r\n    }\r\n    __info_of__notEdge:Info={type: 'LGraphElement', txt: \"The first element of the collection notEdges\"};\r\n    protected get_notEdge(context: Context): this[\"notEdge\"] {\r\n        return this.get_nodes(context).find( l => !(l.className?.includes('Edge'))) as any;\r\n    }\r\n    vertexes!: LVertex[];\r\n    vertex!: LVertex;\r\n    __info_of__vertexes:Info={type: 'LVertex[]', txt: \"The subset of \\\"nodes\\\" containing only vertexes.\"};\r\n    __info_of__vertex:Info={type: 'LVertex', txt: \"The first element of the collection vertexes\"};\r\n    protected get_vertexes(context: Context): this[\"vertexes\"] {\r\n        return this.get_nodes(context).filter( l => l.className?.includes('Vertex')) as any;\r\n    }\r\n    protected get_vertex(context: Context): this[\"vertex\"] {\r\n        return this.get_nodes(context).find( l => l.className?.includes('Vertex')) as any;\r\n    }\r\n    edgePoints!: LEdgePoint[];\r\n    edgePoint!: LEdgePoint;\r\n    __info_of__edgePoints:Info={type: 'LVertex[]', txt: \"The subset of \\\"nodes\\\" containing only edgePoints.\"};\r\n    __info_of__edgePoint:Info={type: 'LVertex', txt: \"The first element of the collection edgePoints\"};\r\n    protected get_edgePoints(context: Context): this[\"edgePoints\"] {\r\n        return this.get_nodes(context).filter( l => l.className?.includes('EdgePoint')) as any;\r\n    }\r\n    protected get_edgePoint(context: Context): this[\"edgePoint\"] {\r\n        return this.get_nodes(context).find( l => l.className?.includes('EdgePoint')) as any;\r\n    }\r\n    graphs!: LGraph[];\r\n    graph!: LGraph;\r\n    __info_of__graphs:Info={type: 'LGraph[]', txt: \"The subset of \\\"nodes\\\" containing only graphs.\"};\r\n    __info_of__graph:Info={type: 'LGraph', txt: \"The first element of the collection graphs\"};\r\n    protected get_graphs(context: Context): this[\"graphs\"] {\r\n        return this.get_nodes(context).filter( l => {\r\n            let d = l.__raw;\r\n            return d.className === 'DGraph' || d.className === 'DGraphVertex'\r\n        }) as any;\r\n    }\r\n    protected get_graph(context: Context): this[\"graph\"] {\r\n        return this.get_nodes(context).find( l => {\r\n            let d = l.__raw;\r\n            return d.className === 'DGraph' || d.className === 'DGraphVertex'\r\n        }) as any;\r\n    }\r\n    fields!: LGraphElement[];\r\n    field!: LGraphElement;\r\n    __info_of__fields:Info={type: 'LGraphElement[]', txt: \"The subset of \\\"nodes\\\" containing only fields.\"};\r\n    __info_of__field:Info={type: 'LGraphElement', txt: \"The first element of the collection fields\"};\r\n    protected get_fields(context: Context): this[\"fields\"] {\r\n        return this.get_nodes(context).filter( l => l.className === 'DGraphElement') as any;\r\n    }\r\n    protected get_field(context: Context): this[\"field\"] {\r\n        return this.get_nodes(context).find( l => l.className === 'DGraphElement') as any;\r\n    }\r\n\r\n    /*\r\n    protected get_nodes(context: Context): this[\"nodes\"] {\r\n        return context.data.nodes.map((pointer) => {\r\n            return LPointerTargetable.from(pointer)\r\n        });\r\n    }\r\n    protected set_nodes(val: PackArr<this[\"nodes\"]>, context: Context): boolean {\r\n        const list = val.map((lItem) => { return Pointers.from(lItem) });\r\n        SetFieldAction.new(context.data, 'nodes', list);\r\n        return true;\r\n    }\r\n    */\r\n\r\n    protected get_model(context: Context): LModel {\r\n        return this.get_until_parent(context.proxyObject, context.data, DModel) as LModel;\r\n    }\r\n\r\n    protected get_package(context: Context): LPackage {\r\n        return this.get_until_parent(context.proxyObject, context.data, DPackage) as LPackage;\r\n    }\r\n\r\n    protected get_class(context: Context): LClass | null {\r\n        return this.get_until_parent(context.proxyObject, context.data, DClass);\r\n    } // todo: might be better for pergormance to erase this universal method and add implementations to every single L-class counting the correct amount of \"father\" navigations for each ( attrib to package? use attrib.father.father)\r\n    protected get_operation(context: Context): LOperation | null {\r\n        return this.get_until_parent(context.proxyObject, context.data, DOperation);\r\n    }\r\n\r\n    protected get_enum(context: Context): LEnumerator | null {\r\n        return this.get_until_parent(context.proxyObject, context.data, DEnumerator);\r\n    }\r\n\r\n    protected get_father(context: Context): LModelElement {\r\n        return LPointerTargetable.from(context.data.father);\r\n    }\r\n\r\n    protected get_children_idlist(context: Context): Pointer<DAnnotation | DPackage | DClassifier | DEnumerator | DEnumLiteral | DParameter | DStructuralFeature | DOperation | DObject | DValue, 1, 'N'> { // LPackage | LClassifier | LTypedElement | LAnnotation | LEnumLiteral | LParameter | LStructuralFeature | LOperation\r\n        return context.data.annotations ? [...context.data.annotations] : [];\r\n    }\r\n\r\n    protected get_children(context: Context): this[\"children\"] {\r\n        // return this.get_children_idlist(context).map(e => LPointerTargetable.from(e));\r\n        return LPointerTargetable.from(this.get_children_idlist(context));\r\n    }\r\n\r\n    protected set_children(a: never, context: Context): boolean {\r\n        return Log.exx('children is a derived read-only collection', context.data);\r\n    }\r\n\r\n/*\r\n    add_parent(val: Pack<this[\"parent\"]>, c: Context): boolean { // will be used?\r\n        const ptr = Pointers.from(val);\r\n        TRANSACTION(this.get_name(c)+'.parent+=', ()=>{\r\n            SetFieldAction.new(c.data, 'parent', ptr, '+=', true); // need to update children of the old and new parents\r\n        })\r\n        return true;\r\n    }\r\n    protected remove_parent(c: Context): boolean {\r\n        return SetFieldAction.new(c.data, 'parent', [], '', true);\r\n    }\r\n\r\n    protected get_parent(c: Context): this[\"parent\"] {\r\n        return LPointerTargetable.from(c.data.id);\r\n    }*/\r\n\r\n    protected set_parent(val: Pack<LAnnotation>, c: Context): boolean { // val: Pack<DModelElement>\r\n        const ptrs = Pointers.from(val);\r\n        let ptr: Pointer;\r\n        if (Array.isArray(ptrs)) ptr = ptrs[0];\r\n        else ptr = ptrs;\r\n        if (c.data.father === ptr) return true;\r\n        TRANSACTION(this.get_name(c)+'.parent', ()=>{\r\n            SetFieldAction.new(c.data, 'father', ptr, '', true);\r\n            //SetFieldAction.new(c.data, 'parent', ptrs, '', true);\r\n        }, this.get_father(c)?.name, LPointerTargetable.wrap(ptr)?.name)\r\n        return true;\r\n    }\r\n\r\n    add_annotation(val: Pack<this[\"annotations\"]>, c: Context): boolean {\r\n        const ptrs = Pointers.from(val);\r\n        TRANSACTION(this.get_name(c)+'.annotations+=', ()=>{\r\n            SetFieldAction.new(c.data, 'annotations', ptrs, '+=', true);\r\n        }, undefined, ptrs.length)\r\n        return true;\r\n    }\r\n\r\n    remove_annotation(val: Pack<this[\"annotations\"]>, c: Context): boolean { // todo: when this will be ever used? this should be triggered by LObject but only get_ / set_ and delete of whole elements should be triggerable.\r\n        let ptrs: Pointer<DAnnotation, 1, 'N', LAnnotation> = Pointers.from(val) as any;\r\n        if (!Array.isArray(ptrs)) ptrs = [ptrs] as any;\r\n        let indexes = ptrs.map(ptr => c.data.annotations.indexOf(ptr)).filter(p => p >= 0);\r\n        if (indexes.length === 0) return true;\r\n        TRANSACTION(this.get_name(c)+'.annotations-=', ()=>{\r\n            SetFieldAction.new(c.data, 'annotations', indexes, '-=', true);\r\n        }, undefined, ptrs.length)\r\n        return true;\r\n    }\r\n\r\n    protected get_annotations(context: Context): this[\"annotations\"] {\r\n        return LPointerTargetable.fromPointer(context.data.annotations);\r\n    }\r\n\r\n    protected set_annotations(val: Pack<LAnnotation>, c: Context): boolean {\r\n        //  if (!Array.isArray(val)) val = [val];\r\n        //         val = val.map( v => (v instanceof LAnnotation ? v.id : ( Pointers.filterValid(v) ? v : null ))) as Pointer<DAnnotation>[];\r\n        let ptrs = Pointers.from(val);\r\n        if (!Array.isArray(ptrs)) ptrs = [ptrs] as any;\r\n        if (!ptrs.length) return true;\r\n        TRANSACTION(this.get_name(c)+'.annotations', ()=>{\r\n            SetFieldAction.new(c.data, 'annotations', ptrs, '', true);\r\n        }, undefined, ptrs.length)\r\n        return true;\r\n    }\r\n\r\n    protected get_addChild(c: Context): (type?: string, ...params: any[]) => LModelElement { // just for add new, not for add pre-existing.\r\n        return (type?: string, ...args: any) => {\r\n            let ret: undefined | ((...params: any[]) => LModelElement) = undefined;\r\n            TRANSACTION(this.get_name(c)+'.addChild()', ()=>{\r\n                let type0 = type;\r\n                if (!type || type === \"auto\") {\r\n                    switch(c.data.className){\r\n                        case DModel.cname: if ((c.data as DModel).isMetamodel) type = \"package\"; else type = \"object\"; break;\r\n                        case DObject.cname: type = \"value\"; break;\r\n                        case DPackage.cname: type = \"package\"; break;\r\n                        case DClass.cname: type = \"attribute\"; break;\r\n                        case DEnumerator.cname: type = \"literal\"; break;\r\n                        case DOperation.cname: type = \"parameter\"; break;\r\n                        default: type = \"annotation\"; break;\r\n                    }\r\n                }\r\n                let fatherElement;\r\n                switch (type.toLowerCase()) {\r\n                    default:\r\n                        Log.ee('cannot find children type requested to add:', {type: (type || '').toLowerCase(), c});\r\n                        ret = () => undefined as any;\r\n                        break;\r\n                    case \"package\":\r\n                        ret = (this.get_package(c) || this.get_model(c))?.addPackage;\r\n                        break;\r\n                    case \"class\":\r\n                        // let current = c.proxyObject;\r\n                        fatherElement = this.get_package(c);\r\n                        if (!fatherElement) {\r\n                            let model = this.get_model(c);\r\n                            //if (model && !model.isMetamodel) model = model.instanceof;\r\n                            fatherElement = model.packages[0];\r\n                            if (!fatherElement) fatherElement = model.addPackage();\r\n                        }\r\n                        ret = fatherElement.addClass;\r\n                        //ret = (this as any).get_addClass(context as any);\r\n                        break;\r\n                    case \"enum\":\r\n                    case \"enumerator\":\r\n                        fatherElement = this.get_package(c);\r\n                        if (!fatherElement) {\r\n                            let model = this.get_model(c);\r\n                            //if (model && !model.isMetamodel) model = model.instanceof;\r\n                            fatherElement = model.packages[0];\r\n                            if (!fatherElement) fatherElement = model.addPackage();\r\n                        }\r\n                        ret = fatherElement.addEnumerator;\r\n                        break;\r\n                    case \"attribute\":\r\n                        ret = this.get_class(c)?.addAttribute;\r\n                        break;\r\n                    case \"reference\":\r\n                        ret = this.get_class(c)?.addReference;\r\n                        break;\r\n                    case \"literal\":\r\n                        ret = this.get_enum(c)?.addLiteral;\r\n                        break;\r\n                    case \"operation\":\r\n                        ret = this.get_class(c)?.addOperation;\r\n                        break;\r\n                    case \"parameter\":\r\n                        ret = this.get_operation(c)?.addParameter;\r\n                        break;\r\n                    case \"object\":\r\n                        if (c.data.className === \"DValue\") {\r\n                            ret = (this as any as LValue).get_addObject(c as any as LogicContext<DValue>);\r\n                        }\r\n                        else {\r\n                            ret = this.get_model(c).addObject;\r\n                        }\r\n\r\n                    //case \"exception\": ret = ((exception: Pack1<LClassifier>) => { let rett = this.get_addException(context as any); rett(exception); }) as any; break;\r\n                    /*case \"exception\": exceptions should not be \"added\" here, this is for creating objects. exceptions are not created but just linked. they are classes.\r\n                        ret = (this as any).get_addException(c as any);\r\n                        break; */\r\n                }\r\n                // console.log('x6 addchild()', {type0, type, args, fatherElement, ret, rts:ret?.toString()});\r\n                ret = ret ? ret(...args) : null as any;\r\n            })\r\n            return ret as any;\r\n        }\r\n    }\r\n\r\n    protected get_addException(c: Context): () => void {\r\n        let ret = () => {};\r\n        const dOperation: DOperation | null = (c.data?.className === \"DOperation\") ? c.data as DOperation : null;\r\n        if (!dOperation) return ret;\r\n        const dClass = DPointerTargetable.from(dOperation.father);\r\n        if (!dClass) return ret;\r\n        ret = () => {\r\n            TRANSACTION(this.get_name(c)+'.exceptions+=', ()=>{\r\n                SetFieldAction.new(dOperation, \"exceptions\", dClass.id, '+=', true);\r\n            }, undefined, LPointerTargetable.fromD(dClass).name)\r\n        }\r\n        ret();\r\n        // todo: test & fix this double call, i suspect if you call it\r\n        //  from get_addChildren it triggers once (return is ignored) but twice if directly\r\n        return ret;\r\n    }\r\n\r\n    // activated by user in JSX\r\n    // todo: this.wrongAccessMessage(\"addClass\");\r\n    protected cannotCall(name: string, ...params: string[]): any {\r\n        Log.exDevv(name + ' should never be called directly, but should trigger get_' + name + '(' + params.join(', ') + '), this is only a signature for type checking.');\r\n    }\r\n\r\n    public addClass(): void {\r\n        this.cannotCall('addClass');\r\n    }\r\n\r\n    public addAttribute(): void {\r\n        this.cannotCall('addAttribute');\r\n    }\r\n\r\n    public addReference(): void {\r\n        this.cannotCall('addReference');\r\n    }\r\n\r\n    public addEnumerator(): void {\r\n        this.cannotCall('addEnumerator');\r\n    }\r\n\r\n    public addParameter(): void {\r\n        this.cannotCall('addParameter');\r\n    }\r\n\r\n    // chiedere al prof: cosa può lanciato come eccezione: se tutte le classi o se solo quelle che estendono Exception\r\n    public addException(exception?: DClassifier): () => void {\r\n        throw this.wrongAccessMessage(\"AddException\");\r\n    }\r\n\r\n    public addChild(type: string): DModelElement {\r\n        return this.cannotCall('addChild', type);\r\n    }\r\n\r\n}\r\n\r\n/*function isValidPointer<T extends DPointerTargetable = DModelElement, LB extends number = 0, UB extends number = 1, RET extends LPointerTargetable = LModelElement>\r\n(p: Pointer<T, LB, UB, RET>, constraintType?: typeof DPointerTargetable): boolean {\r\n    const pointerval: RET | null = LModelElement.ResolvePointer(p);\r\n    if (!pointerval) return false;\r\n    if (!constraintType) return true;\r\n    return (pointerval instanceof constraintType); }*/\r\n\r\n/* todo:\r\nnel proxy aggiungi regola di default, se prendi qualcosa che inizia con \"set_X\" esplicitamente (dovrebbe farlo solo il dev)\r\nrichiama _set_X(context, ...params)     <---- nuova funzione set di default, anche this.x = x richiama _set_x\r\n\r\nil dev specifica set_x come public di sola firma senza implementazione (throw exception) e senza context\r\nil dev specifica _set_x come implementazione private\r\n\r\nper la get esiste solo _get_x, non \"get_x\"\r\n\r\n todo2: aggiungi readonly a tutti i campi L per non sbagliarsi e fare in modo che il dev usi sempre i \"set_\" che sono correttamente tipizzati\r\n*\r\n* */\r\n\r\n/*todo:\r\n* for every feature X: typed L, in CLASS_L0 with a side effects when they are edited (like need to update other data for consistency)\r\n*\r\n* dev will use this\r\n* protected set_X(val: D | L | Pointer<D> ) { throw new Error(\"set_X should never be executed, the proxy should redirect to get_set_X.\"); }\r\n* protected get_set_X( val: D | L | Pointer<D>, otherparams, ContextD>) { throw new Error(\"set_X should never be executed, the proxy should redirect to get_set_X.\"); }\r\n*\r\n*\r\n* */\r\n// export type WModelElement = DModelElement | LModelElement | _WModelElement;\r\nRuntimeAccessibleClass.set_extend(DPointerTargetable, DModelElement);\r\nRuntimeAccessibleClass.set_extend(DPointerTargetable, LModelElement);\r\n\r\n@Leaf\r\n@RuntimeAccessible('DAnnotation')\r\nexport class DAnnotation extends DModelElement { // extends Mixin(DAnnotation0, DModelElement)\r\n    // static singleton: LAnnotation;\r\n    // static logic: typeof LAnnotation;\r\n    // static structure: typeof DAnnotation;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // inherit redefine\r\n    id!: Pointer<DAnnotation, 1, 1, LAnnotation>;\r\n    parent: Pointer<DModelElement, 0, 'N', LModelElement> = [];\r\n    father!: Pointer<DModelElement, 1, 1, LModelElement>;\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    // personal\r\n    source!: string;\r\n    details!: DAnnotationDetail[];//Dictionary<string, string>;\r\n\r\n    public static new(source?: DAnnotation[\"source\"], details?: DAnnotation[\"details\"], father?: Pointer, persist: boolean = true): DAnnotation {\r\n        // if (!name) name = this.defaultname(\"annotation \", father);\r\n        return new Constructors(new DAnnotation('dwc'), father, persist, undefined).DPointerTargetable().DModelElement().DAnnotation(source, details).end();\r\n    }\r\n}\r\n\r\n@Node\r\n@RuntimeAccessible('LAnnotation')\r\nexport class LAnnotation<Context extends LogicContext<DAnnotation> = any, D extends DAnnotation = DAnnotation> extends LModelElement {\r\n    // Mixin(DAnnotation0, LModelElement)\r\n    // @ts-ignore\r\n    __namee!: \"LAnnotation\" = \"LAnnotation\";\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DAnnotation;\r\n    id!: Pointer<DAnnotation, 1, 1, LAnnotation>;\r\n    // static singleton: LAnnotation;\r\n    // static logic: typeof LAnnotation;\r\n    // static structure: typeof DAnnotation;\r\n\r\n    // inherit redefine\r\n    parent!: LModelElement[];\r\n    father!: LModelElement;\r\n    annotations!: LAnnotation[];\r\n    // personal\r\n    source!: string;\r\n    details!: LAnnotationDetail[];// Dictionary<string, string> = {};\r\n\r\n    protected generateEcoreJson_impl(context: Context, loopDetectionObj: Dictionary<Pointer, DModelElement> = {}): Json {\r\n        loopDetectionObj[context.data.id] = context.data;\r\n        const json: Json = {};\r\n        EcoreParser.write(json, ECoreAnnotation.source, context.data.source);\r\n        // EcoreParser.write(json, ECoreAnnotation.references, context.proxyObject.referencesStr);\r\n        EcoreParser.write(json, ECoreAnnotation.details, context.proxyObject.details.map(d => d.generateEcoreJson(loopDetectionObj)));\r\n        return json;\r\n    }\r\n\r\n    public duplicate(deep: boolean = true): this {\r\n        return this.cannotCall(((this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name) + \"duplicate()\");\r\n    }\r\n\r\n    protected get_duplicate(c: Context): ((deep?: boolean) => LAnnotation) {\r\n        return (deep: boolean = false) => {\r\n            let ret: LAnnotation = null as any;\r\n            TRANSACTION('duplicate ' + this.get_name(c), ()=>{\r\n                let de = c.proxyObject.father.addAnnotation(c.data.source, (deep ? c.proxyObject.details.map(ldet => ldet.duplicate().__raw) : c.data.details));\r\n                let le: LAnnotation = LPointerTargetable.fromD(de);\r\n                let we: WAnnotation = le as any;\r\n                we.annotations = deep ? c.proxyObject.annotations.map(lchild => lchild.duplicate(deep).id) : c.data.annotations;\r\n                ret = le; // set ret = le only if the transaction is complete.\r\n            })\r\n            return ret;\r\n        }\r\n    }\r\n\r\n    protected get_source(context: Context): this[\"source\"] {\r\n        return context.data.source;\r\n    }\r\n\r\n    protected set_source(val: this[\"source\"], c: Context): boolean {\r\n        if (val === c.data.source) return true;\r\n        TRANSACTION(this.get_name(c)+'.source', ()=>{\r\n            SetFieldAction.new(c.data, 'source', val, '', false);\r\n        }, c.data.source, val);\r\n        return true;\r\n    }\r\n\r\n    protected get_details(context: Context): this[\"details\"] {\r\n        return TargetableProxyHandler.wrapAll(context.data.details);\r\n    }\r\n\r\n    protected set_details(val: this[\"details\"], c: Context): boolean {\r\n        if (val === c.data.details) return true;\r\n        TRANSACTION(this.get_name(c)+'.details', ()=>{\r\n            SetFieldAction.new(c.data, 'details', val);\r\n        }, c.data.details, val)\r\n        return true;\r\n    }\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(DModelElement, DAnnotation);\r\nRuntimeAccessibleClass.set_extend(LModelElement, LAnnotation);\r\n@Leaf\r\n@RuntimeAccessible('LAnnotationDetail')\r\nexport class LAnnotationDetail<Context extends LogicContext<DAnnotationDetail> = any> extends LModelElement { // todo\r\n    father!: LAnnotation;\r\n\r\n    protected generateEcoreJson_impl(context: Context, loopDetectionObj: Dictionary<Pointer, DModelElement> = {}): Json {\r\n        // loopDetectionObj[context.data.id] = context.data;\r\n        const json: Json = {};\r\n        // if (context.data.name !== null) EcoreParser.write(json, ECoreDetail.key, context.data.name);\r\n        // if (context.data.value !== null) EcoreParser.write(json, ECoreDetail.value, context.data.value);\r\n        return json;\r\n    }\r\n\r\n    public duplicate(deep: boolean = true): this {\r\n        return this.cannotCall(((this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name) + \"duplicate()\");\r\n    }\r\n\r\n    protected get_duplicate(context: Context): ((deep?: boolean) => this) {\r\n        Log.exDevv(\"LAnnotationDetail.getDuplicate(): todo\");\r\n        return () => this;\r\n        // return (deep: boolean = false) => (context.proxyObject as LAnnotationDetail).father.addAnnotationDetail( {...context.data._subMaps})\r\n    }\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(DModelElement, DAnnotationDetail);\r\nRuntimeAccessibleClass.set_extend(LModelElement, LAnnotationDetail);\r\n@Node\r\n@RuntimeAccessible('DNamedElement')\r\nexport class DNamedElement extends DPointerTargetable { // Mixin(DNamedElement0, DAnnotation)\r\n    // static _super = DAnnotation;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LNamedElement;\r\n    // static logic: typeof LNamedElement;\r\n    // static structure: typeof DNamedElement;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DNamedElement, 1, 1, LNamedElement>;\r\n    parent: Pointer<DModelElement, 0, 'N', LModelElement> = [];\r\n    father!: Pointer<DModelElement, 1, 1, LModelElement>;\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    // personal\r\n    name!: string;\r\n\r\n    public static new(name?: DNamedElement[\"name\"]): DNamedElement {\r\n        Log.exx(\"DNamedElement is abstract, cannot instantiate\");\r\n        return null as any;\r\n        // return new Constructors(new DNamedElement('dwc')).DPointerTargetable().DModelElement().DNamedElement(name).end();\r\n    }\r\n\r\n}\r\n\r\n@Abstract\r\n@RuntimeAccessible('LNamedElement')\r\nexport class LNamedElement<Context extends LogicContext<DNamedElement> = any> extends LModelElement { // Mixin(DNamedElement0, DAnnotation)\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // public __raw!: DNamedElement;\r\n    id!: Pointer<DNamedElement, 1, 1, LNamedElement>;\r\n    // static singleton: LNamedElement;\r\n    // static logic: typeof LNamedElement;\r\n    // static structure: typeof DNamedElement;\r\n\r\n    // inherit redefine\r\n    parent!: LModelElement[];\r\n    father!: LModelElement;\r\n    annotations!: LAnnotation[];\r\n    // personal\r\n    name!: string;\r\n    namespace!: string;\r\n\r\n    protected set_containers(): boolean {\r\n        return this.cannotSet('containers');\r\n    }\r\n\r\n    protected get_containers(context: Context): LNamedElement[\"containers\"] {\r\n        let thiss: LNamedElement = context.proxyObject;\r\n        const ret: LNamedElement[] = [thiss];\r\n        while (true) {\r\n            thiss = thiss.father as LNamedElement;\r\n            if (!thiss) break;\r\n            ret.push(thiss);\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    // protected get_namespace(context: Context): string { throw new Error(\"?? get namespace ?? todo\"); return \"\"; }\r\n\r\n}\r\n\r\n\r\n// export type WNamedElement = DNamedElement | LNamedElement | _WNamedElement;\r\nRuntimeAccessibleClass.set_extend(DModelElement, DNamedElement);\r\nRuntimeAccessibleClass.set_extend(LModelElement, LNamedElement);\r\n@RuntimeAccessible('DTypedElement')\r\nexport class DTypedElement extends DPointerTargetable { // Mixin(DTypedElement0, DNamedElement)\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LTypedElement;\r\n    // static logic: typeof LTypedElement;\r\n    // static structure: typeof DTypedElement;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DTypedElement, 1, 1, LTypedElement>;\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    parent: Pointer<DModelElement, 0, 'N', LModelElement> = [];\r\n    father!: Pointer<DModelElement, 1, 1, LModelElement>;\r\n    name!: string;\r\n    instances!: Pointer<DValue, 0, 'N', LValue>;\r\n    // personal\r\n    type!: Pointer<DClassifier, 1, 1, LClassifier>;\r\n    ordered: boolean = true;\r\n    unique: boolean = true;\r\n    lowerBound: number = 0;\r\n    upperBound: number = 1;\r\n    many!: boolean; // ?\r\n    required!: boolean; // ?\r\n\r\n\r\n    public static new(name?: DNamedElement[\"name\"], type?: DTypedElement[\"type\"], father?: Pointer, persist: boolean = true): DTypedElement {\r\n        Log.exx(\"DTypedElement is abstract, cannot instantiate\");\r\n        return null as any;\r\n        //return new Constructors(new DTypedElement('dwc'), father, persist, undefined).DPointerTargetable().DModelElement().DNamedElement(name).DTypedElement(type).end();\r\n    }\r\n}\r\n\r\n@Abstract\r\n@RuntimeAccessible('LTypedElement')\r\nexport class LTypedElement<Context extends LogicContext<DTypedElement> = any> extends LNamedElement { // extends Mixin(DTypedElement0, LNamedElement)\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DTypedElement;\r\n    id!: Pointer<DTypedElement, 1, 1, LTypedElement>;\r\n    // static singleton: LTypedElement;\r\n    // static logic: typeof LTypedElement;\r\n    // static structure: typeof DTypedElement;\r\n\r\n    // inherit redefine\r\n    parent!: LModelElement[];\r\n    father!: LModelElement;\r\n    annotations!: LAnnotation[];\r\n    name!: string;\r\n    namespace!: string;\r\n    instances!: LValue[];\r\n    // personal\r\n    type!: LClassifier;\r\n\r\n    primitiveType?: LClass;\r\n    classType?: LClass;\r\n    enumType?: LEnumerator;\r\n\r\n    ordered!: boolean;\r\n    unique!: boolean;\r\n    lowerBound!: number;\r\n    upperBound!: number;\r\n    many!: boolean;\r\n    required!: boolean;\r\n\r\n\r\n    protected get_classType(context: Context): this[\"classType\"] {\r\n        let type = this.get_type(context);\r\n        return type.isClass ? type as LClass : undefined;\r\n    }\r\n\r\n    protected get_enumType(context: Context): this[\"enumType\"] {\r\n        let type = this.get_type(context);\r\n        return type.isEnum ? type as LEnumerator : undefined;\r\n    }\r\n\r\n    protected get_primitiveType(context: Context): this[\"primitiveType\"] {\r\n        let type = this.get_type(context);\r\n        return type.isPrimitive ? type as LClass : undefined;\r\n    }\r\n\r\n    protected get_type(c: Context): this[\"type\"] {\r\n        let type = LPointerTargetable.from(c.data.type);\r\n        if (type) return type;\r\n        if (c.className === 'DReference') return LPointerTargetable.from(c.data.father);\r\n        else return LPointerTargetable.fromPointer('Pointer_ESTRING');\r\n    }\r\n\r\n    protected set_type(val: Pack1<this[\"type\"]>, c: Context): boolean {\r\n        // let instances: LValue[] = this.get_instances(c);\r\n        let ptr = Pointers.from(val);\r\n        if (c.data.type === ptr) return true;\r\n        TRANSACTION(this.get_name(c)+'.type', ()=>{\r\n            SetFieldAction.new(c.data, 'type', ptr, \"\", true);\r\n        }, this.get_type(c)?.fullname, LPointerTargetable.wrap(val)?.fullname);\r\n        return true;\r\n    }\r\n\r\n    protected get_ordered(context: Context): this[\"ordered\"] {\r\n        return context.data.ordered;\r\n    }\r\n\r\n    protected set_ordered(val: this[\"ordered\"], c: Context): boolean {\r\n        val = !!val;\r\n        if (c.data.ordered === val) return true;\r\n        TRANSACTION(this.get_name(c)+'.ordered', ()=>{\r\n            SetFieldAction.new(c.data, 'ordered', val);\r\n        }, c.data.ordered, val)\r\n        return true;\r\n    }\r\n\r\n    protected get_unique(context: Context): this[\"unique\"] {\r\n        return context.data.unique;\r\n    }\r\n\r\n    protected set_unique(val: this[\"unique\"], c: Context): boolean {\r\n        val = !!val;\r\n        if (c.data.ordered === val) return true;\r\n        TRANSACTION(this.get_name(c)+'.unique', ()=>{\r\n            SetFieldAction.new(c.data, 'unique', val);\r\n        }, c.data.unique, val)\r\n        return true;\r\n    }\r\n\r\n    protected get_lowerBound(context: Context): this[\"lowerBound\"] {\r\n        return context.data.lowerBound;\r\n    }\r\n\r\n    protected set_lowerBound(val: this[\"lowerBound\"], c: Context): boolean {\r\n        val = +val;\r\n        if (isNaN(val)) val = 0;\r\n        else val = Math.max(0, val);\r\n        if (val === c.data.lowerBound) return true;\r\n        TRANSACTION(this.get_name(c)+'.lowerBound', ()=>{\r\n            SetFieldAction.new(c.data, 'lowerBound', val);\r\n            if (c.data.upperBound !=-1 && val > c.data.upperBound) SetFieldAction.new(c.data, 'upperBound', val);\r\n        }, c.data.lowerBound, val)\r\n        return true;\r\n    }\r\n\r\n    protected get_upperBound(context: Context): this[\"upperBound\"] {\r\n        return context.data.upperBound;\r\n    }\r\n\r\n    protected set_upperBound(val: this[\"upperBound\"], c: Context): boolean {\r\n        val = +val;\r\n        if (isNaN(val)) val = -1;\r\n        else val = Math.max(-1, val);\r\n\r\n        TRANSACTION(this.get_name(c)+'.upperBound', ()=>{\r\n            SetFieldAction.new(c.data, 'upperBound', val);\r\n            if (val !== -1 && val < c.data.lowerBound) SetFieldAction.new(c.data, 'lowerBound', val);\r\n        }, c.data.upperBound, val)\r\n        return true;\r\n    }\r\n\r\n    protected get_many(context: Context): this[\"many\"] {\r\n        return context.data.many;\r\n    }\r\n\r\n    protected set_many(val: this[\"many\"], c: Context): boolean {\r\n        val = !!val;\r\n        if (val === c.data.many) return true;\r\n        TRANSACTION(this.get_name(c)+'.many', ()=>{\r\n            SetFieldAction.new(c.data, 'many', val);\r\n        }, c.data.many, val)\r\n        return true;\r\n    }\r\n\r\n    protected get_required(context: Context): this[\"required\"] {\r\n        return context.data.required;\r\n    }\r\n\r\n    protected set_required(val: this[\"required\"], c: Context): boolean {\r\n        val = !!val;\r\n        if (val === c.data.many) return true;\r\n        TRANSACTION(this.get_name(c)+'.required', ()=>{\r\n            SetFieldAction.new(c.data, 'required', val);\r\n        }, c.data.many, val)\r\n        return true;\r\n    }\r\n\r\n    public typeToEcoreString(): string {\r\n        return this.cannotCall(\"typeToEcoreString\");\r\n    }\r\n\r\n    protected get_typeToEcoreString(context: Context): () => string {\r\n        // if (context.data.classType) return EcoreParser.classTypePrefix + context.proxyObject.classType.name;\r\n        // if (context.data.enumType) return EcoreParser.classTypePrefix + context.proxyObject.enumType.name;\r\n        // if (context.data.primitiveType) return context.proxyObject.primitiveType.long;\r\n        return () => context.proxyObject.type.typeEcoreString;\r\n    }\r\n\r\n    public typeToShortString(): string {\r\n        return this.cannotCall(\"typeToShortString\");\r\n    }\r\n\r\n    protected get_typeToShortString(context: Context): () => string {\r\n        // if (context.data.classType) return '' + context.data.classType.name;\r\n        // if (context.data.enumType) return '' + context.data.enumType.name;\r\n        // if (context.data.primitiveType) return '' + context.data.primitiveType.getName();\r\n        return () => {\r\n            return context.proxyObject.type.typeString;\r\n        }\r\n    }\r\n\r\n    canOverride(context: Context, other: LTypedElement): boolean {\r\n        // i primitivi identici sono compatibili\r\n        if (context.data.type === other.type.id) return true;\r\n        let t1 = context.proxyObject.type;\r\n        let t2 = other.type;\r\n        // se entrambi primitivi\r\n        if (context.proxyObject.primitiveType && other.primitiveType) {\r\n            ShortAttribSuperTypes[t1.name as ShortAttribETypes].includes(other.name as ShortAttribETypes);\r\n        }\r\n        if (context.proxyObject.enumType) return t1 === t2; // only if they are same enumerator\r\n        // now assumed to be class type\r\n        if (other.classType === other.classType) return true;\r\n        return (context.proxyObject.classType as LClass).isExtending(other.classType as LClass);\r\n    }\r\n\r\n}\r\n\r\n// @RuntimeAccessible('') export class _WTypedElement extends _WNamedElement { }\r\n// export type WTypedElement = DTypedElement | LTypedElement | _WTypedElement;\r\nRuntimeAccessibleClass.set_extend(DNamedElement, DTypedElement);\r\nRuntimeAccessibleClass.set_extend(LNamedElement, LTypedElement);\r\n@RuntimeAccessible('DClassifier')\r\nexport class DClassifier extends DPointerTargetable { // extends DNamedElement\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LClassifier;\r\n    // static logic: typeof LClassifier;\r\n    // static structure: typeof DClassifier;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DClassifier, 1, 1, LClassifier>;\r\n    parent: Pointer<DPackage, 0, 'N', LPackage> = [];\r\n    father!: Pointer<DPackage, 1, 1, LPackage>;\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    name!: string;\r\n    // personal\r\n    instanceClassName!: string;\r\n    // instanceClass: EJavaClass // ?\r\n    defaultValue!: Pointer<DObject, 1, 1, LObject>[] | string[];\r\n    // isInstance(object: EJavaObject): boolean; ?\r\n    // getClassifierID(): number;\r\n\r\n    public static new(name?: DNamedElement[\"name\"], father?: Pointer, persist: boolean = true): DClassifier {\r\n        Log.exx(\"DClassifier is abstract, cannot instantiate\");\r\n        return null as any;\r\n        // return new Constructors(new DClassifier('dwc'), father, persist, undefined).DPointerTargetable().DModelElement().DNamedElement(name).DClassifier().end();\r\n    }\r\n}\r\n\r\n@Abstract\r\n@RuntimeAccessible('LClassifier')\r\nexport class LClassifier<Context extends LogicContext<DClassifier> = any> extends LNamedElement { // extends DNamedElement\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DClassifier;\r\n    id!: Pointer<DClassifier, 1, 1, LClassifier>;\r\n    // static singleton: LClassifier;\r\n    // static logic: typeof LClassifier;\r\n    // static structure: typeof DClassifier;\r\n\r\n    // inherit redefine\r\n    parent!: LPackage[];\r\n    father!: LPackage;\r\n    annotations!: LAnnotation[];\r\n    name!: string;\r\n    namespace!: string;\r\n    // personal\r\n    instanceClassName!: string;\r\n    // instanceClass: EJavaClass // ?\r\n    defaultValue!: LObject[] | string[];\r\n    isPrimitive!: boolean;\r\n    isClass!: boolean;\r\n    isEnum!: boolean;\r\n    // isInstance(object: EJavaObject): boolean; ?\r\n    // getClassifierID(): number;\r\n\r\n    protected get_instanceClassName(context: Context): this[\"instanceClassName\"] {\r\n        return context.data.instanceClassName;\r\n    }\r\n\r\n    protected set_instanceClassName(val: this[\"instanceClassName\"], c: Context): boolean {\r\n        TRANSACTION(this.get_name(c)+'.instanceClassName', ()=>{\r\n            SetFieldAction.new(c.data, 'instanceClassName', val, \"\", false);\r\n        }, c.data.instanceClassName, val)\r\n        return true;\r\n    }\r\n\r\n    protected set_isPrimitive(val: this[\"isPrimitive\"], context: Context): boolean {\r\n        return this.cannotSet(\"isPrimitive\");\r\n    }\r\n\r\n    protected set_isClass(val: this[\"isClass\"], context: Context): boolean {\r\n        return this.cannotSet(\"isClass\");\r\n    }\r\n\r\n    protected set_isEnum(val: this[\"isEnum\"], context: Context): boolean {\r\n        return this.cannotSet(\"isEnum\");\r\n    }\r\n\r\n    protected get_isPrimitive(context: Context): this[\"isPrimitive\"] {\r\n        return !!((context.data as DClass).isPrimitive as unknown);\r\n    }\r\n\r\n    protected get_isClass(context: Context): this[\"isClass\"] {\r\n        return (context.data as DClass).isPrimitive ? false : context.data.className === DClass.cname;\r\n    }\r\n\r\n    protected get_isEnum(context: Context): this[\"isEnum\"] {\r\n        return context.data.className === DEnumerator.cname;\r\n    }\r\n\r\n    protected set_defaultValue(val: this[\"defaultValue\"] | DClassifier[\"defaultValue\"], c: Context): boolean {\r\n        TRANSACTION(this.get_name(c)+'.defaultValue', ()=>{\r\n            if (typeof val !== \"object\" && !Pointers.isPointer(val)) {\r\n                // primitive default value for enums\r\n                SetFieldAction.new(c.data, 'defaultValue', val, \"\", false);\r\n            } else {\r\n                SetFieldAction.new(c.data, 'defaultValue', Pointers.from(val as Pointer[]) || [], \"\", true);\r\n            }\r\n        })\r\n        return true;\r\n    }\r\n\r\n    typeEcoreString!: string;\r\n    typeString!: string;\r\n\r\n    private get_typeEcoreString(c: Context) {\r\n        return EcoreParser.classTypePrefix + c.data.name;\r\n    }\r\n\r\n    get_typeString(context: Context) {\r\n        return context.data.name;\r\n    }\r\n}\r\n\r\n// @RuntimeAccessible('') export class _WClassifier extends _WNamedElement { }\r\n// export type WClassifier = DClassifier | LClassifier | _WClassifier;\r\nRuntimeAccessibleClass.set_extend(DNamedElement, DClassifier);\r\nRuntimeAccessibleClass.set_extend(LNamedElement, LClassifier);\r\n\r\n@Leaf\r\n@RuntimeAccessible('DPackage')\r\nexport class DPackage extends DPointerTargetable { // extends DNamedElement\r\n    // static _super = DNamedElement;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LPackage;\r\n    // static logic: typeof LPackage;\r\n    // static structure: typeof DPackage;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DPackage, 1, 1, LPackage>;\r\n    parent: Pointer<DPackage | DModel, 0, 'N', LPackage | LModel> = [];\r\n    father!: Pointer<DPackage | DModel, 1, 1, LPackage | LModel>;\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    name!: string;\r\n    // personal\r\n    classifiers: Pointer<DClassifier, 0, 'N', LClassifier> = [];\r\n    subpackages: Pointer<DPackage, 0, 'N', LPackage> = [];\r\n    uri!: string;\r\n    prefix!: string;\r\n\r\n    public static new(name?: DNamedElement[\"name\"], uri?: DPackage[\"uri\"], prefix?: DPackage[\"prefix\"], father?: Pointer, persist: boolean = true, fatherType?: Constructor): DPackage {\r\n        let dmodel: DModel | undefined;\r\n        if (!name) {\r\n            dmodel = father && DPointerTargetable.from(father);\r\n            name = this.defaultname(\"pkg_\", dmodel);\r\n        }\r\n        /*if (!uri) {\r\n            dmodel = dmodel || father && DPointerTargetable.from(father);\r\n            uri = ('org.jodel-react.') + (dmodel?.name || \"username\"); // (DPointerTargetable.from(DUser.current)).name) todo: when DUser is done\r\n        }*/\r\n        return new Constructors(new DPackage('dwc'), father, persist, fatherType).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DPackage(uri, prefix).end();\r\n    }/*\r\n    static new15(setter: (d: DPackage) => void, father: DPackage[\"father\"], fatherType: Constructor, name?: string): DPackage {\r\n        if (!name) name = this.defaultname(\"pkg_\", father);\r\n        return new Constructors(new DPackage('dwc'), father, true, fatherType).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DPackage().end(setter);\r\n    }\r\n    static new2(setter: Partial<ObjectWithoutPointers<DPackage>>, fatherType: Constructor, persist: boolean = true): DPackage {\r\n        if (!name) name = this.defaultname(\"pkg_\", father);\r\n        return new Constructors(new DPackage('dwc'), father, true, fatherType).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DPackage().end((d)=> { Object.assign(d, setter); });\r\n    }*/\r\n    static new3(a: Partial<PackagePointers>, callback: undefined | ((d: DPackage, c: Constructors) => void), fatherType: Constructor, persist: boolean = true): DPackage {\r\n        if (!a.name) a.name = this.defaultname(\"pkg_\", a.father);\r\n        return new Constructors(new DPackage('dwc'), a.father, persist, fatherType, a.id).DPointerTargetable().DModelElement()\r\n            .DNamedElement(a.name).DPackage().end(callback);\r\n    }\r\n}\r\n\r\n@Leaf\r\n@RuntimeAccessible('LPackage')\r\nexport class LPackage<Context extends LogicContext<DPackage> = any, C extends Context = Context, D extends DPackage = DPackage> extends LNamedElement { // extends DNamedElement\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DPackage;\r\n    id!: Pointer<DPackage, 1, 1, LPackage>;\r\n    // static singleton: LPackage;\r\n    // static logic: typeof LPackage;\r\n    // static structure: typeof DPackage;\r\n    // inherit redefine\r\n    parent!: (LPackage| LModel)[];  // ype 'LPackage' is missing the following properties from type 'LModelElement': get_set_parent, set_parent\r\n    father!: LPackage | LModel;\r\n    annotations!: LAnnotation[];\r\n    name!: string;\r\n    namespace!: string;\r\n    // personal\r\n    classifiers!: LClassifier[];\r\n    subpackages!: LPackage[];\r\n    uri!: string;\r\n    prefix: string = '';\r\n    // derived\r\n    classes!: LClass[] & Dictionary<DocString<\"$name\">, LClass>;\r\n    enums!: LEnumerator[] & Dictionary<DocString<\"$name\">, LEnumerator>;\r\n    enumerators!: LEnumerator[];\r\n\r\n    // utilities to go down in the tree (plural names)\r\n    allSubPackages!: LPackage[];\r\n    allSubEnums!: LEnumerator[];\r\n    allSubClasses!: LClass[];\r\n    operations!: LOperation[];\r\n    parameters!: LParameter[];\r\n    exceptions!: LClassifier[];\r\n    attributes!: LAttribute[];\r\n    references!: LReference[];\r\n    literals!: LEnumLiteral[];\r\n\r\n    protected get_name(c: Context): this['name'] {\r\n        let l = c.proxyObject;\r\n        let ret: string = (l as GObject)['$name']?.value || c.data.name;\r\n        if (ret === 'default') {\r\n            let model = this.get_model(c);\r\n            if (model.__raw.packages[0] === c.data.id) return model.name;\r\n        }\r\n        return ret;\r\n    }\r\n    protected generateEcoreJson_impltemplate(context: Context, loopDetectionObj: Dictionary<Pointer, DModelElement> = {}): Json {\r\n        loopDetectionObj[context.data.id] = context.data;\r\n        const json: GObject = {};\r\n        return json; }\r\n\r\n    protected generateEcoreJson_impl(context: Context, loopDetectionObj: Dictionary<Pointer, DModelElement> = {}): Json {\r\n        loopDetectionObj[context.data.id] = context.data;\r\n        const model: GObject = {};\r\n        const d = context.data;\r\n        let classarr = context.proxyObject.classes.map( c => c.generateEcoreJson(loopDetectionObj));\r\n        let enumarr = context.proxyObject.enums.map(e => e.generateEcoreJson(loopDetectionObj));\r\n        const classifiers: Json[] = Array.prototype.concat.call(classarr, enumarr);\r\n        model[ECorePackage.xmiversion] = '2.0';\r\n        model[ECorePackage.xmlnsxmi] = 'http://www.omg.org/XMI';\r\n        model[ECorePackage.xmlnsxsi] = 'http://www.w3.org/2001/XMLSchema-instance';\r\n        model[ECorePackage.xmlnsecore] = 'http://www.eclipse.org/emf/2002/Ecore';\r\n        model[ECorePackage.namee] = d.name;\r\n        model[ECorePackage.nsURI] = d.uri;\r\n        model[ECorePackage.nsPrefix] = d.prefix;//getModelRoot().namespace();\r\n        model[ECorePackage.eClassifiers] = classifiers;\r\n        return model; }\r\n\r\n    public duplicate(deep: boolean = true): this {\r\n        return this.cannotCall( ((this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name) + \"duplicate()\"); }\r\n    protected get_duplicate(c: Context): ((deep?: boolean) => LPackage) {\r\n        return (deep: boolean = false) => {\r\n            let ret: LPackage = null as any;\r\n            TRANSACTION('duplicate ' + this.get_name(c), ()=>{\r\n                let le: LPackage = c.proxyObject.father.addPackage(c.data.name, c.data.uri, c.data.prefix);\r\n                let de: D = le.__raw as D;\r\n                let we: WPackage = le as any;\r\n                we.subpackages = deep ? c.proxyObject.subpackages.map( lchild => lchild.duplicate(deep).id) : c.data.subpackages;\r\n                we.classifiers = deep ? c.proxyObject.classifiers.map( lchild => lchild.duplicate(deep).id) : c.data.classifiers;\r\n                we.annotations = deep ? c.proxyObject.annotations.map( lchild => lchild.duplicate(deep).id) : c.data.annotations;\r\n                ret = le;\r\n            })\r\n            return ret;\r\n        }\r\n    }\r\n\r\n    public addPackage(name?: D[\"name\"], uri?: D[\"uri\"], prefix?: D[\"prefix\"]): LPackage { return this.cannotCall(\"addPackage\"); }\r\n\r\n    protected get_addPackage(context: Context): this[\"addPackage\"] {\r\n        console.log(\"Package.get_addPackage()\", {context, thiss:this});\r\n        return (name?: D[\"name\"], uri?: D[\"uri\"], prefix?: D[\"prefix\"]) => {\r\n            return LPointerTargetable.fromD(DPackage.new(name, uri, prefix, context.data.id, true, DPackage));\r\n        }\r\n    }\r\n\r\n    public addClass(name?: DClass[\"name\"], isInterface?: DClass[\"interface\"], isAbstract?: DClass[\"abstract\"], isPrimitive?: DClass[\"isPrimitive\"],\r\n                    isPartial?: DClass[\"partial\"], partialDefaultName?: DClass[\"partialdefaultname\"]): LClass {\r\n        return this.cannotCall(\"addClass\"); }\r\n    protected get_addClass(context: Context): this[\"addClass\"] {\r\n        return (name?: DClass[\"name\"], isInterface?: DClass[\"interface\"], isAbstract?: DClass[\"abstract\"], isPrimitive?: DClass[\"isPrimitive\"],\r\n                isPartial?: DClass[\"partial\"], partialDefaultName?: DClass[\"partialdefaultname\"]\r\n        ) => LPointerTargetable.fromD(DClass.new(name, isInterface, isAbstract, isPrimitive, isPartial, partialDefaultName, context.data.id, true));\r\n    }\r\n\r\n    public addEnum(...p:Parameters<this[\"addEnumerator\"]>): LEnumerator { return this.addEnumerator(...p); }\r\n    protected get_addEnum(context: Context): this[\"addEnumerator\"] {\r\n        return this.get_addEnumerator(context); }\r\n    public addEnumerator(name?: DEnumerator[\"name\"]): LEnumerator { return this.cannotCall(\"addEnumerator\"); }\r\n    protected get_addEnumerator(context: Context): this[\"addEnumerator\"] {\r\n        return (name?: DEnumerator[\"name\"]) => LPointerTargetable.fromD(DEnumerator.new(name, context.data.id, true));\r\n    }\r\n\r\n    protected get_classes(context: Context, state?: DState, setNameKeys: boolean = true): LClass[] & Dictionary<DocString<\"$name\">, LClass> {\r\n        if (!context.data.classifiers.length) return [] as any;\r\n        if (!state) state = store.getState();\r\n        let classifiers = DPointerTargetable.fromPointer(context.data.classifiers as Pointer<DClassifier, 1, 1, LClassifier>[], state);\r\n        let dclasses = classifiers.filter(dc => dc?.className === DClass.cname) as DClass[];\r\n        let lclasses: LClass[] & Dictionary<DocString<\"$name\">, LClass> = LPointerTargetable.fromD(dclasses) as any;\r\n        if (setNameKeys) for (let i = 0; i < dclasses.length; i++) lclasses[\"$\"+dclasses[i].name] = lclasses[i];\r\n        return lclasses;\r\n    }\r\n    protected get_enums(context: Context): (LEnumerator[] & Dictionary<DocString<\"$name\">, LEnumerator>) { return this.get_enumerators(context); }\r\n    protected get_enumerators(context: Context, state?: DState, setNameKeys: boolean = true): (LEnumerator[] & Dictionary<DocString<\"$name\">, LEnumerator>) {\r\n        if (!context.data.classifiers.length) return [] as any;\r\n        if (!state) state = store.getState();\r\n        let classifiers = DPointerTargetable.fromPointer(context.data.classifiers as Pointer<DClassifier, 1, 1, LClassifier>[], state);\r\n        let denums = classifiers.filter(dc => dc?.className === DEnumerator.cname) as DEnumerator[];\r\n        let lenums: LEnumerator[] & Dictionary<DocString<\"$name\">, LEnumerator> = LPointerTargetable.fromD(denums) as any;\r\n        if (setNameKeys) for (let i = 0; i < denums.length; i++) (lenums as GObject)[\"$\"+denums[i].name] = lenums[i];\r\n        return lenums;\r\n    }\r\n    //private get_allClasses(context: Context): LClass[] & Dictionary<DocString<\"$name\">, LClass> { return this.get_allSubClasses(c); }\r\n    private get_allSubClasses(context: Context): LClass[] & Dictionary<DocString<\"$name\">, LClass> {\r\n        // if (!context.data.isMetamodel) return (context.data.instanceof?.allSubClasses(context) || [] as any);\r\n        const s: DState = store.getState();\r\n        let arr = this.get_allSubPackages(context, s);\r\n        let ret: (LClass[] & Dictionary<DocString<\"$name\">, LClass>) = [] as any;\r\n        // this.get_allSubPackages(context, s).flatMap(p => (p.classes || [])); this was losing the naming $keys!\r\n        for (let a of arr) {\r\n            let classarr: LClass[] & Dictionary<DocString<\"$name\">, LClass> = (a.classes || []) as any;\r\n            U.mergeNamedArray(ret, classarr);\r\n        }\r\n        return ret; }\r\n\r\n    private get_allSubEnums(context: Context): (LEnumerator[] & Dictionary<DocString<\"$name\">, LEnumerator>) { return this.get_allSubEnumerators(context); }\r\n    private get_allSubEnumerators(context: Context): (LEnumerator[] & Dictionary<DocString<\"$name\">, LEnumerator>) {\r\n        const s: DState = store.getState();\r\n        let arr = this.get_allSubPackages(context, s);\r\n        let ret: (LEnumerator[] & Dictionary<DocString<\"$name\">, LEnumerator>) = [] as any;\r\n        // this.get_allSubPackages(context, s).flatMap(p => (p.enums || [])); this was losing the naming $keys!\r\n        for (let a of arr) {\r\n            let enumarr: (LEnumerator[] & Dictionary<DocString<\"$name\">, LEnumerator>) = (a.enumerators || []) as any;\r\n            U.mergeNamedArray(ret, enumarr);\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    protected get_allSubPackages(c: Context, state?: DState): this[\"allSubPackages\"] {\r\n        // return context.data.packages.map(p => LPointerTargetable.from(p));\r\n        state = state || store.getState();\r\n        let tocheck: Pointer<DPackage>[] = c.data.subpackages || [];\r\n        let checked: Dictionary<Pointer, DPackage> = {};\r\n        checked[c.data.id] = c.data;\r\n        while (tocheck.length) {\r\n            let newtocheck: Pointer<DPackage>[] = [];\r\n            for (let ptr of tocheck) {\r\n                if (checked[ptr]) throw new Error(\"loop in packages containing themselves\");\r\n                let dpackage: DPackage = DPointerTargetable.from(ptr, state);\r\n                checked[ptr] = dpackage;\r\n                U.arrayMergeInPlace(newtocheck, dpackage?.subpackages);\r\n            }\r\n            tocheck = newtocheck;\r\n        }\r\n        let darr: DPackage[] = Object.values(checked);\r\n        let larr: LPackage[] & Dictionary<DocString<\"$name\">, LPackage> = LPointerTargetable.fromArr(darr, state);\r\n        U.toNamedArray(larr, darr);\r\n        return larr;\r\n    }\r\n\r\n    protected get_children_idlist(context: Context): Pointer<DAnnotation | DPackage | DClassifier, 1, 'N'> {\r\n        return [...super.get_children_idlist(context) as Pointer<DAnnotation | DPackage | DClassifier, 1, 'N'>, ...context.data.subpackages, ...context.data.classifiers]; }\r\n\r\n    protected get_classifiers(context: Context): this[\"classifiers\"] {\r\n        return context.data.classifiers.map((pointer) => {\r\n            return LPointerTargetable.from(pointer)\r\n        });\r\n    }\r\n    protected set_classifiers(val: PackArr<this[\"classifiers\"]>, c: Context): boolean {\r\n        const list: Pointer<DClassifier>[] = val.map((lItem) => { return Pointers.from(lItem) });\r\n        const oldList = c.data.classifiers;\r\n        const diff = U.arrayDifference(oldList, list);\r\n        TRANSACTION(''+this.get_name(c)+'.classifiers', ()=>{\r\n            SetFieldAction.new(c.data, 'classifiers', list, \"\", true);\r\n            for (let id of diff.added) {\r\n                SetFieldAction.new(id, 'father', c.data.id, '', true);\r\n                SetFieldAction.new(id, 'parent', c.data.id, '+=', true);\r\n            }\r\n            for (let id of diff.removed as Pointer<DModelElement>[]) {\r\n                SetFieldAction.new(id, 'father', undefined, '', true);\r\n                const parent = DPointerTargetable.from(id).parent;\r\n                U.arrayRemoveAll(parent, c.data.id);\r\n                SetFieldAction.new(id, 'parent', parent, '', true);\r\n            }\r\n        })\r\n        return true;\r\n    }\r\n\r\n    protected get_subpackages(context: Context): this[\"subpackages\"] {\r\n        return context.data.subpackages.map((pointer) => {\r\n            return LPointerTargetable.from(pointer)\r\n        });\r\n    }\r\n    protected set_subpackages(val: PackArr<this[\"subpackages\"]>, c: Context): boolean {\r\n        const list = val.map((lItem) => { return Pointers.from(lItem) });\r\n        const oldList = c.data.subpackages;\r\n        const diff = U.arrayDifference(oldList, list);\r\n        TRANSACTION(this.get_name(c)+'.packages', ()=>{\r\n            SetFieldAction.new(c.data, 'subpackages', list, \"\", true);\r\n            for (let id of diff.added) {\r\n                SetFieldAction.new(id, 'father', c.data.id, '', true);\r\n                SetFieldAction.new(id, 'parent', c.data.id, '+=', true);\r\n            }\r\n            for (let id of diff.removed as Pointer<DModelElement>[]) {\r\n                SetFieldAction.new(id, 'father', undefined, '', true);\r\n                const parent = DPointerTargetable.from(id).parent;\r\n                U.arrayRemoveAll(parent, c.data.id);\r\n                SetFieldAction.new(id, 'parent', parent, '', true);\r\n            }\r\n        })\r\n        return true;\r\n    }\r\n\r\n    protected get_uri(context: Context): this[\"uri\"] {\r\n        if (context.data.uri) return context.data.uri + \".\" + context.data.name;\r\n        return ('org.jodel-react.') + (context.proxyObject.model?.name || \"username\") + \".\" + context.data.name;\r\n    }\r\n    protected set_uri(val: this[\"uri\"], c: Context): boolean {\r\n        val = val || '';\r\n        let pos = val.lastIndexOf(c.data.name);\r\n        if (pos) val = val.substring(0, pos - 1); // removes final name and dot, to keep the name part dinamically added in the getter.\r\n        if (val === c.data.uri) return true;\r\n        TRANSACTION(this.get_name(c)+'.uri', ()=>{\r\n            SetFieldAction.new(c.data, 'uri', val, \"\", false);\r\n        }, c.data.uri, val);\r\n        return true;\r\n    }\r\n    protected get_prefix(context: Context): this[\"uri\"] { return context.data.prefix; }\r\n    protected set_prefix(val: this[\"prefix\"], c: Context): boolean {\r\n        if (c.data.prefix === val) return true;\r\n        TRANSACTION(this.get_name(c)+'.prefix', ()=>{\r\n            SetFieldAction.new(c.data, 'prefix', val, \"\", false);\r\n        }, c.data.prefix, val)\r\n        return true;\r\n    }\r\n\r\n}\r\n// @RuntimeAccessible('') export class _WPackage extends _WNamedElement { }\r\n// export type WPackage = DPackage | LPackage | _WPackage;\r\nRuntimeAccessibleClass.set_extend(DNamedElement, DPackage);\r\nRuntimeAccessibleClass.set_extend(LNamedElement, LPackage);\r\n\r\n@Leaf\r\n@RuntimeAccessible('DOperation')\r\nexport class DOperation extends DPointerTargetable { // extends DTypedElement\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LOperation;\r\n    // static logic: typeof LOperation;\r\n    // static structure: typeof DOperation;\r\n\r\n    // inherit redefine\r\n    instances!: never[];\r\n    id!: Pointer<DOperation, 1, 1, LObject>;\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    parent: Pointer<DClass, 0, 'N', LClass> = [];\r\n    father!: Pointer<DClass, 1, 1, LClass>;\r\n    name!: string;\r\n    type!: Pointer<DClassifier, 1, 1, LClassifier>;\r\n    ordered: boolean = true;\r\n    unique: boolean = true;\r\n    lowerBound: number = 0;\r\n    upperBound: number = 1;\r\n    many!: boolean;\r\n    required!: boolean;\r\n    // personal\r\n    exceptions: Pointer<DClassifier, 0, 'N', LClassifier> = [];\r\n    parameters: Pointer<DParameter, 0, 'N', LParameter> = [];\r\n    visibility: AccessModifier = AccessModifier.private;\r\n    implementation!: string;\r\n    allowCrossReference!: boolean;\r\n\r\n    public static new(name?: DNamedElement[\"name\"], type?: DOperation[\"type\"], exceptions: DOperation[\"exceptions\"] = [], father?: DOperation[\"father\"], persist: boolean = true): DOperation {\r\n        if (!name) name = this.defaultname(\"fx_\", father);\r\n        if (!type) type = father;\r\n        return new Constructors(new DOperation('dwc'), father, persist, undefined).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DTypedElement(type).DOperation(exceptions).end();\r\n    }\r\n\r\n    static new2(setter: Partial<ObjectWithoutPointers<DOperation>>, father: DOperation[\"father\"], type?: DOperation[\"type\"], name?: string): DOperation {\r\n        if (!name) name = this.defaultname(\"fx_\", father);\r\n        if (!type) type = father;\r\n        return new Constructors(new DOperation('dwc'), father, true).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DTypedElement(type).DOperation().end((d)=> { Object.assign(d, setter); });\r\n    }\r\n\r\n    static new3(a: Partial<OperationPointers>, callback: undefined | ((d: DOperation, c: Constructors) => void), persist: boolean = true): DOperation {\r\n        if (!a.name) a.name = this.defaultname(\"fx_\", a.father);\r\n        if (!a.type) a.type = a.father;\r\n        return new Constructors(new DOperation('dwc'), a.father, persist, undefined, a.id).DPointerTargetable().DModelElement()\r\n            .DNamedElement(a.name).DTypedElement(a.type).DOperation().end(callback);\r\n    }\r\n\r\n\r\n}\r\n\r\n@Node\r\n@RuntimeAccessible('LOperation')\r\nexport class LOperation<Context extends LogicContext<DOperation> = any, C extends Context = Context, D extends DOperation = DOperation>  extends LTypedElement { // extends DTypedElement\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DOperation;\r\n    id!: Pointer<DOperation, 1, 1, LOperation>;\r\n    // static singleton: LOperation;\r\n    // static logic: typeof LOperation;\r\n    // static structure: typeof DOperation;\r\n\r\n    // inherit redefine\r\n    instances!: never[];\r\n    annotations!: LAnnotation[];\r\n    parent!: LClass[];\r\n    father!: LClass;\r\n    name!: string;\r\n    namespace!: string;\r\n    type!: LClassifier;\r\n    ordered: boolean = true;\r\n    unique: boolean = true;\r\n    lowerBound: number = 0;\r\n    upperBound: number = 1;\r\n    many!: boolean;\r\n    required!: boolean;\r\n    // personal\r\n    implementation!: string;\r\n    signatureImplementation!: string; // (param1 /*type*/, param2 = value, ...) => /*return type*/\r\n    exceptions!: LClassifier[];\r\n    parameters!: LParameter[];\r\n    visibility!: AccessModifier;\r\n    allowCrossReference!: boolean;\r\n\r\n\r\n    protected generateEcoreJson_impl(context: Context, loopDetectionObj: Dictionary<Pointer, DModelElement> = {}): Json {\r\n        loopDetectionObj[context.data.id] = context.data;\r\n        const json: Json = {};\r\n        json[ECoreOperation.eParameters] = context.proxyObject.parameters.map( par => par.generateEcoreJson(loopDetectionObj));\r\n        EcoreParser.write(json, ECoreOperation.namee, context.data.name);\r\n        EcoreParser.write(json, ECoreOperation.eType, context.proxyObject.type.typeEcoreString);\r\n        EcoreParser.write(json, ECoreOperation.lowerBound, '' + context.data.lowerBound);\r\n        EcoreParser.write(json, ECoreOperation.upperBound, '' + context.data.upperBound);\r\n        EcoreParser.write(json, ECoreOperation.eexceptions, context.proxyObject.exceptions.map( (l: LClassifier) => l.typeEcoreString).join(' ')); // todo: not really sure it's this format\r\n        EcoreParser.write(json, ECoreOperation.ordered, '' + context.data.ordered);\r\n        EcoreParser.write(json, ECoreOperation.unique, '' + context.data.unique);\r\n        return json; }\r\n\r\n    public duplicate(deep: boolean = true): this {\r\n        return this.cannotCall( ((this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name) + \"duplicate()\"); }\r\n    protected get_duplicate(context: Context): ((deep?: boolean) => LOperation) {\r\n        return (deep: boolean = false) => {\r\n            let ret: LOperation = null as any;\r\n            TRANSACTION('duplicate ' + this.get_name(context), ()=>{\r\n                let le: LOperation = context.proxyObject.father.addOperation(context.data.name, context.data.type);\r\n                let de: D = le.__raw as D;\r\n                de.many = context.data.many;\r\n                de.lowerBound = context.data.lowerBound;\r\n                de.upperBound = context.data.upperBound;\r\n                de.ordered = context.data.ordered;\r\n                de.required = context.data.required;\r\n                de.unique = context.data.unique;\r\n                de.visibility = context.data.visibility;\r\n                de.exceptions = context.data.exceptions;\r\n                let we: WOperation = le as any;\r\n                we.annotations = deep ? context.proxyObject.annotations.map(lchild => lchild.duplicate(deep).id) : context.data.annotations;\r\n                we.parameters = deep ? context.proxyObject.parameters.map(lchild => lchild.duplicate(deep).id) : context.data.parameters;\r\n                we.exceptions = context.data.exceptions;\r\n                ret = le;\r\n            })\r\n            return ret; }\r\n    }\r\n\r\n    public addParameter(name?: DParameter[\"name\"], type?: DParameter[\"type\"]): LParameter { return this.cannotCall(\"addParameter\"); }\r\n    protected get_addParameter(context: Context): this[\"addParameter\"] {\r\n        return (name?: DParameter[\"name\"], type?: DParameter[\"type\"]) => LPointerTargetable.fromD(DParameter.new(name, type, context.data.id, true)); }\r\n\r\n    public execute(thiss: LObject, ...params: any): any { return this.cannotCall(\"execute\"); }\r\n    protected get_execute(context: Context): ((thiss: LObject, ...params: any[])=>any) {\r\n        return (thiss: LObject, ...params: any) => {\r\n            let func: Function = eval(this.get_signatureImplementation(context, true) + \" {\\n\"+ context.data.implementation + \"\\n}\");\r\n            func.apply(thiss, params);\r\n        };\r\n    }\r\n    public set_implementation(val: this[\"implementation\"], c: Context): boolean {\r\n        TRANSACTION(this.get_fullname(c)+'.implementation', ()=>{\r\n            SetFieldAction.new(c.data.id, \"implementation\", val, undefined, false);\r\n        })\r\n        return true;\r\n    }\r\n    public get_implementation(context: Context): this[\"implementation\"] { return context.data.implementation; }\r\n    public set_signatureImplementation(val: this[\"signatureImplementation\"], context: Context): boolean { return this.cannotSet(\"signatureImplementation\"); }\r\n    public get_signatureImplementation(context: Context, typedComments: boolean = true): this[\"signatureImplementation\"] {\r\n        let operation = context.proxyObject;\r\n        let typedcommentpre = typedComments ? \"/* :\" : ': ' ;\r\n        let typedcommentpost = typedComments ? \" */\" : '';\r\n        return \"(\" +\r\n            operation.parameters.map(\r\n                (p) => p.name + (p.defaultValue !== undefined ? \"=\" + p.defaultValue : typedcommentpre + p.typeToShortString() + typedcommentpost)\r\n            ).join(\", \")\r\n            + \") => \" +typedcommentpre.replace(\":\", \"\") + operation.type + typedcommentpost;\r\n    }\r\n    public get_signature(context: Context): this[\"signatureImplementation\"] { return this.get_signatureImplementation(context, false); }\r\n\r\n    protected get_children_idlist(context: Context): Pointer<DAnnotation | DClassifier | DParameter, 1, 'N'> {\r\n        return [...super.get_children_idlist(context) as Pointer<DAnnotation | DParameter | DClassifier, 1, 'N'>, ...context.data.exceptions, ...context.data.parameters]; }\r\n\r\n    protected get_exceptions(context: Context): this[\"exceptions\"] {\r\n        return context.data.exceptions.map((pointer) => {\r\n            return LPointerTargetable.from(pointer)\r\n        });\r\n    }\r\n    protected set_exceptions(val: PackArr<this[\"exceptions\"]>, c: Context): boolean {\r\n        const list = val.map((lItem) => { return Pointers.from(lItem) });\r\n        TRANSACTION(this.get_name(c)+'.exceptions', ()=>{\r\n            SetFieldAction.new(c.data, 'exceptions', list, \"\", true);\r\n        })\r\n        return true;\r\n    }\r\n\r\n    protected get_parameters(context: Context): this[\"parameters\"] {\r\n        return context.data.parameters.map((pointer) => {\r\n            return LPointerTargetable.from(pointer)\r\n        });\r\n    }\r\n    protected set_parameters(val: PackArr<this[\"parameters\"]>, c: Context): boolean {\r\n        const list = val.map((lItem) => { return Pointers.from(lItem) });\r\n        const oldList = c.data.parameters;\r\n        const diff = U.arrayDifference(oldList, list);\r\n        TRANSACTION(this.get_name(c)+'.parameters', ()=>{\r\n            SetFieldAction.new(c.data, 'parameters', list, \"\", true);\r\n            for (let id of diff.added) {\r\n                SetFieldAction.new(id, 'father', c.data.id, '', true);\r\n                SetFieldAction.new(id, 'parent', c.data.id, '+=', true);\r\n            }\r\n            for (let id of diff.removed as Pointer<DModelElement>[]) {\r\n                SetFieldAction.new(id, 'father', undefined, '', true);\r\n                const parent = DPointerTargetable.from(id).parent;\r\n                U.arrayRemoveAll(parent, c.data.id);\r\n                SetFieldAction.new(id, 'parent', parent, '', true);\r\n            }\r\n        })\r\n        return true;\r\n    }\r\n\r\n    // protected get_type(context: Context): this[\"type\"] { return context.proxyObject.parameters[0].type; }\r\n    // protected set_type(val: Pack1<this[\"type\"]>, context: Context): this[\"type\"] { return super.set_type(val, context); }\r\n\r\n    _mark(b: boolean, superchildren: LOperation, override: string) {\r\n\r\n    }\r\n\r\n    _canOverride(superchildren: LOperation) {\r\n        return undefined;\r\n    }\r\n\r\n    _canPolymorph(superchildren: LOperation) {\r\n        return undefined;\r\n    }\r\n}\r\nRuntimeAccessibleClass.set_extend(DTypedElement, DOperation);\r\nRuntimeAccessibleClass.set_extend(LTypedElement, LOperation);\r\n\r\n@Leaf\r\n@RuntimeAccessible('DParameter')\r\nexport class DParameter extends DPointerTargetable { // extends DTypedElement\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LParameter;\r\n    // static logic: typeof LParameter;\r\n    // static structure: typeof DParameter;\r\n\r\n    // inherit redefine\r\n    instances!: never[];\r\n    id!: Pointer<DParameter, 1, 1, LParameter>;\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    parent: Pointer<DOperation, 0, 'N', LOperation> = [];\r\n    father!: Pointer<DOperation, 1, 1, LOperation>;\r\n    name!: string;\r\n    type!: Pointer<DClassifier, 1, 1, LClassifier>;\r\n    ordered: boolean = true;\r\n    unique: boolean = true;\r\n    lowerBound: number = 0;\r\n    upperBound: number = 1;\r\n    many!: boolean;\r\n    required!: boolean;\r\n    defaultValue!: any;\r\n    // personal\r\n    allowCrossReference!: boolean;\r\n\r\n    public static new(name?: DNamedElement[\"name\"], type?: DTypedElement[\"type\"], father?: Pointer, persist: boolean = true): DParameter {\r\n        if (!type) type = LPointerTargetable.from(Selectors.getFirstPrimitiveTypes()).id; // default type as string\r\n        if (!name) name = this.defaultname(\"arg\", father);\r\n        return new Constructors(new DParameter('dwc'), father, persist, undefined).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DTypedElement(type).DParameter().end();\r\n    }\r\n\r\n    static new2(setter: Partial<ObjectWithoutPointers<DParameter>>, father: DParameter[\"father\"], type?: DParameter[\"type\"], name?: DParameter[\"name\"]): DParameter {\r\n        if (!name) name = this.defaultname((name || \"arg\"), father);\r\n        return new Constructors(new DParameter('dwc'), father, true).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DTypedElement(type).end((d) => { Object.assign(d, setter); });\r\n    }\r\n\r\n    static new3(a: Partial<ParameterPointers>, callback: undefined | ((d: DParameter, c: Constructors) => void), persist: boolean = true): DParameter {\r\n        if (!a.name) a.name = this.defaultname(\"arg\", a.father);\r\n        return new Constructors(new DParameter('dwc'), a.father, persist, undefined, a.id).DPointerTargetable().DModelElement()\r\n            .DNamedElement(a.name).DTypedElement(a.type).DOperation().end(callback);\r\n    }\r\n}\r\n\r\n@Leaf\r\n@RuntimeAccessible('LParameter')\r\nexport class LParameter<Context extends LogicContext<DParameter> = any, C extends Context = Context, D extends DParameter = DParameter>  extends LTypedElement { // extends DTypedElement\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DParameter;\r\n    id!: Pointer<DParameter, 1, 1, LParameter>;\r\n    // static singleton: LParameter;\r\n    // static logic: typeof LParameter;\r\n    // static structure: typeof DParameter;\r\n\r\n    // inherit redefine\r\n    instances!: never[];\r\n    annotations!: LAnnotation[];\r\n    parent!: LOperation[];\r\n    father!: LOperation;\r\n    name!: string;\r\n    namespace!: string;\r\n    type!: LClassifier;\r\n    ordered: boolean = true;\r\n    unique: boolean = true;\r\n    lowerBound: number = 0;\r\n    upperBound: number = 1;\r\n    many!: boolean;\r\n    required!: boolean;\r\n    // personal\r\n    defaultValue!: any;\r\n    allowCrossReference!: boolean;\r\n\r\n    protected generateEcoreJson_impl(context: Context, loopDetectionObj: Dictionary<Pointer, DModelElement> = {}): Json {\r\n        loopDetectionObj[context.data.id] = context.data;\r\n        const json: Json = {};\r\n        const l = context.proxyObject;\r\n        const d = context.data;\r\n        EcoreParser.write(json, ECoreOperation.lowerBound, '' + d.lowerBound);\r\n        EcoreParser.write(json, ECoreOperation.upperBound, '' + d.upperBound);\r\n        EcoreParser.write(json, ECoreOperation.ordered, '' + d.ordered);\r\n        EcoreParser.write(json, ECoreOperation.unique, '' + d.unique);\r\n        EcoreParser.write(json, ECoreOperation.eType, '' + l.type.typeEcoreString);\r\n        return json; }\r\n\r\n    public duplicate(deep: boolean = true): this {\r\n        return this.cannotCall( ((this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name) + \"duplicate()\"); }\r\n    protected get_duplicate(context: Context): ((deep?: boolean) => LParameter) {\r\n        return (deep: boolean = false) => {\r\n            let ret: LParameter = null as any;\r\n            TRANSACTION('duplicate ' + this.get_name(context), ()=>{\r\n                let le: LParameter = context.proxyObject.father.addParameter(context.data.name, context.data.type);\r\n                let de: D = le.__raw as D;\r\n                de.many = context.data.many;\r\n                de.lowerBound = context.data.lowerBound;\r\n                de.upperBound = context.data.upperBound;\r\n                de.ordered = context.data.ordered;\r\n                de.required = context.data.required;\r\n                de.unique = context.data.unique;\r\n                let we: WParameter = le as any;\r\n                we.annotations = deep ? context.proxyObject.annotations.map(lchild => lchild.duplicate(deep).id) : context.data.annotations;\r\n                ret = le;\r\n            })\r\n            return ret; }\r\n    }\r\n}\r\nRuntimeAccessibleClass.set_extend(DTypedElement, DParameter);\r\nRuntimeAccessibleClass.set_extend(LTypedElement, LParameter);\r\nexport class ClassReferences{\r\n    id?: Pack1<LClass>\r\n    parent?: this[\"father\"][];\r\n    father?: Pack1<LPackage>;\r\n    instances?: Pointer<DObject, 0, 'N', LObject> = [];\r\n    operations?: Pointer<DOperation, 0, 'N', LOperation> = [];\r\n    features?: Pointer<DStructuralFeature, 0, 'N', LStructuralFeature> = [];\r\n    references?: Pointer<DReference, 0, 'N', LReference> = [];\r\n    attributes?: Pointer<DAttribute, 0, 'N', LAttribute> = [];\r\n    referencedBy?: Pointer<DReference, 0, 'N', LReference> = [];\r\n    extends?: Pointer<DClass, 0, 'N', LClass> = [];\r\n    extendedBy?: Pointer<DClass, 0, 'N', LClass> = [];\r\n    implements?: Pointer<DClass, 0, 'N', LClass> = [];\r\n    implementedBy?: Pointer<DClass, 0, 'N', LClass> = [];\r\n}\r\n\r\n@RuntimeAccessible('DClass')\r\nexport class DClass extends DPointerTargetable { // extends DClassifier\r\n    // static _super = DClassifier;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LClass;\r\n    // static logic: typeof LClass;\r\n    // static structure: typeof DClass;\r\n\r\n    // inherit redefine\r\n    // instanceClass: EJavaClass // ?\r\n    // isInstance(object: EJavaObject): boolean; ?\r\n    // getClassifierID(): number;\r\n    id!: Pointer<DClass, 1, 1, LClass>;\r\n    instanceClassName!: string;\r\n    parent: Pointer<DPackage, 0, 'N', LPackage> = [];\r\n    father!: Pointer<DPackage, 1, 1, LPackage>;\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    name!: string;\r\n    defaultValue!: Pointer<DObject, 1, 1, LObject>[];\r\n    // personal\r\n    // isSuperTypeOf(someClass: DClassifier): boolean { return todoret; }\r\n    // getEstructuralFeatureByID(featureID: number): DStructuralFeature { return todoret; }\r\n    // getEstructuralFeature(featureName: string): DStructuralFeature { return todoret; }\r\n    abstract: boolean = false;\r\n    interface: boolean = false;\r\n    instances: Pointer<DObject, 0, 'N', LObject> = [];\r\n    operations: Pointer<DOperation, 0, 'N', LOperation> = [];\r\n    features: Pointer<DStructuralFeature, 0, 'N', LStructuralFeature> = [];\r\n    references: Pointer<DReference, 0, 'N', LReference> = [];\r\n    attributes: Pointer<DAttribute, 0, 'N', LAttribute> = [];\r\n    referencedBy: Pointer<DReference, 0, 'N', LReference> = [];\r\n    extends: Pointer<DClass, 0, 'N', LClass> = [];\r\n    extendedBy: Pointer<DClass, 0, 'N', LClass> = [];\r\n\r\n    // mia aggiunta:\r\n    isPrimitive!: boolean;\r\n    implements: Pointer<DClass, 0, 'N', LClass> = [];\r\n    implementedBy: Pointer<DClass, 0, 'N', LClass> = [];\r\n    partial!: boolean;\r\n    partialdefaultname!: string;\r\n\r\n    isSingleton!: boolean;\r\n    rootable?: boolean;\r\n    sealed!: Pointer<DClass>[];\r\n    final!: boolean;\r\n    allowCrossReference!: boolean;//for extend\r\n\r\n    // for m1:\r\n    // hideExcessFeatures: boolean = true; // isn't it like partial?? // old comment: se attivo questo e creo una DClass di sistema senza nessuna feature e di nome Object, ho creato lo schema di un oggetto schema-less a cui tutti sono conformi\r\n\r\n    public static new(name?: DNamedElement[\"name\"], isInterface: DClass[\"interface\"] = false, isAbstract: DClass[\"abstract\"] = false, isPrimitive: DClass[\"isPrimitive\"] = false, partial?: DClass[\"partial\"],\r\n                      partialDefaultName?: DClass[\"partialdefaultname\"], father?: Pointer, persist: boolean = true, id?: string): DClass {\r\n        if (!name) name = this.defaultname(\"Concept \", father);\r\n\r\n        // console.log('x6 addchild() new class', {father, arguments, name});\r\n        return new Constructors(new DClass('dwc'), father, persist, undefined, id).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DClassifier().DClass(isInterface, isAbstract, isPrimitive, partial, partialDefaultName).end();\r\n    }\r\n\r\n    static new2(setter: Partial<ObjectWithoutPointers<DClass>>, father: DClass[\"father\"], name?: DClass[\"name\"]): DClass {\r\n        if (!name) name = this.defaultname((name || \"Concept \"), father);\r\n        return new Constructors(new DClass('dwc'), father, true, undefined).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DClassifier().DClass().end((d) => { Object.assign(d, setter); });\r\n    }\r\n\r\n    static new3(a: Partial<ClassPointers>, callback: undefined | ((d: DClass, c: Constructors) => void), persist: boolean = true): DClass {\r\n        if (!a.name) a.name = this.defaultname(\"Concept \", a.father);\r\n        return new Constructors(new DClass('dwc'), a.father, persist, undefined, a.id).DPointerTargetable().DModelElement()\r\n            .DNamedElement(a.name).DClassifier().DClass().end(callback);\r\n    }\r\n\r\n}\r\n\r\n(window as any).dc = DClassifier;\r\n(window as any).c = DClass;\r\n@Instantiable // (LObject)\r\n@Node\r\n@RuntimeAccessible('LClass')\r\nexport class LClass<D extends DClass = DClass, Context extends LogicContext<DClass> = any, C extends Context = Context>  extends LClassifier{ // extends DClassifier\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DClass;\r\n    id!: Pointer<DClass, 1, 1, LClass>;\r\n    // static singleton: LClass;\r\n    // static logic: typeof LClass;\r\n    // static structure: typeof DClass;\r\n\r\n    // inherit redefine\r\n    // instanceClass: EJavaClass // ?\r\n    // isInstance(object: EJavaObject): boolean; ?\r\n    // getClassifierID(): number;\r\n    instanceClassName!: string;\r\n    parent!: LPackage[];\r\n    father!: LPackage;\r\n    annotations!: LAnnotation[];\r\n    name!: string;\r\n    namespace!: string;\r\n    defaultValue!: LObject[];\r\n    // personal\r\n    // isSuperTypeOf(someClass: DClassifier): boolean { return todoret; }\r\n    // getEstructuralFeatureByID(featureID: number): DStructuralFeature { return todoret; }\r\n    // getEstructuralFeature(featureName: string): DStructuralFeature { return todoret; }\r\n    abstract!: boolean;\r\n    interface!: boolean;\r\n    instances!: LObject[];\r\n    operations!: LOperation[];\r\n    features!: LStructuralFeature[];\r\n    references!: LReference[];\r\n    attributes!: LAttribute[];\r\n    referencedBy!: LReference[];\r\n    extends!: LClass[];\r\n    __info_of__extends: Info = {type:\"LClass[]\", txt: \"classes directly extended by this. check also: \\\"superclasses\\\".\"}\r\n    extendsChain!: LClass[];  // list of all super classes (father, father of father, ...)  todo: isn't this the same as \"superclasses\" ? check implementation differeces, eventually remove one.\r\n    extendedBy!: LClass[];\r\n    nodes!: LGraphElement[]; // ipotesi, non so se tenerlo\r\n    allowCrossReference!: boolean;\r\n    sealed!: LClass[];\r\n    __info_of__sealed: Info = {type: 'LClass[]', txt:'A sealed class can specify a list of other classes that are allowed to extend it.' +\r\n            '\\n A sealed class that does not allow any class to extend it is a \"final\" class.'}\r\n\r\n    final!: boolean;\r\n    __info_of__final: Info = {type: 'boolean', txt:'A final class cannot be extended.'}\r\n\r\n    rootable!: boolean;\r\n    __info_of__roootable: Info = {type: 'boolean', txt:'Specifies if the class can become a m1 model root, overriding the usual restriction of not being target of a containment reference.'}\r\n\r\n    isSingleton!: boolean;\r\n    __info_of__singleton: Info = {type: 'boolean', txt:'A singleton element is always present exactly 1 time in every model.' +\r\n            '\\n A single instance is created dynamically and cannot be created by the user.'}\r\n\r\n    // fittizi:\r\n\r\n    instantiable!: boolean;\r\n    __info_of__intantiable: Info = {type: 'boolean', txt:'Whether the class can be instantiated.'}\r\n\r\n    aggregated!: boolean;\r\n    __info_of__aggregated: Info = {type: 'boolean', txt:'Whether the class is targeted by an aggregation relationship.'}\r\n\r\n    composed!: boolean;\r\n    __info_of__composed: Info = {type: 'boolean', txt:'Whether the class is targeted by a composition relationship.'}\r\n\r\n    contained!: boolean;\r\n    __info_of__contained: Info = {type: 'boolean', txt:'Whether the class is targeted by a composition or aggregation relationship.'}\r\n\r\n    public superclasses!: LClass[];\r\n    __info_of__superclasses: Info = {type:\"LClass[]\", txt: \"all classes directly and indirectly extended by this. same as check also: \\\"extends\\\".\"}\r\n    public allSubClasses!: LClass[];\r\n\r\n    partialdefaultname!: string;\r\n    isPrimitive!: boolean;\r\n    isClass!: boolean; // false if it's primitive type\r\n    isEnum!: false;\r\n    implements: Pointer<DClass, 0, 'N', LClass> = [];  //todo: interface\r\n    implementedBy: Pointer<DClass, 0, 'N', LClass> = [];\r\n\r\n    ownAttributes!: LAttribute[];\r\n    ownReferences!: LReference[];\r\n    ownOperations!: LOperation[];\r\n    ownChildren!: (LStructuralFeature|LOperation)[];\r\n\r\n    inheritedAttributes!: LAttribute[];\r\n    inheritedReferences!: LReference[];\r\n    inheritedOperations!: LOperation[];\r\n    inheritedChildren!: (LStructuralFeature|LOperation)[];\r\n\r\n    allAttributes!: LAttribute[];\r\n    allReferences!: LReference[];\r\n    allOperations!: LOperation[]; // includes inherited and shadowed features\r\n    allChildren!: (LStructuralFeature|LOperation)[];\r\n\r\n\r\n\r\n    // utilities to go down in the tree (plural names)\r\n    exceptions!: LClassifier[] | null;\r\n    parameters!: LParameter[] | null;\r\n    // [`@${string}`]: LModelElement; todo: try to put it\r\n\r\n\r\n    validTargetsJSX!: JSX.Element[];\r\n    get_validTargetsJSX(c: Context): this['validTargetsJSX'] {\r\n        let opts: MultiSelectOptGroup[] = [];\r\n        this.get_validTargets(c, opts);\r\n        return UX.options(opts);\r\n    }\r\n    validTargetOptions!: MultiSelectOptGroup[];\r\n    get_validTargetOptions(c: Context): this['validTargetOptions'] {\r\n        let opts: MultiSelectOptGroup[] = [];\r\n        this.get_validTargets(c, opts);\r\n        return opts;\r\n    }\r\n    validTargets!: LClass[];\r\n    get_validTargets(c: Context, out?: MultiSelectOptGroup[]): this['validTargets'] {\r\n        let lclass: LClass = c.proxyObject as any;\r\n        // let extendOptions: {value: string, label: string}[] lclass.extends.map(lsubclass=> ({value: lsubclass.id, label: lsubclass.name}));\r\n        let m2: LModel = lclass.model;\r\n        let dclass = c.data;\r\n        let extendsarr = lclass.extendsChain.map(l=>l.id); //dclass.extends;\r\n        let pkgs = dclass.allowCrossReference ? m2.allCrossSubPackages : m2.allSubPackages;\r\n        let extendValue: {value: string, label: string}[] = [];\r\n        if (!out) out = [];\r\n        let ret: LClass[] = [];\r\n        out.push(...pkgs.map(p => (\r\n            {label: p.fullname, options: p.classes.map(c => {\r\n                    let opt = {value:c.id, label: c.name};\r\n                    if (opt.value === dclass.id) return undefined;\r\n                    if (!extendsarr.includes(opt.value)) return opt;\r\n                    extendValue.push(opt);\r\n                    ret.push(c);\r\n                    return undefined;\r\n                }).filter(e=>!!e) as {value: string, label: string}[]})));\r\n        return ret;\r\n    }\r\n\r\n    get_childNames(c: Context): string[] { return this.get_allChildren(c).map( c => c.name).filter(c=>!!c) as string[]; }\r\n    //get_isSealed(c: Context): LClass['sealed'] { return this.get_sealed(c); }\r\n    get_sealed(c: Context): LClass['sealed'] { return LPointerTargetable.wrapAll(c.data.sealed); }\r\n    set_sealed(val: PackArr<LClass>, c: Context): boolean{\r\n        if (!val) val = [];\r\n        else if (!Array.isArray(val)) val = [val];\r\n        const ptrs = [...new Set(val.map((val) => { return val && Pointers.from(val) }).filter(e=>!!e))];\r\n        if (Uarr.equalsUnsorted(c.data.sealed, ptrs)) return true;\r\n        TRANSACTION(this.get_name(c)+'.sealed ', ()=>{\r\n            SetFieldAction.new(c.data, 'sealed', ptrs, '', true);\r\n            if (ptrs.length) {\r\n                SetFieldAction.new(c.data, 'isSingleton', false);\r\n                SetFieldAction.new(c.data, 'final', false);\r\n            } else {\r\n                SetFieldAction.new(c.data, 'final', true);\r\n            }\r\n        });\r\n        return true;\r\n    }\r\n    get_isFinal(c: Context): LClass['final'] { return this.get_final(c); }\r\n    get_final(c: Context): LClass['final']{ return c.data.final; }\r\n    set_final(val: boolean, c: Context): boolean{\r\n        val = !!val;\r\n        if (val === c.data.final) return true;\r\n        if (c.data.extendedBy.length > 0) { U.alert('e', 'Class cannot become final as it is currently extended.', 'Remove the subclasses before.'); return true; }\r\n        TRANSACTION(this.get_name(c)+'.final', ()=>{\r\n            SetFieldAction.new(c.data, 'final', val);\r\n            SetFieldAction.new(c.data, 'sealed', [], '', true);\r\n            if (!val) SetFieldAction.new(c.data, 'isSingleton', false);\r\n        }, c.data.final, val);\r\n        return true;\r\n    }\r\n    get_isSingleton(c: Context): LClass['isSingleton'] { return this.get_singleton(c); }\r\n    get_singleton(c: Context): LClass['isSingleton']{ return c.data.isSingleton; }\r\n    set_isSingleton(val: boolean, c: Context): boolean{ return this.set_singleton(val, c); }\r\n    set_singleton(val: boolean, c: Context): boolean{\r\n        val = !!val;\r\n        if (c.data.instances.length > 1) { U.alert('e', 'Class cannot become a singleton since there are multiple instances already.','Delete some and retry.'); return true; }\r\n        if (c.data.extendedBy.length > 0) { U.alert('e', 'Class cannot become a singleton unless is also final, and is currently extended.', 'Remove the subclasses before.'); return true; }\r\n        TRANSACTION(this.get_name(c)+'.singleton', ()=>{\r\n            SetFieldAction.new(c.data, 'isSingleton', val);\r\n            if (val) {\r\n                SetFieldAction.new(c.data, 'final', true);\r\n                let m2 = this.get_model(c);\r\n                let instances: LObject[] = this.get_instances(c);\r\n                let modelsWithInstance: Pointer<DModel>[] = instances.map( o => o.model?.id );\r\n                for (let m1 of m2.instances) {\r\n                    if (modelsWithInstance.includes(m1.id)) continue;\r\n                    m1.addObject({name: c.data.name}, c.data, true);\r\n                }\r\n            }\r\n        }, c.data.isSingleton, val);\r\n        return c.data.final;\r\n    }\r\n    get_instantiable(c: Context): LClass['instantiable']{ return !(c.data.abstract || c.data.interface || c.data.isSingleton); }\r\n    get_isInstantiable(c: Context): LClass['instantiable'] { return this.get_instantiable(c); }\r\n    get_isComposed(c: Context): LClass['composed'] { return this.get_composed(c); }\r\n    get_isAggregated(c: Context): LClass['aggregated'] { return this.get_aggregated(c); }\r\n    get_isContained(c: Context): LClass['contained'] { return this.get_contained(c); }\r\n    get_contained(c: Context): LClass['contained']{\r\n        let refs = this.get_referencedBy(c);\r\n        for (let r of refs) { if (r && (r.aggregation || r.composition)) return true; }\r\n        return false;\r\n    }\r\n    get_aggregated(c: Context): LClass['aggregated']{\r\n        let refs = this.get_referencedBy(c);\r\n        for (let r of refs) if (r&&r.aggregation) return true;\r\n        return false;\r\n    }\r\n    get_composed(c: Context): LClass['composed']{\r\n        let refs = this.get_referencedBy(c);\r\n        for (let r of refs) if (r&&r.composition) return true;\r\n        return false;\r\n    }\r\n    get_isRootable(c: Context): LClass['rootable'] { return this.get_rootable(c); }\r\n    protected get_rootable(c: Context): this[\"rootable\"] {\r\n        if (c.data.rootable !== undefined) return c.data.rootable;\r\n        else return this.get_instantiable(c) && !this.get_isComposed(c);\r\n    }\r\n    protected set_rootable(val: this[\"rootable\"], c: Context): boolean {\r\n        if (c.data.rootable === val) return true;\r\n\r\n        TRANSACTION(this.get_name(c)+'.rootable', ()=>{\r\n            SetFieldAction.new(c.data, 'rootable', val);\r\n        }, c.data.rootable, val);\r\n        return true;\r\n    }\r\n\r\n    protected get_ownAttributes(context: Context): this['ownAttributes'] {\r\n        return LAttribute.fromPointer(context.data.attributes);\r\n    }\r\n    protected get_ownReferences(context: Context): this['ownReferences'] {\r\n        return LReference.fromPointer(context.data.references);\r\n    }\r\n    protected get_ownOperations(context: Context): this['ownOperations'] {\r\n        return LOperation.fromPointer(context.data.operations);\r\n    }\r\n    protected get_ownChildren(context: Context): this['ownChildren'] {\r\n        return U.arrayMergeInPlace<any>(this.get_ownAttributes(context), this.get_ownReferences(context),\r\n            this.get_ownOperations(context));\r\n    }\r\n\r\n    allExtends!: this['extendsChain'];\r\n    get_allExtends(c:Context): this['extendsChain']{ return this.get_extendsChain(c); }\r\n    private get_extendsChain(context: Context): this['extendsChain'] {\r\n        let targets: LClass[] = LClass.fromArr(context.data.extends);\r\n        let alreadyParsed: Dictionary<Pointer, LClass> = {};\r\n        while (targets.length) {\r\n            let nextTargets = [];\r\n            for (let target of targets){\r\n                if (alreadyParsed[target.id]) continue;\r\n                alreadyParsed[target.id] = target;\r\n                for (let next of target.extends) nextTargets.push(next);\r\n            }\r\n            targets = nextTargets;\r\n        }\r\n        return Object.values(alreadyParsed);\r\n    }\r\n\r\n    public isSubClassOf(superClass: LClass, returnIfSameClass: boolean = true): boolean { return this.cannotCall(\"isSubClassOf\"); }\r\n    public isSuperClassOf(subClass: LClass, returnIfSameClass: boolean = true): boolean { return this.cannotCall(\"isSuperClassOf\"); }\r\n    protected get_isSubClassOf(c: Context): ((superClass: LClass, returnIfSameClass?: boolean) => boolean) {\r\n        return (superClass?: LClass, returnIfSameClass: boolean = true) => {\r\n            superClass = LPointerTargetable.wrap(superClass);\r\n            if (!superClass) return false;\r\n            if (superClass.id === c.data.id) return returnIfSameClass;\r\n            for (let subclass of this.get_extendsChain(c)) {\r\n                if (subclass.id === superClass.id) return true;\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n    protected get_isSuperClassOf(c: Context): ((subClass: LClass, returnIfSameClass?: boolean) => boolean) {\r\n        return (subClass: LClass, returnIfSameClass: boolean = true) => {\r\n            if (!subClass) return false;\r\n            if (subClass.id === c.data.id) return returnIfSameClass;\r\n            return subClass.isSubClassOf(c.proxyObject, returnIfSameClass);\r\n        }\r\n    }\r\n\r\n    protected get_inheritedAttributes(context: Context): this['inheritedAttributes'] {\r\n        return this.get_extendsChain(context).flatMap((superClass) => superClass.ownAttributes);\r\n    }\r\n    protected get_inheritedReferences(context: Context): this['inheritedReferences'] {\r\n        return this.get_extendsChain(context).flatMap((superClass) => superClass.ownReferences);\r\n    }\r\n    protected get_inheritedOperations(context: Context): this['inheritedOperations'] {\r\n        return this.get_extendsChain(context).flatMap((superClass) => superClass.ownOperations);\r\n    }\r\n    protected get_inheritedChildren(context: Context): this['inheritedChildren'] {\r\n        return U.arrayMergeInPlace<any>(this.get_inheritedAttributes(context), this.get_inheritedReferences(context),\r\n            this.get_inheritedOperations(context));\r\n    }\r\n\r\n    protected get_allAttributes(context: Context): this['allAttributes'] {\r\n        return U.arrayMergeInPlace<any>(this.get_ownAttributes(context), this.get_inheritedAttributes(context));\r\n    }\r\n    protected get_allReferences(context: Context): this['allReferences'] {\r\n        return U.arrayMergeInPlace<any>(this.get_ownReferences(context), this.get_inheritedReferences(context));\r\n    }\r\n    protected get_allOperations(context: Context): this['allOperations'] {\r\n        return U.arrayMergeInPlace<any>(this.get_ownOperations(context), this.get_inheritedOperations(context));\r\n    }\r\n    protected get_allChildren(context: Context): this['allChildren'] {\r\n        return U.arrayMergeInPlace<any>(this.get_ownChildren(context), this.get_inheritedChildren(context));\r\n    }\r\n\r\n    protected generateEcoreJson_impl(context: Context, loopDetectionObj: Dictionary<Pointer, DModelElement> = {}): Json {\r\n        loopDetectionObj[context.data.id] = context.data;\r\n        const json: GObject = {};\r\n        const featurearr: Json[] = [];\r\n        const operationsarr: Json[] = [];\r\n        let supertypesstr = [];\r\n        const d = context.data;\r\n        const l = context.proxyObject;\r\n        for (let att of l.attributes) { featurearr.push(att.generateEcoreJson(loopDetectionObj)); }\r\n        for (let ref of l.references) { featurearr.push(ref.generateEcoreJson(loopDetectionObj)); }\r\n        for (let op of l.operations) { operationsarr.push(op.generateEcoreJson(loopDetectionObj)); }\r\n\r\n        json[ECoreClass.xsitype] = 'ecore:EClass';\r\n        json[ECoreClass.namee] = d.name;\r\n        json[ECoreClass.interface] = U.toBoolString(d.interface, false);\r\n        json[ECoreClass.abstract] = U.toBoolString(d.abstract, false);\r\n        if (d.instanceClassName) json[ECoreClass.instanceTypeName] = d.instanceClassName;\r\n        json[ECoreClass.eSuperTypes] = l.extends.map( superclass => superclass.typeEcoreString).join(\" \");\r\n        if (featurearr) json[ECoreClass.eStructuralFeatures] = featurearr;\r\n        if (operationsarr) json[ECoreClass.eOperations] = operationsarr;\r\n        return json; }\r\n\r\n\r\n    public duplicate(deep: boolean = true): this {\r\n        return this.cannotCall( ((this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name) + \"duplicate()\"); }\r\n    protected get_duplicate(context: Context): ((deep?: boolean) => LClass) {\r\n        return (deep: boolean = false) => {\r\n            let ret: LClass = null as any;\r\n            TRANSACTION('duplicate '+this.get_name(context), () => {\r\n                let le: LClass = context.proxyObject.father.addClass(context.data.name, context.data.interface, context.data.abstract, context.data.isPrimitive);\r\n                let de: D = le.__raw as D;\r\n                // de.hideExcessFeatures = context.data.hideExcessFeatures;\r\n                let we: WClass = le as any;\r\n                we.defaultValue = context.data.defaultValue;\r\n                we.extends = context.data.extends;\r\n                we.attributes = deep ? context.proxyObject.attributes.map(lchild => lchild.duplicate(deep).id) : context.data.attributes;\r\n                we.references = deep ? context.proxyObject.references.map(lchild => lchild.duplicate(deep).id) : context.data.references;\r\n                we.operations = deep ? context.proxyObject.operations.map(lchild => lchild.duplicate(deep).id) : context.data.operations;\r\n                ret = le; // set ret = le only if the transaction is complete.\r\n            });\r\n            return ret; }\r\n    }\r\n\r\n    protected get_children_idlist(context: Context): Pointer<DAnnotation | DStructuralFeature | DOperation, 1, 'N'> {\r\n        return [...super.get_children_idlist(context) as Pointer<DAnnotation | DStructuralFeature, 1, 'N'>,\r\n            ...context.data.attributes,\r\n            ...context.data.references,\r\n            ...context.data.operations];\r\n    }\r\n\r\n\r\n    protected set_name(val: this[\"name\"], context: Context): boolean {\r\n        if (context.data.name === val) return true;\r\n        super.set_name(val, context);\r\n        SetRootFieldAction.new('ClassNameChanged.'+context.data.id, val, '', false); // it is pointer, but related to transient stuff, so don't need pointedBy's\r\n        return true;\r\n    }\r\n\r\n    partial!: boolean;\r\n    __info_of__partial: Info = {type: 'boolean', txt:'A partial object have can add unlisted features as a shapeless (schemaless) object does,' +\r\n            ' on top of a set of fixed listed features.'}\r\n    protected set_partial(val: D[\"partial\"], c: Context): boolean {\r\n        val = !!val;\r\n        if (val === c.data.partial) return true;\r\n        TRANSACTION(this.get_name(c)+'.partial', ()=>{\r\n            SetFieldAction.new(c.data.id, \"partial\", val);\r\n        }, c.data.partial, val)\r\n        return true;\r\n    }\r\n    protected get_partial(context: Context): D[\"partial\"] { return context.data.partial; }\r\n\r\n    protected set_partialdefaultname(val: D[\"partialdefaultname\"], c: Context): boolean {\r\n        if (val === c.data.partialdefaultname) return true;\r\n        TRANSACTION(this.get_name(c)+'.partialdefaultname', ()=>{\r\n            SetFieldAction.new(c.data.id, \"partialdefaultname\", val, undefined, false);\r\n        })\r\n        return true;\r\n    }\r\n    protected get_partialdefaultname(context: Context): D[\"partialdefaultname\"] { return context.data.partialdefaultname; }\r\n\r\n    public addAttribute(name?: DAttribute[\"name\"], type?: DAttribute[\"type\"]): LAttribute { return this.cannotCall(\"addAttribute\"); }\r\n    protected get_addAttribute(context: Context): this[\"addAttribute\"] {\r\n        return (name?: DAttribute[\"name\"], type?: DAttribute[\"type\"]) => LPointerTargetable.fromD(DAttribute.new(name, type, context.data.id, true));\r\n    }\r\n\r\n    public addReference(name?: DReference[\"name\"], type?: DReference[\"type\"]): LReference { return this.cannotCall(\"addReference\"); }\r\n    protected get_addReference(context: Context): this[\"addReference\"] {\r\n        return (name?: DReference[\"name\"], type?: DReference[\"type\"]) => LPointerTargetable.fromD(DReference.new(name, type, context.data.id, true));\r\n    }\r\n\r\n    public addOperation(name?: DOperation[\"name\"], type?: DOperation[\"type\"]): LOperation { return this.cannotCall(\"addOperation\"); }\r\n    protected get_addOperation(context: Context): this[\"addOperation\"] {\r\n        return (name?: DOperation[\"name\"], type?: DOperation[\"type\"]) => LPointerTargetable.fromD(DOperation.new(name, type, [], context.data.id, true));\r\n    }\r\n\r\n\r\n    protected get_abstract(context: Context): this[\"abstract\"] { return context.data.abstract; }\r\n    protected set_abstract(val: this[\"abstract\"], c: Context): boolean {\r\n        const data = c.data;\r\n        val = !!val;\r\n        if (val === c.data.abstract) return true;\r\n        if(val && data.instances.length > 0) {\r\n            U.alert('e', 'Cannot change the abstraction level since there are instances.','');\r\n        } else {\r\n            TRANSACTION(this.get_name(c)+'.abstract', ()=>{\r\n                SetFieldAction.new(data, 'abstract', val);\r\n            }, c.data.abstract, val)\r\n        }\r\n        return true;\r\n    }\r\n\r\n    protected set_isPrimitive(val: this[\"isPrimitive\"], c: Context): boolean {\r\n        val = !!val;\r\n        if (val === c.data.isPrimitive) return true;\r\n        TRANSACTION(this.get_name(c)+'.isPrimitive', ()=>{\r\n            SetFieldAction.new(c. data, 'isPrimitive', val);\r\n        })\r\n        return true;\r\n    }\r\n    // get is in classifier with all other \"type\"s getter and setter\r\n\r\n    protected get_interface(context: Context): this[\"interface\"] { return context.data.interface; }\r\n    protected set_interface(val: this[\"interface\"], c: Context): boolean {\r\n        val = !!val;\r\n        if (c.data.interface === val) return true;\r\n        if (val && c.data.instances.length > 0) {\r\n            U.alert('e', 'Class cannot become an interface since there are instances.', '');\r\n        } else {\r\n            TRANSACTION(this.get_name(c)+'.interface', ()=>{\r\n                SetFieldAction.new(c.data, 'interface', val);\r\n            }, c.data.interface, val)\r\n        }\r\n        return true;\r\n    }\r\n\r\n    allInstances!: LObject[];\r\n    __info_of__allInstances: Info = {type: 'LObject[]', txt: \"Instances in m1 of this class and of all subclasses.\"};\r\n    protected get_allInstances(context: Context): this[\"instances\"] {\r\n        let sc = this.get_allSubClasses(context, true);\r\n        return sc.flatMap( (c) => c.instances);\r\n    }\r\n\r\n    protected get_instances(context: Context): this[\"instances\"] {\r\n        return context.data.instances.map((pointer) => {\r\n            return LPointerTargetable.from(pointer)\r\n        });\r\n    }\r\n    protected set_instances(val: PackArr<this[\"instances\"]>, c: Context): boolean {\r\n        const list = val.map((lItem) => { return Pointers.from(lItem) });\r\n        TRANSACTION(this.get_name(c)+'.instances', ()=>{\r\n            SetFieldAction.new(c.data, 'instances', list, \"\", true);\r\n        })\r\n        return true;\r\n    }\r\n\r\n    protected get_operations(context: Context): this[\"operations\"] {\r\n        return context.data.operations.map((pointer) => {\r\n            return LPointerTargetable.from(pointer)\r\n        });\r\n    }\r\n    protected set_operations(val: PackArr<this[\"operations\"]>, context: Context): boolean {\r\n        const list = val.map((lItem) => { return Pointers.from(lItem) });\r\n        const oldList = context.data.operations;\r\n        const diff = U.arrayDifference(oldList, list);\r\n        TRANSACTION(this.get_name(context)+'.operations', ()=>{\r\n            SetFieldAction.new(context.data, 'operations', list, \"\", true);\r\n            for (let id of diff.added) {\r\n                SetFieldAction.new(id, 'father', context.data.id, '', true);\r\n                SetFieldAction.new(id, 'parent', context.data.id, '+=', true);\r\n            }\r\n            for (let id of diff.removed as Pointer<DModelElement>[]) {\r\n                SetFieldAction.new(id, 'father', undefined, '', true);\r\n                const parent = DPointerTargetable.from(id).parent;\r\n                U.arrayRemoveAll(parent, context.data.id);\r\n                SetFieldAction.new(id, 'parent', parent, '', true);\r\n            }\r\n        })\r\n        return true;\r\n    }\r\n\r\n    protected get_features(context: Context): this[\"features\"] {\r\n        return context.data.features.map((pointer) => { return LPointerTargetable.from(pointer) });\r\n    }\r\n    protected set_features(val: PackArr<this[\"features\"]>, context: Context): boolean {\r\n        const list = val.map((lItem) => { return Pointers.from(lItem) });\r\n        const oldList = context.data.features;\r\n        const diff = U.arrayDifference(oldList, list);\r\n        let le: this = null as any;\r\n        TRANSACTION(this.get_name(context)+'.features', ()=>{\r\n            SetFieldAction.new(context.data, 'features', list, \"\", true);\r\n            for (let id of diff.added) {\r\n                SetFieldAction.new(id, 'father', context.data.id, '', true);\r\n                SetFieldAction.new(id, 'parent', context.data.id, '+=', true);\r\n            }\r\n            for (let id of diff.removed as Pointer<DModelElement>[]) {\r\n                SetFieldAction.new(id, 'father', undefined, '', true);\r\n                const parent = DPointerTargetable.from(id).parent;\r\n                U.arrayRemoveAll(parent, context.data.id);\r\n                SetFieldAction.new(id, 'parent', parent, '', true);\r\n            }\r\n        })\r\n        return true;\r\n    }\r\n\r\n    protected get_references(context: Context): this[\"references\"] {\r\n        return context.data.references.map((pointer) => {\r\n            return LPointerTargetable.from(pointer)\r\n        });\r\n    }\r\n    protected set_references(val: PackArr<this[\"references\"]>, context: Context): boolean {\r\n        const list = val.map((lItem) => { return Pointers.from(lItem) });\r\n        const oldList = context.data.references;\r\n        const diff = U.arrayDifference(oldList, list);\r\n        TRANSACTION(this.get_name(context)+'.references', ()=>{\r\n            SetFieldAction.new(context.data, 'references', list, \"\", true);\r\n            for (let id of diff.added) {\r\n                SetFieldAction.new(id, 'father', context.data.id, '', true);\r\n                SetFieldAction.new(id, 'parent', context.data.id, '+=', true);\r\n            }\r\n            for (let id of diff.removed as Pointer<DModelElement>[]) {\r\n                SetFieldAction.new(id, 'father', undefined, '', true);\r\n                const parent = DPointerTargetable.from(id).parent;\r\n                U.arrayRemoveAll(parent, context.data.id);\r\n                SetFieldAction.new(id, 'parent', parent, '', true);\r\n            }\r\n        })\r\n        return true;\r\n    }\r\n\r\n    protected get_attributes(context: Context): this[\"attributes\"] {\r\n        return context.data.attributes.map((pointer) => {\r\n            return LPointerTargetable.from(pointer)\r\n        });\r\n    }\r\n    protected set_attributes(val: PackArr<this[\"attributes\"]>, context: Context): boolean {\r\n        const list = val.map((lItem) => { return Pointers.from(lItem) });\r\n        const oldList = context.data.attributes;\r\n        const diff = U.arrayDifference(oldList, list);\r\n        TRANSACTION(this.get_name(context)+'.attributes', ()=>{\r\n            SetFieldAction.new(context.data, 'attributes', list, \"\", true);\r\n            for (let id of diff.added) {\r\n                SetFieldAction.new(id, 'father', context.data.id, '', true);\r\n                SetFieldAction.new(id, 'parent', context.data.id, '+=', true);\r\n            }\r\n            for (let id of diff.removed as Pointer<DModelElement>[]) {\r\n                SetFieldAction.new(id, 'father', undefined, '', true);\r\n                const parent = DPointerTargetable.from(id).parent;\r\n                U.arrayRemoveAll(parent, context.data.id);\r\n                SetFieldAction.new(id, 'parent', parent, '', true);\r\n            }\r\n        })\r\n        return true;\r\n    }\r\n\r\n    public get_referencedBy(c: Context): this[\"referencedBy\"] {\r\n        let keystr: string;\r\n        if (c.data.className === 'DClass'){ keystr = '.type'; }\r\n        // @ts-ignore\r\n        else if (c.data.className === 'DObject'){ return LObject.singleton.get_referencedBy(c); }\r\n        // else if (c.data.className === 'DObject'){ keystr = '.values'; } nope, model also have .values+=\r\n        // and lvalues might be under either \".values\" | \".values+=\" | \".values.0\" (in rightbar)\r\n        else return [];\r\n\r\n        let ptrs = c.data.pointedBy.map(e=> {\r\n            /*\r\n            if (c.data.className === 'DObject'){\r\n                let parent = this.get_father(c);\r\n                return parent.className === 'DValue' ? [parent] : [];\r\n            }*/\r\n            let index = e.source.lastIndexOf(keystr);\r\n            if (index !== (e.source.length - keystr.length)) return null;\r\n            return e.source.substring('idlookup.'.length, index);\r\n\r\n        }).filter(e=>!!e);\r\n\r\n        return LPointerTargetable.fromArr(ptrs);\r\n        // return context.data.referencedBy.map((pointer) => LPointerTargetable.from(pointer) );\r\n    }\r\n    protected set_referencedBy(val: PackArr<this[\"referencedBy\"]>, context: Context): boolean {\r\n        return this.cannotSet('referencedBy', 'is automatically updated through pointedBy');\r\n        /*if (!val) val = [];\r\n        else if (!Array.isArray(val)) val = [val];\r\n        const ptrs = [...new Set(val.map((val) => { return val && Pointers.from(val) })).filter(e=>!!e)];\r\n        SetFieldAction.new(context.data, 'referencedBy', ptrs, \"\", true);\r\n        return true;*/\r\n    }\r\n\r\n    protected get_extends(context: Context): this[\"extends\"] {\r\n        return context.data.extends.map((pointer) => {\r\n            return LPointerTargetable.from(pointer)\r\n        });\r\n    }\r\n    protected set_extends(val: PackArr<this[\"extends\"]>, c: Context): boolean {\r\n        if (!val) val = [];\r\n        else if (!Array.isArray(val)) val = [val];\r\n        let ptrs: Pointer[] = [...new Set(val.map((val) => { return val && Pointers.from(val) }).filter(e=>!!e))];\r\n        let diff = Uarr.arrayDifference(c.data.extends, ptrs);\r\n        let invalid: GObject[] = [];\r\n        let invalidPtrs: Pointer[] = [];\r\n        for (let ptr of diff.added){\r\n            let reason: GObject = {ptr};\r\n            if (this.get_canExtend(c)(ptr as any, reason as any)) continue;\r\n            invalid.push(reason);\r\n            invalidPtrs.push(ptr);\r\n        }\r\n        if (invalid.length) {\r\n            Log.ww('tried to add invalid extends, they were ignored:', invalid);\r\n            ptrs = ptrs.filter(e=>!invalid.includes(e));\r\n        }\r\n        if (diff.removed.length === 0 && diff.added.length === invalid.length) return true;\r\n\r\n        TRANSACTION(this.get_name(c)+'.extends', ()=>{\r\n            SetFieldAction.new(c.data, 'extends', ptrs, \"\", true);\r\n        }, undefined, ('+'+diff.added.length+', -'+diff.removed.length))\r\n        return true;\r\n    }\r\n\r\n    add_extends(val: PackArr<this[\"extends\"]>): void { this.cannotCall('add_extends'); }\r\n    get_add_extends(val: PackArr<this[\"extends\"]>, context: Context): this['add_extends'] {\r\n        return ((val: string[])=>this.impl_add_extends(val as any, context)) as any;\r\n    }\r\n    impl_add_extends(val: PackArr<this[\"extends\"]>, c: Context): void {\r\n        if (!val) val = [];\r\n        else if (!Array.isArray(val)) val = [val];\r\n        if (!val.length) return;\r\n        let ptrs = [...new Set(val.map((val) => { return val && Pointers.from(val) }).filter(e=>!!e && !c.data.extends.includes(e)))];\r\n\r\n        ptrs = ptrs.filter(ptr => this.get_canExtend(c)(ptr as any, {} as any));\r\n        if (!ptrs.length) return;\r\n        // todo: extendedby? or make it derived from pointedby\r\n\r\n        TRANSACTION(this.get_name(c)+'.extends+=', ()=>{\r\n            SetFieldAction.new(c.data, 'extends', [...c.data.extends, ...ptrs], '', true);\r\n        }, undefined, ptrs.length)\r\n    }\r\n\r\n    protected remove_extends(val: PackArr<this[\"extends\"]> | number | number[], c: Context): void {\r\n        if (!val) val = [];\r\n        else if (!Array.isArray(val)) val = [val];\r\n        if (!val.length) return;\r\n        let finalVal: D[\"extends\"];\r\n        if (typeof val[0] === \"number\") { finalVal = c.data.extends.filter((elem,index,arr)=> { return (val as any[]).includes(index); }); }\r\n        else {\r\n            finalVal = [...c.data.extends];\r\n            let ptrs: Pointer<DClass> = Pointers.from(val as PackArr<this[\"extends\"]>) as any;\r\n            for (let v of ptrs) { U.arrayRemoveAll(finalVal, v); }\r\n        }\r\n\r\n        TRANSACTION(this.get_name(c)+'.extends-=', ()=>{\r\n            SetFieldAction.new(c.data, 'extends', finalVal, '', true);\r\n        }, undefined, c.data.extends.length - finalVal.length)\r\n    }\r\n\r\n    protected get_extendedBy(c: Context): this[\"extendedBy\"] {\r\n        return c.data.extendedBy.map((pointer) => {\r\n            return LPointerTargetable.from(pointer)\r\n        });\r\n    }\r\n    protected set_extendedBy(val: PackArr<this[\"extendedBy\"]>, c: Context): boolean {\r\n        if (!val) val = [];\r\n        else if (!Array.isArray(val)) val = [val];\r\n        const ptrs = [...new Set(val.map((val) => { return val && Pointers.from(val) }).filter(e=>!!e))];\r\n        TRANSACTION(this.get_name(c)+'.extendedBy', ()=>{\r\n            SetFieldAction.new(c.data, 'extendedBy', ptrs, \"\", true);\r\n        })\r\n        return true;\r\n    }\r\n\r\n    protected get_implements(context: Context): this[\"implements\"] { return context.data.implements; }\r\n    protected set_implements(val: this[\"implements\"], c: Context): boolean {\r\n        TRANSACTION(this.get_name(c)+'.implements', ()=>{\r\n            SetFieldAction.new(c.data, 'implements', val, \"\", true);\r\n        })\r\n        return true;\r\n    }\r\n\r\n    protected get_implementedBy(context: Context): this[\"implementedBy\"] { return context.data.implementedBy; }\r\n    protected set_implementedBy(val: this[\"implementedBy\"], c: Context): boolean {\r\n        TRANSACTION(this.get_name(c)+'.implementedBy', ()=>{\r\n            SetFieldAction.new(c.data, 'implementedBy', val, \"\", true);\r\n        })\r\n        return true;\r\n    }\r\n\r\n\r\n    public canExtend(superclass: LClass, output: {reason: string, allTargetSuperClasses: LClass[]} = {reason: '', allTargetSuperClasses: []}): boolean {\r\n        this.cannotCall(\"canExtend\"); return false;\r\n    }\r\n\r\n    private get_canExtend(context: Context): (superclass: LClass, output: {reason: string, allTargetSuperClasses: LClass[]}) => boolean {\r\n        return (superclass: LClass, output: {reason: string, allTargetSuperClasses: LClass[]} =\r\n            {reason: '', allTargetSuperClasses: []}) => this._canExtend(context, superclass, output);\r\n    }\r\n\r\n    public isExtending(superclass: Pack1<LClass>, directly: boolean = false): boolean { return this.cannotCall(\"isExtending\"); }\r\n    public isSubclassOf(superclass: Pack1<LClass>, directly: boolean = false): boolean { return this.cannotCall(\"isSubclassOf\"); }\r\n    __info_of__isSubclassOf: Info = {type: \"(superclass: Pointer | LClass, directly: boolean = false) => boolean\", txt: \"Alias for isExtending\"};\r\n    __info_of__isExtending: Info = {type: \"(superclass: Pointer | LClass, directly: boolean = false) => boolean\",\r\n        txt:<div>Tells if \"this\" is a subclass of the \"superclass\" parameter.\r\n            <br/>- If \"directly\" is set to true, it will only include direct subclassing as in \"class A extends C\" not considering chains.\r\n            <br/>    If \"directly\" is set to true: \"class A extends B\" & \"Class B extends C\". In that case A.isExtending(C, true) will return false.</div>};\r\n\r\n    private get_isSubclassOf(c: Context, plusThis: boolean = true): this[\"isExtending\"] { return this.get_isExtending(c, plusThis); }\r\n    private get_isExtending(c: Context, plusThis: boolean = true): this[\"isExtending\"] {\r\n        return (superclass: Pack1<LClass>, directly: boolean = false): boolean => {\r\n            let ptr = Pointers.from(superclass);\r\n            if (directly) return c.data.extends.includes(ptr);\r\n            return this.get_superclasses(c, plusThis).map(classe=>classe.id).includes(ptr);\r\n        }\r\n    }\r\n\r\n    private get_superclasses(context: Context, plusThis: boolean = false): LClass[] {\r\n        let i: number;\r\n        const thiss: LClass = context.proxyObject;\r\n        const visited: Dictionary<Pointer, LClass> = {};\r\n        let queue: LClass[] = thiss.extends;\r\n        if (plusThis) queue = [thiss, ...queue];\r\n        const ret: LClass[] = [];\r\n        for (i = 0; i < queue.length; i++) {\r\n            let elem: LClass = queue[i];\r\n            if (visited[elem.id]) continue;\r\n            visited[elem.id] = elem;\r\n            ret.push(elem);\r\n            queue.push(...elem.extends);\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    private get_allSubClasses(context: Context, plusThis: boolean = false, state?: DState): LClass[] {\r\n        const thiss: LClass = context.proxyObject;\r\n        let extendedBy = thiss.extendedBy;\r\n        let ebyIDS = extendedBy.map(e => e.id);\r\n        /* old version, remade longer but more efficient\r\n        const set: Set<LClass> = plusThis ? new Set<LClass>([thiss.id, ...ebyIDS]) : new Set(ebyIDS);\r\n        for (let i = 0; i < extendedBy.length; i++) { U.SetMerge(true, set, extendedBy[i].allSubClasses.map(e=>e.id)); }*/\r\n        let parsedSubclasses: Dictionary<Pointer, DClass> = {}\r\n        parsedSubclasses[context.data.id] = context.data;\r\n        let stack: DClass[] = [context.data];\r\n        if (!state && !context.data.extendedBy?.length) state = store.getState();\r\n        while (stack.length) {\r\n            let newstack: DClass[] = [];\r\n            for (let d of stack) {\r\n                for (let sid of d.extendedBy) {\r\n                    if (!sid || parsedSubclasses[sid]) continue;\r\n                    let d: DClass = DClass.from(sid, state);\r\n                    if (!d) continue;\r\n                    parsedSubclasses[sid] = d;\r\n                    newstack.push(d);\r\n                }\r\n            }\r\n            stack = newstack;\r\n        }\r\n        if (!plusThis) delete parsedSubclasses[context.data.id];\r\n        return Object.values(parsedSubclasses).map(d=>LPointerTargetable.fromD(d)); }\r\n\r\n\r\n    private _canExtend(c: Context, superclass: LClass, output: {reason: string, allTargetSuperClasses: LClass[]} = {reason: '', allTargetSuperClasses: []}): boolean {\r\n        if (!output) output = {allTargetSuperClasses:[]} as any;\r\n        superclass = superclass && LPointerTargetable.wrap(superclass) as any;\r\n        if (!superclass) { output.reason = 'Invalid extend target: ' + superclass; return false; }\r\n        let sealed = superclass.sealed || [];\r\n        if (sealed.length) {\r\n            let inSealed = false;\r\n            for (let allowed of sealed) if (allowed && allowed.isSubClassOf(c.proxyObject)) { inSealed = true; break; }\r\n            if (!inSealed) {\r\n                output.reason = 'sealed on attempted superclass';\r\n                return false;\r\n            }\r\n        }\r\n        if (superclass.final) {\r\n            output.reason = 'final on attempted superclass';\r\n            return false;\r\n        }\r\n        const thiss: LClass = c.proxyObject;\r\n        if (superclass.id === thiss.id) { output.reason = 'Classes cannot extend themselves.'; return false; }\r\n        // todo: se diversi proxy dello stesso oggetto sono considerati diversi questo fallisce, in tal caso fai thiss.extends.map( l => l.id).indexof(superclass.id)\r\n        if (thiss.extends.map(sc=>sc.id).indexOf(superclass.id) >= 0) { output.reason = 'Target class is already directly extended.'; return false; }\r\n        output.allTargetSuperClasses = superclass.superclasses;\r\n        if (thiss.superclasses.map(sc=> sc.id).indexOf(superclass.id) >= 0) { output.reason = 'Target class is already indirectly extended.'; return false; }\r\n        if (output.allTargetSuperClasses.map(sc=>sc.id).indexOf(thiss.id) >= 0) { output.reason = 'Cannot set this extend, it would cause a inheritance loop.'; return false; }\r\n        if (thiss.interface && !superclass.interface) { output.reason = 'An interface cannot extend a class.'; return false; }\r\n        // ora verifico se causa delle violazioni di override (attibuti omonimi string e boolean non possono overridarsi)\r\n        let i: number;\r\n        let j: number;\r\n        let children: LOperation[] =  thiss.operations; //[...thiss.getBasicOperations()];\r\n        let superchildren: LOperation[] = superclass.operations; //[...superclass.getBasicOperations()];\r\n        for (i = 0; i < children.length; i++) {\r\n            let op: LOperation = children[i];\r\n            for (j = 0; j < superchildren.length; j++){\r\n                let superchild: LOperation = superchildren[j];\r\n                if (op.name !== superchild.name) continue;\r\n                if (op._canOverride(superchild) || op._canPolymorph(superchild)) continue;\r\n                output.reason = 'Marked homonymous operations cannot override nor polymorph each others.';\r\n                setTimeout( () => {\r\n                    op._mark(true, superchild, 'override'); //  mark op && superchildren\r\n                    setTimeout( () => { op._mark(false, superchild, 'override'); }, 3000); // unmark\r\n                }, 1);\r\n                return false;\r\n            }\r\n        }\r\n        return true; }\r\n\r\n    private _isExtending(context: Context, superclass: LClass, orEqual: boolean = true): boolean {\r\n        if (!superclass) return false;\r\n        return this.get_superclasses(context, orEqual).includes(superclass); }\r\n\r\n    private add_Extends(c: Context, superclass: LClass, force: boolean = false): boolean {\r\n        let out: {reason: string, allTargetSuperClasses: LClass[]} = {reason: '', allTargetSuperClasses: []};\r\n        const thiss: LClass = c.proxyObject;\r\n        superclass = LPointerTargetable.wrap(superclass) as any;\r\n        if (!superclass) return true;\r\n        if (!force && !this._canExtend(c, superclass, out)) {  return false; }\r\n\r\n        TRANSACTION(this.get_name(c)+'.extends+=', ()=>{\r\n            SetFieldAction.new(thiss.__raw, 'extends', [superclass.id], '+=', true);\r\n            SetFieldAction.new(superclass.__raw, 'extendedBy', [thiss.id], '+=', true);\r\n        }, undefined, superclass.fullname)\r\n        // const extendChildren: LClass[] =  [thiss, ...thiss.superclasses];\r\n        // console.log('calculateViolationsExtend children:'  + extendChildren, this);\r\n        // for (let extChild of extendChildren) { extChild._checkViolations(false); } // after instances have their meta-class changed, they might need to change shape or values.\r\n        return true; }\r\n\r\n    unsetExtends(superclass: LClass): void { return this.cannotCall('unsetExtends'); }\r\n    get_unsetExtends(c: Context, superclass: LClass): (superclass: LClass)=>void {\r\n        return (superclass: LClass)=>{\r\n            superclass = LPointerTargetable.wrap(superclass) as any;\r\n            if (!superclass) return;\r\n            console.log('UnsetExtend:', c, superclass);\r\n            // todo: when Object is loaded in m3, set him there for easy access.\r\n            //  if (superclass.id === LClass.genericObjectid) { Log.w(true, 'Cannot un-extend \"Object\"'); return; }\r\n            const thiss: LClass = c.proxyObject;\r\n            let superclassid = superclass.id;\r\n            let extendsarr = c.data.extends;\r\n            let index: number = extendsarr.indexOf(superclassid);\r\n            if (index < 0) return;\r\n            // let extendedby = superclass.__raw.extendedBy;\r\n\r\n            TRANSACTION(this.get_name(c)+'.extends-=', ()=>{\r\n                // @ts-ignore\r\n                SetFieldAction.new(thiss, 'extends', superclass.id, '-=', true);\r\n                // @ts-ignore\r\n                SetFieldAction.new(superclass, 'extendedBy', thiss.id, '-=', true);\r\n            }, undefined, superclass.fullname)\r\n            // todo: update instances for (i = 0; i < thiss.instances.length; i++) { thiss.instances[i].unsetExtends(superclass); }\r\n            // todo: check violations\r\n            // const extendedby: LClass[] = [thiss, ...thiss.allSubClasses];\r\n            // for (i = 0; i < extendedby.length; i++) { extendedby[i].checkViolations(true); }\r\n        }\r\n    }\r\n\r\n    public instance(): DObject { return this.cannotCall('instance'); }\r\n    /*private get_instance_old(context: Context): () => DObject {\r\n        return () => {\r\n            const dClass: DClass = context.data;\r\n            const lClass: LClass = LClass.from(dClass);\r\n            const dObject = DObject.new(lClass.name.toLowerCase());\r\n            CreateElementAction.new(dObject);\r\n            BEGIN()\r\n            SetFieldAction.new(dObject, 'instanceof', dClass.id, '', true);\r\n            SetFieldAction.new(dClass, 'instances', dObject.id, '+=', true);\r\n\r\n            let father: LClass|undefined = lClass;\r\n            while(father) {\r\n                for(let dFeature of [...father.attributes, ...father.references]) {\r\n                    const dValue = DValue.new(dFeature.name); dValue.value = [U.initializeValue(dFeature.type)];\r\n                    CreateElementAction.new(dValue);\r\n\r\n                    SetFieldAction.new(dValue, 'father', dObject.id, '', true);\r\n                    SetFieldAction.new(dValue, 'instanceof', dFeature.id, '', true);\r\n                    SetFieldAction.new(dFeature, 'instances', dValue.id, '+=', true);\r\n                    SetFieldAction.new(dObject, 'features', dValue.id, '+=', true);\r\n\r\n                }\r\n                father = (father.extends.length > 0) ? father.extends[0] : undefined;\r\n            }\r\n            END()\r\n            return dObject;\r\n        };\r\n    }*/\r\n\r\n}\r\nRuntimeAccessibleClass.set_extend(DClassifier, DClass);\r\nRuntimeAccessibleClass.set_extend(LClassifier, LClass);\r\n@RuntimeAccessible('DDataType')\r\nexport class DDataType extends DPointerTargetable { // extends DClassifier\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LDataType;\r\n    // static logic: typeof LDataType;\r\n    // static structure: typeof DDataType;\r\n\r\n    // inherit redefine\r\n    // instanceClass: EJavaClass // ?\r\n    // isInstance(object: EJavaObject): boolean; ?\r\n    // getClassifierID(): number;\r\n    id!: Pointer<DDataType, 1, 1, LDataType>;\r\n    instanceClassName!: string;\r\n    parent: Pointer<DPackage, 0, 'N', LPackage> = [];\r\n    father!: Pointer<DPackage, 1, 1, LPackage>;\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    name!: string;\r\n    defaultValue!: Pointer<DObject, 1, 1, LObject>[] | string[];\r\n    // personal\r\n    serializable: boolean = true;\r\n    // usedBy: Pointer<DAttribute, 0, 'N', LAttribute> = [];\r\n\r\n\r\n    public static new(name?: DNamedElement[\"name\"], father?: Pointer, persist: boolean = true): DDataType {\r\n        Log.exx(\"DDataType is abstract, cannot instantiate\");\r\n        return null as any;\r\n        // if (!name) name = this.defaultname(\"datatype_\", father);\r\n        // return new Constructors(new DDataType('dwc'), father, persist, undefined).DPointerTargetable().DModelElement().DNamedElement(name).DClassifier().DDataType().end();\r\n    }\r\n}\r\n\r\n@Abstract\r\n@RuntimeAccessible('LDataType')\r\nexport class LDataType<Context extends LogicContext<DDataType> = any, C extends Context = Context> extends LClassifier { // extends DClassifier\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DDataType;\r\n    id!: Pointer<DDataType, 1, 1, LDataType>;\r\n    // static singleton: LDataType;\r\n    // static logic: typeof LDataType;\r\n    // static structure: typeof DDataType;\r\n\r\n    // inherit redefine\r\n    // instanceClass: EJavaClass // ?\r\n    // isInstance(object: EJavaObject): boolean; ?\r\n    // getClassifierID(): number;\r\n    instanceClassName!: string;\r\n    parent!: LPackage[];\r\n    father!: LPackage;\r\n    annotations!: LAnnotation[];\r\n    name!: string;\r\n    namespace!: string;\r\n    defaultValue!: LObject[] | string[];\r\n    isPrimitive!: false;\r\n    isClass!: false;\r\n    isEnum!: true;\r\n    // personal\r\n    serializable!: boolean;\r\n\r\n\r\n    protected get_serializable(context: Context): this[\"serializable\"] { return context.data.serializable; }\r\n    protected set_serializable(val: this[\"serializable\"], c: Context): boolean {\r\n        val = !!val;\r\n        if (val === c.data.serializable) return true;\r\n        TRANSACTION(this.get_name(c)+'.serializable', ()=>{\r\n            SetFieldAction.new(c.data, 'serializable', val);\r\n        }, c.data.serializable, val)\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(DClassifier, DDataType);\r\nRuntimeAccessibleClass.set_extend(LClassifier, LDataType);\r\n@RuntimeAccessible('DStructuralFeature')\r\nexport class DStructuralFeature extends DPointerTargetable { // DTypedElement\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LStructuralFeature;\r\n    // static logic: typeof LStructuralFeature;\r\n    // static structure: typeof DStructuralFeature;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DStructuralFeature, 1, 1, LStructuralFeature>;\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    parent: Pointer<DClass, 0, 'N', LClass> = [];\r\n    father!: Pointer<DClass, 1, 1, LClass>;\r\n    name!: string;\r\n    type!: Pointer<DClassifier, 1, 1, LClassifier>;\r\n    ordered: boolean = true;\r\n    unique: boolean = true;\r\n    lowerBound: number = 0;\r\n    upperBound: number = 1;\r\n    many!: boolean;\r\n    required!: boolean;\r\n    // personal\r\n    instances: Pointer<DValue, 0, 'N', LValue> = [];\r\n    changeable: boolean = true;\r\n    volatile: boolean = true;\r\n    transient: boolean = false;\r\n    unsettable: boolean = false;// if the feature can be \"unsetted\" aka undefined/deleted ?\r\n    allowCrossReference!:boolean;\r\n    public derived!: boolean;\r\n    /*protected */derived_read?: string;\r\n    /*protected */derived_write?: string;\r\n    /*protected*/ __info_of__derived: Info = {type: 'string', txt:'A ECore flag to signal the values of this feature depend on other features.\\n' +\r\n            'To make it usable at runtime in jjodel check derived_read and derived_write.'}\r\n    /*protected*/ __info_of__derived_read: Info = {type: 'string', txt:'A function in string format with 2 or less attributes: (data, oldValue).\\n' +\r\n            '- data is the LValue hosting this derived feature\\n' +\r\n            '- originalValues are the current **non-derived** values actually memorized in the data.values\\n'+\r\n            'The mandatory return value of this function will be returned when attempted to read data.values.'}\r\n    /*protected*/ __info_of__derived_write: Info = {type: 'string', txt:'A function in string format with 3 or less attributes: (value, data, oldValue).\\n' +\r\n            '- value is the value currently attempted to be set, which triggered the function call.\\n' +\r\n            '- data is the LValue hosting this derived feature\\n' +\r\n            '- originalValues are the current **non-derived** values actually memorized in the data.values\\n'+\r\n            'The optional return value of this function will be stored inside data, allowing for hybrid dependency-persistant features' +\r\n            '\\n or for a feature \"depending on itself\". like uppercasing his values before setting them.'}\r\n    defaultValue!: (Pointer<DObject, 1, 1, LObject> | PrimitiveType)[];\r\n\r\n    public static new(name?: DNamedElement[\"name\"], type?: DTypedElement[\"type\"], father?: Pointer, persist: boolean = true): DStructuralFeature {\r\n        Log.exx(\"DStructuralFeature is abstract, cannot instantiate\");\r\n        return null as any;\r\n        // if (!name) name = this.defaultname(\"feature \", father);\r\n        // return new Constructors(new DStructuralFeature('dwc'), father, persist, undefined).DPointerTargetable().DModelElement().DNamedElement(name).DTypedElement(type).DStructuralFeature().end();\r\n    }\r\n    // getFeatureID(): number;\r\n    // getContainerClass(): EJavaClass\r\n}\r\n\r\n@Abstract\r\n@RuntimeAccessible('LStructuralFeature')\r\nexport class LStructuralFeature<Context extends LogicContext<DStructuralFeature> = any,\r\n    C extends Context = Context, D extends DStructuralFeature = DStructuralFeature>  extends LTypedElement { // DTypedElement\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DStructuralFeature;\r\n    id!: Pointer<DStructuralFeature, 1, 1, LStructuralFeature>;\r\n    // static singleton: LStructuralFeature;\r\n    // static logic: typeof LStructuralFeature;\r\n    // static structure: typeof DStructuralFeature;\r\n\r\n    // inherit redefine\r\n    annotations!: LAnnotation[];\r\n    parent!: LClass[];\r\n    father!: LClass;\r\n    name!: string;\r\n    namespace!: string;\r\n    type!: LClassifier;\r\n    ordered: boolean = true;\r\n    unique: boolean = true;\r\n    lowerBound: number = 0;\r\n    upperBound: number = 1;\r\n    many!: boolean;\r\n    required!: boolean;\r\n    public derived!: boolean;\r\n    /*protected */derived_read?: string;\r\n    /*protected */derived_write?: string;\r\n    /*protected*/ __info_of__derived: Info = {type: 'string', txt:'A ECore flag to signal the values of this feature depend on other features.\\n' +\r\n            'To make it usable at runtime in jjodel check derived_read and derived_write.'}\r\n    /*protected*/ __info_of__derived_read: Info = {type: 'string', txt:'A function in string format with 2 or less attributes: (data, oldValue).\\n' +\r\n            '- data is the LValue hosting this derived feature\\n' +\r\n            '- originalValues are the current **non-derived** values actually memorized in the data.values\\n'+\r\n            'The mandatory return value of this function will be returned when attempted to read data.values.'}\r\n    /*protected*/ __info_of__derived_write: Info = {type: 'string', txt:'A function in string format with 3 or less attributes: (value, data, oldValue).\\n' +\r\n            '- value is the value currently attempted to be set, which triggered the function call.\\n' +\r\n            '- data is the LValue hosting this derived feature\\n' +\r\n            '- originalValues are the current **non-derived** values actually memorized in the data.values\\n'+\r\n            'The optional return value of this function will be stored inside data, allowing for hybrid dependency-persistant features' +\r\n            '\\n or for a feature \"depending on itself\". like uppercasing his values before setting them.'}\r\n    // personal\r\n    instances!: LValue[];\r\n    changeable!: boolean;\r\n    volatile!: boolean;\r\n    transient!: boolean;\r\n    unsettable!: boolean;\r\n    // defaultValueLiteral!: string;\r\n    defaultValue!: (LObject[] | PrimitiveType[]);\r\n    // getFeatureID(): number;\r\n    // getContainerClass(): EJavaClass\r\n    allowCrossReference!:boolean;\r\n\r\n    get_crossReference(c: Context): this['allowCrossReference'] { return this.get_allowCrossReference(c); }\r\n    get_isCrossReference(c: Context): this['allowCrossReference'] { return this.get_allowCrossReference(c); }\r\n    set_crossReference(v: this['allowCrossReference'], c: Context): boolean { return this.set_allowCrossReference(v, c); }\r\n    set_isCrossReference(v: this['allowCrossReference'], c: Context): boolean { return this.set_allowCrossReference(v, c); }\r\n    get_allowCrossReference(c: Context): boolean { return c.data.allowCrossReference; }\r\n    set_allowCrossReference(v: this['allowCrossReference'], c: Context): boolean {\r\n        v = !!v;\r\n        if (v === c.data.allowCrossReference) return true;\r\n        TRANSACTION(this.get_name(c)+'.allowCrossReference', ()=>{\r\n            SetFieldAction.new(c.data, 'allowCrossReference', v);\r\n        }, c.data.allowCrossReference, v)\r\n        return true;\r\n    }\r\n\r\n    validTargetsJSX!: JSX.Element[];\r\n    get_validTargetsJSX(c: Context): this['validTargetsJSX'] {\r\n        let opts: MultiSelectOptGroup[] = [];\r\n        this.get_validTargets(c, opts);\r\n        return UX.options(opts);\r\n    }\r\n    validTargetOptions!: MultiSelectOptGroup[];\r\n    get_validTargetOptions(c: Context): this['validTargetOptions'] {\r\n        let opts: MultiSelectOptGroup[] = [];\r\n        this.get_validTargets(c, opts);\r\n        return opts;\r\n    }\r\n    validTargets!: (LObject | LEnumLiteral)[];\r\n    get_validTargets(c: Context, out?: MultiSelectOptGroup[]): this['validTargets'] {\r\n        let addClasses: boolean = false;\r\n        let addModels: boolean = false;\r\n        let addEnums: boolean = false;\r\n        let addPrimitives: boolean = false;\r\n        let addReturnTypes: boolean = false;\r\n        let isCrossRef = this.get_isCrossReference(c);\r\n        let d = c.data;\r\n        switch (d.className){\r\n            case DModel.cname:     addModels = true; break;\r\n            case DReference.cname: addClasses = true; break;\r\n            case DAttribute.cname:              addPrimitives = addEnums = true; break;\r\n            case DParameter.cname: addClasses = addPrimitives = addEnums = true; break;\r\n            case DOperation.cname: addClasses = addPrimitives = addEnums = addReturnTypes = true; break;\r\n        }\r\n        let m2: LModel = this.get_model(c);\r\n        let map = (object: LNamedElement): MultiSelectOption => {\r\n            let fname = object.fullname;\r\n            return {value:object.id, label: isCrossRef ? fname : object.name, title: object.fullname}\r\n        };\r\n        let map2 = (object: LNamedElement): MultiSelectOption => {\r\n            let name = object.name;\r\n            return {value:object.id, label: name, title: name}\r\n        };\r\n        let sort = (a:MultiSelectOption, b: MultiSelectOption) => (a.label > b.label ? +1 : -1);\r\n        let validClasses: LClass[] = [];\r\n        let validEnums: LEnumerator[] = [];\r\n        let validPrimitives: LClass[] = [];\r\n        let validModels: LModel[] = [];\r\n        let state: DState | null = null;\r\n        if (addModels) {\r\n            if (!state) state = store.getState();\r\n            validModels = LPointerTargetable.fromPointer(state.m2models);\r\n            if (out) out.push({label: 'Models', options: validModels.map(map2).sort(sort)});\r\n        }\r\n        if (addPrimitives) {\r\n            if (!state) state = store.getState();\r\n            validPrimitives = LPointerTargetable.fromPointer(state.primitiveTypes);\r\n        }\r\n        if (addReturnTypes) {\r\n            if (!state) state = store.getState();\r\n            U.arrayMergeInPlace(validPrimitives, LPointerTargetable.fromPointer(state.returnTypes));\r\n        }\r\n        if (out && validPrimitives.length) out.push({label: 'Primitives', options: validPrimitives.map(map2).sort(sort)});\r\n\r\n        if (addClasses) {\r\n            let m = this.get_model(c);\r\n            let pkgs = isCrossRef ? m.allCrossSubPackages : m.allSubPackages;\r\n            if (out) for (let pkg of pkgs){\r\n                let classes = pkg.classes;\r\n                if (classes.length === 0) continue;\r\n                out.push({label: 'Classes ('+pkg.fullname+')', options: classes.map(map2).sort(sort)});\r\n                U.arrayMergeInPlace(validClasses, classes);\r\n            } else validClasses = (isCrossRef ? m2.crossClasses : m2.classes);\r\n        }\r\n        if (addEnums) {\r\n            let m = this.get_model(c);\r\n            let pkgs = isCrossRef ? m.allCrossSubPackages : m.allSubPackages;\r\n            if (out) for (let pkg of pkgs){\r\n                let enums = pkg.enumerators;\r\n                if (enums.length === 0) continue;\r\n                out.push({label: 'Enumerators ('+pkg.fullname+')', options: enums.map(map2).sort(sort)});\r\n                U.arrayMergeInPlace(validEnums, enums);\r\n            } else validEnums = (isCrossRef ? m2.crossEnumerators : m2.enumerators);\r\n            //if (out) out.push({label: 'Enumerators', options: validEnums.map(map).sort(sort)});\r\n        }\r\n        return U.arrayMergeInPlace(validClasses as any[], validPrimitives, validEnums, validModels);\r\n    }\r\n    protected get_instances(context: Context): this[\"instances\"] {\r\n        return context.data.instances.map((pointer) => {\r\n            return LPointerTargetable.from(pointer)\r\n        });\r\n    }\r\n\r\n    protected set_instances(val: PackArr<this[\"instances\"]>, c: Context): boolean {\r\n        const list = val.map((lItem) => { return Pointers.from(lItem) });\r\n        TRANSACTION(this.get_name(c)+'.instances', ()=>{\r\n            SetFieldAction.new(c.data, 'instances', list, \"\", true);\r\n        })\r\n        return true;\r\n    }\r\n\r\n    protected get_changeable(context: Context): this[\"changeable\"] { return context.data.changeable; }\r\n    protected set_changeable(val: this[\"changeable\"], c: Context): boolean {\r\n        val = !!val;\r\n        if (c.data.changeable === val) return true;\r\n        TRANSACTION(this.get_name(c)+'.changeable', ()=>{\r\n            SetFieldAction.new(c.data, 'changeable', val);\r\n        }, c.data.changeable, val)\r\n        return true;\r\n    }\r\n\r\n    protected get_volatile(context: Context): this[\"volatile\"] { return context.data.volatile; }\r\n    protected set_volatile(val: this[\"volatile\"], c: Context): boolean {\r\n        val = !!val;\r\n        if (c.data.volatile === val) return true;\r\n        TRANSACTION(this.get_name(c)+'.volatile', ()=>{\r\n            SetFieldAction.new(c.data, 'volatile', val);\r\n        }, c.data.volatile, val)\r\n        return true;\r\n    }\r\n\r\n    protected get_transient(context: Context): this[\"transient\"] { return context.data.transient; }\r\n    protected set_transient(val: this[\"transient\"], c: Context): boolean {\r\n        val = !!val;\r\n        if (c.data.transient === val) return true;\r\n        TRANSACTION(this.get_name(c)+'.transient', ()=>{\r\n            SetFieldAction.new(c.data, 'transient', val);\r\n        }, c.data.transient, val)\r\n        return true;\r\n    }\r\n\r\n    protected get_unsettable(context: Context): this[\"unsettable\"] { return context.data.unsettable; }\r\n    protected set_unsettable(val: this[\"unsettable\"], c: Context): boolean {\r\n        val = !!val;\r\n        if (c.data.unsettable === val) return true;\r\n        TRANSACTION(this.get_name(c)+'.unsettable', ()=>{\r\n            SetFieldAction.new(c.data, 'unsettable', val);\r\n        }, c.data.unsettable, val)\r\n        return true;\r\n    }\r\n\r\n    protected get_derived(context: Context): D[\"derived\"] { return context.data.derived; }\r\n    protected set_derived(val: D[\"derived\"], c: Context): boolean {\r\n        val = !!val;\r\n        if (c.data.derived === val) return true;\r\n        TRANSACTION(this.get_name(c)+'.derived', ()=>{\r\n            SetFieldAction.new(c.data, 'derived', val);\r\n        }, c.data.derived, val)\r\n        return true;\r\n    }\r\n    /*\r\n        protected get_defaultValueLiteral(context: Context): this[\"defaultValueLiteral\"] { return context.data.defaultValueLiteral; }\r\n        protected set_defaultValueLiteral(val: this[\"defaultValueLiteral\"], context: Context): boolean {\r\n            SetFieldAction.new(context.data, 'defaultValueLiteral', val, \"\", false);\r\n            return true;\r\n        }*/\r\n}\r\nRuntimeAccessibleClass.set_extend(DTypedElement, DStructuralFeature);\r\nRuntimeAccessibleClass.set_extend(LTypedElement, LStructuralFeature);\r\n\r\n@Instantiable // DValue\r\n@Leaf\r\n@RuntimeAccessible('DReference')\r\nexport class DReference extends DPointerTargetable { // DStructuralFeature\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LReference;\r\n    // static logic: typeof LReference;\r\n    // static structure: typeof DReference;\r\n\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DReference, 1, 1, LReference>;\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    name!: string;\r\n    type!: Pointer<DClass, 1, 1, LClass>;\r\n    ordered: boolean = true;\r\n    unique: boolean = true;\r\n    lowerBound: number = 0;\r\n    upperBound: number = 1;\r\n    many!: boolean;\r\n    required!: boolean;\r\n    changeable: boolean = true;\r\n    volatile: boolean = true;\r\n    transient: boolean = false;\r\n    unsettable: boolean = false;\r\n    defaultValueLiteral: string = '';\r\n    parent: Pointer<DClass, 0, 'N', LClass> = [];\r\n    father!: Pointer<DClass, 1, 1, LClass>;\r\n    instances: Pointer<DValue, 0, 'N', LValue> = [];\r\n    defaultValue!: Pointer<DObject, 1, 1, LObject>[];\r\n    allowCrossReference!:boolean;\r\n    public derived!: boolean;\r\n    /*protected */derived_read?: string;\r\n    /*protected */derived_write?: string;\r\n    /*protected*/ __info_of__derived: Info = {type: 'string', txt:'A ECore flag to signal the values of this feature depend on other features.\\n' +\r\n            'To make it usable at runtime in jjodel check derived_read and derived_write.'}\r\n    /*protected*/ __info_of__derived_read: Info = {type: 'string', txt:'A function in string format with 2 or less attributes: (data, oldValue).\\n' +\r\n            '- data is the LValue hosting this derived feature\\n' +\r\n            '- originalValues are the current **non-derived** values actually memorized in the data.values\\n'+\r\n            'The mandatory return value of this function will be returned when attempted to read data.values.'}\r\n    /*protected*/__info_of__derived_write: Info = {type: 'string', txt:'A function in string format with 3 or less attributes: (value, data, oldValue).\\n' +\r\n            '- value is the value currently attempted to be set, which triggered the function call.\\n' +\r\n            '- data is the LValue hosting this derived feature\\n' +\r\n            '- originalValues are the current **non-derived** values actually memorized in the data.values\\n'+\r\n            'The optional return value of this function will be stored inside data, allowing for hybrid dependency-persistant features' +\r\n            '\\n or for a feature \"depending on itself\". like uppercasing his values before setting them.'}\r\n\r\n    // personal\r\n    rootable?:boolean;\r\n    composition: boolean = false;\r\n    aggregation: boolean = false; // exist in uml but not in ecore\r\n    container: boolean = false;\r\n    __info_of__container: Info = {type: 'boolean', txt: \"A reference is a container if it has an opposite that is a containment.\"};\r\n    opposite?: Pointer<DReference>;\r\n    target: Pointer<DClass, 0, 'N', LClass> = [];\r\n    edges: Pointer<DEdge, 0, 'N', LEdge> = [];\r\n\r\n    public static new(name?: DReference[\"name\"], type?: DReference[\"type\"], father?: DReference[\"father\"], persist: boolean = true): DReference {\r\n        if (!type) type = father // default type is self-reference\r\n        if (!name) name = this.defaultname(\"ref_\", father);\r\n        return new Constructors(new DReference('dwc'), father, persist, undefined).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DTypedElement(type).DStructuralFeature().DReference().end();\r\n    }\r\n\r\n    static new2(setter: Partial<ObjectWithoutPointers<DReference>>, father: DReference[\"father\"], type?: DReference[\"type\"], name?: DReference[\"name\"]): DReference {\r\n        if (!name) name = this.defaultname((name || \"ref_\"), father);\r\n        return new Constructors(new DReference('dwc'), father, true, undefined).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DTypedElement(type).DStructuralFeature().DReference()\r\n            .end((d) => { Object.assign(d, setter); });\r\n    }\r\n\r\n    static new3(a: Partial<ReferencePointers>, callback: undefined | ((d: DReference, c: Constructors) => void), persist: boolean = true): DReference {\r\n        if (!a.name) a.name = this.defaultname(\"ref_\", a.father);\r\n        return new Constructors(new DReference('dwc'), a.father, persist, undefined, a.id).DPointerTargetable().DModelElement()\r\n            .DPointerTargetable().DModelElement().DNamedElement(a.name)\r\n            .DTypedElement(a.type).DStructuralFeature().DReference()\r\n            .end(callback);\r\n    }\r\n\r\n}\r\n\r\n@Instantiable // LValue\r\n@Leaf\r\n@RuntimeAccessible('LReference')\r\nexport class LReference<Context extends LogicContext<DReference> = any, C extends Context = Context, D extends DReference = DReference>  extends LStructuralFeature {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DReference;\r\n    id!: Pointer<DReference, 1, 1, LReference>;\r\n    // static singleton: LReference;\r\n    // static logic: typeof LReference;\r\n    // static structure: typeof DReference;\r\n\r\n    // inherit redefine\r\n    annotations!: LAnnotation[];\r\n    name!: string;\r\n    namespace!: string;\r\n    type!: LClass;\r\n    ordered!: boolean;\r\n    unique!: boolean;\r\n    lowerBound!: number;\r\n    upperBound!: number;\r\n    many!: boolean;\r\n    required!: boolean;\r\n    changeable!: boolean;\r\n    volatile!: boolean;\r\n    transient!: boolean;\r\n    unsettable!: boolean;\r\n    allowCrossReference!:boolean;\r\n    public derived!: boolean;\r\n    /*protected */derived_read?: string;\r\n    /*protected */derived_write?: string;\r\n    /*protected */__info_of__derived: Info = {type: 'string', txt:'A ECore flag to signal the values of this feature depend on other features.\\n' +\r\n            'To make it usable at runtime in jjodel check derived_read and derived_write.'}\r\n    /*protected */__info_of__derived_read: Info = {type: 'string', txt:'A function in string format with 2 or less attributes: (data, oldValue).\\n' +\r\n            '- data is the LValue hosting this derived feature\\n' +\r\n            '- originalValues are the current **non-derived** values actually memorized in the data.values\\n'+\r\n            'The mandatory return value of this function will be returned when attempted to read data.values.'}\r\n    /*protected */__info_of__derived_write: Info = {type: 'string', txt:'A function in string format with 3 or less attributes: (value, data, oldValue).\\n' +\r\n            '- value is the value currently attempted to be set, which triggered the function call.\\n' +\r\n            '- data is the LValue hosting this derived feature\\n' +\r\n            '- originalValues are the current **non-derived** values actually memorized in the data.values\\n'+\r\n            'The optional return value of this function will be stored inside data, allowing for hybrid dependency-persistant features' +\r\n            '\\n or for a feature \"depending on itself\". like uppercasing his values before setting them.'}\r\n    defaultValueLiteral!: string;\r\n    parent!: LClass[];\r\n    father!: LClass;\r\n    instances!: LValue[];\r\n    defaultValue!: LObject[];\r\n\r\n    // personal\r\n    composition!: boolean; // aggregation || containment\r\n    aggregation!: boolean;\r\n    containment!: boolean;\r\n    container!: boolean;\r\n\r\n    rootable?:boolean;\r\n    __info_of__rootable: Info = {type:\"boolean | undefined\",\r\n        txt: \"if missing, only classes not contained, not abstract and not interface can be a model root. if present this dictates it.\"};\r\n    __info_of__composition: Info = {type:\"boolean\",\r\n        txt: \"Defines a \\\"part of\\\" relationship where the target cannot exist without the source. Building -> Room \\\"A Room cannot exist without a Building\\\"\"};\r\n    __info_of__aggregation: Info = {type:\"boolean\",\r\n        txt: \"Defines a \\\"part of\\\" relationship where the target can exist without the source. Building -> Student \\\"A Student can exist outside a Building\\\"\"};\r\n    opposite?: LReference;\r\n    // target!: LClass[]; replaced by type\r\n    edges!: LEdge[];\r\n\r\n\r\n\r\n    protected generateEcoreJson_impl(context: Context, loopDetectionObj: Dictionary<Pointer, DModelElement> = {}): Json {\r\n        loopDetectionObj[context.data.id] = context.data;\r\n        const model: GObject = {};\r\n        const d = context.data;\r\n        const l = context.proxyObject;\r\n        model[ECoreReference.xsitype] = 'ecore:EReference';\r\n        model[ECoreReference.eType] = l.type.typeEcoreString;\r\n        model[ECoreReference.namee] = d.name;\r\n        if (d.lowerBound != null && !isNaN(+d.lowerBound)) { model[ECoreReference.lowerbound] = +d.lowerBound; }\r\n        if (d.upperBound != null && !isNaN(+d.upperBound)) { model[ECoreReference.upperbound] = +d.upperBound; }\r\n        let cont = d.aggregation || d.composition;\r\n        if (cont != null) { model[ECoreReference.containment] = cont; }\r\n        if (d.container != null) { model[ECoreReference.container] = d.container; }\r\n        return model; }\r\n\r\n    public duplicate(deep: boolean = true): this {\r\n        return this.cannotCall( ((this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name) + \"duplicate()\"); }\r\n    protected get_duplicate(context: Context): ((deep?: boolean) => LReference) {\r\n        return (deep: boolean = false) => {\r\n            let ret: LReference = undefined as any;\r\n            TRANSACTION('duplicate ' + this.get_name(context), ()=>{\r\n                let le: LReference = context.proxyObject.father.addReference(context.data.name, context.data.type);\r\n                let de: D = le.__raw as D;\r\n                de.many = context.data.many;\r\n                de.lowerBound = context.data.lowerBound;\r\n                de.upperBound = context.data.upperBound;\r\n                de.ordered = context.data.ordered;\r\n                de.required = context.data.required;\r\n                de.unique = context.data.unique;\r\n                de.changeable = context.data.changeable;\r\n                de.container = context.data.container;\r\n                de.composition = context.data.composition;\r\n                de.aggregation = context.data.aggregation;\r\n                de.defaultValueLiteral = context.data.defaultValueLiteral;\r\n                de.derived = context.data.derived;\r\n                de.transient = context.data.transient;\r\n                de.unsettable = context.data.unsettable;\r\n                de.volatile = context.data.unsettable;\r\n                let we: WReference = le as any;\r\n                we.opposite = context.data.opposite || undefined;\r\n                we.defaultValue = context.data.defaultValue;\r\n                we.type = context.data.type;\r\n                we.annotations = deep ? context.proxyObject.annotations.map(lchild => lchild.duplicate(deep).id) : context.data.annotations;\r\n                // we.target = deep ? context.proxyObject.target.map(lchild => lchild.duplicate(deep).id) : context.data.target;\r\n                ret = le;\r\n            })\r\n            return ret; }\r\n    }\r\n\r\n    protected set_type(val: Pack1<this[\"type\"]>, context: Context): boolean {\r\n        super.set_type(val, context);\r\n        return true;\r\n    }\r\n\r\n    public addClass(name?: DClass[\"name\"], isInterface?: DClass[\"interface\"], isAbstract?: DClass[\"abstract\"], isPrimitive?: DClass[\"isPrimitive\"],\r\n                    isPartial?: DClass[\"partial\"], partialDefaultName?: DClass[\"partialdefaultname\"]): LClass {\r\n        return this.cannotCall(\"LReference.addClass\"); }\r\n    protected get_addClass(c: Context): this[\"addClass\"] {\r\n        return (name?: DClass[\"name\"], isInterface?: DClass[\"interface\"], isAbstract?: DClass[\"abstract\"], isPrimitive?: DClass[\"isPrimitive\"],\r\n                isPartial?: DClass[\"partial\"], partialDefaultName?: DClass[\"partialdefaultname\"]) => {\r\n            let dclass: DClass = null as any\r\n            TRANSACTION(this.get_name(c)+'.addClass()', ()=>{\r\n                dclass = DClass.new(name, isInterface, isAbstract, isPrimitive, isPartial, partialDefaultName, c.proxyObject.package!.id, true);\r\n                // SetFieldAction.new(context.data.id, \"type\", dclass.id);\r\n                this.set_type(dclass.id as any, c);\r\n            }, undefined, name)\r\n            return LPointerTargetable.fromD(dclass);\r\n        } }\r\n\r\n\r\n    get_containment(context: Context): this[\"containment\"] { return context.data.composition || context.data.aggregation; }\r\n    set_containment(val: this[\"containment\"], c: Context, mainkey:'composition'|'aggregation' = 'composition', altkey:'composition'|'aggregation' = 'aggregation'): boolean {\r\n        // return this.cannotSet('containment', 'set aggregation or composition instead');\r\n        val = !!val;\r\n        if (!!c.data[mainkey] === val) return true;\r\n        TRANSACTION(this.get_name(c)+'.'+mainkey, ()=>{\r\n            // set composition and unset aggregation or viceversa\r\n            SetFieldAction.new(c.data, mainkey, val);\r\n            if (val && c.data[altkey]) SetFieldAction.new(c.data, altkey, !val);\r\n            let containedObjects: Dictionary<Pointer, LObject> = {};\r\n            let removedValues: Pointer[] = [];\r\n            let parentChanges: LObject[] = [];\r\n            for (let lval of this.get_instances(c) as LValue[]) {\r\n                // todo: in set_values crop the arr to max upperbound\r\n                let dval = lval.__raw\r\n                let values = dval.values;\r\n                let lmodel = lval.model;\r\n                let dmodel = lmodel.__raw;\r\n                for (let ptr of values) {\r\n                    if (!Pointers.isPointer(ptr)) continue;\r\n                    if (containedObjects[ptr]) {\r\n                        // Log.ee('Cannot activate ' + mainkey+ ' on this reference because some objects are referenced twice in the model')\r\n                        // todo: ask for confirmation if want to abort or delete those values.\r\n                        if (val) {\r\n                            SetFieldAction.new(dval, 'values', ptr as any, '-=', true); // if is containment=true prevent the targets from being contained twice}\r\n                            removedValues.push(ptr);\r\n                            continue;\r\n                        }\r\n                    }\r\n                    // update parent\r\n                    let pointedobj = containedObjects[ptr] = LPointerTargetable.fromPointer(ptr);\r\n                    let newid = (val ? dval.id : dmodel.id) as any;\r\n                    let oldparent = pointedobj.father;\r\n                    if (oldparent?.id === newid) continue;\r\n                    pointedobj.father = newid;\r\n                    parentChanges.push(pointedobj);\r\n                }\r\n            }\r\n            if (removedValues.length || parentChanges.length){\r\n                Log.ww([\r\n                    removedValues.length ? removedValues.length+' values were removed':undefined,\r\n                    parentChanges.length ? parentChanges.length+' parents were changed':undefined\r\n                ].filter(e=>!!e).join(' and ') + ' as result.',//\\n If you want to check chem, write \"containmentSideEffects[\\''+c.data.id+'\\']\" in console.',\r\n                {removedValues, parentChanges}\r\n                );\r\n            }\r\n            //if (!windoww.containmentSideEffects) windoww.containmentSideEffects = {};\r\n            //windoww.containmentSideEffects[c.data.id] = {removedValues, parentChanges};\r\n        }, c.data[mainkey], val);\r\n        return true;\r\n    }\r\n\r\n    protected get_aggregation(context: Context): this[\"aggregation\"] { return context.data.aggregation; }\r\n    protected get_composition(context: Context): this[\"composition\"] { return context.data.composition; }\r\n    /*\r\n    protected get_container(context: Context): this[\"container\"] { return context.data.container; }\r\n    protected set_container(val: this[\"container\"], context: Context): boolean { return SetFieldAction.new(context.data, 'container', val); }*/\r\n\r\n    protected set_aggregation(val: this[\"aggregation\"], c: Context): boolean { return this.set_containment(val, c, 'aggregation', 'composition'); }\r\n    protected set_composition(val: this[\"composition\"], c: Context): boolean { return this.set_containment(val, c, 'composition', 'aggregation'); }\r\n\r\n    protected get_opposite(context: Context): this[\"opposite\"] { return context.data.opposite && LPointerTargetable.from(context.data.opposite); }\r\n    protected set_opposite(val: Pack<LReference | undefined>, c: Context): boolean {\r\n        let ptr = Pointers.from(val) as any as LAnnotation[\"id\"];\r\n        if (ptr === c.data.opposite) return true;\r\n        TRANSACTION(this.get_name(c)+'.opposite', ()=>{\r\n            SetFieldAction.new(c.data, 'opposite', ptr, \"\", true);\r\n        }, LPointerTargetable.wrap(c.data.opposite)?.fullname, LPointerTargetable.wrap(ptr)?.fullname)\r\n        return true;\r\n    }\r\n    /*\r\n        /// todo: why this exist?  why not type?\r\n        protected get_target(context: Context): this[\"target\"] { return context.data.target.map(pointer => LPointerTargetable.from(pointer)); }\r\n        protected set_target(val: PackArr<this[\"target\"]>, context: Context): boolean {\r\n            const list = val.map((lItem) => { return Pointers.from(lItem) });\r\n            SetFieldAction.new(context.data, 'target', list, \"\", true);\r\n            return true;\r\n        }*/\r\n\r\n    protected get_defaultValue(context: Context): this[\"defaultValue\"] { return LPointerTargetable.fromPointer(context.data.defaultValue); }\r\n    protected set_defaultValue(val: PackArr<this[\"defaultValue\"]>, c: Context): boolean {\r\n        // @ts-ignore\r\n        if (!val) (val) = []; else if (!Array.isArray(val)) val = [val];\r\n        let ptrs = Pointers.from(val);\r\n        TRANSACTION(this.get_name(c)+'.defaultValue', ()=>{\r\n            SetFieldAction.new(c.data, 'defaultValue', ptrs, '', false);\r\n        })\r\n        return true; }\r\n\r\n    protected get_edges(context: Context): this[\"edges\"] {\r\n        return context.data.edges.map((pointer) => {\r\n            return LPointerTargetable.from(pointer)\r\n        });\r\n    }\r\n    protected set_edges(val: PackArr<this[\"edges\"]>, c: Context): boolean {\r\n        const list = val.map((lItem) => { return Pointers.from(lItem) });\r\n        TRANSACTION(this.get_name(c)+'.edges', ()=>{\r\n            SetFieldAction.new(c.data, 'edges', list, \"\", true);\r\n        })\r\n        return true;\r\n    }\r\n}\r\nRuntimeAccessibleClass.set_extend(DStructuralFeature, DReference);\r\nRuntimeAccessibleClass.set_extend(LStructuralFeature, LReference);\r\nfunction has_opposite(oppositename: string, ...comments: string[]): any {\r\n    // return (c:Constructor, key:string, ):any =>{}\r\n}\r\nfunction obsolete_attribute(...comments: string[]) {\r\n    return undefined as any; // function(c:Constructor, key:string,): any {}\r\n}\r\n\r\n@Leaf\r\n@RuntimeAccessible('DAttribute')\r\nexport class DAttribute extends DPointerTargetable { // DStructuralFeature\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LAttribute;\r\n    // static logic: typeof LAttribute;\r\n    // static structure: typeof DAttribute;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DAttribute, 1, 1, LAttribute>;\r\n    // @has_opposite(\"father\")\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    name!: string;\r\n    type!: Pointer<DClassifier, 1, 1, LClassifier>;\r\n    ordered: boolean = true;\r\n    unique: boolean = true;\r\n    lowerBound: number = 0;\r\n    upperBound: number = 1;\r\n    many!: boolean;\r\n    required!: boolean;\r\n    changeable: boolean = true;\r\n    volatile: boolean = true;\r\n    transient: boolean = false;\r\n    unsettable: boolean = false;\r\n    defaultValueLiteral: string = '';\r\n    allowCrossReference!:boolean;\r\n    public derived!: boolean;\r\n    /*protected */derived_read?: string;\r\n    /*protected */derived_write?: string;\r\n    /*protected*/ __info_of__derived: Info = {type: 'string', txt:'A ECore flag to signal the values of this feature depend on other features.\\n' +\r\n            'To make it usable at runtime in jjodel check derived_read and derived_write.'}\r\n    /*protected*/ __info_of__derived_read: Info = {type: 'string', txt:'A function in string format with 2 or less attributes: (data, oldValue).\\n' +\r\n            '- data is the LValue hosting this derived feature\\n' +\r\n            '- originalValues are the current **non-derived** values actually memorized in the data.values\\n'+\r\n            'The mandatory return value of this function will be returned when attempted to read data.values.'}\r\n    /*protected*/ __info_of__derived_write: Info = {type: 'string', txt:'A function in string format with 3 or less attributes: (value, data, oldValue).\\n' +\r\n            '- value is the value currently attempted to be set, which triggered the function call.\\n' +\r\n            '- data is the LValue hosting this derived feature\\n' +\r\n            '- originalValues are the current **non-derived** values actually memorized in the data.values\\n'+\r\n            'The optional return value of this function will be stored inside data, allowing for hybrid dependency-persistant features' +\r\n            '\\n or for a feature \"depending on itself\". like uppercasing his values before setting them.'}\r\n    //@obsolete_attribute()\r\n    parent: Pointer<DClass, 0, 'N', LClass> = [];\r\n\r\n    //@has_opposite(\"attributes\")\r\n    father!: Pointer<DClass, 1, 1, LClass>;\r\n\r\n    //@has_opposite(\"instanceof\")\r\n    instances: Pointer<DValue, 0, 'N', LValue> = [];\r\n    defaultValue!: PrimitiveType[];\r\n\r\n    // personal\r\n    isID: boolean = false; // ? exist in ecore as \"iD\" ?\r\n    isIoT: boolean = false;\r\n\r\n    public static new(name?: DAttribute[\"name\"], type?: DAttribute[\"type\"], father?: DAttribute[\"father\"], persist: boolean = true): DAttribute {\r\n        if (!name) name = this.defaultname(\"attr_\", father);\r\n        if (!type) type = LPointerTargetable.from(Selectors.getFirstPrimitiveTypes()).id; // default type as string\r\n        return new Constructors(new DAttribute('dwc'), father, persist, undefined).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DTypedElement(type).DStructuralFeature().DAttribute().end();\r\n    }\r\n    static new2(setter: Partial<ObjectWithoutPointers<DReference>>, father: DAttribute[\"father\"], type?: DAttribute[\"type\"], name?: DAttribute[\"name\"]): DAttribute {\r\n        if (!name) name = this.defaultname((name || \"ref_\"), father);\r\n        return new Constructors(new DAttribute('dwc'), father, true, undefined).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DTypedElement(type).DStructuralFeature().DAttribute()\r\n            .end((d) => { Object.assign(d, setter); });\r\n    }\r\n    static new3(a: Partial<AttributePointers>, callback: undefined | ((d: DAttribute, c: Constructors) => void), persist: boolean = true): DAttribute {\r\n        if (!a.name) a.name = this.defaultname(\"attr_\", a.father);\r\n        return new Constructors(new DAttribute('dwc'), a.father, persist, undefined, a.id)\r\n            .DPointerTargetable().DModelElement().DNamedElement(a.name)\r\n            .DTypedElement(a.type).DStructuralFeature().DAttribute()\r\n            .end(callback);\r\n    }\r\n}\r\n\r\n\r\n@Leaf\r\n@Instantiable // (LValue)\r\n@RuntimeAccessible('LAttribute')\r\nexport class LAttribute <Context extends LogicContext<DAttribute> = any, C extends Context = Context, D extends DAttribute = DAttribute> extends LStructuralFeature { // DStructuralFeature\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DAttribute;\r\n    id!: Pointer<DAttribute, 1, 1, LAttribute>;\r\n    // static singleton: LAttribute;\r\n    // static logic: typeof LAttribute;\r\n    // static structure: typeof DAttribute;\r\n\r\n    // inherit redefine\r\n    annotations!: LAnnotation[];\r\n    name!: string;\r\n    namespace!: string;\r\n    type!: LClassifier;\r\n    ordered!: boolean;\r\n    unique!: boolean;\r\n    lowerBound!: number;\r\n    upperBound!: number;\r\n    many!: boolean;\r\n    required!: boolean;\r\n    changeable!: boolean;\r\n    volatile!: boolean;\r\n    transient!: boolean;\r\n    unsettable!: boolean;\r\n    // defaultValueLiteral!: string;\r\n    defaultValue!: PrimitiveType[];\r\n    parent!: LClass[];\r\n    father!: LClass;\r\n    instances!: LValue[];\r\n\r\n    // personal\r\n    isID: boolean = false; // ? exist in ecore as \"iD\" ?\r\n    isIoT: boolean = false;\r\n    allowCrossReference!:boolean;\r\n\r\n    protected generateEcoreJson_impl(context: Context, loopDetectionObj: Dictionary<Pointer, DModelElement> = {}): Json {\r\n        loopDetectionObj[context.data.id] = context.data;\r\n        const model = {};\r\n        const d = context.data;\r\n        const l = context.proxyObject;\r\n        EcoreParser.write(model, ECoreAttribute.xsitype, 'ecore:EAttribute');\r\n        EcoreParser.write(model, ECoreAttribute.eType, l.type.typeEcoreString);\r\n        EcoreParser.write(model, ECoreAttribute.namee, d.name);\r\n        EcoreParser.write(model, ECoreAttribute.lowerbound, '' + d.lowerBound);\r\n        EcoreParser.write(model, ECoreAttribute.upperbound, '' + d.upperBound);\r\n        return model; }\r\n\r\n\r\n    public duplicate(deep: boolean = true): this {\r\n        return this.cannotCall( ((this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name) + \"duplicate()\"); }\r\n    protected get_duplicate(context: Context): ((deep?: boolean) => LAttribute) {\r\n        return (deep: boolean = false) => {\r\n            let ret: LAttribute = null as any;\r\n            TRANSACTION('duplicate ' + this.get_name(context), ()=>{\r\n                let le: LAttribute = context.proxyObject.father.addAttribute(context.data.name, context.data.type);\r\n                let de: D = le.__raw as D;\r\n                de.many = context.data.many;\r\n                de.lowerBound = context.data.lowerBound;\r\n                de.upperBound = context.data.upperBound;\r\n                de.ordered = context.data.ordered;\r\n                de.required = context.data.required;\r\n                de.unique = context.data.unique;\r\n                de.changeable = context.data.changeable;\r\n                de.defaultValue = context.data.defaultValue;\r\n                de.defaultValueLiteral = context.data.defaultValueLiteral;\r\n                de.derived = context.data.derived;\r\n                de.transient = context.data.transient;\r\n                de.unsettable = context.data.unsettable;\r\n                de.volatile = context.data.volatile;\r\n                de.isID = context.data.isID;\r\n                de.isIoT = context.data.isIoT;\r\n                let we: WAttribute = le as any;\r\n                we.type = context.data.type;\r\n                we.annotations = deep ? context.proxyObject.annotations.map(lchild => lchild.duplicate(deep).id) : context.data.annotations;\r\n                ret = le;\r\n            })\r\n            return ret; }\r\n    }\r\n\r\n    public addEnum(...p:Parameters<this[\"addEnumerator\"]>): LEnumerator { return this.addEnumerator(...p); }\r\n    protected get_addEnum(context: Context): this[\"addEnumerator\"] { return this.get_addEnumerator(context); }\r\n    public addEnumerator(name?: DEnumerator[\"name\"], father?: DEnumerator[\"father\"]): LEnumerator { return this.cannotCall(\"Attribute.addEnumerator\"); }\r\n    protected get_addEnumerator(context: Context): this[\"addEnumerator\"] {\r\n        return (name?: DEnumerator[\"name\"], father?: DEnumerator[\"father\"]) => LPointerTargetable.fromD(DEnumerator.new(name, context.proxyObject.package?.id, true)); }\r\n\r\n    protected get_isID(context: Context): this[\"isID\"] { return context.data.isID; }\r\n    protected set_isID(val: this[\"isID\"], c: Context): boolean {\r\n        val = !!val;\r\n        if (!!c.data.isID === val) return true;\r\n        TRANSACTION(this.get_name(c)+'.isID', ()=>{\r\n            SetFieldAction.new(c.data, 'isID', val);\r\n        }, c.data.isID, val)\r\n        return true;\r\n    }\r\n    protected get_isIoT(context: Context): this[\"isIoT\"] { return context.data.isIoT; }\r\n    protected set_isIoT(val: this[\"isIoT\"], c: Context): boolean {\r\n        val = !!val;\r\n        if (!!c.data.isIoT === val) return true;\r\n        TRANSACTION(this.get_name(c)+'.isIoT', () => {\r\n            for (const value of c.proxyObject.instances) {\r\n                SetFieldAction.new(value, 'topic', '', '', false);\r\n            }\r\n            SetFieldAction.new(c.data, 'isIoT', val);\r\n        }, c.data.isIoT, val)\r\n        return true;\r\n    }\r\n    protected get_defaultValue(context: Context): this[\"defaultValue\"] { return context.data.defaultValue; }\r\n    protected set_defaultValue(val: unArr<this[\"defaultValue\"]>, c: Context): boolean {\r\n        // @ts-ignore\r\n        if (!val) (val) = []; else if (!Array.isArray(val)) val = [val];\r\n        TRANSACTION(this.get_name(c)+'.defaultValue', ()=>{\r\n            SetFieldAction.new(c.data, 'defaultValue', val, '', false);\r\n        })\r\n        return true; }\r\n\r\n}\r\nRuntimeAccessibleClass.set_extend(DStructuralFeature, DAttribute);\r\nRuntimeAccessibleClass.set_extend(LStructuralFeature, LAttribute);\r\n\r\n@Leaf\r\n@RuntimeAccessible('DEnumLiteral')\r\nexport class DEnumLiteral extends DPointerTargetable { // DNamedElement\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LAttribute;\r\n    // static logic: typeof LAttribute;\r\n    // static structure: typeof DAttribute;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DEnumLiteral, 1, 1, LEnumLiteral>;\r\n    parent: Pointer<DEnumerator, 0, 'N', LEnumerator> = [];\r\n    father!: Pointer<DEnumerator, 1, 1, LEnumerator>;\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    name!: string;\r\n    // personal\r\n    value!: number;\r\n    // ordinal: number=1; replaced by value\r\n    literal!: string;\r\n\r\n    public static new(name?: DNamedElement[\"name\"], value?: DEnumLiteral[\"value\"], father?: Pointer, persist: boolean = true): DEnumLiteral { //vv4\r\n        if (!name) name = this.defaultname(\"literal \", father);\r\n        return new Constructors(new DEnumLiteral('dwc'), father, persist, undefined).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DEnumLiteral(value).end();\r\n    }\r\n    static new2(setter: Partial<ObjectWithoutPointers<DEnumLiteral>>, father: DEnumLiteral[\"father\"], name?: DEnumLiteral[\"name\"]): DEnumLiteral {\r\n        if (!name) name = this.defaultname(\"literal \", father);\r\n        return new Constructors(new DEnumLiteral('dwc'), father, true, undefined).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DEnumLiteral()\r\n            .end((d) => { Object.assign(d, setter); });\r\n    }\r\n    static new3(a: Partial<LiteralPointers>, callback: undefined | ((d: DEnumLiteral, c: Constructors) => void), persist: boolean = true): DEnumLiteral {\r\n        if (!a.name) a.name = this.defaultname(\"literal_\", a.father);\r\n        return new Constructors(new DEnumLiteral('dwc'), a.father, persist, undefined, a.id)\r\n            .DPointerTargetable().DModelElement().DNamedElement(a.name)\r\n            .DEnumLiteral()\r\n            .end(callback);\r\n    }\r\n}\r\n\r\n@Leaf\r\n@RuntimeAccessible('LEnumLiteral')\r\nexport class LEnumLiteral<Context extends LogicContext<DEnumLiteral> = any, C extends Context = Context, D extends DEnumLiteral = DEnumLiteral>  extends LNamedElement { // DNamedElement\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DEnumLiteral;\r\n    id!: Pointer<DEnumLiteral, 1, 1, LEnumLiteral>;\r\n    // static singleton: LAttribute;\r\n    // static logic: typeof LAttribute;\r\n    // static structure: typeof DAttribute;\r\n\r\n    // inherit redefine\r\n    parent!: LEnumerator[];\r\n    father!: LEnumerator;\r\n    annotations!: LAnnotation[];\r\n    name!: string;\r\n    namespace!: string;\r\n    // personal\r\n    value!: this[\"ordinal\"];\r\n    ordinal!: number;\r\n    literal!: string;\r\n\r\n    protected generateEcoreJson_impl(context: Context, loopDetectionObj: Dictionary<Pointer, DModelElement> = {}): Json {\r\n        loopDetectionObj[context.data.id] = context.data;\r\n        const json: Json = {};\r\n        const d = context.data;\r\n        json[EcoreLiteral.value] = d.value;\r\n        json[EcoreLiteral.literal] = d.literal;\r\n        json[EcoreLiteral.namee] = d.name;\r\n        return json; }\r\n\r\n    public generateEcoreJsonM1(): this[\"ordinal\"] { return this.cannotCall(\"GenerateEcoreJsonM1\"); }\r\n    protected get_generateEcoreJsonM1(context: Context): () => this[\"ordinal\"] { return this.impl_generateEcoreJsonM1(context); }\r\n    protected impl_generateEcoreJsonM1(context: Context): () => this[\"ordinal\"] {\r\n        // loopDetectionObj[context.data.id] = context.data; no loop detection here, the same literal can be exported multiple times in m1\r\n        // return context.data.literal;\r\n        // return context.data.name;\r\n        return () => context.data.value; }\r\n\r\n\r\n    public duplicate(deep: boolean = true): this {\r\n        return this.cannotCall( ((this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name) + \"duplicate()\"); }\r\n    protected get_duplicate(c: Context): ((deep?: boolean) => LEnumLiteral) {\r\n        return (deep: boolean = false) => {\r\n            let ret: LEnumLiteral = null as any;\r\n            TRANSACTION(this.get_name(c)+'.duplicate()', ()=>{\r\n                let le: LEnumLiteral = c.proxyObject.father.addLiteral(c.data.name, c.data.value);\r\n                let de: D = le.__raw as D;\r\n                de.literal = c.data.literal;\r\n                de.value = c.data.value;\r\n                let we: WEnumLiteral = le as any;\r\n                we.annotations = deep ? c.proxyObject.annotations.map(lchild => lchild.duplicate(deep).id) : c.data.annotations;\r\n                ret = le;\r\n            })\r\n            return ret; }\r\n    }\r\n\r\n\r\n    protected get_ordinal(context: Context): this[\"ordinal\"] { return this.get_value(context); }\r\n    protected set_ordinal(val: this[\"ordinal\"], context: Context): boolean { return this.set_value(val, context); }\r\n\r\n    protected get_value(context: Context): this[\"value\"] {\r\n        let ordinalAssumedByPosition = true; // per ottimizzazione forse è disattivabile\r\n        if (!ordinalAssumedByPosition) return context.data.value || 0;\r\n        return context.proxyObject.father.ordinals.map( o => o?.id).indexOf(context.data.id);\r\n    }\r\n    protected set_value(val: this[\"value\"], c: Context): boolean {\r\n        if (val === c.data.value) return true;\r\n        let ordinals = (this.get_father(c) as LEnumerator).ordinals;\r\n        if (ordinals[val]) {\r\n            Log.e(true, \"that ordinal place is already taken by \" + ordinals[val].name, {sameOrdinalLit:ordinals[val], ordinals, thiss:c.data});\r\n            return true; }\r\n\r\n        TRANSACTION(this.get_name(c)+'.value', ()=>{\r\n            SetFieldAction.new(c.data, 'value', val);\r\n        }, c.data.value, val)\r\n        return true;\r\n    }\r\n    /*\r\n        protected get_literal(context: Context): this[\"literal\"] { return context.data.literal; }\r\n        protected set_literal(val: this[\"literal\"], context: Context): boolean {\r\n            return SetFieldAction.new(context.data, 'literal', val, '', false); }*/\r\n    protected get_literal(context: Context): this[\"literal\"] { return context.data.name; }\r\n    protected set_literal(val: this[\"literal\"], c: Context): boolean {\r\n        if (val === c.data.name) return true;\r\n        TRANSACTION(this.get_name(c)+'.name', ()=>{\r\n            return SetFieldAction.new(c.data, 'name', val, '', false);\r\n        }, c.data.name, val)\r\n        return true;\r\n    }\r\n\r\n\r\n}\r\nRuntimeAccessibleClass.set_extend(DNamedElement, DEnumLiteral);\r\nRuntimeAccessibleClass.set_extend(LNamedElement, LEnumLiteral);\r\n\r\n@Leaf\r\n@RuntimeAccessible('DEnumerator')\r\nexport class DEnumerator extends DPointerTargetable { // DDataType\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LEnumerator;\r\n    // static logic: typeof LEnumerator;\r\n    // static structure: typeof DEnumerator;\r\n\r\n    // inherit redefine\r\n    // instanceClass: EJavaClass // ?\r\n    // isInstance(object: EJavaObject): boolean; ?\r\n    // getClassifierID(): number;\r\n    id!: Pointer<DEnumerator, 1, 1, LEnumerator>;\r\n    instanceClassName!: string;\r\n    parent: Pointer<DPackage, 0, 'N', LPackage> = [];\r\n    father!: Pointer<DPackage, 1, 1, LPackage>;\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    name!: string;\r\n    defaultValue!: string[];\r\n    serializable: boolean = true;\r\n    // usedBy: Pointer<DAttribute, 0, 'N', LAttribute> = []; obsolete?\r\n    // personal\r\n    literals: Pointer<DEnumLiteral, 0, 'N', LEnumLiteral> = [];\r\n\r\n    public static new(name?: DNamedElement[\"name\"], father?: DEnumerator[\"father\"], persist: boolean = true): DEnumerator {\r\n        if (!name) name = this.defaultname(\"enum \", father);\r\n        return new Constructors(new DEnumerator('dwc'), father, persist, undefined).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DEnumerator().end();\r\n    }\r\n    static new2(setter: Partial<ObjectWithoutPointers<DEnumerator>>, father: DEnumerator[\"father\"], name?: DEnumerator[\"name\"]): DEnumerator {\r\n        if (!name) name = this.defaultname(\"enum \", father);\r\n        return new Constructors(new DEnumerator('dwc'), father, true, undefined).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DEnumerator().end((d) => { Object.assign(d, setter); });\r\n    }\r\n\r\n    static new3(a: Partial<EnumPointers>, callback: undefined | ((d: DEnumerator, c: Constructors) => void), persist: boolean = true): DEnumerator {\r\n        if (!a.name) a.name = this.defaultname(\"enum \", a.father);\r\n        return new Constructors(new DEnumerator('dwc'), a.father, persist, undefined, a.id)\r\n            .DPointerTargetable().DModelElement().DNamedElement(a.name)\r\n            .DEnumerator()\r\n            .end(callback);\r\n    }\r\n}\r\n\r\n@Node\r\n@RuntimeAccessible('LEnumerator')\r\nexport class LEnumerator<Context extends LogicContext<DEnumerator> = any, C extends Context = Context, D extends DEnumerator = DEnumerator> extends LDataType { // DDataType\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DEnumerator;\r\n    id!: Pointer<DEnumerator, 1, 1, LEnumerator>;\r\n    // static singleton: LEnumerator;\r\n    // static logic: typeof LEnumerator;\r\n    // static structure: typeof DEnumerator;\r\n\r\n    // inherit redefine\r\n    // instanceClass: EJavaClass // ?\r\n    // isInstance(object: EJavaObject): boolean; ?\r\n    // getClassifierID(): number;\r\n    instanceClassName!: string;\r\n    parent!: LPackage [];\r\n    father!: LPackage;\r\n    annotations!: LAnnotation[];\r\n    name!: string;\r\n    namespace!: string;\r\n    defaultValue!:string[];\r\n    serializable!: boolean;\r\n    // usedBy!: LAttribute[];\r\n    isPrimitive!: false;\r\n    isClass!: false;\r\n    isEnum!: true;\r\n    // personal\r\n    literals!: LEnumLiteral[];\r\n    ordinals!: LEnumLiteral[]; // literal array ordered by ordinal number\r\n\r\n    protected generateEcoreJson_impl(context: Context, loopDetectionObj: Dictionary<Pointer, DModelElement> = {}): Json {\r\n        loopDetectionObj[context.data.id] = context.data;\r\n        const json: Json = {};\r\n        let d = context.data;\r\n        if (d.instanceClassName) json[ECoreEnum.instanceTypeName] = d.instanceClassName;\r\n        json[ECoreEnum.xsitype] = 'ecore:EEnum';\r\n        json[ECoreEnum.namee] = d.name;\r\n        json[ECoreEnum.serializable] = d.serializable ? \"true\" : \"false\";\r\n        json[ECoreEnum.eLiterals] = context.proxyObject.literals.map(l => l.generateEcoreJson(loopDetectionObj));\r\n        return json; }\r\n\r\n    public duplicate(deep: boolean = true): this {\r\n        return this.cannotCall( ((this.constructor as typeof RuntimeAccessibleClass).cname || this.constructor.name) + \"duplicate()\"); }\r\n    protected get_duplicate(c: Context): ((deep?: boolean) => LEnumerator) {\r\n        return (deep: boolean = false) => {\r\n            let ret: LEnumerator = null as any;\r\n            TRANSACTION(this.get_name(c)+'.duplicate()', ()=>{\r\n                let le: LEnumerator = c.proxyObject.father.addEnumerator(c.data.name);\r\n                let de: D = le.__raw as D;\r\n                de.defaultValue = c.data.defaultValue;\r\n                de.serializable = c.data.serializable;\r\n                let we: WEnumerator = le as any;\r\n                we.annotations = deep ? c.proxyObject.annotations.map(lchild => lchild.duplicate(deep).id) : c.data.annotations;\r\n                we.literals = deep ? c.proxyObject.literals.map(lchild => lchild.duplicate(deep).id) : c.data.literals;\r\n                ret = le;\r\n            })\r\n            return ret; }\r\n    }\r\n\r\n\r\n    protected get_children_idlist(c: Context): Pointer<DAnnotation | DEnumLiteral, 1, 'N'> {\r\n        return [...super.get_children_idlist(c) as Pointer<DAnnotation | DEnumLiteral, 1, 'N'>, ...c.data.literals]; }\r\n\r\n    public addLiteral(name?: DEnumLiteral[\"name\"], value?: DEnumLiteral[\"value\"]): LEnumLiteral { return this.cannotCall(\"addLiteral\"); }\r\n    protected get_addLiteral(c: Context): this[\"addLiteral\"] {\r\n        return (name?: DEnumLiteral[\"name\"], value?: DEnumLiteral[\"value\"]) => LPointerTargetable.fromD(DEnumLiteral.new(name, value, c.data.id, true)); }\r\n\r\n    protected get_literals(context: Context): this[\"literals\"] {\r\n        return context.data.literals.map((pointer) => {\r\n            return LPointerTargetable.from(pointer)\r\n        }); }\r\n\r\n    protected set_literals(val: PackArr<this[\"literals\"]>, context: Context): boolean {\r\n        const list = val.map((lItem) => { return Pointers.from(lItem) });\r\n        const oldList = context.data.literals;\r\n        const diff = U.arrayDifference(oldList, list);\r\n        TRANSACTION(this.get_name(context)+'.literals', ()=>{\r\n            SetFieldAction.new(context.data, 'literals', list, \"\", true);\r\n            for (let id of diff.added) {\r\n                SetFieldAction.new(id, 'father', context.data.id, '', true);\r\n                SetFieldAction.new(id, 'parent', context.data.id, '+=', true);\r\n            }\r\n            for (let id of diff.removed as Pointer<DModelElement>[]) {\r\n                SetFieldAction.new(id, 'father', undefined, '', true);\r\n                const parent = DPointerTargetable.from(id).parent;\r\n                U.arrayRemoveAll(parent, context.data.id);\r\n                SetFieldAction.new(id, 'parent', parent, '', true);\r\n            }\r\n        })\r\n        return true; }\r\n\r\n    protected get_ordinals(context: Context): this[\"ordinals\"]{\r\n        let ret: LEnumLiteral[] = [];\r\n        let literals: LEnumLiteral[] = context.proxyObject.literals;\r\n        let dliterals: DEnumLiteral[] = literals.map(d => d.__raw);\r\n        /*\r\n        if it happens like:   second=2, third, fourth=4, fifth=3, sixth.(six would be 4 but 4 already exist)\r\n        there are 2 problems:\r\n        1) [3] is already occupied by third, but fith is correctly being the only one explicitly declaring his ordinal 3.\r\n           fixed by first assigning all known ordinals, then starting with the assumed ordinals.\r\n        2) sixth would get in position fourth, but that is already occupied\r\n         */\r\n\r\n        // adressing 1)\r\n        for (let i = 0; i < dliterals.length; i++) {\r\n            let v = dliterals[i].value;\r\n            if (v) { ret[v] = literals[i]; }\r\n        }\r\n\r\n        // setting assumed literals\r\n        let currentOrdinal = 0;\r\n        for (let i = 0; i < dliterals.length; i++) {\r\n            let v = dliterals[i].value;\r\n            if (v) { currentOrdinal = v; continue; }\r\n            while (ret[currentOrdinal]) currentOrdinal++; // adressing 2)\r\n            ret[currentOrdinal] = literals[i];\r\n        }\r\n        return ret;\r\n    }\r\n}\r\nRuntimeAccessibleClass.set_extend(DDataType, DEnumerator);\r\nRuntimeAccessibleClass.set_extend(LDataType, LEnumerator);\r\n@RuntimeAccessible('DModelM1')\r\nexport class DModelM1 extends DNamedElement{\r\n    name!: string;\r\n    roots!: Pointer<DObject, 1, 'N', LObject> // no package ma LObjects[] (solo quelli isRoot)\r\n    children!: DModelM1[\"roots\"];\r\n}\r\n\r\n@RuntimeAccessible('LModelM1')\r\nexport class LModelM1 extends LNamedElement{\r\n    name!: string;\r\n    roots!: LObject[];\r\n    children!: LModelM1[\"roots\"];\r\n\r\n}\r\nRuntimeAccessibleClass.set_extend(DModelM1, DNamedElement);\r\nRuntimeAccessibleClass.set_extend(LModelM1, LNamedElement);\r\ntype DPrimitiveType = DClass;\r\ntype LPrimitiveType = LClass;\r\n\r\n\r\n// problema: o costringo l'utente a fare sempre .value per ricevere il valore invece dei metadati\r\n// oppure ritorno il valore da subito ma dal valore non posso accedere ai metadati (upperbound...) a meno che non trovi un altor sistema.\r\n\r\n// possibile fix: LValue.toString() che ritorna il .value\r\n\r\n\r\n\r\n\r\n\r\n@RuntimeAccessible('DModel')\r\nexport class DModel extends DNamedElement { // DNamedElement\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LModel;\r\n    // static logic: typeof LModel;\r\n    // static structure: typeof DModel;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DModel, 1, 1, LModel>;\r\n    parent: Pointer<DModelElement, 0, 'N', LModelElement> = [];\r\n    father!: Pointer<DModelElement, 1, 1, LModelElement>;\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    name!: string;\r\n    // personal\r\n    packages: Pointer<DPackage, 0, 'N', LPackage> = [];\r\n    isMetamodel: boolean = true;\r\n    objects: Pointer<DObject, 0, 'N', LObject> = [];\r\n    models: Pointer<DModel, 0, 'N', LModel> = [];\r\n    instanceof?: Pointer<DModel>;\r\n    instances!: Pointer<DModelElement>[];\r\n    dependencies!: Pointer<DModel>[];\r\n\r\n    public static new(name?: DNamedElement[\"name\"], instanceoff?: DModel[\"instanceof\"], isMetamodel?: DModel[\"isMetamodel\"], persist: boolean = true): DModel {\r\n        let dmodels: DModel[] = Selectors.getAll(DModel, undefined, undefined, true, false);\r\n        let dmodelnames: string[] = dmodels.map((d: DModel) => d.name);\r\n        if (!name) name = this.defaultname(\"model_\", ((name: string) => dmodelnames.includes(name)));\r\n        return new Constructors(new DModel('dwc'), undefined, persist, undefined).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DModel(instanceoff, isMetamodel).end();\r\n    }\r\n    static new2(setter: Partial<ObjectWithoutPointers<DModel>>, name?: DModel[\"name\"], instanceoff?: DModel[\"instanceof\"]): DModel {\r\n        let dmodels: DModel[] = Selectors.getAll(DModel, undefined, undefined, true, false);\r\n        let dmodelnames: string[] = dmodels.map((d: DModel) => d.name);\r\n        if (!name) name = this.defaultname(\"model_\", ((name: string) => dmodelnames.includes(name)));\r\n        return new Constructors(new DModel('dwc'), undefined, true, undefined).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DModel(instanceoff).end((d) => { Object.assign(d, setter); });\r\n    }\r\n\r\n    static new3(a: Partial<ModelPointers>, callback: undefined | ((d: DModel, c: Constructors) => void), persist: boolean = true): DModel {\r\n        let dmodels: DModel[] = Selectors.getAll(DModel, undefined, undefined, true, false);\r\n        let dmodelnames: string[] = dmodels.map((d: DModel) => d.name);\r\n        if (!a.name) a.name = this.defaultname(\"model_\", ((name: string) => dmodelnames.includes(name)));\r\n        return new Constructors(new DModel('dwc'), a.father, persist, undefined, a.id)\r\n            .DPointerTargetable().DModelElement().DNamedElement(a.name)\r\n            .DModel(a.instanceof, !a.instanceof)\r\n            .end(callback);\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('EdgeStarter')\r\nexport class EdgeStarter<T1=any, T2=any>{ // <T1 extends LPointerTargetable = LPointerTargetable, T2 extends LPointerTargetable = LPointerTargetable>{\r\n    id: string; // suggested id & key for the element.\r\n    start: LModelElement;\r\n    end: LModelElement;\r\n    startNode: LGraphElement;\r\n    endNode: LGraphElement;\r\n    startVertex: LVoidVertex;\r\n    endVertex: LVoidVertex;\r\n    startGraph: LGraph;\r\n    endGraph: LGraph;\r\n    startSize: GraphSize;\r\n    endSize: GraphSize;\r\n    startVertexSize: GraphSize;\r\n    endVertexSize: GraphSize;\r\n    otherEnds: LGraphElement[];\r\n    extendTargets: LGraphElement[];\r\n    sameGraph: boolean;\r\n    isSameGraph: boolean;\r\n    overlaps: boolean;\r\n    vertexOverlaps: boolean;/*\r\n    firstRenderedStartNode: LGraphElement;\r\n    firstRenderedEndNode: LGraphElement;*/\r\n    // todo: if you want to get the first visible parent node (like for pkg dependencies), use edgestarter.startNode.firstRenderedNode\r\n    constructor(start: LModelElement, end: LModelElement, sn: LGraphElement, en: LGraphElement,\r\n                otherPossibleEnds: LGraphElement[], m1refindex: number, type:string) {\r\n        this.start = start;\r\n        this.end = end;\r\n        this.startNode = sn;\r\n        this.endNode = en;\r\n        this.otherEnds = this.extendTargets = otherPossibleEnds;// || end.nodes;\r\n        //console.log('edgestarter ss', {end, start, sn, en});\r\n\r\n        this.startSize = sn.outerSize;\r\n        this.endSize = en.outerSize;\r\n        this.startVertex = sn.vertex as any;\r\n        this.endVertex = en.vertex as any;\r\n        this.startGraph = this.startVertex?.root;\r\n        this.endGraph = this.endVertex?.root;\r\n        this.sameGraph = this.isSameGraph = this.endGraph?.id === this.startGraph?.id;\r\n        //this.firstRenderedStartNode = this.startNode.firstRenderedNode;\r\n        //this.firstRenderedEndNode = this.startNode.firstRenderedNode;\r\n        // this.firstVisibleStart = this.startNode.firstRenderedNode;\r\n        //console.log('edgestarter evs', {end, start, sn, en});\r\n        this.startVertexSize = this.startVertex === sn ? this.startSize : this.startVertex.outerSize;\r\n        this.endVertexSize = this.endVertex === en ? this.endSize : this.endVertex.outerSize;\r\n        this.overlaps = this.startSize?.isOverlapping(this.endSize);\r\n        this.vertexOverlaps = this.startVertexSize?.isOverlapping(this.endVertexSize);\r\n        //console.log('edgestarter end', {end, start, sn, en});\r\n        // how to pick edgeid:\r\n        // using nodeid is useless, as a ref might be hidden and take the node of a class or upper, it must be resolved at conceptual model-level\r\n        // mid = model id\r\n        // NB: mid -> mid is safe for extends, why:\r\n        // if a->b1->c && a->b2->c and both b1,b2 are hidden, extend edges might become both a->c, but in that case is fine to have it only once (filter it in suggestions)\r\n        // mid -> mid                   is safe for package-dependencies for the same reason as class inheritance.\r\n        // mid -> mid                   is not safe for dvalues which might have duplicate references. (DValue.a -> [Object.b, Object.b])\r\n        // mid + (valueindex) -> mid    is safe for everything i think.\r\n        // !!!! REMEMBER, DOTS AND ~ ARE NOT ALLOWED IN ID (css selector char) !!!\r\n        this.id = start.id + ('_' + m1refindex) + '-' + end.id + type;\r\n    }\r\n    /*\r\n    static oneToMany<T1 extends LModelElement = LModelElement, T2 extends LModelElement = LModelElement>(start: T1, ends:T2[]): EdgeStarter<T1, T2>[] {\r\n        let sn = start.node;\r\n        if (!sn) return [];\r\n        let rett: (EdgeStarter | undefined)[] = ends.map( (e) => {\r\n            if(!e) return undefined;\r\n            let en = e.node;\r\n            return en ? new EdgeStarter(start, e, sn as LGraphElement, en) : undefined;\r\n        });\r\n        let ret: (EdgeStarter)[] = rett.filter<EdgeStarter>(function(e: EdgeStarter|undefined): e is EdgeStarter { return !!e });\r\n        // let ret: (EdgeStarter)[] = rett.filter<EdgeStarter>((e): (e is EdgeStarter) => { return !!e });\r\n        return ret;\r\n    }*/\r\n}\r\n\r\n@RuntimeAccessible('LModel')\r\nexport class LModel<Context extends LogicContext<DModel> = any, C extends Context = Context, D extends DModel = DModel> extends LNamedElement {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DModel;\r\n    id!: Pointer<DModel, 1, 1, LModel>;\r\n    // static singleton: LModel;\r\n    // static logic: typeof LModel;\r\n    // static structure: typeof DModel;\r\n\r\n    // inherit redefine\r\n    parent!: LModel[];\r\n    father!: LModel;\r\n    annotations!: LAnnotation[];\r\n    name!: string;\r\n    namespace!: string;\r\n    // personal\r\n    isMetamodel!: boolean;\r\n\r\n    // Metamodel\r\n    packages!: LPackage[];\r\n    models!: LModel[];\r\n    instances!: LModel[];\r\n    dependencies!: LModel[]; // points to other models of the same level\r\n    allDependencies!: LModel[];\r\n    __info_of__dependencies: Info = {type: 'LModel[]',\r\n        txt:'Include other models as prerequisite for this model, it is as if this model is \"extending\" other models.'};\r\n    __info_of__allDependencies: Info = {type: 'LModel[]', txt:'Same as dependencies, but it solves recursively the dependencies of his dependencies.'};\r\n\r\n    // Model\r\n    instanceof?: LModel;\r\n    objects!: LObject[];\r\n    crossObjects!: LObject[];\r\n    roots!: LObject[];\r\n\r\n    // utilities to go down in the tree (plural names)\r\n    enums!: LEnumerator[] & Dictionary<DocString<\"$name\">, LEnumerator>; // alias for enumerators\r\n    enumerators!: LEnumerator[] & Dictionary<DocString<\"$name\">, LEnumerator>;\r\n    crossEnumerators!: LEnumerator[] & Dictionary<DocString<\"$name\">, LEnumerator>;\r\n    classes!: LClass[] & Dictionary<DocString<\"$name\">, LClass>;\r\n    crossClasses!: LClass[] & Dictionary<DocString<\"$name\">, LClass>;\r\n    operations!: LOperation[];\r\n    parameters!: LParameter[];\r\n    exceptions!: LClassifier[];\r\n    attributes!: LAttribute[];\r\n    references!: LReference[];\r\n    literals!: LEnumLiteral[];\r\n    values!: LValue[];\r\n    allSubAnnotations!: LAnnotation[];\r\n    allCrossSubAnnotations!: LAnnotation[];\r\n    allSubPackages!: LPackage[];\r\n    allCrossSubPackages!: LPackage[];\r\n    allSubObjects!: LObject[];\r\n    allCrossSubObjects!: LObject[];\r\n    allSubValues!: LValue[];\r\n    allCrossSubValues!: LValue[];\r\n    suggestedEdges!: {extend: EdgeStarter[], reference:EdgeStarter[], packageDependencies: EdgeStarter[]}; //, model: EdgeStarter[], package:EdgeStarter[], class:EdgeStarter[]};\r\n    __info_of__suggestedEdges: Info = {type: 'Dictionary<\"extend\" | \"reference\" | \"packageDependencies\" | DmodelName, EdgeStarter[]>', txt: \"A map to access all possible kind of edges based on model data.\" +\r\n            \"<br/>extend and reference are the most commonly used for horizontal references (outside the containment tree schema).\" +\r\n            \"<br/>packageDependencies links packages using classes from other packages.\" +\r\n            // \"<br/>other keys are the names of container data types (mode, package, class, object...) from them to their childrens rendered as Nodes (vertical tree schema).\" +\r\n            // todo: implement the commented part as LGrahElement.vertexs.map(v=>{start:v.parentnode.isVertex ? v.parentnode.id : undefined, end:v.id}).filter(e=>e.start) instead. it's a thing of graph more than model.\r\n            \"<br/> EdgeStarter is a collection of data useful to start a &lt;Edge /&gt; in JSX.\"}\r\n\r\n    protected generateEcoreJson_impl(context: Context, loopDetectionObj: Dictionary<Pointer, DModelElement> = {}): Json {\r\n        loopDetectionObj[context.data.id] = context.data;\r\n        const json: GObject = {};\r\n\r\n        // if it's M2 metamodel\r\n        if (context.data.isMetamodel) {\r\n            const packageArr: Json[] = [];\r\n            for (let pkg of context.proxyObject.packages) { packageArr.push(pkg.generateEcoreJson(loopDetectionObj)); }\r\n            // return (context.proxyObject.packages[0])?.generateEcoreJson(loopDetectionObj);\r\n            json[ECoreRoot.ecoreEPackage] = packageArr;\r\n            return json;\r\n        }\r\n\r\n        // if it's M1 model\r\n        // let serializeasroot = context.proxyObject.isRoot && loopDetectionObj.length; // if rootobj is nested because you started the serialization from another node, i prevent it generating root content\r\n        for (let obj of context.proxyObject.roots) { json[obj.ecoreRootName] = obj.generateEcoreJson(loopDetectionObj); }\r\n\r\n        return json; }\r\n\r\n    public addPackage(name?: DPackage[\"name\"], uri?: DPackage[\"uri\"], prefix?: DPackage[\"prefix\"]): LPackage { return this.cannotCall(\"addPackage\"); }\r\n    public get_addPackage(context: Context): ((name?: DPackage[\"name\"], uri?: DPackage[\"uri\"], prefix?: DPackage[\"prefix\"]) => LPackage) {\r\n        console.log(\"Model.addPackage()\", {context, thiss: this});\r\n        return (name?: DPackage[\"name\"], uri?: DPackage[\"uri\"], prefix?: DPackage[\"prefix\"]) => {\r\n            return LPointerTargetable.fromD(DPackage.new(name, uri, prefix, context.data.id, true, DModel));\r\n        }\r\n    }\r\n\r\n    public get_dependencies(c: Context): this['dependencies']{\r\n        return LPointerTargetable.fromPointer(c.data.dependencies);\r\n    }\r\n    public get_allDependencies(c: Context): this['allDependencies']{\r\n        let targets: LModel[] = L.fromArr(c.data.dependencies);\r\n        return U.iterateChildProperties(targets, (e)=>e.dependencies);\r\n        /*let alreadyParsed: Dictionary<Pointer, LModel> = {};\r\n        while (targets.length) {\r\n            let nextTargets = [];\r\n            for (let target of targets){\r\n                if (alreadyParsed[target.id]) continue;\r\n                alreadyParsed[target.id] = target;\r\n                U.arrayMergeInPlace(nextTargets, target.dependencies);\r\n            }\r\n            targets = nextTargets;\r\n        }\r\n        return Object.values(alreadyParsed);*/\r\n    }\r\n    /*public set_dependencies(c: Context): this['dependencies']{\r\n        default setter is fine, should automatically do the difference of pointers and trigger -= or +=\r\n    }*/\r\n\r\n    public static namesORDObjectsToID<T extends DPointerTargetable = DPointerTargetable>(a: T): Pointer<T>[];\r\n    public static namesORDObjectsToID<T extends DPointerTargetable = DPointerTargetable>(a: T[]): Pointer<T>[];\r\n    public static namesORDObjectsToID<L extends LPointerTargetable = LPointerTargetable>(a: L): Pointer<LtoD<L>>[];\r\n    public static namesORDObjectsToID<L extends LPointerTargetable = LPointerTargetable>(a: L[]): Pointer<LtoD<L>>[];\r\n    public static namesORDObjectsToID<T extends DPointerTargetable = DPointerTargetable>(a: Pointer<T>): Pointer<T>[];\r\n    public static namesORDObjectsToID<T extends DPointerTargetable = DPointerTargetable>(a: Pointer<T>[]): Pointer<T>[];\r\n    public static namesORDObjectsToID(a: string, namedCandidates: LModelElement[]): Pointer[];\r\n    public static namesORDObjectsToID(a: string[], namedCandidates: LModelElement[]): Pointer[];\r\n    public static namesORDObjectsToID(a: string | LClass | DClass | Pointer, namedCandidates: LModelElement[]): Pointer[];\r\n    public static namesORDObjectsToID(a: (string | LClass | DClass | Pointer)[], namedCandidates: LModelElement[]): Pointer[];\r\n    public static namesORDObjectsToID<T extends DPointerTargetable = DPointerTargetable>(a: orArr<(string | T | Pointer<T>)>): Pointer<T>[];\r\n    // return the first array parameter converted in an array of pointers. The second parameter is the scope where names are allowed to match. if empty all class.names will fail mapping to id's.\r\n    // second parameter is mandatory when the array contain names, to prevent looking into class names of different models.\r\n    public static namesORDObjectsToID<T extends DPointerTargetable = DPointerTargetable>(targets: orArr<(string | T | Pointer<T>)>, namedCandidates?: LModelElement[]): Pointer<T>[] {\r\n        // let targets = any[] = (!Array.isArray(targets0)) ? targets0 : [targets0];\r\n        if (!targets) return [];\r\n        let ret: Pointer<T>[] = [];\r\n        let state: DState = store.getState();\r\n        if (targets && !Array.isArray(targets)) targets = [targets];\r\n        let dnamedcandidates: DNamedElement[] = namedCandidates ? DPointerTargetable.fromArr(namedCandidates as any) as DNamedElement[] : [];\r\n        let dAllowedNamesMap: Dictionary<DocString<\"name\">, Pointer<T>> = (dnamedcandidates as any[]).reduce( (acc, val) => { acc[val.name] = val.id; return acc; }, {});\r\n        //let dtargets: DNamedElement[] = targets ? DPointerTargetable.fromArr(targets) as DNamedElement[] : [];\r\n        let tmp: Pointer<T> | undefined;\r\n        for (let target of targets) {\r\n            // try as name\r\n            tmp = dAllowedNamesMap[target as string];\r\n            if (tmp) { ret.push(tmp); continue; }\r\n            // try as $name\r\n            tmp = dAllowedNamesMap[\"$\" + target as string];\r\n            if (tmp) { ret.push(tmp); continue; }\r\n            // try as id\r\n            let d: DNamedElement = DPointerTargetable.from(target as Pointer, state);\r\n            if (d && dAllowedNamesMap[d.name]) { ret.push(target as Pointer<T>); continue; }\r\n            Log.ww(\"namesORDObjectsToID() could not resolve name:\", {name: target, namedCandidates, targets});\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    _defaultGetter(c: Context, key: string): any {\r\n        //console.log(\"$getter 000\", {key, ism1:!c.data.isMetamodel, ism:c.data.isMetamodel, data:c.data});\r\n        if (!c.data.isMetamodel) return this._defaultGetterM1(c, key);\r\n        return this._defaultGetterM2(c, key);\r\n    }\r\n    _defaultGetterM2(c: Context, key: string): any{\r\n        if ((TargetableProxyHandler.childKeys[key[0]])){\r\n            // look for m1 matches\r\n            let k = key.substring(1).toLowerCase();\r\n            let s = store.getState();\r\n\r\n            for (let subelement of this.get_allSubPackages(c, s)){\r\n                let n = subelement.__raw.name;\r\n                if (n && n.toLowerCase() === k) return subelement;\r\n            }\r\n            for (let subelement of this.get_classes(c, s)){\r\n                let n = subelement.__raw.name;\r\n                if (n && n.toLowerCase() === k) return subelement;\r\n            }\r\n        }\r\n        return this.__defaultGetter(c, key);\r\n        // Log.ee(\"Could not find property \" + key + \" on MetaModel\", {c, key});\r\n    }\r\n    _defaultGetterM1(c: Context, key: string): any{\r\n        // if m1.$m1RootObjectName then --> return that root object\r\n        // if m1.$m1ObjectName then --> return that sub object nested somewhere in the model.\r\n        // if m1.$m2classname\"s\" then --> this.instancesOf(\"m2classname\")\r\n        // if m1.$m2classname then ---> m2.$m2classname (lower priority, if there are 2 metaclasses differing only by final s,\r\n        // the one with 1 more final \"s\" if shadowed by the instances of the one with 1 less final \"s\",\r\n        // in that case you can access the shadowed one through m1.instanceof.$classnames\r\n        // priorities: 1) m1 name natch --> m1object. 2) m2 exact name match --> m2item, 3) m2 name+\"s\" match --> instances\r\n        // to access m2 classes within a package, need to navigate it like model.$packagename.Ssubcpackagename.$classname,\r\n        // path + \"s\" won't work in that case, and need to use this.getInstancesOf instead\r\n        if (TargetableProxyHandler.childKeys[key[0]]){\r\n            // look for m1 matches\r\n            let deepmatch: LObject | undefined;\r\n            let k = key.substring(1).toLowerCase();\r\n\r\n            const directSubObjects: Dictionary<Pointer, boolean> = U.objectFromArrayValues(c.data.objects);\r\n            for (let subobject of this.get_allSubObjects(c)){\r\n                let n = subobject.name;\r\n                if (!n || n.toLowerCase() !== k) continue;\r\n                // A0) perfect match with direct child object\r\n                if (directSubObjects[subobject.id]) return subobject; // actually cannot do direct match, because proxy get function will solve it directly before calling _defaultGetter\r\n                else if (!deepmatch) deepmatch = subobject;\r\n            }\r\n            // A1) match with deep sub-object\r\n            if (deepmatch) return deepmatch;\r\n\r\n            // look for m2 matches\r\n            let m2: LModel | undefined = this.get_instanceof(c);\r\n            if (!m2) return Log.ee(\"Could not find m1 match for data.$name. And the metamodel is missing, so cannot get instances by type.\", {c, key, m2});\r\n            let m2item: LClass | LPackage;\r\n            // check for a perfect m2 name match and return it\r\n            m2item = (m2 as GObject)[key];\r\n            if (m2item) return m2item; //this.instancesOf(key);\r\n            if (!m2) Log.ee(\"Could not find property \" + key + \" on M1 Model\", {c, key, m2});\r\n            // if not a perfect name match, i try name+s match for instances\r\n            if (key[key.length - 1] === \"s\") {\r\n                let key1 = key.substring(0, key.length - 1);\r\n                m2item = (m2 as GObject)[key1];\r\n                if (m2item) {\r\n                    if (m2item.className === \"DClass\") return this.get_instancesOf(c)(m2item as LClass);\r\n                    else return Log.ee(\"Could not get instances of \" + key1 + \".\", {c, key, m2});\r\n                }\r\n            }\r\n            if (!m2) return Log.ee(\"Could not find any subelement with name \" + key + \" on M1 or M2 Models\", {c, key, m1: c.data, m2});\r\n        }\r\n\r\n        return this.__defaultGetter(c, key);\r\n    }\r\n    private static otherObjectsTemp: Dictionary<DocString<\"className\">, LObject[]> = undefined as any;\r\n    private static otherObectsAccessedKeys: DocString<\"className\">[] = [];\r\n    // public otherObjectsSetup(){ LModel.otherObjectsTemp = undefined; LModel.otherObectsAccessedKeys = []; }\r\n    otherObjects!: (excludeInstances: orArr<(string | LClass | Pointer)>, excludeSubclasses?: boolean)=>LObject[];\r\n    otherInstances!: (excludeInstances: orArr<(string | LClass | Pointer)>, excludeSubclasses?: boolean)=>LObject[];\r\n    __info_of__otherObjects: Info = {type:\"(...excludeInstances: (string|LClass|Pointer)[], excludeSubclasses: boolean = false)=>LObject[]\", txt:<div>Alias for this.otherInstances.</div>};\r\n    __info_of__otherInstances: Info = {type:\"(...excludeInstances: (string|LClass|Pointer)[], excludeSubclasses: boolean = false)=>LObject[]\", txt:<div>Read this.instancesOf documentation first.\r\n            <br/>Retrieves all the objects not obtained between previous calls of this.instancesOf and the last call of this method.\r\n            <br/>Meaning calling it twice without any instancesOf in between, it will return all objects.</div>};\r\n\r\n    public get_otherObjects(c: Context): (excludeInstances: orArr<(string | LClass | Pointer)>, excludeSubclasses?: boolean)=>LObject[]{\r\n        return this.get_otherInstances(c); }\r\n    public get_otherInstances(c: Context): (excludeInstances: orArr<(string | LClass | Pointer)>, excludeSubclasses?: boolean)=>LObject[]{\r\n        // todo:\r\n        return (excludeInstances: orArr<(string | LClass | Pointer)>, includeSubclasses: boolean = false)=>{\r\n            let ret: LObject[];\r\n            this.get_instancesOf(c)(excludeInstances, includeSubclasses) // and drop the result\r\n            if (!LModel.otherObjectsTemp) { ret = this.get_allSubObjects(c); }\r\n            else {\r\n                let dict = {...LModel.otherObjectsTemp};\r\n                for (let key of LModel.otherObectsAccessedKeys) delete dict[key];\r\n                delete (LModel as any).otherObjectsTemp;\r\n                delete (LModel as any).otherObectsAccessedKeys;\r\n                ret = Object.values(dict).flat();\r\n            }\r\n            return ret;\r\n        }\r\n    }\r\n    // not meant to be called directly.\r\n    private _populateOtherObjects(c:Context, classes?: LClass[]): void {\r\n        // from names, DClass and ptrs, make them only ptrs. all classes of this model are valid name targets.\r\n        // nb: cannot optimize getting only instantiated classes from this.get_allSubObjects because if a class have 0 instances should have an empty array instead of undefined (risk jsx crash)\r\n        let state: DState = store.getState();\r\n        let dinstancetypes: DClass[] = (classes || this.get_classes(c, state)).map(c => c.__raw);\r\n        let namemap: Dictionary<DocString<\"className\">, DClass> = {};\r\n        namemap = dinstancetypes.reduce( (acc, current) => { namemap[current.name] = current; return namemap; }, namemap);\r\n        let idtoname: Dictionary<Pointer, string> = {};\r\n        for (let n in namemap) {idtoname[namemap[n].id] = n; }\r\n        // make it more general, first make a dictionary holding all selected types as keys, including \"_other\"\r\n        // then a SEPARATE (split this) function to return only the selected keys, merging the subarrays in the global naming instance map.\r\n        LModel.otherObjectsTemp = {};\r\n        LModel.otherObectsAccessedKeys = [];\r\n        // part 1: i add empty arrays for all instances, but not include shapeless objects.\r\n        for (let name in namemap) { LModel.otherObjectsTemp[name] = []; } //LPointerTargetable.fromPointer(namemap[name].instances); }\r\n        // part 2: for shapeless objs too\r\n        LModel.otherObjectsTemp[undefined as any] = [];\r\n        let allObjects: LObject[] = this.get_allSubObjects(c, state);\r\n        // part 3: now i populate the Model.otherObjectsTemp dictionary arrays\r\n        for (let o of allObjects) {\r\n            // if (o.__instanceof) continue;\r\n            let name: string | undefined = idtoname[o.__raw.instanceof];\r\n            if (!LModel.otherObjectsTemp[name]) {\r\n                LModel.otherObjectsTemp[name] = [o];\r\n                Log.eDevv(\"model._populateOtherObjects() this case should never happen\", {name, o, allObjects, namemap, idtoname});\r\n            }\r\n            else LModel.otherObjectsTemp[name].push(o);\r\n        }\r\n    }\r\n\r\n    public instancesOf(instancetypes0: orArr<(string | LClass | Pointer)>, includeSubclasses: boolean = false): LObject[]{ return this.cannotCall(\"instancesOf\"); }\r\n    public __info_of__instancesOf: Info = {type: \"(instancetypes: orArr<(string | LClass | Pointer)>, includeSubclasses: boolean = false) => LObject[]\",\r\n        txt:<div>Retrieves all objects instancing a target class.\r\n            <br/>The first parameter is the targeted class, which can be his name, pointer or object.\r\n            <br/>The second parameter tells if instances of his subclasses needs to be retreieved as well.</div>\r\n    }\r\n    // M1\r\n    public get_instancesOf(c:Context): (this[\"instancesOf\"]){\r\n        if (c.data.isMetamodel) { return (...a:any) => { Log.ww(\"cannot call instancesOf() on a metamodel\"); return []; } }\r\n        return (instancetypes0: orArr<(string | LClass | Pointer)>, includeSubclasses: boolean = false): LObject[] => {\r\n            let state: DState = store.getState();\r\n            let classes = this.get_classes(c, state);\r\n            if (!LModel.otherObjectsTemp) this._populateOtherObjects(c, classes);\r\n            if (!Array.isArray(instancetypes0)) instancetypes0 = [instancetypes0];\r\n            // from names, DClass and ptrs, make them only ptrs. all classes of this model are valid name targets.\r\n            let instancetypes: Pointer<DClass>[] = LModel.namesORDObjectsToID(instancetypes0, classes) as any;\r\n            let dinstancetypes: DClass[] = DClass.fromPointer(instancetypes, state);\r\n            if (includeSubclasses) {\r\n                let arr: LClass[] = dinstancetypes.map(d => LPointerTargetable.fromD(d));\r\n                for (let c of arr) dinstancetypes.push(...(c.allSubClasses.map(l => l.__raw) || []));\r\n                dinstancetypes = [...new Set(dinstancetypes)];\r\n            }\r\n            let ret: LObject[] = []\r\n            for (let c of dinstancetypes) {\r\n                let arr: LObject[] = LModel.otherObjectsTemp[c.name]\r\n                if (!arr || !arr.length) continue;\r\n                ret.push(...arr);\r\n                LModel.otherObectsAccessedKeys.push(c.name);\r\n            }\r\n            return ret;\r\n        }\r\n    }\r\n/*\r\n* instanceof === some class -> instantiate object and forces to conform to that class\r\ninstanceof === null  --> shapeless object\r\ninstanceof === undefined or missing  --> auto-detect and assign the type\r\n */\r\n    addObject(json: GObject, instanceoff: Pack1<LClass> | DocString<\"ClassName\"> | undefined | null = undefined, forceCreation: boolean = false): ReturnType<LValue[\"addObject\"]>{ return this.cannotCall(\"LValue.addObject\"); }\r\n    __info_of__addObject: Info = {type: \"(json: object, instanceof?: LClass) => LObject\",\r\n        txt: \"Appends an object instancing \\\"instanceof\\\" to the model.\\n<br>Setting his own properties, and DValues according to the content of the parameter object.\"}\r\n    get_addObject(c: Context): ReturnType<LValue[\"get_addObject\"]> { return (LValue.singleton as LValue).get_addObject.call(this, c); }\r\n\r\n    instantiableClasses(o?: GObject, loose: boolean = false):LClass[] { return this.cannotCall(\"instantiableClasses\"); }\r\n    __info_of__instantiableClasses: Info = {type: \"(o?: object, loose?: boolean) => LClass[]\",\r\n        txt: \"List of all classes which can be used to instantiate an object.\" +\r\n            \"\\n<br>Abstract and Interface classes are excluded.\" +\r\n            \"\\n<br>If the parameter \\\"o\\\" is specified, it will filter only the instances conforming to the object schema.\" +\r\n            \"\\n<br>Results are sorted from tightest fit to loosest fit.\" +\r\n            \"\\n<br>loose parameter set to true makes return instead a list of matching scores of all subclasses.\", hidden: true}\r\n    // M1\r\n    get_instantiableClasses(c: Context): LValue[\"instantiableClasses\"] {\r\n        if (c.data.isMetamodel) { return (...a:any)=> { Log.ww(\"cannot call instantiableClasses() on a metamodel\"); return []; } }\r\n        return (LValue.singleton as LValue).get_instantiableClasses.call(this, c)\r\n    }\r\n\r\n    public get_suggestedEdges(context: Context): this[\"suggestedEdges\"]{\r\n        let ret: this[\"suggestedEdges\"];\r\n        if (context.data.isMetamodel) ret = this.impl_get_suggestedEdgesM2(context);\r\n        else ret = this.impl_get_suggestedEdgesM1(context);\r\n\r\n        return ret;\r\n    }\r\n\r\n    private impl_get_suggestedEdgesM1(context: Context, state?: DState): this[\"suggestedEdges\"]{\r\n        let ret: this[\"suggestedEdges\"] = {extend: [], reference: [], packageDependencies: []};\r\n        if (context.data.isMetamodel) { Log.ww(\"cannot call suggestedEdgesM1() on a metamodel\"); return ret; }\r\n        if (Debug.lightMode) { return ret; }\r\n        let s: DState = store.getState();\r\n        let values: LValue[] = this.get_allSubValues(context, s);\r\n        let map: Dictionary<DocString<\"starting dvalue id\">, EdgeStarter[]> = {};\r\n        if (!state) state = store.getState();\r\n        outer:\r\n            for (let lval of values) {\r\n                if (!lval) continue;\r\n                let dval = lval.__raw;\r\n                let values: any[] = dval.values || [];\r\n                // NB: ELiterals can be pointers in L, but string or ordinal numbers in D, but they won't make edges, so i use .__raw\r\n                inner:\r\n                    for (let valindex = 0; valindex < values.length; valindex++) {\r\n                        let v: any = values[valindex];\r\n                        if (!Pointers.isPointer(v, state)) continue inner;\r\n                        let snode = lval.notEdge;\r\n                        if (!snode || !snode.html) continue outer;\r\n                        if (v === dval.id) continue inner; // pointing to itself\r\n                        let ltarget: undefined | LEnumLiteral | LObject = LPointerTargetable.fromPointer(v, state);\r\n                        if (!ltarget) continue;\r\n                        if (ltarget.className !== DObject.cname) continue inner;\r\n                        let enode = ltarget.notEdge;\r\n                        if (!enode || !enode.html) continue inner;\r\n                        if (!map[dval.id]) map[dval.id] = [];\r\n                        map[dval.id].push(new EdgeStarter(lval, ltarget, snode, enode, [], valindex, 'values'));\r\n                    }\r\n            }\r\n        ret.reference = Object.values(map).flat();\r\n        return ret;\r\n    }\r\n    private impl_get_suggestedEdgesM2(context: Context): this[\"suggestedEdges\"]{\r\n        let ret: this[\"suggestedEdges\"] = {extend: [], reference: [], packageDependencies: []};\r\n        if (!context.data.isMetamodel) { Log.ww(\"cannot call suggestedEdgesM2() on a model\"); return ret; }\r\n        let s: DState = store.getState();\r\n        let classes: LClass[] = this.get_classes(context, s);\r\n        let references: LReference[] = Debug.lightMode ? [] : classes.flatMap(c=>c.references);\r\n        ret.reference = references.map( (r) => {\r\n            let sn = r?.notEdge;\r\n            if (!sn || !sn.html) return undefined;\r\n            let end = r.type;\r\n            // if (end.id === r.id) return undefined;\r\n            let en = end?.notEdge;\r\n            if (!en || !en.html) return undefined;\r\n            //console.log('pre edgestarter', {r, end, sn, en});\r\n            return new EdgeStarter(r, end, sn, en, [], 0, 'association');\r\n        }).filter<EdgeStarter>(function(e):e is EdgeStarter{ return !!e});\r\n        // ret.extend = classes.flatMap( c => EdgeStarter.oneToMany(c, c.extends));\r\n\r\n        let alreadyAdded: Dictionary<Pointer, LClass> = {};\r\n        // if A extends B1, B2;    B1 extends C1, C2;    and node B1 is hidden. instead of edge from A to B, i display edge from A~C1, A~C2, A~B2\r\n        function SkipExtendNodeHidden(start: LClass): ({start: LClass, end: LClass, sn: LGraphElement, en: LGraphElement, oth:LGraphElement[]})[] {\r\n            return SkipExtendNodeHidden_recstep(start);\r\n        }\r\n        function SkipExtendNodeHidden_recstep(start: LClass, sn?: LGraphElement, end?: LClass[], startgraphid: Pointer|null = null): ({start: LClass, end: LClass, sn: LGraphElement, en: LGraphElement, oth:LGraphElement[]})[] {\r\n            let ret: {start: LClass, end: LClass, sn: LGraphElement, en: LGraphElement, oth:LGraphElement[]}[] = [] as any;\r\n            // ret.start = start;\r\n            let isRootcall = !startgraphid;\r\n            if (isRootcall) {\r\n                // end classes can get added twice if from a different starting subclass path:\r\n                // in classes.flatMap -> do not initialize the dict, it must be shared and initialized here locally\r\n                alreadyAdded = {[start.id]: start};\r\n                sn = start.nodes.find(node=>filternode(node, null)); // start.notEdge;\r\n                if (!sn || !sn.html) return [];\r\n                startgraphid = sn.graph?.id;\r\n                if (!startgraphid) return [];\r\n                if (!end) end = start.extends;\r\n            }\r\n            if (!end) return [];\r\n            for (let e of end) {\r\n                if (!e) continue;\r\n                let eid = e.id;\r\n                if (alreadyAdded[eid]) continue; // without this there might be duplicates if A extends B1, B2;  and both B1 & B2 extends C\r\n                alreadyAdded[eid] = e;\r\n                let nodes = e.nodes.filter(o=>filternode(o, startgraphid));// let en = e.notEdge; if (en && en.html) { ret.push({start, end:e, sn, en}); continue; }\r\n                if (nodes.length) {\r\n                    ret.push({start, sn:sn as LGraphElement, end:e, en:nodes[0], oth:nodes});\r\n                    continue;\r\n                }\r\n                let secondTierExtends = e.extends;\r\n                ret.push(...SkipExtendNodeHidden_recstep(start, sn, secondTierExtends, startgraphid));\r\n            }\r\n            return ret;\r\n        }\r\n        windoww.SkipExtendNodeHidden = SkipExtendNodeHidden;\r\n\r\n        function filternode(c: LGraphElement, startgraphid: Pointer | null): boolean {\r\n            if (!c || !c.rendered) return false;\r\n            let qualify = U.categorizeNode(c);\r\n            if (qualify.edge || qualify.edgepoint || qualify.puregraph) return false;\r\n            if (startgraphid && startgraphid !== c.root?.id) return false;\r\n            return true;\r\n        }\r\n        ret.extend = classes.flatMap( (c) => SkipExtendNodeHidden(c).map(es=>{\r\n            return new EdgeStarter(es.start, es.end, es.sn, es.en, es.oth, 0, 'extend');\r\n        }));\r\n\r\n        if (false) ret.extend = classes.flatMap(c => SkipExtendNodeHidden(c)).map( (es) => {\r\n            let otherEdgeEnds = es;/*.start.extendsChain.flatMap(c=>(c?.nodes||[])).filter(c=> {\r\n                if (!c || !c.rendered) return false;\r\n                let qualify = U.categorizeNode(c);\r\n                if (qualify.edge || qualify.edgepoint || qualify.puregraph) return false;\r\n                if (es.sn?.root?.id !== c.root?.id) return false;\r\n                return true;\r\n            }) as LGraphElement[];\r\n*/\r\n            return new EdgeStarter(es.start, es.end, es.sn, es.en, [], 0, 'extend');\r\n        });\r\n\r\n        let dependencies: {src:LModelElement, ends: LModelElement[]}[] =\r\n            Debug.lightMode ? [] : [\r\n                ...(classes.map(c=>{ return {src:c, ends:c.superclasses}})),\r\n                ...(references.map(r=> { return {src:r, ends:[r.type]}}))\r\n            ]\r\n        let pkgdependencies: {src: LPackage, sn: LGraphElement, ends: Dictionary<Pointer, {end:LPackage, en:LGraphElement}>}[] = []; // transform form in dictionary to prevent duplicates\r\n        //dependencies.map( d=> { let end = d.end.package; return {src:d.src.package, end, endid:end.id}})\r\n\r\n        for (let d of dependencies) {\r\n            let src: LPackage | null = d.src.package;\r\n            if (!src) continue;\r\n            let srcnode: LGraphElement | undefined = src.notEdge;\r\n            if (!srcnode || !srcnode.html) continue;\r\n            let ends: Dictionary<Pointer, {end:LPackage, en:LGraphElement}> = {};\r\n            for (let end of d.ends) {\r\n                let ep: LPackage|null = end.package;\r\n                if (!ep) continue;\r\n                let epnode: LGraphElement | undefined = ep.notEdge;\r\n                if (!epnode || !epnode.html) continue;\r\n                ends[ep.id] = {end:ep, en:epnode};\r\n            }\r\n            pkgdependencies.push( {src, sn:srcnode, ends});\r\n        }\r\n        // todo: check\r\n        ret.packageDependencies = pkgdependencies.flatMap(\r\n            (pd) => ( Object.values(pd.ends).map((end) => new EdgeStarter(pd.src, end.end, pd.sn, end.en, [], 0, 'pkg_dep')))\r\n        );\r\n        return ret;\r\n    }\r\n\r\n\r\n    protected get_models(context: Context): LModel[] { // todo: should this not be data.instances instead?\r\n        return LModel.fromPointer(context.data.models);\r\n    }\r\n    protected set_models(val: PackArr<this['models']>, context: Context): boolean {\r\n        const list = val.map((lItem) => { return Pointers.from(lItem) });\r\n        const oldList = context.data.models;\r\n        const diff = U.arrayDifference(oldList, list);\r\n        TRANSACTION(this.get_name(context)+'.models', ()=>{\r\n            SetFieldAction.new(context.data, 'models', list, '', true);\r\n            for (let id of diff.added) {\r\n                SetFieldAction.new(id, 'father', context.data.id, '', true);\r\n                SetFieldAction.new(id, 'parent', context.data.id, '+=', true);\r\n            }\r\n            for (let id of diff.removed as Pointer<DModelElement>[]) {\r\n                SetFieldAction.new(id, 'father', undefined, '', true);\r\n                const parent = DPointerTargetable.from(id).parent;\r\n                U.arrayRemoveAll(parent, context.data.id);\r\n                SetFieldAction.new(id, 'parent', parent, '', true);\r\n            }\r\n        })\r\n        return true;\r\n    }\r\n\r\n    public duplicate(deep: boolean = true): this { throw new Error(\"Model.duplicate(): use export/import ecore instead.\"); }\r\n\r\n    protected set_instanceof(val: Pack1<this[\"instanceof\"]>, c: Context): boolean {\r\n        let ptr = Pointers.from<DNamedElement>(val as any);// as (undefined | Pointer<DNamedElement>);\r\n        if (c.data.instanceof === ptr) return true;\r\n        TRANSACTION(this.get_name(c)+'.instanceof', ()=>{\r\n            SetFieldAction.new(c.data.id, \"instanceof\", ptr, undefined, true);\r\n            // update father's collections (pointedby's here are set automatically)\r\n            // todo: ptr && SetFieldAction.new(ptr, \"instances\", context.data.id, '+=', true);\r\n        }, this.get_instanceof(c)?.fullname, LPointerTargetable.wrap(ptr)?.fullname)\r\n        return true; }\r\n    protected get_instanceof(c: Context): this[\"instanceof\"] {\r\n        return c.data.instanceof ? LPointerTargetable.fromPointer(c.data.instanceof) : undefined;\r\n    }\r\n\r\n    protected set_name(val: this['name'], c: Context): boolean {\r\n        const models: LModel[] = LModel.fromPointer(store.getState()['models']);\r\n        if (models.filter((model) => { return model.name === val }).length > 0) {\r\n            U.alert('e', 'Cannot rename the selected model, this name is already taken.');\r\n        } else {\r\n            if (c.data.name === val) return true;\r\n            TRANSACTION(this.get_name(c)+'.name', ()=>{\r\n                SetFieldAction.new(c.data, 'name', val, '', false);\r\n            }, undefined, val)\r\n        }\r\n        return true;\r\n    }\r\n    protected get_children_idlist(context: Context): Pointer<DAnnotation | (DPackage|DObject), 1, 'N'> {\r\n        let children: Pointer<(DPackage|DObject), 0, 'N', (LPackage|LObject)>;\r\n        if(context.data.isMetamodel) children = context.data.packages;\r\n        else children = context.proxyObject.allSubObjects.map(o => o.id);\r\n        return [...super.get_children_idlist(context) as Pointer<DAnnotation | (DPackage|DObject), 1, 'N'>,\r\n            ...children];\r\n    }\r\n\r\n    protected get_isMetamodel(context: Context): this['isMetamodel'] {\r\n        return !!context.data.isMetamodel;\r\n    }\r\n    protected set_isMetamodel(val: this['isMetamodel'], c: Context): boolean {\r\n        val = !!val;\r\n        if (!!c.data.isMetamodel === val) return true;\r\n        TRANSACTION(this.get_name(c)+'.isMetamodel', ()=>{\r\n            SetFieldAction.new(c.data, 'isMetamodel', val, '', false);\r\n        }, c.data.isMetamodel, val)\r\n        return true;\r\n    }\r\n\r\n    protected get_crossObjects(context: Context): this[\"objects\"] { return this.get_objects(context, true); }\r\n    protected get_objects(context: Context, includeCrossReferences: boolean = false): this['objects'] {\r\n        let ret: LObject[] = context.data.objects.map((pointer) => LPointerTargetable.from(pointer));\r\n        if (includeCrossReferences) U.arrayMergeInPlace(ret, context.proxyObject.allDependencies.flatMap(dep=>dep.objects));\r\n        return ret;\r\n    }\r\n    protected get_crossPackages(context: Context): this[\"packages\"] { return this.get_packages(context, true); }\r\n\r\n    protected get_packages(context: Context, includeCrossReferences: boolean = false): this[\"packages\"] {\r\n        if (!context.data.isMetamodel) { return context.data.instanceof ? (this.get_instanceof(context) as LModel).packages : []; }\r\n        let ret: LPackage[] = context.data.packages.map((pointer) => LPointerTargetable.from(pointer));\r\n        if (includeCrossReferences) U.arrayMergeInPlace(ret, context.proxyObject.allDependencies.flatMap(dep=>dep.packages));\r\n        return ret;\r\n    }\r\n\r\n    protected set_packages(val: PackArr<this[\"packages\"]>, c: Context): boolean {\r\n        const list = val.map((lItem) => { return Pointers.from(lItem) });\r\n        const oldList = c.data.packages;\r\n        const diff = U.arrayDifference(oldList, list);\r\n        TRANSACTION(this.get_name(c)+'.packages', ()=>{\r\n            SetFieldAction.new(c.data, 'packages', list, \"\", true);\r\n            for (let id of diff.added) {\r\n                SetFieldAction.new(id, 'father', c.data.id, '', true);\r\n                SetFieldAction.new(id, 'parent', c.data.id, '+=', true);\r\n            }\r\n            for (let id of diff.removed as Pointer<DModelElement>[]) {\r\n                SetFieldAction.new(id, 'father', undefined, '', true);\r\n                const parent = DPointerTargetable.from(id).parent;\r\n                U.arrayRemoveAll(parent, c.data.id);\r\n                SetFieldAction.new(id, 'parent', parent, '', true);\r\n            }\r\n        })\r\n        return true;\r\n    }\r\n\r\n    protected get_crossRoots(context: Context): this[\"roots\"] { return this.get_roots(context, true); }\r\n    protected get_roots(context: Context, includeCross: boolean = false): this[\"roots\"] {\r\n        return this.get_objects(context, includeCross);//.filter( o => o.isRoot);\r\n    }\r\n\r\n    protected get_crossClasses(c: Context, s?: DState): this[\"classes\"] { return this.get_classes(c, s, true); }\r\n    protected get_classes(c: Context, s?: DState, includeCross: boolean = false): this[\"classes\"] {\r\n        let key = 'classes';\r\n        let crossKey = 'crossClasses';\r\n        let kind = DClass;\r\n        if (!c.data.isMetamodel) {\r\n            if (!c.data.instanceof) return [] as any;\r\n            let meta = this.get_instanceof(c) as GObject<LModel>;\r\n            if (includeCross && c.data.dependencies.length) return meta[crossKey];\r\n            return meta[key];\r\n        }\r\n        return this._getallSub(c, s, kind, includeCross);\r\n    }\r\n    protected get_crossReferences(c: Context, s?: DState): this[\"references\"] { return this.get_references(c, s, true); }\r\n    protected get_references(c: Context, s?: DState, includeCross: boolean = false): this[\"references\"] {\r\n        let key = 'references';\r\n        let crossKey = 'crossReferences';\r\n        let kind = DReference;\r\n        if (!c.data.isMetamodel) {\r\n            if (!c.data.instanceof) return [] as any;\r\n            let meta = this.get_instanceof(c) as GObject<LModel>;\r\n            if (includeCross && c.data.dependencies.length) return meta[crossKey];\r\n            return meta[key];\r\n        }\r\n        return this._getallSub(c, s, kind, includeCross);\r\n    }\r\n\r\n    protected get_crossEnums(context: Context): this[\"enums\"] { return this.get_enumerators(context, undefined, true); }\r\n    protected get_enums(context: Context): this[\"enums\"] {\r\n        if (!context.data.isMetamodel) { return context.data.instanceof ? (this.get_instanceof(context) as LModel).enumerators : [] as any; }\r\n        return this.get_enumerators(context, undefined, false);\r\n    }\r\n\r\n    protected get_crossEnumerators(context: Context, s?: DState): this[\"enums\"] { return this.get_enumerators(context, s, true); }\r\n    protected get_enumerators(c: Context, s?: DState, includeCross:boolean = false): this[\"enums\"] {\r\n        let key = 'enumerators';\r\n        let crossKey = 'crossEnumerators';\r\n        let kind = DEnumerator;\r\n        if (!c.data.isMetamodel) {\r\n            if (!c.data.instanceof) return [] as any;\r\n            let meta = this.get_instanceof(c) as GObject<LModel>;\r\n            if (includeCross && c.data.dependencies.length) return meta[crossKey];\r\n            return meta[key];\r\n        }\r\n        return this._getallSub(c, s, kind, includeCross);\r\n    }\r\n    protected get_allCrossSubPackages(c: Context, s?: DState): this[\"allCrossSubPackages\"] { return this.get_allSubPackages(c, s, true); }\r\n\r\n    protected get_allSubPackages(c: Context, s?: DState, includeCross: boolean = false): this[\"allSubPackages\"] {\r\n        let key = 'allSubPackages';\r\n        let crossKey = 'allCrossSubPackages';\r\n        let kind = DPackage;\r\n        if (!c.data.isMetamodel) {\r\n            if (!c.data.instanceof) return [] as any;\r\n            let meta = this.get_instanceof(c) as GObject<LModel>;\r\n            if (includeCross && c.data.dependencies.length) return meta[crossKey];\r\n            return meta[key];\r\n        }\r\n        return this._getallSub(c, s, kind, includeCross);\r\n        /*state = state || store.getState();\r\n        let tocheck: Pointer<DPackage>[] = context.data.packages || [];\r\n        let checked: Dictionary<Pointer, DPackage> = {};\r\n        while (tocheck.length) {\r\n            let newtocheck: Pointer<DPackage>[] = [];\r\n            for (let ptr of tocheck) {\r\n                if (checked[ptr]) throw new Error(\"loop in packages containing themselves\");\r\n                let dpackage: DPackage = DPointerTargetable.from(ptr, state);\r\n                checked[ptr] = dpackage;\r\n                U.arrayMergeInPlace(newtocheck, dpackage?.subpackages);\r\n            }\r\n            tocheck = newtocheck;\r\n        }\r\n        let darr: DPackage[] = Object.values(checked);\r\n        let larr: LPackage[] & Dictionary<DocString<\"$name\">, LPackage> = LPointerTargetable.fromArr(darr, state);\r\n        U.toNamedArray(larr, darr);\r\n        return larr;*/\r\n    }\r\n\r\n    protected get_allCrossSubValues(c: Context, s?: DState): this[\"allCrossSubValues\"] { return this.get_allSubValues(c, s, true); }\r\n    protected get_allSubValues(c: Context, s?: DState, includeCross?:boolean): this[\"allSubValues\"] { return this._getallSub(c, s, DValue, includeCross); }\r\n    // allCrossSubAnnotations!: LAnnotation[];     allCrossSubPackages!: LPackage[];     allCrossObjects!: LObject[];     allCrossSubValues!: LValue[];\r\n    protected get_allCrossSubObjects(c: Context, s?: DState): this[\"allCrossSubObjects\"] { return this.get_allSubObjects(c, s, true); }\r\n\r\n    protected get_allSubObjects(c: Context, s?: DState, includeCross?:boolean): this[\"allSubObjects\"] {\r\n        return this._getallSub(c, s, DObject, includeCross);\r\n    }\r\n    protected _getallSub(context: Context, state: DState|undefined, kind: Any<typeof DModelElement>, includeCross?:boolean): any[]&Dictionary<any, any> {\r\n        state = state || store.getState();\r\n        let darr = Selectors.getAll(kind, undefined, state, true, false) as DModelElement[];\r\n\r\n        //console.log('get_allSubPackages', {includeCross, kind});\r\n        // console.log(\"gao\", {darr:[...darr]});\r\n        let larr = [];\r\n        // let validModels = includeCross ? [c.data.id, ...c.data.dependencies] : [c.data.id];\r\n        let allDeps = includeCross ? this.get_allDependencies(context) : [];\r\n        let allDepPtrs = allDeps.map(m=>m.id);\r\n        for (let i = 0; i < darr.length; i++){\r\n            let l = LPointerTargetable.fromD(darr[i]);\r\n            if (!l) continue;\r\n            let lmodel = l.model;\r\n            // Log.exDev(!lmodel, \"missing model in model element\", {l, context}); normal for primitive types in \"m3\"\r\n            if (!lmodel) continue;\r\n            let lmodelid = l.model.id;\r\n            if (lmodelid === context.data.id || includeCross && allDepPtrs.includes(lmodelid)) {\r\n                larr.push(l);\r\n            }\r\n            darr[i] = undefined as any;\r\n            continue;\r\n        }\r\n        // console.log(\"gao\", {darr:[...darr], larr});\r\n        darr = darr.filter(d=>!!d);\r\n        // console.log(\"gao\", {darr, larr});\r\n        U.toNamedArray(larr, darr);\r\n        return larr;\r\n    }\r\n\r\n    public getClassByNameSpace(namespacedclass: string): LClass | undefined { return this.cannotCall(\"getClassByNameSpace\"); }\r\n    protected get_getClassByNameSpace(context: Context): this[\"getClassByNameSpace\"] {\r\n        if (!context.data.isMetamodel) { return context.data.instanceof ? (this.get_instanceof(context) as LModel).getClassByNameSpace : undefined as any; }\r\n        return (namespacedclass: string): LClass | undefined => {\r\n            let pos = namespacedclass.lastIndexOf(\":\");\r\n            let pkguri = namespacedclass.substring(0, pos);\r\n            let classname = namespacedclass.substring(pos+1);\r\n            let pkg: LPackage | undefined = this.get_getPackageByUri(context)(pkguri);\r\n            if (!pkg) return undefined;\r\n            // return pkg[\"@\" + classname];\r\n            return pkg.classes.filter((c) => c.name === classname)[0];\r\n        }; }\r\n    public getPackageByUri(uri: string): LPackage | undefined { return this.cannotCall(\"getPackageByUri\"); }\r\n    protected get_getPackageByUri(context: Context): this[\"getPackageByUri\"] {\r\n        return (uri: string)=>context.proxyObject.allSubPackages.filter((p)=>p.uri === uri)[0]; }\r\n\r\n\r\n    /* See src/api/persistance/save.ts */\r\n\r\n    protected get_attributes(context: Context): this['attributes'] {\r\n        if (!context.data.isMetamodel) { return context.data.instanceof ? (this.get_instanceof(context) as LModel).attributes : []; }\r\n        return context.proxyObject.classes.flatMap(c => c.attributes);\r\n    }\r\n\r\n    protected get_literals(context: Context): this['literals'] {\r\n        if (!context.data.isMetamodel) { return context.data.instanceof ? (this.get_instanceof(context) as LModel).literals : []; }\r\n        return context.proxyObject.enumerators.flatMap(e => e.literals);\r\n    }\r\n\r\n    protected get_values(context: Context): this['values'] {\r\n        return context.proxyObject.objects.flatMap(o => o.features);\r\n    }\r\n}\r\nRuntimeAccessibleClass.set_extend(DNamedElement, DModel);\r\nRuntimeAccessibleClass.set_extend(LNamedElement, LModel);\r\n\r\n\r\n@RuntimeAccessible('DFactory_useless_')\r\nexport abstract class DFactory_useless_ extends DPointerTargetable { // DModelElement\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LFactory_useless_;\r\n    // static logic: typeof LFactory_useless_;\r\n    // static structure: typeof DFactory_useless_;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DFactory_useless_, 1, 1, LFactory_useless_>;\r\n    parent: Pointer<DModelElement, 0, 'N', LModelElement> = [];\r\n    father!: Pointer<DModelElement, 1, 1, LModelElement>;\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    // personal\r\n    ePackage: Pointer<DPackage, 1, 1, LPackage> = '';\r\n    abstract create(DClass: DClass): DObject;\r\n    abstract createFromString(eDataType: DDataType, literalValue: string): EJavaObject;\r\n    abstract convertFromString(eDataType: DDataType, instanceValue: EJavaObject): string;\r\n    // ********************** my additions inherited ********************* //\r\n    // ********************** my additions personal ********************** //\r\n}\r\n@RuntimeAccessible('LFactory_useless_')\r\nexport abstract class LFactory_useless_<Context extends LogicContext<DFactory_useless_> = any, C extends Context = Context>  extends LModelElement {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DFactory_useless_;\r\n    id!: Pointer<DFactory_useless_, 1, 1, LFactory_useless_>;\r\n    // static singleton: LFactory_useless_;\r\n    // static logic: typeof LFactory_useless_;\r\n    // static structure: typeof DFactory_useless_;\r\n\r\n    // inherit redefine\r\n    parent!: LModelElement[];\r\n    father!: LModelElement;\r\n    annotations!: LAnnotation[];\r\n    // personal\r\n    ePackage!: LPackage;\r\n    abstract create(DClass: DClass): DObject;\r\n    abstract createFromString(eDataType: DDataType, literalValue: string): EJavaObject;\r\n    abstract convertFromString(eDataType: DDataType, instanceValue: EJavaObject): string;\r\n    // ********************** my additions inherited ********************* //\r\n    // ********************** my additions personal ********************** //\r\n}\r\n\r\n// DModelElement.subclasses.push('DFactory_useless_'); // because it's abstract and cannot be used as a value, it's pure type definition\r\n// DModelElement.subclasses.push('LFactory_useless_'); // because it's abstract and cannot be used as a value, it's pure type definition\r\n// RuntimeAccessibleClass.set_extend(DModelElement, DFactory_useless_);\r\n// RuntimeAccessibleClass.set_extend(LModelElement, LFactory_useless_);\r\n\r\n@RuntimeAccessible('EJavaObject')\r\nexport class EJavaObject{\r\n\r\n}// ??? EDataType instance?\r\n\r\n\r\n@RuntimeAccessible('DMap')\r\nexport class DMap extends RuntimeAccessibleClass { // DPointerTargetable\r\n    // static logic: typeof LModelElement;\r\n    // static structure: typeof DModelElement;\r\n    // static singleton: LModelElement;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    __isDMap!: true;\r\n    constructor() {\r\n        super();\r\n    }\r\n\r\n    // id!: Pointer<DModelElement, 1, 1, LModelElement>;\r\n}\r\n\r\n@RuntimeAccessible('LMap')\r\nexport class LMap<Context extends LogicContext<DMap> = any, C extends Context = Context>  extends LPointerTargetable {\r\n    // static logic: typeof LModelElement;\r\n    // static structure: typeof DModelElement;\r\n    // static singleton: LModelElement;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    __isLMap!: true;\r\n    // id!: Pointer<DModelElement, 1, 1, LModelElement>;\r\n}\r\nRuntimeAccessibleClass.set_extend(DPointerTargetable, DMap as any);\r\nRuntimeAccessibleClass.set_extend(LPointerTargetable, LMap);\r\n\r\n\r\n@Leaf\r\n@RuntimeAccessible('DObject')\r\nexport class DObject extends DPointerTargetable { // extends DNamedElement, m1 class instance\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n\r\n    // inherit redefine\r\n    annotations!: never[];\r\n    id!: Pointer<DObject, 1, 1, LObject>;\r\n    parent: Pointer<DModel | DValue, 0, 'N', LModel | LValue> = [];\r\n    father!: Pointer<DModel, 1, 1, LModel> |  Pointer<DValue, 1, 1, LValue>;\r\n    // annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    name!: string;\r\n\r\n    // personal\r\n    instanceof!: Pointer<DClass>; // actually nullable now, but takes too much type refactoring. be careful to check if it's present\r\n    features: Pointer<DValue>[] = [];\r\n\r\n\r\n    public static new(instanceoff?: DObject[\"instanceof\"], father?: DObject[\"father\"], fatherType?: typeof DModel | typeof DValue, name?: DNamedElement[\"name\"], persist: boolean = true): DObject {\r\n        // if (!name) name = this.defaultname(((meta: LNamedElement) => meta.name + \" \"), father);\r\n        if (!name) name = this.defaultname(((meta: LNamedElement) => (meta?.name || \"obj\") + \"_\"), father, instanceoff);\r\n        let ret = new Constructors(new DObject('dwc'), father, persist, fatherType).DPointerTargetable().DModelElement()\r\n            .DNamedElement(name).DObject(instanceoff).end();\r\n        return ret;\r\n    }\r\n\r\n    public static new3(ptrs:Partial<ObjectPointers>, then:(d:DObject, c: Constructors)=>void, fatherType?: typeof DModel | typeof DValue, persist: boolean = true): DObject{\r\n        if (!ptrs.name) ptrs.name = this.defaultname(((meta: LNamedElement) => (meta?.name || \"obj\") + \"_\"), ptrs.father, ptrs.instanceof);\r\n        return new Constructors(new DObject('dwc'), ptrs.father, persist, fatherType, ptrs.id)\r\n            .DPointerTargetable().DModelElement()\r\n            .DNamedElement(ptrs.name).DObject(ptrs.instanceof).end(then);\r\n    }\r\n\r\n\r\n}\r\n\r\n@RuntimeAccessible('LObject')\r\nexport class LObject<Context extends LogicContext<DObject> = any, C extends Context = Context, D extends DObject = DObject> extends LNamedElement { // extends DNamedElement, m1 class instance\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DObject;\r\n    id!: Pointer<DObject, 1, 1, LObject>;\r\n\r\n    // inherit redefine\r\n    annotations!: never[];\r\n    children!: LValue[];\r\n    allChildren!: LValue[]; // including hidden values\r\n    truechildren!: LValue[]; // real shape without \"mirage\" values\r\n    parent!: (LModel | LValue)[];\r\n    father!: LModel | LValue;\r\n    model!: LModel;\r\n    // annotations!: LAnnotation[];\r\n    // from LClass\r\n\r\n    name!: string;\r\n    ecoreRootName!: string;\r\n    namespace!: string;\r\n    defaultValue!: DClass[\"defaultValue\"];\r\n    // abstract!: boolean;\r\n    // interface!: boolean;\r\n    // references!: LReference[];\r\n    // attributes!: LAttribute[];\r\n    // operations!: LOperation[];\r\n\r\n    // personal\r\n    deepSubObjects!: LObject[]; // todo: itera features (lvalue[]) deep e vitando di inserire doppioni (salva una mappatura di di già aggiunti e skip se ricompaiono)\r\n    subObjects!: LObject[];\r\n    referenceFeatures!: LValue[]; // subset of features that are references.\r\n    attributeFeatures!: LValue[]; // subset of features that are attributes.\r\n    shapelessFeatures!: LValue[]; // subset of features that are not mapped and can have any kind of values.\r\n    // + tutte le funzioni di comodità navigazionale del modello, trattarlo un pò come se fosse un modello (e quasi può esserlo)\r\n    instanceof!: LClass;\r\n    features!: LValue[];\r\n    isRoot!: boolean;\r\n    readonly partial!: boolean;\r\n\r\n    protected get_name(context: Context): this['name'] {\r\n        return (context.proxyObject as GObject)['$name']?.value || context.data.name || context.proxyObject.instanceof.name;\r\n    }\r\n\r\n    composed!:boolean;\r\n    aggregated!:boolean;\r\n    contained!:boolean;\r\n    referencedBy!: LValue[];\r\n    protected get_composed(c: Context): this['composed'] { return (LClass.singleton as LClass).get_composed(c as any); }\r\n    protected get_aggregated(c: Context): this['aggregated'] { return (LClass.singleton as LClass).get_aggregated(c as any); }\r\n    protected get_contained(c: Context): this['contained'] { return (LClass.singleton as LClass).get_contained(c as any); }\r\n    /*\r\n    protected get_referencedBy(c: Context): this[\"referencedBy\"] { return (LClass.singleton as LClass).get_referencedBy(c as any) as any; }\r\n    */\r\n    get_referencedBy(context: Context): LObject[\"referencedBy\"] {\r\n        let state: DState = store.getState();\r\n        let targeting: LValue[] = LPointerTargetable.fromArr(context.data.pointedBy.map( p => {\r\n            let s: GObject = state;\r\n            for (let key of PointedBy.getPathArr(p)) {\r\n                s = s[key];\r\n                if (!s) return null;\r\n                if (s.className === DValue.cname) return s.id;\r\n            }\r\n        }));\r\n        return targeting;\r\n    }\r\n\r\n    protected get_truechildren(context: Context): this[\"children\"] {\r\n        let childs: LValue[] = super.get_children(context);\r\n        if (!context.data.instanceof) return childs;\r\n        return childs.filter( (c) => !c.isMirage);\r\n    }\r\n\r\n    protected get_allChildren(context: Context): this[\"children\"] { return super.get_children(context); }\r\n\r\n    protected get_children(context: Context, sort: boolean = true): this[\"children\"] {\r\n        const pointers = [...(new Set(super.get_children(context).map(c => c.id)))];\r\n        let childs: LValue[] = LValue.fromArr(pointers);\r\n        let meta: LClass = context.proxyObject.instanceof;\r\n        // if (!sort && (!meta || meta.partial)) return childs;\r\n        let conformchildren: undefined | Pointer[] = meta && !meta.partial ? meta.allChildren.map(c => c.id) : undefined;\r\n        if (!sort) {\r\n            // console.log(\"return get features:\", {context, meta, childs, conformchildren, ret:childs.filter((c) => (c.instanceof?.id) && conformchildren!.includes(c.instanceof?.id))});\r\n            if (!conformchildren) return childs;\r\n            return childs.filter((c) => (c.instanceof?.id) && conformchildren!.includes(c.instanceof?.id));\r\n        }\r\n\r\n        let bymetaparent: Dictionary<DocString<\"metaparent pointer\">, LValue[]> = {};\r\n        for (let v of childs) {\r\n            let vmeta = v.instanceof;\r\n            // console.log(\"get features filtering:\", {context, meta, vmeta, v, childs, conformchildren});\r\n\r\n            if (conformchildren && (!vmeta || !conformchildren.includes(vmeta.id))) continue;\r\n            let vmetaid: string = vmeta?.id as string; // undef as key is fine even if compiler complains, so i cast it\r\n            if (!bymetaparent[vmetaid]) bymetaparent[vmetaid] = [v]; else bymetaparent[vmetaid as any].push(v);\r\n        }\r\n        // console.log(\"return get features:\", {context, meta, childs, conformchildren, ret:Object.values(bymetaparent).flat()});\r\n        return Object.values(bymetaparent).flat();\r\n    }\r\n\r\n    typeStr!:string; // derivate attribute, abstract\r\n    typeString!:string; // derivate attribute, abstract\r\n    __info_of__typeStr: Info = {type: ShortAttribETypes.EString, txt: <div>Alias of<i>this.typeString</i></div>}\r\n    __info_of__typeString: Info = {type: ShortAttribETypes.EString, txt: <div>Stringified version of <i>this.type</i></div>}\r\n    protected get_typeString(c: Context): string { return this.get_typeStr(c); }\r\n    protected get_typeStr(c: Context): string {\r\n        let thiss: GObject<this> = this as any;\r\n        if (!thiss.get_instanceof) return 'shapeless';\r\n        let meta: any = thiss.get_instanceof(c);\r\n        return meta?.typeToShortString?.() || \"shapeless\"; }\r\n\r\n    // protected get_fromlclass<T extends keyof (LClass)>(meta: LClass, key: T): LClass[T] { return meta[key]; }\r\n    protected get_model(context: Context): LModelElement[\"model\"] {\r\n        let l: LValue | LObject | LModel = context.proxyObject;\r\n        while (l && l.className !== DModel.cname) l = l.father;\r\n        return l as LModel; }\r\n    // protected set_name(val: string, context: Context): boolean { return this.cannotSet(\"name\"); }\r\n    protected set_namespace(val: string, context: Context): boolean { return this.cannotSet(\"namespace\"); }\r\n    // protected get_namespace(context: Context): LClass[\"namespace\"] { return context.proxyObject.instanceof.namespace; }\r\n    protected set_fullname(val: string, context: Context): boolean { return this.cannotSet(\"fullname\"); }\r\n    // protected get_fullname(context: Context): LClass[\"fullname\"] { return context.proxyObject.instanceof.fullname; }\r\n    protected set_ecoreRootName(val: string, context: Context): boolean { return this.cannotSet(\"ecoreRootName\"); }\r\n    protected get_ecoreRootName(context: Context): LObject[\"ecoreRootName\"] {\r\n        let instanceoff: LClass = context.proxyObject.instanceof;\r\n        if (!instanceoff) return \"schemaless:Object\";\r\n        return this.get_uri(context) + \":\" + instanceoff.name; // optimize later in instanceoff.namespace + \":\" + instanceoff.name; and implement namespace all around\r\n    }\r\n    protected set_partialdefaultname(val: DClass[\"partialdefaultname\"], context: Context): boolean { return this.cannotSet(\"DObject.partialdefaultname()\"); }\r\n    protected get_partialdefaultname(context: Context): DClass[\"partialdefaultname\"] { return context.data.instanceof ? context.proxyObject.instanceof.partialdefaultname : \"val_\"; }\r\n    protected set_partial(val: DClass[\"partial\"], context: Context): boolean { return this.cannotSet(\"DObject.set_partial()\"); }\r\n    protected get_partial(context: Context): DClass[\"partial\"] { return context.data.instanceof ? context.proxyObject.instanceof?.partial : true; }\r\n\r\n    /*    protected set_abstract(val: string, context: Context): boolean { return this.cannotSet(\"abstract\"); }\r\n        protected get_abstract(context: Context): LClass[\"abstract\"] { return context.proxyObject.instanceof.abstract; }\r\n        protected set_interface(val: string, context: Context): boolean { return this.cannotSet(\"interface\"); }\r\n        protected get_interface(context: Context): LClass[\"interface\"] { return context.proxyObject.instanceof.interface; }*/\r\n    protected set_defaultValue(val: string, context: Context): boolean { return this.cannotSet(\"defaultValue\"); }\r\n    protected get_defaultValue(context: Context): LClass[\"defaultValue\"] { return context.proxyObject.instanceof.defaultValue; }\r\n    protected set_referencedBy(val: string, context: Context): boolean { return this.wrongAccessMessage(\"referencedBy cannot be set directly. It should be updated automatically as side effect\"); }\r\n\r\n    protected get_subObjects(context: Context): this[\"subObjects\"] {\r\n        let ref_features: LValue[] = this.get_referenceFeatures(context, false).filter( (f) => (f.instanceof as LReference)!.containment );\r\n        let shapeless_features: LValue[] = this.get_shapelessFeatures(context);\r\n        let vals: LObject[] = [\r\n            ...ref_features.flatMap((f) => (f.values as LObject[])).filter((val)=>!!val),\r\n            ...shapeless_features.flatMap((f) => (f.values as any))\r\n                .filter((val)=>(!!val && val.className === DObject.cname)) as LObject[]\r\n        ];\r\n        return vals;\r\n    }\r\n\r\n    protected get_deepSubObjects(context: Context): this[\"deepSubObjects\"] {\r\n        let alreadyparsed: Dictionary<Pointer, LObject> = {};\r\n        let arr: LObject[] = this.get_subObjects(context);\r\n        while(arr.length) {\r\n            let next: LObject[] = [];\r\n            for (let obj of arr) {\r\n                if (alreadyparsed[obj.id]) continue;\r\n                alreadyparsed[obj.id] = obj;\r\n                next.push(...obj.subObjects);\r\n            }\r\n            arr = next;\r\n        }\r\n        return Object.values(alreadyparsed) || [];\r\n    }\r\n\r\n    protected get_referenceFeatures(context: Context, includeshapeless: boolean = false): this[\"referenceFeatures\"] {\r\n        return context.proxyObject.features.filter((f) => (!f.instanceof ? includeshapeless : f.instanceof.className === DReference.cname));\r\n    }\r\n    protected get_attributeFeatures(context: Context, includeshapeless: boolean = false): this[\"attributeFeatures\"] {\r\n        return context.proxyObject.features.filter((f) => (!f.instanceof ? includeshapeless : f.instanceof.className === DAttribute.cname));\r\n    }\r\n\r\n    protected get_shapelessFeatures(context: Context): this[\"shapelessFeatures\"] {\r\n        return context.proxyObject.features.filter((f) => (!f.instanceof));\r\n    }\r\n\r\n    protected get_isRoot(context: Context): LObject[\"isRoot\"] { return context.proxyObject.father.className === DModel.cname; }\r\n    protected set_isRoot(val: never, context: Context): boolean { return this.wrongAccessMessage(\"isRoot cannot be set directly, change father element instead.\"); }\r\n\r\n    public feature(name: string): (PrimitiveType|LObject)|(PrimitiveType|LObject)[] { this.cannotCall('feature'); return null; }\r\n    private get_feature(context: Context): (name: string) => LValue[\"value\"] | LValue[\"values\"] {\r\n        return (name: string) => {\r\n            const lObject = context.proxyObject;\r\n            const features = lObject.features.filter((value) => {\r\n                return value.instanceof?.name === name\r\n            });\r\n            if(features.length > 0) {\r\n                const matchedFeature = features[0];\r\n                switch(matchedFeature.values.length) {\r\n                    case 0: return '';\r\n                    case 1: return matchedFeature.value;\r\n                    default: return matchedFeature.values;\r\n                }\r\n            } return '';\r\n        }\r\n    }\r\n\r\n\r\n    protected generateEcoreJson_impl(context: Context, loopDetectionObj: Dictionary<Pointer, DModelElement> = {}): Json {\r\n        loopDetectionObj[context.data.id] = context.data;\r\n        let asEcoreRoot = (context.proxyObject.isRoot);\r\n        // todo: actually use this loopdetectionobj\r\n        const json: GObject = {};\r\n        if (asEcoreRoot) {\r\n            console.log(\"generate object ecore\", {context, asEcoreRoot, json});\r\n            const lc: LClass = context.proxyObject.instanceof;\r\n            json[ECorePackage.xmiversion] = '2.0';\r\n            json[ECorePackage.xmlnsxmi] = 'http://www.omg.org/XMI';\r\n            // json[ECorePackage.xmlnsxsi] = 'http://www.w3.org/2001/XMLSchema-instance';\r\n            json[\"xmlns:\" + ( lc ? (lc.father.uri + \".\" +lc.father.name) : \"shapeless.model.uri\")] = 'http://www.eclipse.org/emf/2002/Ecore';\r\n        }\r\n\r\n        let features = context.proxyObject.features || [];\r\n        console.log(\"features\", {features});\r\n        for (let f of features) {\r\n            if (!f) continue;\r\n            let meta = f.instanceof;\r\n            if (meta?.volatile) { continue; }\r\n            (!json[f.name]) && (json[f.name] = f.generateEcoreJson(loopDetectionObj));\r\n        }\r\n        return json; }\r\n\r\n    public addValue(name?: DValue[\"name\"], instanceoff?: DValue[\"instanceof\"], value?: DValue[\"values\"], isMirage?: boolean): LValue { return this.cannotCall(\"addValue\"); }\r\n    protected get_addValue(context: Context): this[\"addValue\"] {\r\n        return (name?: DValue[\"name\"], instanceoff?: DValue[\"instanceof\"], value?: DValue[\"values\"], isMirage?: boolean) => {\r\n            return LPointerTargetable.fromD(DValue.new(name, instanceoff, value, context.data.id, true, isMirage));\r\n        }\r\n    }\r\n\r\n    protected get_namespace(context: Context): string {\r\n        return context.data.instanceof ? context.proxyObject.instanceof.father.prefix : \"schemaless\"; }\r\n    protected get_uri(context: Context): string {\r\n        if (!context.data.instanceof) return \"schemaless\";\r\n        let pkg = context.proxyObject.instanceof.father;\r\n        return pkg.uri;// + \".\" + pkg.name;\r\n    }\r\n    // protected get_namespace(context: Context): string { if (!context.data.instanceof) return \"schemaless\"; return context.proxyObject.instanceof.namespace; }\r\n\r\n    protected get_children_idlist(context: Context): Pointer<DAnnotation | DValue, 1, 'N'> {\r\n        return [...super.get_children_idlist(context) as Pointer<DAnnotation | DValue, 1, 'N'>,\r\n            ...context.data.features];\r\n    }\r\n\r\n    protected get_instanceof(context: Context): this[\"instanceof\"] {\r\n        const pointer = context.data.instanceof;\r\n        return pointer && LPointerTargetable.from(pointer)\r\n    }\r\n    protected set_instanceof(val: Pack1<this[\"instanceof\"]>, c: Context): boolean {\r\n        const metaptr: D[\"instanceof\"] = Pointers.from(val);\r\n        if (metaptr === c.data.instanceof) return true;\r\n        TRANSACTION(this.get_name(c)+'.instanceof', ()=>{\r\n            this._removeConformity(c);\r\n            SetFieldAction.new(c.data.id, \"instanceof\", metaptr, undefined, true);\r\n            // update father's collections (pointedby's here are set automatically)\r\n            metaptr && SetFieldAction.new(metaptr as Pointer<DClass>, \"instances\", c.data.id, '+=', true);\r\n            if (metaptr) this._forceConformity(c, metaptr);\r\n        }, this.get_instanceof(c)?.fullname, LPointerTargetable.wrap(metaptr)?.fullname)\r\n        return true;\r\n    }\r\n\r\n    private forceConformity(context: Context, meta: D[\"instanceof\"]): void {\r\n        let oldinstanceof = context.data.instanceof;\r\n        // context.data.instanceof = meta;\r\n        let ret = this._forceConformity(context, meta);\r\n        // context.data.instanceof = oldinstanceof;\r\n        return ret;\r\n    }\r\n    private _forceConformity(context: Context, meta: D[\"instanceof\"]): void {\r\n        let lmeta = meta && LPointerTargetable.wrap(meta) as this[\"instanceof\"];\r\n        if (!lmeta) return;\r\n        let attrs = lmeta.allAttributes;\r\n        let refs = lmeta.allReferences;\r\n        let values = context.proxyObject.allChildren;\r\n        let idmap: Dictionary<string, LAttribute | LReference> = {};\r\n        for (let a of attrs) { idmap[a.id] = a; }\r\n        for (let a of refs) { idmap[a.id] = a; }\r\n        console.log({idmap, values, data: context.data, l:context.proxyObject});\r\n        // damiano: todo quando viene cancellato una feature il puntatore in features e values rimane. use pointedby's\r\n        // then remove attributes and references that are already instantiated in the object\r\n        for (let v of values) { if(v && v.__raw.instanceof) delete idmap[v.__raw.instanceof]; }\r\n        console.log(\"forceconformity\", {attrs, refs, valuesPre: values.map(v => v && v.__raw.instanceof), toadd:idmap});\r\n        for (let id in idmap) {\r\n            // let l = idmap[id];\r\n            context.proxyObject.addValue(undefined, id, [],true);\r\n        }\r\n    }\r\n    private _removeConformity(context: Context): void {\r\n        let childs = context.proxyObject.features;\r\n        for (let child of childs) if (child.isMirage) child.delete();\r\n    }\r\n\r\n\r\n    protected get_delete(context: Context): () => void {\r\n        return () => {\r\n            let c: LClass = this.get_instanceof(context);\r\n            if(c && c.isSingleton) {\r\n                Log.ww('Object is a singleton and cannot be removed, remove his singleton flag in m2 first.', context.data);\r\n                return;\r\n            }\r\n            super.get_delete(context)();\r\n        }\r\n    }\r\n    protected get_features(context: Context): this['features'] {\r\n        return this.get_children(context);\r\n        // return context.data.features.map((feature) => { return LPointerTargetable.from(feature) });\r\n    }\r\n\r\n    public ecorePointer(): string { return this.cannotCall(\"ecorePointer\"); }\r\n    protected get_ecorePointer(context: Context): () => string {\r\n        let lastvisited: Pointer<DObject, 1, 1, LObject> = context.data.id;\r\n        return () => \"@//\" + this.get_fatherList(context).map( (f: LModelElement | LObject | LValue) => {\r\n            if (f.className === DObject.cname) { lastvisited = (f as LObject).id; return ''; }\r\n            if (f.className === DModel.cname) { return ''; }\r\n            console.log(\"get_ecorepointer\", f, f.__raw, lastvisited);\r\n            return (f as LValue).name + \".\" + ((f as LValue).__raw.values.indexOf(lastvisited));\r\n        }).filter(v=>!!v).join(\"@/\");\r\n    }\r\n\r\n}\r\nRuntimeAccessibleClass.set_extend(DNamedElement, DObject);\r\nRuntimeAccessibleClass.set_extend(LNamedElement, LObject);\r\n\r\n@Leaf\r\n@RuntimeAccessible('DValue')\r\nexport class DValue extends DModelElement { // extends DModelElement, m1 value (attribute | reference)\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LValue;\r\n    // static logic: typeof LModelElement;\r\n    // static structure: typeof DValue;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DValue, 1, 1, LValue>;\r\n    parent: Pointer<DObject, 0, 'N', LObject> = [];\r\n    father!: Pointer<DObject, 1, 1, LObject>;\r\n    annotations: Pointer<DAnnotation, 0, 'N', LAnnotation> = [];\r\n    //name!: string; // nome opzionale solo per modelli schema-less//, ma se manca restsituisce 'DValue'\r\n\r\n    // personal\r\n    // value: PrimitiveType | Pointer<DObject, 1, 1, LObject>; // vv4\r\n    // values: PrimitiveType[] | Pointer<DObject, 1, 'N', LObject> | Pointer<DEnumLiteral, 1, 'N', LEnumLiteral> = []; // vv4\r\n    values: PrimitiveType[] | Pointer<DObject|DEnumLiteral, 1, 'N', LObject|LEnumLiteral> = [];\r\n    instanceof!: Pointer<DAttribute, 1, 1, LAttribute > | Pointer<DReference, 1, 1, LReference> | undefined; // todo: maybe min lowerbound 0 if you want to allow free shape objects chiedere prof\r\n    edges!: Pointer<DEdge, 0, 'N', LEdge>;\r\n    // conformsTo!: Pointer<DStructuralFeature, 0, 'N', LStructuralFeature>; // low priority to do: attributo fittizio controlla a quali elementi m2 è conforme quando viene richiesto\r\n    isMirage!: boolean;\r\n    allowCrossReference!: boolean;\r\n    // IoT Section\r\n    topic: string = '';\r\n\r\n    public static new(name?: DNamedElement[\"name\"], instanceoff?: DValue[\"instanceof\"], val?: DValue[\"values\"],\r\n                      father?: DValue[\"father\"] | DObject, persist: boolean = true, isMirage: boolean = false): DValue {\r\n        if (!name) name = this.defaultname(\"property_\", father);\r\n        return new Constructors(new DValue('dwc'), (typeof father === \"string\" ? father : (father as DObject)?.id), persist, undefined)\r\n            .DPointerTargetable().DModelElement()\r\n            .DNamedElement(name)\r\n            .DValue(instanceoff, val, isMirage).end();\r\n    }\r\n\r\n    public static new3(a:Partial<ValuePointers>, then?:((d:DValue, c: Constructors)=>void), persist: boolean = true): DValue{\r\n        if (!a.name) a.name = this.defaultname(\"property_\", a.father);\r\n        return new Constructors(new DValue('dwc'), a.father, persist, undefined, a.id)\r\n            .DPointerTargetable().DModelElement()\r\n            .DNamedElement(a.name)\r\n            .DValue(a.instanceof, a.values)\r\n            .end(then);\r\n    }\r\n}\r\n@RuntimeAccessible('LValue')\r\nexport class LValue<Context extends LogicContext<DValue> = any, C extends Context = Context, D extends DValue = DValue> extends LModelElement { // extends DModelElement, m1 value (attribute | reference)\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    public __raw!: DValue;\r\n    id!: Pointer<DValue, 1, 1, LValue>;\r\n\r\n    // inherit redefine\r\n    parent!: (LObject | LModel)[];\r\n    father!: LObject | LModel;\r\n    model!: LModel;\r\n    // from namedelement\r\n    name!: string;\r\n    namespace!: string;\r\n    fullname!:string;\r\n    type!: LClassifier; // Classifiers describing PrimitiveTypes or the classes that can be pointed.\r\n    primitiveType!: LClass;\r\n    classType!: LClass;\r\n    enumType!: LEnumerator;\r\n// from structuralfeature (ref + attr)\r\n    ordered!: boolean;\r\n    unique!: boolean;\r\n    lowerBound!: number;\r\n    upperBound!: number;\r\n    many!: boolean;\r\n    required!: boolean;\r\n    allowCrossReference!: boolean;\r\n\r\n    changeable!: boolean;\r\n    volatile!: boolean;\r\n    transient!: boolean;\r\n    unsettable!: boolean;\r\n    public derived!: boolean;\r\n    /*protected */derived_read?: string;\r\n    /*protected */derived_write?: string;\r\n    /*protected*/ __info_of__derived: Info = {type: 'string', txt:'A ECore flag to signal the values of this feature depend on other features.\\n' +\r\n            'To make it usable at runtime in jjodel check derived_read and derived_write.'}\r\n    /*protected*/ __info_of__derived_read: Info = {type: 'string', txt:'A function in string format with 2 or less attributes: (data, oldValue).\\n' +\r\n            '- data is the LValue hosting this derived feature\\n' +\r\n            '- originalValues are the current **non-derived** values actually memorized in the data.values\\n'+\r\n            'The mandatory return value of this function will be returned when attempted to read data.values.'}\r\n    /*protected*/ __info_of__derived_write: Info = {type: 'string', txt:'A function in string format with 3 or less attributes: (value, data, oldValue).\\n' +\r\n            '- value is the value currently attempted to be set, which triggered the function call.\\n' +\r\n            '- data is the LValue hosting this derived feature\\n' +\r\n            '- originalValues are the current **non-derived** values actually memorized in the data.values\\n'+\r\n            'The optional return value of this function will be stored inside data, allowing for hybrid dependency-persistant features' +\r\n            '\\n or for a feature \"depending on itself\". like uppercasing his values before setting them.'}\r\n    defaultValue!: DStructuralFeature[\"defaultValue\"];\r\n    // defaultValueLiteral!: string;\r\n    // target!: LClass[]; is value[]\r\n    edges!: LEdge[];\r\n    // IoT Section\r\n    topic!: string;\r\n\r\n\r\n    // personal\r\n    value!: PrimitiveType | LObject | LEnumLiteral;\r\n    isMirage!: boolean;\r\n    // value!: PrimitiveType | LObject;\r\n    values!: PrimitiveType[] | LObject[] | LEnumLiteral[];\r\n    instanceof!: LAttribute | LReference | undefined;\r\n    conformsTo!:( LAttribute | LReference)[]; // low priority to do: attributo fittizio controlla a quali elementi m2 è conforme quando viene richiesto\r\n\r\n\r\n    length!: number;\r\n    __info_of__length: Info = {type: 'number', txt: \"shortcut for data.values.length.\"};\r\n    get_length(c: Context): number{\r\n        return this.get_values(c).length;\r\n    }\r\n\r\n\r\n\r\n    protected set___readonly(val: any, c: Context): boolean {\r\n        val = !!val;\r\n        if (val === !!c.data.__readonly) return true;\r\n        super.set___readonly(val, c);\r\n        let lref: LReference = this.get_instanceof(c) as LReference;\r\n        if (!lref) return true;\r\n        let dref = lref.__raw;\r\n        if (dref.composition || dref.aggregation) for(let v0 of this.get_values(c)) {\r\n            if (!v0) continue;\r\n            let v: GObject = v0 as any;\r\n            if (v.__isproxy) v.__readonly = val;\r\n        }\r\n        return true;\r\n    }\r\n    protected get_toPrimitive(c: Context): ()=>(string | number){\r\n        return ()=>this.get_value(c) as any;\r\n    }\r\n\r\n\r\n// from reference\r\n    container!: boolean;\r\n    opposite?: LValue; // if DRef have opposite DRef, when you set a value ref you also set a opposite value ref from target to this src. they are always mirroring.\r\n    containment!:boolean;\r\n    aggregation!:boolean;\r\n    composition!:boolean;\r\n    upperbound!:boolean;\r\n    lowerbound!:boolean;\r\n    protected _defaultGetter(c: Context, k: string | number): any {\r\n        if (k in c.data || typeof k === \"symbol\") return this.__defaultGetter(c, k);\r\n\r\n        // get from values\r\n        if (typeof k === \"number\") return this.get_values(c)[k];\r\n        if (TargetableProxyHandler.childKeys[k[0]]) {\r\n            k = k.substring(1);\r\n            let vals: any[] = this.get_values(c);\r\n            for (let v of vals) {\r\n                if (!v) continue;\r\n                let ret = v[k];\r\n                if (ret !== undefined) return ret;\r\n            }\r\n        }\r\n\r\n        // get from meta\r\n        let getk = 'get_'+k;\r\n        if (k in LReference.singleton || getk in LReference.singleton) return this.get_instanceof(c)?.[k as any];\r\n        if (k in LAttribute.singleton || getk in LAttribute.singleton) return this.get_instanceof(c)?.[k as any];\r\n\r\n        return this.__defaultGetter(c, k);\r\n    }\r\n\r\n    protected _defaultSetter(v: any, c: Context, k: keyof Context[\"data\"] & string): true { //\r\n        if (super._setterFor$stuff_canReturnFalse(v, c, k as string)) return true; // try setter for data.$feature = value; shortcut for data.$feature.value = value;\r\n        this.__defaultSetter(v, c, k);\r\n        return true;\r\n    }\r\n\r\n\r\n    protected get_derived(c: Context): this[\"derived\"] { return (this.get_instanceof(c) as LReference).derived; }\r\n    protected get_derived_read(c: Context): this[\"derived_read\"] { return (this.get_instanceof(c) as LReference).derived_read; }\r\n    protected get_derived_write(c: Context): this[\"derived_write\"] { return (this.get_instanceof(c) as LReference).derived_write; }\r\n    protected set_derived(val: this[\"derived\"], context: Context): boolean { return this.cannotSet('LValue.derived'); }\r\n    protected set_derived_read(val: this[\"derived_read\"], context: Context): boolean { return this.cannotSet('LValue.derived_read'); }\r\n    protected set_derived_write(val: this[\"derived_write\"], context: Context): boolean { return this.cannotSet('LValue.derived_write'); }\r\n\r\n    add(...val: any[]): void { return this.cannotCall(\"LValue.add\"); }\r\n    __info_of__add: Info = {type: \"(...val: any|any[]) => void\", txt: \"Adds a value in the current value collection\"}\r\n    get_add(c: Context): (...val: any[] | this[\"values\"])=>void{\r\n        return (...val: any[] | this[\"values\"]) => { this.set_values([...c.data.values, ...val.map(v => v?.id || v)], c); }\r\n    }\r\n    remove(...val: any[]): void{ return this.cannotCall(\"LValue.remove\"); }\r\n    __info_of__remove: Info = {type: \"(...val: any) => void\", txt: \"Deletes a value in the current value collection, or none if the element is not found.\"}\r\n    get_remove(c: Context): (...val: this[\"values\"])=>void {\r\n        return (...val: any[] | this[\"values\"]) => {\r\n            val = val.map(v => v?.id || v);\r\n            let indices = [];\r\n            let values = c.data.values;\r\n            for (let i = 0; i < values.length; i++) {\r\n                if (val.includes(values[i])) indices.push(i);\r\n            }\r\n            this.get_removeByIndex(c)(...indices); }\r\n    }\r\n    removeByIndex(...val: number[]): void{ return this.cannotCall(\"LValue.removeByIndex\"); }\r\n    __info_of__removeByIndex: Info = {type: \"(...indices: number) => removed[]\", txt: \"Deletes a value in the current value collection, or none if the element is not found.\"}\r\n    get_removeByIndex(c: Context): (...indices: number[])=>void{ return (...indices: number[]) => {\r\n        // reducer is ill-typed, so must force typings\r\n        const indexMap: GObject = indices.reduce<GObject|number>(((accumulator: GObject, currentValue: number) => { accumulator[currentValue] = true; return accumulator;}) as any, {} as GObject) as any;\r\n        this.set_values(c.data.values.filter((v,index) => !indexMap[index]), c);\r\n        // this.set_values(c.data.values.filter((v,index) => indices.includes(index)));\r\n    }\r\n    }\r\n\r\n    instantiableClasses(o?: GObject, loose: boolean = false):LClass[] { return this.cannotCall(\"instantiableClasses\"); }\r\n    __info_of__instantiableClasses: Info = {type: \"(o?: object, loose?: boolean) => LClass[]\",\r\n        txt: \"List of all subclasses of the specified type, which can be used as reference values.\" +\r\n            \"\\n<br>Abstract and Interface classes are excluded.\" +\r\n            \"\\n<br>If the parameter \\\"o\\\" is specified, it will filter only the instances conforming to the object schema.\" +\r\n            \"\\n<br>Results are sorted from tightest fit to loosest fit.\" +\r\n            \"\\n<br>loose parameter set to true makes return instead a list of matching scores of all subclasses.\", hidden: true}\r\n\r\n    // warning: this can be called through model, c.data might be either a value or a model.\r\n    get_instantiableClasses(c: Context): this[\"instantiableClasses\"] {\r\n        return (o?: GObject, loose: boolean = false) => LValue.getInstantiableClasses(this, c, o, loose); }\r\n\r\n\r\n    // @eligibleClasses: search only between those targets.\r\n    // @favoritematch: if this class is a valid match, it is given topmost priority regardless of tightness of excess features over the schema.\r\n    // if a class name actually starts with $ character, it needs to be placed twice to get a match, as in class.$$name\r\n    public static getInstantiableClasses(thiss: GObject<LValue|LModel>, c: LogicContext<DValue> | LogicContext<DModel>, schema?: GObject, loose: boolean = false, eligibleClasses?: LClass[], favoriteMatch?: LClass): LClass[] {\r\n        // find eligible classes\r\n        let isDValue: boolean =  c.data.className === \"DValue\";\r\n        let isDModel: boolean =  c.data.className === \"DModel\";\r\n        let isShapeless = !c.data.instanceof;\r\n        let type: LClass | undefined = isShapeless || !isDValue ? undefined : thiss.get_type(c) as LClass;\r\n        let isReference = !!type && type.className === \"DClass\";\r\n        if (isDValue && !isReference && !isShapeless) return []; // case DValue<Attribute>\r\n        if (!eligibleClasses) {\r\n            if (isReference && !isShapeless) { eligibleClasses = [type as LClass, ...(type as LClass).allSubClasses]; }\r\n            // @ts-ignore\r\n            else {eligibleClasses = thiss.get_model(c).instanceof?.classes || []; }\r\n        }\r\n        let scoreMap: Dictionary<Pointer, {\r\n            id: Pointer, score: number,\r\n            excessFeatures: Dictionary<string>, matchingFeatures: Dictionary<string>, missingFeatures: Dictionary<string>,\r\n            excessFeaturesCount: number, matchingFeaturesCount: number, missingFeaturesCount: number,\r\n            isPartial: boolean,\r\n            class:LClass, instantiable: boolean, namesMap: Dictionary<DocString<\"feature name\">>}> = {};\r\n        for (let c of eligibleClasses) {\r\n            let raw = c.__raw as DClass;\r\n            let instantiable = !(raw.abstract || raw.interface || raw.isSingleton);\r\n            // if (!loose && instantiable) return false;\r\n            if (scoreMap[raw.id]) continue;\r\n            else scoreMap[raw.id] = {class:c, instantiable, isPartial: raw.partial} as any;\r\n        }\r\n        if (schema) {\r\n            // const fix$ = (vals: string[]) => vals.map(v=> (TargetableProxyHandler.childKeys[k[0]]) ? v.substring(1) : v);\r\n            const fix$ = (obj: GObject) => {\r\n                let ret: GObject = {};\r\n                for (let k in obj) {\r\n                    let k1 :string = (TargetableProxyHandler.childKeys[k[0]]) ? k.substring(1) : k;\r\n                    ret[k1] = obj[k];\r\n                }\r\n                return ret;\r\n            }\r\n            schema = fix$(schema);\r\n            let keys: string[] = Object.keys(schema);\r\n            for (let ptr in scoreMap) {\r\n                let score = scoreMap[ptr];\r\n                score.namesMap = U.objectFromArrayValues(score.class.childNames);\r\n                let diff = Uobj.objdiff(score.namesMap, schema);\r\n                console.log( \"objDiff\", {schema, names:score.namesMap, data:score.class});\r\n                score.id = ptr;\r\n                score.excessFeatures = diff.removed;\r\n                score.missingFeatures = diff.added;\r\n                score.matchingFeatures = {...diff.changed, ...diff.unchanged}\r\n                score.excessFeaturesCount = Object.keys(score.excessFeatures).length;\r\n                score.missingFeaturesCount = Object.keys(score.missingFeatures).length;\r\n                score.matchingFeaturesCount = Object.keys(score.matchingFeatures).length;\r\n                score.score = Math.round(((score.instantiable ? 0 : -1) + (keys.length ? score.matchingFeaturesCount / keys.length : 1))*100)/100;\r\n            }\r\n        }\r\n        let sorted = Object.values(scoreMap);\r\n        if (!loose) sorted = sorted.filter((s) => s.instantiable && (!s.missingFeaturesCount || s.isPartial));\r\n        let favoriteMatchID: undefined | Pointer = favoriteMatch?.id;\r\n        sorted = sorted.sort((a, b): number => {\r\n            // return negative if a is less than b, positive if a is greater than b, and zero if they are equal.\r\n            // but since default order is ascending and i want descending, o reverse it.\r\n            if (a.instantiable && !b.instantiable) return -1;\r\n            if (!a.instantiable && b.instantiable) return +1;\r\n            if (a.missingFeaturesCount === 0 && b.missingFeaturesCount === 0) { // >100% match case (might have excess, take tighter)\r\n                // nly if they are both valid full matches, explicit preference takes precedence. then tightness.\r\n                if (a.id === favoriteMatchID) return -1;\r\n                if (b.id === favoriteMatchID) return +1;\r\n                if (a.matchingFeaturesCount !== b.matchingFeaturesCount) return -a.matchingFeaturesCount + b.matchingFeaturesCount;\r\n                if (a.excessFeaturesCount !== b.excessFeaturesCount) return +a.excessFeaturesCount - b.excessFeaturesCount;\r\n            }\r\n            // <99% match, but might be valid for partial classes.\r\n            if (a.isPartial && !b.isPartial) return -1;\r\n            if (!a.isPartial && b.isPartial) return +1;\r\n            if (a.isPartial && b.isPartial) {\r\n                // only if they are both valid partial matches, explicit preference takes precedence. then tightness.\r\n                if (a.id === favoriteMatchID) return -1;\r\n                if (b.id === favoriteMatchID) return +1;\r\n            }\r\n            // if both partials or none is partial\r\n            // if (a.missingFeaturesCount !== b.missingFeaturesCount) return -a.missingFeaturesCount + b.missingFeaturesCount; should be same as matchingFeaturesCount\r\n            if (a.matchingFeaturesCount !== b.matchingFeaturesCount) return -a.matchingFeaturesCount + b.matchingFeaturesCount;\r\n            if (a.excessFeaturesCount !== b.excessFeaturesCount) return +a.excessFeaturesCount - b.excessFeaturesCount;\r\n            return 0;\r\n        });\r\n        if (loose) return sorted as any;\r\n        return sorted.map(score => score.class);\r\n    }\r\n\r\n    addObject(json?: GObject, metaclass: LClass | Pointer<DClass> | DocString<\"ClassName\"> | undefined | null = undefined): LObject{ return this.cannotCall(\"LValue.addObject\"); }\r\n    __info_of__addObject: Info = {type: \"(json: object, instanceof?: LClass | string | null) => LObject\",\r\n        txt: \"Appends an object instancing \\\"instanceof\\\" to the values.\\n<br>Setting his own properties, and DValues according to the content of the parameter object.\\n<br>\" +\r\n            \"If instanceof is:<ul><li><b>a class or a class name</b>, it will instance that class, or a valid non-abstract subclass.\" +\r\n            \"\\n<br/><b>null</b>, it will instantiate a shapeless object.\" +\r\n            \"\\n<br/><b>undefined or missing</b>, it will first try to find a valid type in m2 or fail.</ul\"}\r\n\r\n    // warning: this can be called through model, c.data might be either a value or a model.\r\n    /*\r\n    @param metaclass: null means \"shapeless\", undefined means automatic or failure, never shapeless.\r\n    type assignment priority:\r\n    1) by explicit type argument\r\n    1.1) treating it as a pointer\r\n    1.2) treating it as a $class_name\r\n    1.3) treating it as a DClass\r\n*/\r\n    get_addObject(c: LogicContext<DValue> | LogicContext<DModel>): (json: GObject, metaclass?: Pack1<LClass> | DocString<\"ClassName\"> | null, forceCreation?:boolean)=>LObject{\r\n        return (json: GObject = {}, metaclass: Pack1<LClass> | DocString<\"ClassName\"> | undefined | null = undefined, forceCreation:boolean = false): LObject => {\r\n            let lobj: LObject = undefined as any;\r\n            let father: Pointer<DValue> | Pointer<DModel> = '';\r\n            let isDValue = c.data.className === \"DValue\";\r\n            let isDModel = c.data.className === \"DModel\";\r\n\r\n            TRANSACTION(this.get_name(c as any)+'.addObject()', () => {\r\n                let instanceoff: undefined | LAttribute | LReference = isDValue ? this.get_instanceof(c as Context) : undefined;\r\n                let dinstanceoff: undefined | DAttribute | DReference = instanceoff && instanceoff.__raw;\r\n                // let ShapelessObjectID =\r\n                let isShapeless: boolean = !dinstanceoff; // || dinstanceoff && ((dinstanceoff?.id | dinstanceoff) === ShapelessObjectID);\r\n                let isReference: boolean = !!(dinstanceoff && dinstanceoff.className === \"DReference\");\r\n                if (isDValue && !isReference && !isShapeless) return Log.ee(\"cannot call addObject() on a DValue implementing an attribute\", {dinstanceoff, thiss:c.data});\r\n                let isContainment: boolean = (isDValue && this.get_containment(c as Context)) || isDModel;\r\n                // if (metaclass === undefined) metaclass = \"object\"; // in this case, i first check if a class \"object\" exist, then make a shapeless object if not.\r\n                let state: DState = store.getState();\r\n\r\n                father = isContainment ? c.data.id : this.get_model(c).id;\r\n                let constructorPointers: Partial<ObjectPointers> = {...json, father};\r\n\r\n                // if undefined = explicitly told to make it shapeless. if null, it's automatic selectyion by value.type or m2-model classes.\r\n                //console.log('Object.new3', {metaclass, forceCreation, json});\r\n                if (metaclass !== null) {\r\n                    let lmetaclass: LClass | undefined;\r\n                    // find instance schema: 1) by explicit type argument\r\n                    if (metaclass) {\r\n                        // find instance schema: 1.1) by pointer AND 1.3) by Dclass\r\n                        lmetaclass = LPointerTargetable.from(metaclass, state);\r\n                        // find instance schema: 1.2) by $class_name\r\n                        if ((!lmetaclass || lmetaclass.className !== \"DClass\") && typeof metaclass === \"string\") {\r\n                            let m2classes = c.proxyObject.model?.instanceof?.classes;\r\n                            if (m2classes) lmetaclass = LPointerTargetable.from(m2classes[\"$\" + metaclass] || m2classes[metaclass], state);\r\n                            // if (!lmetaclass && typeof metaclass === \"string\" && metaclass.toLowerCase() === \"object\") lmetaclass = undefined;\r\n                        }\r\n                        //(window as any).debugg = LValue.getInstantiableClasses(this, c, json, true, lmetaclass ? [lmetaclass, ...lmetaclass.allSubClasses] : []);\r\n                        // check if metaclass is found\r\n                        if (!lmetaclass || lmetaclass.className !== \"DClass\") return Log.ee(\"provided schema type does not belong to a Class, cannot intantiate.\", {lmetaclass, schema:metaclass, this:c.data});\r\n                        // check if metaclass is valid (instantiable in the callee collection: .values or .objects)\r\n                        // console.log(\"isExtending\", {lmetaclass, type: isDValue && this.get_type?.(c as any)});\r\n                        if (isDValue && !lmetaclass.isExtending(this.get_type(c as Context) as LClass)) return Log.ee(\"provided schema type does not extend this.type, cannot intantiate.\", {lmetaclass, schema:metaclass, this:c.data});\r\n                    }\r\n                    // find instance schema: 2) by dvalue.type\r\n                    else if (isDValue && !isShapeless) {\r\n                        lmetaclass = this.get_type(c as Context) as LClass;\r\n                    }\r\n                    // phase 2: using lmetaclass (if found), i set constructorPointers.instanceof\r\n                    // if requested type is found. but might be abstract, so i filter the best subclass match\r\n                    if (lmetaclass) {\r\n                        if (forceCreation && metaclass) {\r\n                            constructorPointers.instanceof = (typeof metaclass === 'string' ? metaclass : (metaclass as any).id);\r\n                        }\r\n                        else {\r\n                            constructorPointers.instanceof = LValue.getInstantiableClasses(this, c, json, false,\r\n                                [lmetaclass, ...lmetaclass.allSubClasses], lmetaclass)[0] as any; // actually a L-class, but \"ObjectPointers\" can accept them too.\r\n                        }\r\n                        if (!constructorPointers.instanceof) { // the whole if is just printing error.\r\n                            let matches = LValue.getInstantiableClasses(this, c, json, true, [lmetaclass, ...lmetaclass.allSubClasses]);\r\n                            if (lmetaclass?.isSingleton) Log.ee(\"addObject(schema) cannot instantiate \" + metaclass + \" because it is a singleton.\", {json, matches, this: c.data});\r\n                            return Log.ee(\"addObject(schema) could not find a valid subtype of \" + metaclass +\r\n                                \" conforming ot that schema to instantiate an object.\\n\" + (matches.length ? \"closest match was: \" + matches[0].name : \"\"),\r\n                                {json, matches, this: c.data});\r\n                        }\r\n                    }\r\n                    // if not found, i look among all m2classes\r\n                    else if (!isDValue || isShapeless) {\r\n                        // if shapelessvalue.addObject() --> infer schema from json keys and ref sub-types best match\r\n                        // if model.addObject() --> find best match within all classes\r\n                        (window as any).debugg = this.get_model(c).instantiableClasses(json, true);\r\n                        constructorPointers.instanceof = this.get_model(c).instantiableClasses(json, false)[0] as any // actually a L-class, but \"ObjectPointers\" can accept them too.\r\n                        if (!constructorPointers.instanceof) { // the whole if is just printing error.\r\n                            let matches = isDValue ? this.get_instantiableClasses(c as Context)(json, true) : this.get_model(c).instantiableClasses(json, true);\r\n                            let type: LClassifier = isDValue ? this.get_type(c as Context) : undefined as any;\r\n                            return Log.ee(\"LValue.addObject(schema) could not find a valid \" + (c.data.className === \"DValue\" ? \"subtype of \" + type.name : \"type\") +\r\n                                \" conforming ot that schema to instantiate an object.\\n\" + (matches.length ? \"closest match was: \" + (matches[0] as any)?.class.name : \"\"), {json, type, matches, thiss: c.data});\r\n                        }\r\n                    }\r\n                    if (!constructorPointers.instanceof && isDValue && !isShapeless) {\r\n                        return Log.ee(\"could not find an instantiable subtype for given schema and type \" + instanceoff?.type?.name, {schema: json, type: instanceoff?.type})\r\n                    }\r\n                }\r\n                // both dmodel.objects nad dvalue.values are updated by the Constructors by passing father parameter.\r\n                // phase 3: create object according to schema (or shapeless) and update parent container collection.\r\n                console.log(\"Object.new3\", {constructorPointers});\r\n                if (!constructorPointers.name && constructorPointers.instanceof){\r\n                    let meta = L.from(constructorPointers.instanceof);\r\n                    if (meta.isSingleton){ constructorPointers.name = meta.name; }\r\n                }\r\n                let dobj = DObject.new3(constructorPointers, () => { }, isDModel?DModel:DValue, true);\r\n                if (isReference && !isContainment){\r\n                    // if is ref containment, object.father is set to value, which also appends the object to this.values\r\n                    // if it's model, object.father = model, and it goes in model.objects and not in values.\r\n                    // if it's non-containment value, it goes in model but also appended to this.values\r\n                    // ? if schemaless acts like a containment ref so still fine ?\r\n                    this.set_values([...(c as Context).data.values, dobj.id], c as Context)\r\n                }\r\n                // phase 4: set sub-DDalues.values according to json data provided, or create them if they were missing in partial class match.\r\n                lobj = LPointerTargetable.fromD(dobj);\r\n                let dobjkeys = Object.keys(dobj);\r\n\r\n                // update lmetaclass from candidate root, to selected instance (sub-type)\r\n                let lmetaclass: LClass | undefined = constructorPointers.instanceof && LPointerTargetable.wrap(constructorPointers.instanceof);\r\n                let isPartial: boolean = !!lmetaclass?.partial;\r\n                let childnames: Dictionary<string> = lmetaclass ? U.objectFromArrayValues(lmetaclass.childNames) : {};\r\n                // because at current time Constructor.setPtr actions are not executed yet. so dobject.features is empty, even through LPoint.from(valueid) canaccess the \"pending\" local dvalue not in store.\r\n                setTimeout(()=>TRANSACTION(this.get_name(c as any)+'.addObject() initializing values', ()=>{\r\n                    for (let key in json) {\r\n                        if (TargetableProxyHandler.childKeys[key[0]]) { // if $ is prepended, priority is first and only child values check\r\n                            if (key in childnames) { // if child dvalue with that name including char $ exist, like in \"$\" + \"$name\"\r\n                                (lobj as GObject<LObject>)[\"$\" + key].values = json[key];\r\n                                continue;\r\n                            }\r\n                            let key1 = key.substring(1);\r\n                            if (key1 in childnames) { // if child dvalue with that name excluding char $ exist, like in \"$\" + \"name\" (as normal)\r\n                                (lobj as GObject<LObject>)[\"$\" + key1].values = json[key];\r\n                                continue;\r\n                            }\r\n                            // if child dvalue with that name do not exist\r\n                            if (isShapeless || isPartial) { lobj.addValue(key, undefined, json[key], false); continue; }\r\n                            // this should never happen, if there is a mismatch in finding the correct type conforming to the schema, the function should have already stopped and returned before.\r\n                            Log.eDevv('addObject(schema) error: cannot find value collection named \"' + key + ' \" as defined in the schema parameter.',\r\n                                {lmetaclass, this:c.data, instanceof: constructorPointers.instanceof});\r\n                            continue;\r\n                        }\r\n                        // if $ is NOT prepended, priority is inverted: first DObject properties, then child values\r\n                        if (key in dobjkeys) { (lobj as GObject<LObject>)[key] = json[key]; continue; }\r\n                        else {\r\n                            // redoing the whole childmatch attempt for shaped and shapeless, when first char is not $, as a fallback.\r\n                            if (key in childnames) { // if child dvalue with that name excluding char $ exist, like in \"$\" + \"name\" (as normal)\r\n                                console.log(\"get_addObject() adding values\", {lobj, key, json, childnames, d:constructorPointers.instanceof});\r\n                                (lobj as GObject<LObject>)[\"$\" + key].values = json[key];\r\n                                continue;\r\n                            }\r\n                            else if (isShapeless || isPartial) { lobj.addValue(key, undefined, json[key], false); continue; }\r\n                            Log.eDevv('addObject(schema) error: cannot find value collection named \"' + key + ' \" as defined in the schema parameter.',\r\n                                {lmetaclass, this:c.data, instanceof: constructorPointers.instanceof, dobjkeys});\r\n                            continue;\r\n                        }\r\n                    }\r\n                }), 100);\r\n            });\r\n            return lobj;\r\n        }\r\n    }\r\n\r\n\r\n    protected get_edges(context: Context): this[\"edges\"] { return LPointerTargetable.fromPointer(context.data.edges) || []; }\r\n    protected get_fromlfeature<C, T extends keyof (NonNullable<C>)>(meta: C, key: T): NonNullable<C>[T] { return meta ? (meta as any)[key] : undefined; }\r\n    protected get_opposite(context: Context): LReference[\"opposite\"] { return this.get_fromlfeature(context.proxyObject.instanceof as LReference, \"opposite\"); }\r\n    protected get_container(context: Context): LReference[\"container\"] { return this.get_fromlfeature(context.proxyObject.instanceof as LReference, \"container\"); }\r\n    protected get_isContainment(c: Context): LReference[\"containment\"] { return this.get_containment(c); }\r\n    protected get_containment(context: Context): LReference[\"containment\"] {\r\n        let iof = context.proxyObject.instanceof;\r\n        if (!iof) return true; // shapeless\r\n        return this.get_fromlfeature(iof as LReference, \"containment\"); }\r\n    // protected get_defaultValueLiteral(context: Context): LStructuralFeature[\"defaultValueLiteral\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"defaultValueLiteral\"); }\r\n    protected get_defaultValue(context: Context): LStructuralFeature[\"defaultValue\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"defaultValue\"); }\r\n    protected get_defaultderived(context: Context): DStructuralFeature[\"derived\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"derived\"); }\r\n    protected get_defaultunsettable(context: Context): LStructuralFeature[\"unsettable\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"unsettable\"); }\r\n    protected get_defaulttransient(context: Context): LStructuralFeature[\"transient\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"transient\"); }\r\n    protected get_isVolatile(c: Context): LReference[\"volatile\"] { return this.get_volatile(c); }\r\n    protected get_volatile(context: Context): LStructuralFeature[\"volatile\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"volatile\"); }\r\n    protected get_isChangeable(context: Context): LStructuralFeature[\"changeable\"] { return this.get_changeable(context); }\r\n    protected get_changeable(context: Context): LStructuralFeature[\"changeable\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"changeable\"); }\r\n    protected get_isRequired(context: Context): LStructuralFeature[\"required\"] { return this.get_required(context); }\r\n    protected get_required(context: Context): LStructuralFeature[\"required\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"required\"); }\r\n    protected get_isUnique(context: Context): LStructuralFeature[\"unique\"] { return this.get_unique(context); }\r\n    protected get_unique(context: Context): LStructuralFeature[\"unique\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"unique\"); }\r\n    protected get_isMany(context: Context): LStructuralFeature[\"many\"] { return this.get_many(context); }\r\n    protected get_many(context: Context): LStructuralFeature[\"many\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"many\"); }\r\n    protected get_upperBound(context: Context): LStructuralFeature[\"upperBound\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"upperBound\"); }\r\n    protected get_lowerBound(context: Context): LStructuralFeature[\"lowerBound\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"lowerBound\"); }\r\n    protected get_ordered(context: Context): LStructuralFeature[\"ordered\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"ordered\"); }\r\n    protected get_enumType(context: Context): LStructuralFeature[\"enumType\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"enumType\"); }\r\n    protected get_classType(context: Context): LStructuralFeature[\"classType\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"classType\"); }\r\n    protected get_primitiveType(context: Context): LStructuralFeature[\"primitiveType\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"primitiveType\"); }\r\n    protected get_type(context: Context): LStructuralFeature[\"type\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"type\"); }\r\n    // protected get_fullname(context: Context): LStructuralFeature[\"fullname\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"fullname\"); }\r\n    protected get_namespace(context: Context): LStructuralFeature[\"namespace\"] { return this.get_fromlfeature(context.proxyObject.instanceof, \"namespace\"); }\r\n    protected get_name(context: Context): LStructuralFeature[\"name\"] { return context.data.instanceof ? this.get_fromlfeature(context.proxyObject.instanceof, \"name\") : context.data.name || ''; }\r\n\r\n    protected get_instanceof(context: Context): this[\"instanceof\"] {\r\n        const pointer = context.data.instanceof;\r\n        if (!pointer) return undefined;\r\n        return LPointerTargetable.from(pointer)\r\n    }\r\n    protected set_instanceof(val: Pack1<this[\"instanceof\"]>, c: Context): boolean {\r\n        // const list = val.map((lItem) => { return Pointers.from(lItem) });\r\n        let ptr = Pointers.from<DNamedElement>(val as any);\r\n        if (ptr === c.data.instanceof) return true;\r\n        TRANSACTION(this.get_name(c)+'.instanceof', ()=>{\r\n            SetFieldAction.new(c.data, 'instanceof', ptr, \"\", true);\r\n        }, this.get_instanceof(c)?.fullname, LPointerTargetable.wrap(ptr)?.fullname)\r\n        return true;\r\n    }\r\n\r\n    protected get_isMirage(context: Context): this[\"isMirage\"] { return !!context.data.isMirage; }\r\n    protected set_isMirage(val: this[\"isMirage\"], c: Context): boolean {\r\n        val = !!val;\r\n        if (val === !!c.data.isMirage) return true;\r\n        TRANSACTION(this.get_name(c)+'.isMirage', ()=>{\r\n            SetFieldAction.new(c.data, 'isMirage', val, \"\", false);\r\n        }, c.data.isMirage, val)\r\n        return true;\r\n    }\r\n\r\n    typeStr!:string; // derivate attribute, abstract\r\n    typeString!:string; // derivate attribute, abstract\r\n    __info_of__typeStr: Info = {type: ShortAttribETypes.EString, txt: <div>Alias of<i>this.typeString</i></div>}\r\n    __info_of__typeString: Info = {type: ShortAttribETypes.EString, txt: <div>Stringified version of <i>this.type</i></div>}\r\n    protected get_typeString(c: Context): string { return this.get_typeStr(c); }\r\n    // @ts-ignore\r\n    protected get_typeStr(c: Context): string { return LObject.singleton.get_typeStr.call(this, c); }\r\n\r\n    // individual value getters\r\n    // if withMetaInfo, returns a wrapper for the first non-empty value found containing his index and metainfo\r\n    protected get_value<T extends boolean>(context: Context, namedPointers: boolean = false, ecorePointers: boolean = false,\r\n                                           shapeless: boolean = false, keepempties: boolean = true, withmetainfo: T = false as T): T extends true ? ValueDetail : this[\"value\"]{\r\n        return this.get_values(context, true, namedPointers, ecorePointers, shapeless, keepempties, withmetainfo, 1)[0] as any;\r\n    }\r\n    public getValue<T extends boolean>(namedPointers: boolean = false, ecorePointers: boolean = false, shapeless: boolean = false, keepempties: boolean = true,\r\n                                       withmetainfo: T = false as T): T extends true ? ValueDetail : this[\"value\"]{ return this.cannotCall(\"getValue\"); }\r\n    protected get_getValue(context: Context): this[\"getValue\"] {\r\n        return function (namedPointers: boolean = false, ecorePointers: boolean = false, shapeless: boolean = false,\r\n                         keepempties: boolean = true, withmetainfo: boolean = false) {\r\n            return LValue.prototype.get_value(context, namedPointers, ecorePointers, shapeless, keepempties, withmetainfo) as any;\r\n        }\r\n    }\r\n\r\n    // multiple value getters\r\n    protected get_values<T extends boolean>(context: Context, fitSize: boolean = true, namedPointers: boolean = false, ecorePointers: boolean = false,\r\n                                            shapeless: boolean = false, keepempties: boolean = true, withmetainfo?: T, maxlimit?: number,\r\n                                            solveLiterals: \"ordinals\" | \"literal_obj\" | \"literal_str\" | \"original\" = \"literal_obj\")\r\n        : (T extends undefined ? this[\"values\"] : T extends false ? this[\"values\"] : ValueDetail[]) & {type?: string}  {\r\n        const ldata = context.proxyObject;\r\n        const ddata = context.data;\r\n        let typestr: string = this.get_typeString(context);\r\n        let ret: any[];\r\n\r\n        if (ddata.topic) {/*\r\n            let value: any = store.getState()['topics'];\r\n            const path = data.topic.split('.');\r\n            for(const field of path) value = value[field];\r\n            let ret: any = [value];*/\r\n            const topics = store.getState()['topics'];\r\n            const val = U.extractValueFromTopic(topics, ddata.topic);\r\n            ret = Array.isArray(val) ? val : [val];\r\n            //return ret;\r\n        }\r\n        else ret = [...ddata.values];\r\n        (ret as any).type = typestr; // 'topic';\r\n\r\n        let meta: LAttribute | LReference | undefined = shapeless ? undefined : ldata.instanceof;\r\n        let dmeta: undefined | DAttribute | DReference = meta?.__raw;\r\n\r\n        // if (meta && meta.className === DReference.name) ret = LPointerTargetable.fromArr(ret as DObject[]);\r\n\r\n\r\n        if (dmeta?.derived) {\r\n            let td = transientProperties.modelElement[dmeta.id];\r\n            if (!td.derived_read) {\r\n                try {\r\n                    let txt = dmeta.derived_read || '(data, originalValues)=>{return originalValues}';\r\n                    // data.derived examples: '(d, o)=>3', '(ddd, ooo)=>{return 3}',\r\n                    td.derived_read = new Function('data, originalValues', 'return ('+txt+')(data, originalValues)') as Function2;\r\n                }\r\n                catch (error: any) {\r\n                    Log.ee('invalid derived (get) attribute expression: ' + dmeta.name, {error, derivedText:dmeta.derived_read});\r\n                }\r\n                if (td.derived_read) try {\r\n                    ret = td.derived_read(ldata, ret);\r\n                    if (ret === undefined) ret = [];\r\n                    if (!Array.isArray(ret)) ret = [ret];\r\n                }\r\n                catch (error: any) {\r\n                    Log.ee('Error during derived (get) attribute evaluation: ' + dmeta.name, {error, derivedText:dmeta.derived_read});\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        (ret as GObject).type = typestr;\r\n        if (!Array.isArray(ret)) ret = [];\r\n        if (dmeta && fitSize && ret.length < dmeta.lowerBound && dmeta.lowerBound > 0) {\r\n            let times = dmeta.lowerBound - ret.length;\r\n            while (times-- > 0) ret.push(undefined);\r\n            // ret.length = meta.lowerBound; not really working for expanding, it says \"emptyx10\" or so. doing .map() only iterates \"existing\" elements. behaves like as it's smaller.\r\n        }\r\n        if (maxlimit !== undefined) ret.length = maxlimit;\r\n        else if (dmeta && fitSize && ret.length > dmeta.upperBound && dmeta.upperBound >= 0) ret.length = dmeta.upperBound;\r\n\r\n        // console.log(\"get_values sizefixed\", {fitSize, arguments, upperbound:dmeta?.upperBound, lowerbound: dmeta?.lowerBound, len: ret.length, len0: context.data.values.length});\r\n        let numbermax = 0, numbermin = 0, round = true;\r\n        // ret is always an array of raw values before this point, eventually padded with lowerbound or trimmed at upperbound\r\n\r\n        let index = 0;\r\n        if (withmetainfo) { ret = ret.map(r => {return {value:r, rawValue: r, index: index++, hidden: false} as ValueDetail}); }\r\n        let mapperfunc: (a:any)=>any = undefined as any;\r\n        let numbercasting = (v: any): number => {\r\n            if (typeof v !== \"number\") {\r\n                if (!v) v = 0;\r\n                else if (v === \"true\") v = 1;\r\n                else if (v.constructor?.name=== \"Date\") v = v.getTime();\r\n                else if (typeof v === \"string\") {\r\n                    // console.log(\"number casting:\", v,  U.getFirstNumber(v+'', true), {numbermax, numbermin});\r\n                    v = U.getFirstNumber(v+'', !round);\r\n                } else return NaN;\r\n            }\r\n            v = Math.min(numbermax, Math.max(numbermin, v));\r\n            return round ? Math.round(v) : v;\r\n        };\r\n        switch (typestr) {\r\n            case \"shapeless\":\r\n                let state: DState = store.getState();\r\n                mapperfunc = (val: any) => {\r\n                    if (!val || typeof val !== \"string\") return val;\r\n                    let l: any = LPointerTargetable.fromPointer(val, state);\r\n                    if (!l) return val;\r\n                    if (l.className === DEnumLiteral.cname) { l = (l as DEnumLiteral).literal; } else\r\n                    if (namedPointers) { l = (l.name ? (\"@\" + l.name) : (l as GObject)[\"@\"+l.name]?.__raw?.values?.[0] || (\"#\" + l.className));}\r\n                    else if (ecorePointers){ l = l.ecorePointer(); }\r\n                    return l;\r\n                };\r\n                if (withmetainfo) ret.forEach((struct: ValueDetail) => { struct.value = mapperfunc(struct.value); });\r\n                else ret = ret.map(mapperfunc);\r\n                break;\r\n            default: // it's a reference or enum\r\n                let lenum: LEnumerator = undefined as any;\r\n                let type: LClassifier = (meta as LStructuralFeature)?.type;\r\n                if (type?.className === DEnumerator.cname) {\r\n                    lenum = type as LEnumerator;\r\n                    mapperfunc = (r: any) => {\r\n                        if (solveLiterals === \"original\") return r;\r\n                        numbermin = 0;\r\n                        numbermax = (solveLiterals === \"ordinals\") ? Number.POSITIVE_INFINITY : 0;\r\n                        let lit: LEnumLiteral | undefined\r\n                        if (typeof r === \"string\") lit = Pointers.isPointer(r) ? LPointerTargetable.fromPointer(r) : (lenum as any)[\"@\"+r];\r\n                        else if (typeof r === \"number\") lit = lenum.ordinals[r];\r\n                        switch (solveLiterals) {\r\n                            default:\r\n                            case \"literal_obj\": return lit;\r\n                            // if r was a number and a valid ordinal (found literal through him) return r. if r was a string, don't return r but lenum[\"@\"+r].ordinal\r\n                            case \"ordinals\": return (typeof r === \"number\" ? (lit ? r : undefined) : lit?.ordinal);\r\n                            case \"literal_str\": return (typeof r === \"string\" ? (lit ? r : undefined) : lit?.literal);\r\n                        }\r\n                    }\r\n                } else if (!type.isPrimitive && type?.className === DClass.cname) mapperfunc = (r: any) => r && LPointerTargetable.fromPointer(r);\r\n                else mapperfunc = (r: any) => r;\r\n                if (withmetainfo) ret.forEach((struct: ValueDetail) => { struct.value = mapperfunc(struct.value); });\r\n                else ret = ret.map(mapperfunc);\r\n\r\n                // now ret is pointed DEnumLiteral or DObject or MetaInfoStructure<>\r\n                if (type?.className === DEnumerator.cname) {\r\n                    // replace numeric literals, mapped to literal ordinal. can happen with type switches\r\n                    /*\r\n                    if (solveLiterals) {\r\n                        mapperfunc = (lit: LEnumLiteral|number) => {\r\n                            numbermax = Number.POSITIVE_INFINITY;\r\n                            numbermin = 0;\r\n                            let ordinal = numbercasting(lit);\r\n                            return isNaN(ordinal) ? lit : (meta!.type as LEnumerator).ordinals[ordinal];\r\n                        }\r\n                        if (withmetainfo) ret.forEach((struct: ValueDetail) => { struct.value = mapperfunc(struct.value); });\r\n                        else ret = ret.map(mapperfunc);\r\n                    }*/\r\n                    let filterfunc = (l: LEnumLiteral) => { if (!l) return keepempties; return l.father?.id === (meta as LAttribute).type.id; };\r\n                    if (withmetainfo) for(let struct of ret as ValueDetail[]) { struct.hidden = !filterfunc(struct.value as LEnumLiteral); } // && 'literal target is not of the correct type requested by metamodel'; }\r\n                    else ret = ret.filter(filterfunc);\r\n                    // todo: questo comportamento implica che quando importo un literal come testo da .ecore, devo assegnargli\r\n                    //  il puntatore al suo literal se trovato, altrimenti resta val[i] di tipo string/shapeless\r\n                    if (namedPointers) {\r\n                        mapperfunc = (lit?: LEnumLiteral) => lit?.name;\r\n                        if (withmetainfo) ret.forEach((struct: ValueDetail) => { struct.value = mapperfunc(struct.value); });\r\n                        else ret = ret.map(mapperfunc);\r\n                    }\r\n                    break;\r\n                }\r\n                // is reference with assigned shape (and type) -> filter correct typed targets\r\n                if (meta) {\r\n                    let filterfunc = (l: LObject) => {\r\n                        // hide values with a value that is not a pointer to correct type (but keep empties if requested)\r\n                        //let isExtending = l.instanceof?.isExtending((meta as LReference).type); // damiano: todo test & debug isextending\r\n                        let isExtending = true;\r\n                        return keepempties && !l ? true : isExtending;\r\n                    };\r\n                    if (withmetainfo) for(let struct of ret as ValueDetail[]) { struct.hidden = !filterfunc(struct.value as LObject); } // && \"ref target is not of correct type\"; }\r\n                    else ret = ret.filter(filterfunc);\r\n                }\r\n                // shaped (with m2-reference) but pointing to a shapeless object. can happen\r\n                if (namedPointers) {\r\n                    let mapperfunc = (l:LObject) => l && (l.name ? (\"@\" + l.name) : (l as GObject)[\"@\"+l.name]?.__raw?.values?.[0] || (\"#\" + l.className));\r\n                    if (withmetainfo) ret.forEach((struct: ValueDetail)=>{ struct.value = mapperfunc(struct.value as LObject); });\r\n                    else ret = ret.map(mapperfunc);\r\n                }\r\n                else if (ecorePointers && !(meta as LReference).containment){\r\n                    mapperfunc = (lval: LObject) => lval && lval.ecorePointer();\r\n                    if (withmetainfo) ret.forEach((struct: ValueDetail)=>{ struct.value = mapperfunc(struct.value as LObject); });\r\n                    else ret = ret.map(mapperfunc);\r\n                    // throw new Error(\"values as EcorePointers: todo. for containment do nothing, just nest the obj. for non-containment put the ecore reference string in array vals\")\r\n                }\r\n                break;\r\n            case ShortAttribETypes.EByte:\r\n                numbermin = -128;\r\n                numbermax = 127;\r\n                break;\r\n            case ShortAttribETypes.EShort:\r\n                numbermin = -32768;\r\n                numbermax = 32767;\r\n                break;\r\n            case ShortAttribETypes.EInt:\r\n                numbermin = -2147483648;\r\n                numbermax = 2147483647;\r\n                break\r\n            case ShortAttribETypes.ELong:\r\n                numbermin = -9223372036854775808;\r\n                numbermax = 9223372036854775807;\r\n                break;\r\n            case ShortAttribETypes.EFloat:\r\n            case ShortAttribETypes.EDouble:\r\n                numbermin = Number.NEGATIVE_INFINITY;\r\n                numbermax = Number.POSITIVE_INFINITY;\r\n                round = false;\r\n                break;\r\n            case ShortAttribETypes.EString:\r\n            case ShortAttribETypes.EDate:\r\n                mapperfunc = v => v ? v + '' : ''\r\n                if (withmetainfo) ret.forEach((struct: ValueDetail)=>{ struct.value = mapperfunc(struct.value); });\r\n                else ret = ret.map(mapperfunc);\r\n                break;\r\n            case ShortAttribETypes.EChar:\r\n                mapperfunc = v => v ? (v + '')[0] : 'A';\r\n                if (withmetainfo) ret.forEach((struct: ValueDetail)=>{ struct.value = mapperfunc(struct.value); });\r\n                else ret = ret.map(mapperfunc);\r\n                break;\r\n            case ShortAttribETypes.EBoolean:\r\n                mapperfunc = v => typeof v === \"boolean\" ? v : U.fromBoolString(v+'', v?.length>0, false);\r\n                if (withmetainfo) ret.forEach((struct: ValueDetail)=>{ struct.value = mapperfunc(struct.value); });\r\n                else ret = ret.map(mapperfunc);\r\n                break;\r\n            case ShortAttribETypes.EVoid:\r\n                if (withmetainfo) ret.forEach((struct: ValueDetail)=>struct.hidden = true);\r\n                else ret = [];\r\n                break;\r\n        }\r\n        // some kind of numeric type\r\n        if (numbermax !== 0) {\r\n            if (withmetainfo) ret.forEach((struct: ValueDetail)=>{ struct.value = numbercasting(struct.value); });\r\n            else ret = ret.map(numbercasting);\r\n        }\r\n        return ret as any;\r\n    }\r\n\r\n    public getValues<T extends boolean>(fitSize: boolean = true, namedPointers: boolean = false, ecorePointers: boolean = false, shapeless: boolean = false,\r\n                                        keepempties: boolean = true, withmetainfo?: T, maxlimit?: number)\r\n        : (T extends undefined ? this[\"values\"] : T extends false ? this[\"values\"] : ValueDetail[]) & {type?: string} {\r\n        return this.cannotCall(\"getValues\"); }\r\n    protected get_getValues(context: Context): this[\"getValues\"] {\r\n        return function (fitSize: boolean = true, namedPointers: boolean = true, ecorePointers: boolean = false,\r\n                         shapeless: boolean = false, keepempties: boolean = false, withmetainfo: any = false, limit?: number) {\r\n            return LValue.prototype.get_values(context, fitSize, namedPointers, ecorePointers, shapeless, keepempties, withmetainfo, limit) as any;\r\n        }\r\n    }\r\n    // stringified value getters\r\n    public valuesString(keepemptyquotes?: boolean): string { return this.cannotCall(\"valuestring\"); }\r\n    public valuestring(keepemptyquotes?: boolean): string { return this.cannotCall(\"valuestring\"); }\r\n    private get_valuestring(context: Context): this[\"valuestring\"] { return (keepemptyquotes?: boolean) => this.valuestring_impl(context, keepemptyquotes); }\r\n    private get_valuesString(context: Context): this[\"valuestring\"] { return (keepemptyquotes?: boolean) => this.valuestring_impl(context, keepemptyquotes); }\r\n    private valuestring_impl(context: Context, keepemptyquotes?: boolean): string {\r\n        let val = this.get_values(context, true, true, false, false, true);\r\n        // console.log(\"valuestring_impl\", {val});\r\n        let ret: any;\r\n        switch (val.length) {\r\n            case 0: ret = ''; break;\r\n            case 1: ret = val[0]; break;\r\n            default:\r\n                let havestrings: boolean = val.type === ShortAttribETypes.EString;\r\n                let havechars: boolean = val.type === ShortAttribETypes.EChar;\r\n                let havepointers: boolean = false;\r\n                let haveLelements: boolean = false;\r\n                for (let vall of [val[0]]) {\r\n                    if ((vall as any)?.__isProxy) haveLelements = true;\r\n                    /*else if (typeof vall === \"string\") { havestrings = true; havepointers = havepointers || vall.includes(\"Pointer\"); }}\r\n                     */\r\n                }\r\n                /*if (havepointers) {\r\n                    val = LPointerTargetable.wrapAll(val);\r\n                    haveLelements = true;\r\n                }*//*\r\n                if (haveLelements) {\r\n                    val = val.map( l => l && (l.name ? (\"@\" + l.name) : (\"#\" + l.className)));\r\n                }*/\r\n                if (havestrings || havechars) {\r\n                    let valstr = JSON.stringify(val);\r\n                    if (!keepemptyquotes) valstr = U.replaceAll(valstr, \"\\\"\\\"\", \"\");\r\n                    ret = valstr.substring(1, valstr.length-1);\r\n                    break;\r\n                }\r\n                else ret = val.join(', ');\r\n        }\r\n        return (ret === undefined || ret === null ? '' : ret) + '';\r\n    }\r\n\r\n    public setValueAtPosition(index: number, val: this[\"values\"][0], info?: Partial<SetValueAtPositionInfoType>): {success: boolean, reason?: string} {\r\n        return this.cannotCall(\"setValueAtPosition\"); }\r\n\r\n    // only use through setValueAtPosition\r\n    protected _clearValueAtPosition(context: Context, index: number, info0?: Partial<SetValueAtPositionInfoType>, skipSettingUndefined: boolean = false) {\r\n        // if (!outactions) outactions = {clear:[], set:[]};\r\n        if (index < 0) return;\r\n        let info = (info0 || {}) as unknown as SetValueAtPositionInfoType;\r\n        let oldVal = context.data.values[index];\r\n        let oldTarget: LObject | undefined = typeof oldVal === \"string\" ? LObject.fromPointer(oldVal) : undefined;\r\n        /////////////////////// if oldTarget is LObject, update his pointedBy\r\n        // if (oldTarget) SetFieldAction.new(oldTarget, \"pointedBy\" '-=\", ... no need? reducer should do this)\r\n\r\n        /////////////////////// if ref is containment assign oldTarget father to DModel\r\n\r\n        if (info.isContainment === undefined) {\r\n            if (info.instanceof === undefined) info.instanceof = context.proxyObject.instanceof;\r\n            if (info.instanceof){\r\n                if (info.instanceof.className === DReference.cname) { info.isContainment = (info.instanceof as LReference).containment; }\r\n                else info.isContainment = false;\r\n            }\r\n            else { info.isContainment = true; }\r\n        }\r\n        if (info.isContainment && oldTarget?.className === \"DObject\") {\r\n            SetFieldAction.new(oldVal as Pointer<DObject>, \"father\", context.proxyObject.model.id, undefined, true);\r\n        }\r\n        if (!skipSettingUndefined) SetFieldAction.new(context.data, 'values.' + index as any, undefined, '', info.isPtr);\r\n    }\r\n    protected get_setValueAtPosition(c: Context): ((index: number, val: this[\"values\"][0], info?: Partial<SetValueAtPositionInfoType>, outactions?:outactions) => {success: boolean, reason?: string}) {\r\n        return (index: number, val: this[\"values\"][0] | any, info0?: Partial<SetValueAtPositionInfoType>, outactions?: outactions): { success: boolean, reason?: string } => {\r\n            if (!outactions) outactions = {clear:[], set:[], immediatefire: true}\r\n            let isPtr: boolean = undefined as any;\r\n            let lval: LObject | LEnumLiteral = undefined as any;\r\n            if (val === null) val = undefined;\r\n            let oldval = c.data.values[index];\r\n            if (oldval === val) return { success: false, reason: \"identical assignment\" };\r\n            let tmpval_id = Pointers.from(val) ;\r\n            if (oldval === tmpval_id) return { success: false, reason: \"identical object assignment\" };\r\n            let state = store.getState();\r\n            if (tmpval_id && (val as any)?.className) {\r\n                lval = LPointerTargetable.wrap<DObject>(val, state) as LObject | LEnumLiteral;\r\n                isPtr = !!(lval || Pointers.isPointer(oldval));//LPointerTargetable.wrap(oldval, state));\r\n                val = tmpval_id;\r\n            }\r\n            let info = (info0 || {}) as unknown as SetValueAtPositionInfoType;\r\n            if (isPtr === undefined) isPtr = (info.isPtr === undefined ? Pointers.isPointer(val) || Pointers.isPointer(oldval) : info.isPtr);\r\n\r\n\r\n            // set sideeffect part\r\n            if (val !== undefined) {\r\n                if (isPtr) {\r\n                    if (info.type === undefined) info.type = c.proxyObject.type;\r\n                    if (info.instanceof === undefined) info.instanceof = c.proxyObject.instanceof;\r\n                    if (info.isContainment === undefined) {\r\n                        info.isContainment = !info.instanceof || (info.instanceof.className === DReference.cname && (info.instanceof as LReference).containment);\r\n                    }\r\n                    lval = LPointerTargetable.fromPointer(val);\r\n                    if (!lval) return {success: false, reason: \"invalid pointer: \" + lval};\r\n                    // is enum\r\n                    if (lval.className === DEnumLiteral.cname) {\r\n                        let lvale: LEnumLiteral = lval as LEnumLiteral;\r\n                        if (info.instanceof && info.type && (lvale.father.id !== info.type.id)) return {success: false, reason: \"target is not of correct literal type\"};\r\n                        // no need to do checks / other sideeffects other than pointedBy i think.\r\n                    }\r\n                    // is ref\r\n                    if (lval.className === DObject.cname){\r\n\r\n                        let lvalo = lval as LObject;\r\n                        //let lvalmeta: LClassifier | undefined = lvalo.instanceof;\r\n                        // if (info.instanceof && info.type && (!(lvalmeta as LClass)?.isExtending(info.type))) return {success: false, reason: \"target is not of correct type\"}; damiano todo: enable and implement isExtending\r\n                        if (info.fatherList === undefined) info.fatherList = c.proxyObject.fatherList;\r\n                        if (info.isContainment) {\r\n                            if ((info.fatherList as LPointerTargetable[]).map(father => father.id).includes(val))\r\n                                return {success: false, reason: \"cannot create a containment loop\"}; // todo: in LReference.set_containment need to forbid setting to true if there is a loop\r\n                            let oldContainer: LValue | LModel = lvalo.father;\r\n                            let oldContainerValue: LValue = (oldContainer.className === DModel.cname) ? undefined as any : (oldContainer as LValue);\r\n                            // detach contaied object from old parent\r\n                            if (oldContainerValue && oldContainerValue.id !== c.data.id) outactions.clear.push(()=>{\r\n                                let valarr: any[] = oldContainerValue.__raw.values;\r\n\r\n                                for (let i = 0; i < valarr.length; i++) {\r\n                                    let v = valarr[i];\r\n                                    if (v === val) oldContainerValue.setValueAtPosition(i, undefined as any, undefined);\r\n                                }\r\n\r\n                            });\r\n                            outactions.set.push(()=> {\r\n                                SetFieldAction.new(val as Pointer<DObject>, \"father\", c.data.id, undefined, true)\r\n                            });\r\n                        }\r\n                    }\r\n                    // automatic? SetFieldAction.new(val as Pointer<DObject>, \"pointedBy\", PointedBy.fromID(c.data.id, \"values.\" + index as any), \"+=\");\r\n                } else {\r\n                    // loose checks, i can assign any primitive to any primitive (will cast on get)\r\n                    if (info.instanceof === undefined) info.instanceof = c.proxyObject.instanceof;\r\n                    let metatype: string = (info.instanceof as LAttribute)?.typeToShortString() || \"shapeless\";\r\n                    if (typeof val === \"object\") {\r\n                        if (val.constructor === Date && (metatype !== \"EString\" && metatype !== \"EDate\" && metatype !== \"shapeless\"))\r\n                            return {\r\n                                success: false,\r\n                                reason: \"dates can only be assigned to values of type string or Date\"\r\n                            };\r\n                        // return {success: false, reason: \"objects are not assignable except for dates\"}; maybe i allow this instead\r\n                    }\r\n                }\r\n            }\r\n\r\n            TRANSACTION(this.get_name(c)+'.setValue('+index+': index)', ()=>{\r\n                if (!outactions) return;\r\n                // clear sideeffect part\r\n                outactions.clear.push(()=>this._clearValueAtPosition(c, index, info, true));\r\n                // console.log('set value index', {index, val, isPtr});\r\n                // actual set\r\n                outactions.set.push(()=>SetFieldAction.new(c.data, 'values.' + index as any, val, '', isPtr));\r\n                if (info.setMirage !== false) SetFieldAction.new(c.data, 'isMirage', false, '', false);\r\n\r\n                if (outactions.immediatefire) {\r\n                    for (let a of outactions.clear) a();\r\n                    for (let a of outactions.set) a();\r\n                }\r\n            }, c.data.values[index], val)\r\n            // todo: wrap this func and set toaster with failure message if it fails or better launch Log.w and bind toasts of different colors to Log funcs\r\n            return {success: true};\r\n        }\r\n    }\r\n    protected set_values(val0: orArr<D[\"values\"]>, c: Context): boolean {\r\n        let val: any = val0 as any;\r\n        let modified = false;\r\n        let meta = this.get_instanceof(c);\r\n        let dmeta: DReference | DAttribute | undefined = meta?.__raw;\r\n        if (dmeta?.derived) {\r\n            let td = transientProperties.modelElement[dmeta.id];\r\n            if (!td.derived_write) {\r\n                try {\r\n                    let txt = dmeta.derived_write || '(values, data, oldValues)=>{ data.values = values; }';\r\n                    td.derived_write = new Function('values, data, oldValues', 'return ('+txt+')(data, originalValues)') as Function2;\r\n                }\r\n                catch (error: any) {\r\n                    Log.ee('invalid derived (set) attribute expression: ' + dmeta.name, {error, derivedText:dmeta.derived_write});\r\n                }\r\n                if(td.derived_write) try {\r\n                    TRANSACTION('changed ' + this.get_name(c)+' derived attributes', ()=>{\r\n                        let ret = td?.derived_write?.(val, c.proxyObject, c.data.values);\r\n                        if (ret !== undefined) {\r\n                            val = ret;\r\n                            modified = true;\r\n                        }\r\n                    })\r\n                }\r\n                catch (error: any) {\r\n                    Log.ee('Error during derived (set) attribute evaluation: ' + dmeta.name, {error, derivedText:dmeta.derived_write});\r\n                }\r\n            }\r\n        }\r\n\r\n        val = (Array.isArray(val0) ? val0 : [val0]) as D[\"values\"];\r\n        // val.length = Math.max(val.length, c.data.values.length);\r\n        let isContainment = this.get_isContainment(c);\r\n        if (isContainment) { // remove duplicates in containment\r\n            val = val.map((v: any) => v?.id || v);\r\n            let idmap: Dictionary<string, true> = {}\r\n            val = val.filter((e: any)=> { if (typeof e !== 'string' || !idmap[e]) return true; idmap[e] = true; return true;} )\r\n        }\r\n        TRANSACTION(this.get_fullname(c)+'.values', ()=>{\r\n            let outactions: outactions = {clear:[], set:[], immediatefire: false};\r\n            for (let i = 0; i < val.length; i++) {\r\n                let out = this.get_setValueAtPosition(c)(i, val[i], {setMirage: false} as any, outactions);\r\n                modified = out.success || modified;\r\n                // console.log('set_values', {val, i, modifiedreason:out});\r\n            }\r\n            let excess = c.data.values.length - val.length;\r\n            while (excess-- > 0) {\r\n                SetFieldAction.new(c.data.id, 'values', undefined as any, '-=', true);\r\n            }\r\n            for (let a of outactions.clear) a();\r\n            for (let a of outactions.set) a();\r\n            if (modified) c.data.isMirage && SetFieldAction.new(c.data, 'isMirage', false, '', false);\r\n        });\r\n        return true;\r\n\r\n        // old implementation\r\n        let list: any = val;\r\n        let context = c;\r\n        let l = context.proxyObject;\r\n        let instanceoff: LReference | LAttribute | undefined = l.instanceof;\r\n        let isRef: boolean | undefined = (!instanceoff ? undefined : instanceoff?.className === DReference.cname);\r\n        SetFieldAction.new(context.data, 'values', list as any, '', false);\r\n        // console.log(\"pre set_values actions\", l, list, val, context);\r\n\r\n        if (!l.instanceof || isRef && (instanceoff as LReference).containment) {\r\n            let i = 0;\r\n\r\n            for (let v0 of list) {\r\n                // console.log(\"loop set_value actions\", v, context.data, isRef, instanceoff, Pointers.isPointer(v));\r\n                i++;\r\n                if ((isRef || instanceoff === undefined) && Pointers.isPointer(v0)) { // if shapeless obj need to check val by val\r\n                    let v = v0 as Pointer<DModelElement> //Pointer<DObject> | Pointer<DEnumLiteral>;\r\n                    // console.log(\"loop set_value actions SET\", {v, data:context.data, isRef, instanceoff, isPtr:Pointers.isPointer(v)});\r\n                    let lval: LObject = LPointerTargetable.fromPointer(v);\r\n                    let oldContainer: LValue | LModel = lval.father;\r\n                    SetFieldAction.new(v, \"pointedBy\", PointedBy.fromID(context.data.id, \"values.\" + i as any), \"+=\");\r\n                    SetFieldAction.new(v, \"father\", context.data.id, undefined, true);\r\n                    if (oldContainer.className === DModel.cname) continue;\r\n                    let containerValue = (oldContainer as LValue);\r\n                    // let oldContainerValues = [...containerValue.__raw.value]; U.arrayRemoveAll(oldContainerValues, v);\r\n                    let oldContainerValues: Pointer[] = containerValue.__raw.values.map( va => va===v ? undefined as any : va);\r\n                    SetFieldAction.new(containerValue.id, \"values\", oldContainerValues, \"\", true);\r\n\r\n                    // todo: verify if works: remove val from old container\r\n                    let oldv = context.data.values[i];\r\n                    // if (Pointers.isPointer(oldv)) SetFieldAction.new(context.data.id, \"contains\", U.arrayRemoveAll([...context.data.contains], oldv), '', true);\r\n                    // SetFieldAction.new(context.data.id, \"contains\", oldv as DObject[\"id\"], undefined, true);\r\n\r\n                }\r\n            }\r\n        }\r\n        context.data.isMirage && SetFieldAction.new(context.data, 'isMirage', false, '', false);\r\n        return true;\r\n    }\r\n\r\n    protected set_value(val: D[\"values\"][0], c: Context): boolean {\r\n        let v: ValueDetail = this.get_value(c, false, false, false, true, true);\r\n        let val_id = (val as any)?.id || val;\r\n        if (Pointers.isPointer(val_id) && c.data.values.includes(val_id as any) && this.get_isContainment(c)) { return true; }\r\n        let r = this.get_setValueAtPosition(c)(v?.index || 0, val_id || val);\r\n        Log.e(!r.success,  r.reason);\r\n        return r.success;\r\n    }\r\n\r\n    get_crossReference(c: Context): this['allowCrossReference'] { return this.get_allowCrossReference(c); }\r\n    get_isCrossReference(c: Context): this['allowCrossReference'] { return this.get_allowCrossReference(c); }\r\n    set_crossReference(v: this['allowCrossReference'], c: Context): boolean { return this.set_allowCrossReference(v, c); }\r\n    set_isCrossReference(v: this['allowCrossReference'], c: Context): boolean { return this.set_allowCrossReference(v, c); }\r\n    get_allowCrossReference(c: Context): boolean { return c.data.instanceof ? !!c.proxyObject.instanceof?.allowCrossReference : true; }\r\n    set_allowCrossReference(v: this['allowCrossReference'], c: Context): boolean { return this.cannotSet('LValue.allowCrossReference'); }\r\n\r\n\r\n    validTargetOptions!: MultiSelectOptGroup[];\r\n    get_validTargetOptions(c: Context): this['validTargetOptions'] {\r\n        let opts: MultiSelectOptGroup[] = [];\r\n        this.get_validTargets(c, opts);\r\n        return opts;\r\n    }\r\n    validTargetsJSX!: JSX.Element[];\r\n    get_validTargetsJSX(c: Context): this['validTargetsJSX'] {\r\n        let opts: MultiSelectOptGroup[] = [];\r\n        this.get_validTargets(c, opts);\r\n        return UX.options(opts);\r\n    }\r\n    validTargets!: (LObject | LEnumLiteral)[];\r\n    get_validTargets(c: Context, out?: MultiSelectOptGroup[]): this['validTargets'] {\r\n        let meta: LReference | LAttribute = this.get_instanceof(c) as LReference | LAttribute;\r\n        let isShapeless = !meta;\r\n        let isReference = isShapeless || meta.className === 'DReference';\r\n        let isAttribute = isShapeless || meta.className === 'DAttribute';\r\n        let isCrossRef = this.get_isCrossReference(c);\r\n        let freeObjects: LObject[] = [];\r\n        let boundObjects: LObject[] = [];\r\n        let literals: LEnumLiteral[] = [];\r\n        let isContainment = isShapeless || isReference && (meta as LReference).containment;\r\n        let m1: LModel = this.get_model(c);\r\n        let m2 = m1.instanceof;\r\n        // let map = (object: LNamedElement) => ({value:object.id, label: object.name});\r\n        let map = (object: LNamedElement): MultiSelectOption => {\r\n            let fname = object.fullname;\r\n            return {value:object.id, label: isCrossRef ? fname : object.name, title: object.fullname}\r\n        };\r\n        if (isReference) {\r\n            let isContainment: boolean = this.get_containment(c);\r\n            let containerObjectsID: Pointer[] = this.get_fatherList(c).map(lm => lm.id);\r\n            let validObjects = (isCrossRef ? m1.allCrossSubObjects : m1.allSubObjects)\r\n            if (isContainment) validObjects = validObjects.filter(obj => !containerObjectsID.includes(obj.id));\r\n            let type = meta.type;\r\n            if (!isShapeless) validObjects = validObjects.filter((obj) => (type as LClass).isSuperClassOf(obj.instanceof, true))\r\n            // avoiding containment loops damiano todo: put this filter in set_value too\r\n            for (let o of validObjects) {\r\n                //  continue; // no self contain\r\n                if (o.isRoot) freeObjects.push(o);\r\n                else boundObjects.push(o);\r\n            }\r\n            if (out) out.push({label: 'Free     Objects', options: freeObjects.map(map)});\r\n            if (out) out.push({label: 'Bound Objects', options: boundObjects.map(map)});\r\n        }\r\n        if (isAttribute) {\r\n            let enumm: LEnumerator[];\r\n            if (isShapeless){\r\n                if (!m2) enumm = LPointerTargetable.from(Selectors.getAllEnumerators());\r\n                else enumm = (isCrossRef && m2) ? m2.crossEnumerators : m2.enumerators;\r\n            }\r\n            else {\r\n                let type = meta.type;\r\n                enumm = (type.className === 'DEnumerator') ? [type as LEnumerator] : [];\r\n            }\r\n            for (let e of enumm) {\r\n                let currLiterals = e.literals;\r\n                literals.push(...currLiterals);\r\n                if (out) out.push({label: 'Literals of ' + e.name, options: currLiterals.map(map)});\r\n            }}\r\n        return U.arrayMergeInPlace(freeObjects, boundObjects, literals as any);\r\n    }\r\n\r\n    protected generateEcoreJson_impl(c: Context, loopDetectionObj: Dictionary<Pointer, DModelElement> = {}): Json {\r\n        loopDetectionObj[c.data.id] = c.data;\r\n        let values = this.get_values(c, true, false, true, false, false);//, false, undefined, \"literal_str\");\r\n        delete values[\"type\"];\r\n        let ret: any = [];\r\n        the_loop: for (let v of values){\r\n            let l: LObject | LEnumLiteral = v as any;\r\n            if (!l?.__isProxy) { ret.push(l); continue; }\r\n            switch (l.className){\r\n                case \"DOperation\": continue the_loop;\r\n                case \"DEnumLiteral\": ret.push((l as LEnumLiteral).generateEcoreJsonM1()); break;\r\n                default: ret.push(l.generateEcoreJson(loopDetectionObj)); break;\r\n            }\r\n        }\r\n        // ret = ret.filter((j: any) => (j !== undefined || j !== ''));\r\n        return (ret.length <= 1) ? ret[0] : ret; }\r\n\r\n    protected get_toString(context: Context): () => string { return () => this._toString(context); }\r\n    protected _toString(context: Context): string {\r\n        let val: any = this.get_values(context, true, true, false, false, true);\r\n        if (!val) return val + '';\r\n        if (!Array.isArray(val)) val = [val];\r\n        // if (!context.proxyObject.instanceof) val = val.map( (e: GObject) => { return  e.name ? \"@\" + e.name : e; });\r\n        // else if (context.proxyObject.instanceof?.className === DReference.name) val = val.map( (e: GObject) => { return e.name ? \"@\" + e.name : e; });\r\n        switch(val.length) {\r\n            case 0: return '';\r\n            case 1: return val[0] + '';\r\n            default: return val + '';\r\n        }\r\n    }\r\n\r\n    public rawValues(): void { super.cannotCall('rawValues'); }\r\n    public get_rawValues(context: Context): this[\"values\"]{\r\n        return (this.get_getValues(context))(false, false, false, true, true, false, undefined);\r\n    }\r\n\r\n    protected get_topic(context: Context): this[\"topic\"] {\r\n        return context.data.topic;\r\n    }\r\n    protected set_topic(val: string, c: Context): boolean {\r\n        if (c.data.topic === val) return true;\r\n        TRANSACTION(this.get_name(c)+'.topic', ()=>{\r\n            SetFieldAction.new(c.data, 'topic', val, '', false);\r\n        }, c.data.topic, val)\r\n        return true;\r\n    }\r\n}\r\nRuntimeAccessibleClass.set_extend(DNamedElement, DValue);\r\nRuntimeAccessibleClass.set_extend(LNamedElement, LValue);\r\n\r\nexport type ValueDetail = {\r\n    value: LValue['value'];\r\n    rawValue: DValue['values'][0]; // PrimitiveType | Pointer<DObject> | Pointer<DEnumLiteral>\r\n    index: number;\r\n    hidden: boolean;\r\n};\r\nexport type SetValueAtPositionInfoType = {setMirage: boolean, isPtr: boolean, type: LValue['type'], instanceof: LValue['instanceof'], isContainment: boolean, fatherList: LValue['fatherList']};\r\n\r\nexport type WModelElement = getWParams<LModelElement, DModelElement>;\r\nexport type WModel = getWParams<LModel, DModel>;\r\nexport type WValue = getWParams<LValue, DValue>;\r\nexport type WNamedElement = getWParams<LNamedElement, DNamedElement>;\r\nexport type WObject = getWParams<LObject, DObject>;\r\nexport type WEnumerator = getWParams<LEnumerator, DEnumerator>;\r\nexport type WEnumLiteral = getWParams<LEnumLiteral, DEnumLiteral>;\r\nexport type WAttribute = getWParams<LAttribute, DAttribute>;\r\nexport type WReference = getWParams<LReference, DReference>;\r\nexport type WStructuralFeature = getWParams<LStructuralFeature, DStructuralFeature>;\r\nexport type WClassifier = getWParams<LClassifier, DClassifier>;\r\nexport type WDataType = getWParams<LDataType, DDataType>;\r\nexport type WClass = getWParams<LClass, DClass>;\r\nexport type WParameter = getWParams<LParameter, DParameter>;\r\nexport type WOperation = getWParams<LOperation, DOperation>;\r\nexport type WPackage = getWParams<LPackage, DPackage>;\r\nexport type WTypedElement = getWParams<LTypedElement, DTypedElement>;\r\nexport type WAnnotation = getWParams<LAnnotation, DAnnotation>;\r\n// export type WJavaObject = getWParams<LJavaObject, DJavaObject>;\r\nexport type WMap = getWParams<LMap, DMap>;\r\nexport type WFactory_useless_ = getWParams<LFactory_useless_, DFactory_useless_>;\r\n\r\nDModelElement.cname = 'DModelElement';\r\nLModelElement.cname = 'LModelElement';\r\nDAnnotationDetail.cname = 'DAnnotationDetail';\r\nLAnnotationDetail.cname = 'LAnnotationDetail';\r\nDAnnotation.cname = 'DAnnotation';\r\nLAnnotation.cname = 'LAnnotation';\r\nDNamedElement.cname = 'DNamedElement';\r\nLNamedElement.cname = 'LNamedElement';\r\nDTypedElement.cname = 'DTypedElement';\r\nLTypedElement.cname = 'LTypedElement';\r\nDClassifier.cname = 'DTypedElement';\r\nLClassifier.cname = 'LTypedElement';\r\nDPackage.cname = 'DPackage';\r\nLPackage.cname = 'LPackage';\r\nDOperation.cname = 'DOperation';\r\nLOperation.cname = 'LOperation';\r\nDParameter.cname = 'DParameter';\r\nLParameter.cname = 'LParameter';\r\nDClass.cname = 'DClass';\r\nLClass.cname = 'LClass';\r\n// ClassReferences.cname = 'ClassReferences';\r\nDDataType.cname = 'DDataType';\r\nLDataType.cname = 'LDataType';\r\nDStructuralFeature.cname = 'DStructuralFeature';\r\nLStructuralFeature.cname = 'LStructuralFeature';\r\nDReference.cname = 'DReference';\r\nLReference.cname = 'LReference';\r\nDAttribute.cname = 'DAttribute';\r\nLAttribute.cname = 'LAttribute';\r\nDEnumLiteral.cname = 'DEnumLiteral';\r\nLEnumLiteral.cname = 'LEnumLiteral';\r\nDModelM1.cname = 'DModelM1';\r\nLModelM1.cname = 'LModelM1';\r\nDEnumerator.cname = 'DEnumerator';\r\nLEnumerator.cname = 'LEnumerator';\r\nDModel.cname = 'DModel';\r\nLModel.cname = 'LModel';\r\nDMap.cname = 'DMap';\r\nLMap.cname = 'LMap';\r\nDObject.cname = 'DObject';\r\nLObject.cname = 'LObject';\r\nDValue.cname = 'DValue';\r\nLValue.cname = 'LValue';\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\debugtools\\debug.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\ocl\\ocl.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\model\\dataStructure\\GraphDataElements.tsx",["868","869","870","871","872","873","874","875","876","877","878"],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\view\\viewElement\\view.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\graph\\graphElement\\sharedTypes\\sharedTypes.tsx",["879"],"import React, {CSSProperties, PureComponent, ReactNode} from \"react\";\r\nimport type {\r\n    DEdge,\r\n    DGraph,\r\n    DGraphElement,\r\n    DModelElement,\r\n    DViewElement,\r\n    Json,\r\n    LGraph,\r\n    LGraphElement,\r\n    LModelElement,\r\n    LViewElement,\r\n    Pointer, PrimitiveType\r\n} from \"../../../joiner\";\r\nimport {Dictionary, LClass, LEdge, LUser, LViewPoint, LVoidVertex, RuntimeAccessible} from \"../../../joiner\";\r\nimport {GObject, InitialVertexSize, orArr} from \"../../../joiner/types\";\r\n\r\nexport class GraphElementStatee {/*\r\n    constructor(preRenderFunc: string | undefined, evalContext: GObject, templatefunc: () => React.ReactNode) {\r\n        this.preRenderFunc = preRenderFunc;\r\n        this.evalContext = evalContext;\r\n        this.template = templatefunc;\r\n    }\r\n    preRenderFunc?: string;\r\n    evalContext: Json;\r\n    template: () => ReactNode;* /\r\n    nodeid: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    constructor(nodeid: Pointer<DGraphElement, 1, 1, LGraphElement>) {\r\n        this.nodeid = nodeid;\r\n    }*/\r\n    // displayPosition?: GraphSize; // used while dragging to prevent flood of redux events\r\n    classes!: string[];\r\n}\r\n\r\n\r\nexport class GraphElementReduxStateProps {\r\n    // userexample?: UserState; // todo: make and repace with proxy wrapper \"User\", or make a \"cached\" global variable synchronized with redux state for easier access\r\n    view!: LViewElement;\r\n    views!: LViewElement[]; // all applicable views\r\n    // graphID!: string;\r\n    // dataid?: Pointer<DModelElement, 1, 1, LModelElement>;\r\n    // model?: LModel;\r\n    // [userMappedFromRedux: string]: any; // roba che l'utente ha dichiarato di voler prendere dallo stato e redux gli carica nelle props\r\n    //preRenderFunc?: string;\r\n    // evalContext!: Json; moved to transient properties\r\n    //template!: string;\r\n    node!: LGraphElement;\r\n    data?: LModelElement;\r\n    __skipRender?: boolean;\r\n    // usageDeclarations!: DefaultUsageDeclarations;\r\n    // invalidUsageDeclarations?: Error; // moved in stateProps.usageDeclarations.__invalidUsageDeclarations\r\n    // graph!: LGraph;\r\n\r\n    // lastSelected!: LModelElement | null;\r\n    isEdgePending!: { user: LUser, source: LClass };// vertex only\r\n    nodeid!: Pointer<DGraphElement>;\r\n    dataid?: Pointer<DModelElement>;\r\n    viewid!: Pointer<DViewElement>;\r\n    viewsid!: Pointer<DViewElement>[];\r\n    parentviewid?:Pointer<DViewElement>;\r\n\r\n    static new(): GObject<GraphElementReduxStateProps>{\r\n        let e: GObject<GraphElementReduxStateProps> = new GraphElementReduxStateProps();\r\n        for (let k in e) if (e[k] === undefined) delete e[k];\r\n        return {...e}; // NB: because react complains if it's not a POJO.\r\n    }\r\n    protected constructor(){  }\r\n}\r\n\r\nexport class GraphElementDispatchProps {\r\n}\r\n\r\n// generic props for every component that this component will need to extend joining user-specified values and component-specific built-in values\r\nexport class BasicReactOwnProps {\r\n    children?: ReactNode; // orArr<JSX.Element | PrimitiveType>;\r\n    style?: CSSProperties;\r\n    class?: string | string[]; // my add as a fault-tolerant fix for users not used to jsx\r\n    className?: string | string[];\r\n    key?: string;\r\n\r\n    static new(): GObject<BasicReactOwnProps>{\r\n        let e: GObject<BasicReactOwnProps> = new BasicReactOwnProps();\r\n        for (let k in e) if (e[k] === undefined) delete e[k];\r\n        return e;\r\n    }\r\n    protected constructor(){ }\r\n}\r\n\r\nexport class GraphElementOwnProps extends BasicReactOwnProps {\r\n    data?: Pointer<DModelElement, 0, 1, LModelElement> | LModelElement;\r\n    view?: Pointer<DViewElement, 1, 1, LViewElement> | LViewElement;\r\n    views?: LViewElement[] | Pointer<DViewElement>[];\r\n    isGraph?: boolean;\r\n    isGraphVertex?: boolean;\r\n    isVertex?: boolean;\r\n    isEdgePoint?: boolean;\r\n    isEdge?: boolean;\r\n    isVoid?: boolean;\r\n    isField?: boolean = true;\r\n    onDelete?: (node: LGraphElement)=>boolean; // return false to prevent deletion\r\n\r\n    initialSize?: InitialVertexSize;\r\n\r\n    parentnodeid?: Pointer<DGraphElement, 1, 1, LGraphElement>; // Injected\r\n    nodeid?: Pointer<DGraphElement, 1, 1, LGraphElement>; // Injected\r\n    graphid?: Pointer<DGraph, 1, 1, LGraph>; // injected\r\n    parentViewId?: Pointer<DViewElement, 1, 1, LViewElement>; // injected\r\n    htmlindex?: number; // injected\r\n    childStyle?: CSSProperties; // obsolete use css // injected, indicates some properties are styled from <Polygon or such, and must be transferred to the first child of root\r\n\r\n    static new(): GObject<GraphElementOwnProps>{\r\n        let e: GObject<GraphElementOwnProps> = new GraphElementOwnProps();\r\n        for (let k in e) if (e[k] === undefined) delete e[k];\r\n        return e;\r\n    }\r\n    protected constructor(){ super(); }\r\n}\r\n\r\nexport class EdgeOwnProps extends GraphElementOwnProps {\r\n    onclick?: (e: React.MouseEvent<HTMLDivElement>) => void;\r\n    onmousedown?: (e: React.MouseEvent<HTMLDivElement>) => void;\r\n    start!: LGraphElement[\"id\"];\r\n    end!: LGraphElement[\"id\"];\r\n    label?: DEdge[\"longestLabel\"];\r\n    labels?: DEdge[\"labels\"];\r\n    anchorStart?: string;\r\n    anchorEnd?: string;\r\n    isField?: boolean = false;\r\n    isEdge?: boolean = true;\r\n    isReference?: boolean;\r\n    isValue?: boolean; // if missing it is deduced from isReference.\r\n    isExtend?: boolean;\r\n    isDepencency?: boolean; // package dep\r\n\r\n    static new(): GObject<EdgeOwnProps>{\r\n        let e: GObject<EdgeOwnProps> = new EdgeOwnProps();\r\n        for (let k in e) if (e[k] === undefined) delete e[k];\r\n        return e;\r\n    }\r\n    protected constructor(){ super(); }\r\n}\r\n\r\nexport class EdgeStateProps extends GraphElementReduxStateProps {\r\n    node!: LEdge;\r\n    edge!: LEdge; // just alias for node\r\n    //lastSelected!: LModelElement | null;\r\n    isEdgePending!: { user: LUser, source: LClass };\r\n    viewpoint!: LViewPoint;\r\n    start!: LGraphElement;\r\n    end!: LGraphElement;\r\n    __skipRender?: boolean; // in case start or end are undefined -> do not render the edge\r\n    static new(): GObject<EdgeStateProps>{\r\n        let e: GObject<EdgeStateProps> = new EdgeStateProps();\r\n        for (let k in e) if (e[k] === undefined) delete e[k];\r\n        return {...e}; // NB: because react complains if it's not a POJO.\r\n    }\r\n    protected constructor(){ super(); }\r\n    // key: string;\r\n}\r\n\r\n// @RuntimeAccessible\r\nexport class DefaultUsageDeclarations{\r\n    // all can be deleted in usageDeclaration function except view.\r\n    view?: GraphElementReduxStateProps[\"view\"];\r\n    node?: GraphElementReduxStateProps[\"node\"];\r\n    data: GraphElementOwnProps[\"data\"];\r\n    [key:string]: any;\r\n    constructor(ret: GraphElementReduxStateProps, ownProps: GraphElementOwnProps) {\r\n        /*this.data = ret.data;\r\n        this.view = ret.view;\r\n        this.node = ret.node;/*/\r\n    }\r\n}\r\n\r\n// @RuntimeAccessible\r\nexport class EdgeDefaultUsageDeclarations extends DefaultUsageDeclarations{\r\n    start!: EdgeOwnProps[\"start\"];\r\n    end!: EdgeOwnProps[\"end\"];\r\n}\r\n\r\n\r\n\r\nexport class VertexOwnProps extends GraphElementOwnProps {\r\n    // onclick?: (e: React.MouseEvent<HTMLDivElement>) => void;\r\n    // onmousedown?: (e: React.MouseEvent<HTMLDivElement>) => void;\r\n    isField?: boolean = false;\r\n    isVertex?: boolean = true;\r\n\r\n    decorated?: boolean; // for <decoratedStar /> (defaults true)\r\n    sides?: number // for <Polygon />, <Star /> and <Cross />\r\n    innerRadius?: number // for <Star /> and <Cross />\r\n    ratio?: number // for <Trapezoid />\r\n    rotate?: number // initial vertex rotation\r\n\r\n    static new(): GObject<VertexOwnProps>{\r\n        let e: GObject<VertexOwnProps> = new VertexOwnProps();\r\n        for (let k in e) if (e[k] === undefined) delete e[k];\r\n        return e;\r\n    }\r\n    protected constructor(){ super(); }\r\n}\r\n\r\nexport class VertexStateProps extends GraphElementReduxStateProps {\r\n    node!: LVoidVertex;\r\n    // lastSelected!: LModelElement | null;\r\n    // selected!: Dictionary<Pointer<DUser>, LModelElement|null>;\r\n    //selected!: LGraphElement|null;\r\n    isEdgePending!: { user: LUser, source: LClass };\r\n    viewpoint!: LViewPoint;\r\n\r\n    static new(): GObject<VertexStateProps>{\r\n        let e: GObject<VertexStateProps> = new VertexStateProps();\r\n        for (let k in e) if (e[k] === undefined) delete e[k];\r\n        return {...e}; // NB: because react complains if it's not a POJO.\r\n    }\r\n    protected constructor(){ super(); }\r\n}\r\n\r\n\r\nexport let contextFixedKeys: Dictionary<string, boolean> = {};\r\nsetContextFixedKeys();\r\n\r\nfunction setContextFixedKeys(){\r\n    // @ts-ignore: here i must use the constructor instead of new to have the undefined properties included.\r\n    let propmakers: GObject[] = [new EdgeOwnProps(), new EdgeStateProps(), new VertexOwnProps(), new VertexStateProps(), {\r\n        // \"model\", \"graph\",\r\n        \"constants\": true, \"usageDeclarations\": true,\r\n        \"component\": true,\r\n        \"htmlindex\": true,\r\n        \"state\": true, \"props\": true, \"stateProps\": true, \"ownProps\": true,\r\n        \"otherViews\": true, 'decorators':true, // only on final jsx, decorators are injected\r\n        //\"data\":true, \"node\":true, \"parentViewId\":true, \"parentnodeid\":true,// from props:\r\n        //\"view\":true, \"views\":true, \"viewScores\":true,// from props:\r\n        //\"children\":true, \"isGraph\":true, \"isVertex\":true, isEdge:true, isEdgePoint:true, isVoid: true, \"graphid\":true, \"nodeid\":true,// from props:\r\n    }];\r\n    for (let props of propmakers) for (let k in props) contextFixedKeys[k] = true;\r\n    delete contextFixedKeys.class;\r\n    return contextFixedKeys;\r\n}\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\common\\Dummy.ts",["880","881"],"import {\r\n    DeleteElementAction,\r\n    DState,\r\n    GObject,\r\n    Log,\r\n    LPointerTargetable, Pointer,\r\n    SetFieldAction, U,\r\n    SetRootFieldAction, TRANSACTION, DPointerTargetable, LViewPoint\r\n} from '../joiner';\r\nimport {Dependency} from \"../joiner/types\";\r\n\r\nexport class Dummy {\r\n    protected static get_dependencies(context: any): () => Dependency[] {\r\n        const data = context.data;\r\n        const dependencies: Dependency[] = [];\r\n        const ret = () => {\r\n            for (let pointedBy of data.pointedBy) {\r\n                const raw = pointedBy.source.split('.');\r\n                let root = raw[0];\r\n                const obj = raw[1] || '';\r\n                let field = raw[2] || '';\r\n\r\n                // Delete chars from end that are not in [azAZ].\r\n                const regex = /[^a-zA-Z]+$/;\r\n                root = root.replace(regex, '');\r\n                field = field.replace(regex, '');\r\n                // damiano: this is likely to cause a bug for sure somewhere when a key ends with \"s\" but is not an array. keep in mind when naming variables.\r\n                let op: ''|'-=' = (field && field.endsWith('s')) ? '-=' : '';\r\n                if(!field && root.endsWith('s')) op = '-=';\r\n\r\n                const dependency: Dependency = {root: root  as keyof DState, obj, field: field as keyof DPointerTargetable, op};\r\n                if(!dependencies.includes(dependency)) dependencies.push(dependency);\r\n            }\r\n            return dependencies\r\n        }\r\n        return ret;\r\n    }\r\n    static get_delete(thiss: any, context: any): () => void {\r\n        const lData: LPointerTargetable & GObject = context.proxyObject;\r\n        const dData = context.data;\r\n        const dependencies = Dummy.get_dependencies(context)();\r\n        console.log('get_delete '+(dData as any).name, {dData, dependencies});\r\n\r\n        const ret = () => {\r\n            console.log('0 get_delete() '+(dData as any)?.name, {dData, cn:dData?.className, dependencies});\r\n            SetRootFieldAction.new('_lastSelected', undefined, '');\r\n            const dataID = dData.id as any;\r\n\r\n            if (dData.id.indexOf('Pointer_View') !== -1 ) return; // cannot delete default views/viewpoints\r\n            if (dData.__readonly) return;\r\n            console.log('1 get_delete() '+(dData as any)?.name, {dData, cn:dData?.className, dependencies});\r\n            for (let child of lData.children) {\r\n                child.delete();\r\n                // todo: if a m1-dvalue which conforms to a m2-reference with \"containment\" is deleted, need to delete also target.\r\n                // maybe better to do through override?\r\n                // child.node?.delete();\r\n            }\r\n\r\n            console.log('2 get_delete() '+(dData as any)?.name, {dData, cn:dData?.className});\r\n            // those 2 are exceptions because the pointer is a key in an object instead of a normal value as a field or array member.\r\n            switch (dData.className) {\r\n                case 'DViewElement':\r\n                    SetFieldAction.new(dData.father, 'subViews', dataID, '-=', false);\r\n                    break;\r\n                case 'DViewPoint':\r\n                    let projectid = (lData as LViewPoint)?.project?.id;\r\n                    Log.eDevv('cannot find project id while deleting a viewpoint', {dData, context, dependencies});\r\n                    if (projectid) SetFieldAction.new(projectid, 'viewpoints', dataID, '-=', false);\r\n                    break;\r\n            }\r\n\r\n            for (let dependency of dependencies) {\r\n                const root: keyof DState = dependency.root;\r\n                if(root !== 'idlookup') {\r\n                    SetRootFieldAction.new(root, dataID, '-=', false);\r\n                    continue;\r\n                }\r\n                const pointer: Pointer<any>|null = dependency.obj; // the pointing element (delete a DClass => DAttribute)\r\n                const field = dependency.field;\r\n                const lObj: any = LPointerTargetable.wrap(pointer);\r\n                if (!pointer || !lObj) continue;\r\n                const dObj: any = lObj.__raw;\r\n                switch (field as string) {\r\n                    /* on '-=' pointedby would be removed from the element we are deleting, so it is irrelevant */\r\n                    default:\r\n                        Log.eDevv('Unexpected case in delete:', field, lData);\r\n                        break;\r\n                    case 'metamodels':\r\n                        console.log('mm filter', {newmm:dObj.metamodels.filter((id: Pointer) => id !== dataID), oldmm:dObj.metamodels, dataID})\r\n                        lObj.metamodels = dObj.metamodels.filter((id: Pointer) => id !== dataID);\r\n                        break;\r\n                    case 'dependencies':\r\n                        lObj.dependencies = dObj.dependencies.filter((id: Pointer) => id !== dataID);\r\n                        break;\r\n                    case 'values':\r\n                        lObj.values = dObj.values.filter((o: any) => o !== dataID);\r\n                        break;\r\n                    case 'type':\r\n                        switch (dObj.className) {\r\n                            case 'DAttribute': lObj.type = 'Pointer_ESTRING'; break;\r\n                            case 'DReference': case 'DOperation':\r\n                                // would be nice to set dObj.extends[0] instead but i cannot tell if it was deleted too.\r\n                                // dobj.father instead is safe as even if it's deleted it does not matter as it will delete the feature together\r\n                                lObj.type = dObj.father;\r\n                                break;\r\n                        }\r\n                        break;\r\n                    case 'model':\r\n                        if(dObj.className === 'DPackage') {\r\n                            lObj.father[field] = lObj.father.__raw[field].filter((id: any) => id != dataID);\r\n                            continue;\r\n                        } else {\r\n                            /* Node is deleted in nodes.delete() */\r\n                            continue;\r\n                        }\r\n                    case 'packages':\r\n                    case 'subpackages':\r\n                    case 'classifiers':\r\n                    case 'enumerators':\r\n                    case 'literals':\r\n                    case 'classes':\r\n                    case 'attributes':\r\n                    case 'references':\r\n                    case 'operations':\r\n                    case 'parameters':\r\n                    case 'features':\r\n                    case 'instances':\r\n                    case 'objects':\r\n                        lObj[field] = dObj[field].filter((id: any) => id != dataID);\r\n                        continue;\r\n                    case 'instanceof':\r\n                        lObj.delete();\r\n                        continue;\r\n                    /* No operations required (children) */\r\n                    case 'father':\r\n                    case 'subElements':\r\n                    case 'annotations':\r\n                        break;\r\n                }\r\n                /*\r\n                if ((root === 'idlookup') && obj && field) {\r\n                    console.log('Delete', `SetFieldAction.new('${obj}', '${field}', '${val}', '${op}');`, {dependency});\r\n                    SetFieldAction.new(obj, field, val, op, false);\r\n                } else {\r\n                    console.log('Delete', `SetRootFieldAction.new('${root}', '${val}', '${op}');`);\r\n                    SetRootFieldAction.new(root, val, op, false);\r\n                }\r\n                */\r\n            }\r\n\r\n            console.log('3 get_delete() '+(dData as any)?.name, {dData, cn:dData?.className});\r\n            if (lData.nodes) lData.nodes.map((node: any) => node.delete());\r\n            console.log('4 get_delete() '+(dData as any)?.name, {dData, cn:dData?.className});\r\n            SetRootFieldAction.new('ELEMENT_DELETED', dataID, '+=', false); // here no need to IsPointer because it only affects Transient stuff\r\n            //U.sleep(1).then(() => SetRootFieldAction.new(`idlookup.${dataID}`, undefined, '', false));\r\n            //SetRootFieldAction.new(`idlookup.${dataID}`, undefined, '', false);\r\n            console.log('5 get_delete() '+(dData as any)?.name, {dData, cn:dData?.className});\r\n            DeleteElementAction.new(dData.id);\r\n        };\r\n        console.log('00 get_delete '+(dData as any)?.name, {dData, cn:dData?.className});\r\n        return () => {\r\n            console.log('00 get_delete() '+(dData as any)?.name, {dData, cn:dData?.className});\r\n            TRANSACTION('delete ' + thiss.get_name(context), ()=>{\r\n                console.log('0000 get_delete '+(dData as any)?.name, {dData, cn:dData?.className}); ret(); })\r\n        }\r\n    }\r\n}\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\data\\storage.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\common\\SimpleTree.ts",["882"],"import {Dictionary, GObject, Log, U} from \"../joiner\";\r\n\r\n\r\n/* problema: se creo una key per ordinare l'albero e trovare \"of\" in O(log n), allora perdo l'ordinamento arbitrario di sottoalberi = sottoclassi a prescindere dai nomi.\r\n   potrei fare un dizionario di alberi, 1 albero per ogni dclass e lclass, con sottoelementi\r\n    */\r\n\r\n// not binary, not rb tree, not balanced, just a tree\r\n// it is N-ary\r\n// ma probabilmente non dovrei usare affatto un albero, ma fare un dizionario per ogni classe con cosa estende direttamente\r\n// e uno con cosa estende direttamente e indirettamente popolato automaticamente in n*logn una volta e fine\r\n// navigando superclass\r\n\r\n// B.superclass = [a1, a2] --- > a1.pushdirectsubclass(b), a2 same.  poi se a1 estende c, c.pushindirectsubclass(b)... e si risale da b finchè ci sono superclassi (logn) volte, fatto per tutte le n classi\r\n// each node have a \"node<T>\" value and a subtree with all subelements.\r\n// iterable with for...of with width iterator (not depth)\r\nexport class SimpleTree<T extends GObject> {\r\n    subelements: SimpleTree<T>[];\r\n    node: T; // can be undef, if root was an array instead of a single element.\r\n    // the nodes containing the rooots will be the childrens instead, as if they are N trees\r\n    // with a fake node joining them in a single one\r\n    // up: SimpleTree<T>; maybe do this too\r\n\r\n    [Symbol.iterator] = function*(this:SimpleTree<T>) {\r\n    // [Symbol.iterator]: Generator<number, string, boolean> = function*() {\r\n    // [Symbol.iterator]: Generator<number, string, boolean>= () => {\r\n    // [Symbol.iterator] () {\r\n        yield this;\r\n        let fifo = this.subelements;\r\n        while (fifo.length) {\r\n            let nextLevel = [];\r\n            for (let subtree of fifo) {\r\n                yield subtree;\r\n                nextLevel.push(...subtree.subelements);\r\n            }\r\n            //@ts-ignore\r\n            // console.log(\"fifo -> next level\", fifo.map(f=>f?.node?.cname), nextLevel.map(f=>f?.node?.cname));\r\n            fifo = nextLevel;\r\n        }\r\n    }\r\n\r\n    getiIsSubElementMatrix(namekey: keyof T): Dictionary<string, Dictionary<string, boolean>>{\r\n        let ret: Dictionary<string, Dictionary<string, boolean>> = {}// matrix name x name telling if A extends B\r\n        for (let o of this) { // O(N^2), but optimal for this task, as the matrix size is O(N^2) as well\r\n            let name = o.node[namekey];\r\n            if (!name) Log.ee(\"missing key property  in tree node: \", {tree: this, node:o.node, namekey});\r\n            ret[name] = {};\r\n            // if (o === this) continue;\r\n            for (let subo of o) {\r\n                let subname = subo.node[namekey];\r\n                if (!subname) { console.log(\"skipped\"); continue; }\r\n                ret[name as string][subname as string] = true;\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    public add(e: T, childKey?: keyof T, loopdetector?: WeakMap<T, boolean>): SimpleTree<T> | undefined{\r\n        if (loopdetector) {\r\n            if (loopdetector.get(e)) {\r\n                Log.eDev(e.cname.indexOf(\"GraphVertex\") !== 1,\r\n                    \"A constructor is extending 2 different classes, or there is a loop in Tree constructor parameter.\",\r\n                    \"GraphVertex should be the only class doing that currently\",\r\n                    {e, cname:e.cname, childKey, loopdetector});\r\n                return;\r\n            }\r\n            loopdetector.set(e, true);\r\n        }\r\n        let subtree =  new SimpleTree<T>(e, childKey, loopdetector);\r\n        this.subelements.push(subtree);\r\n        return subtree; }\r\n\r\n    getSubtree(e: T): SimpleTree<T> | undefined {\r\n        for (let t of this) { if (t.node == e) return t; }\r\n        return undefined; }\r\n\r\n    // childkey: adds subobjects found in \"roots\" parameters as nodes<T> in the tree\r\n    // comparison: tells if a node comes first or after another, example: (a, b) => a.name.toUpperCase() < b.name.toUpperCase()\r\n    constructor(roots: GObject | GObject[], childKey?: keyof T, loopdetector?: WeakMap<T, boolean>) {\r\n        // if arr, add N roots as subelements, and delegate actual subelements of the root to subtree constructors\r\n        if (!loopdetector) loopdetector = new WeakMap();\r\n        /*(this as any)[Symbol.iterator] = function *(){\r\n            yield this;\r\n            let fifo = this.subelements;\r\n            while (fifo.length) {\r\n                let nextLevel = [];\r\n                for (let subtree of fifo) {\r\n                    yield subtree;\r\n                    nextLevel.push(subtree);\r\n                }\r\n                fifo = nextLevel;\r\n            }\r\n        }*/\r\n\r\n        //@ts-ignore\r\n        this.debug = roots.cname;\r\n        this.subelements = [];\r\n        if (Array.isArray(roots)) {\r\n            this.node = undefined as any;\r\n            for (let e of roots) {\r\n                if (!e) continue;\r\n                this.add(e as T, childKey, loopdetector);\r\n            }\r\n        }\r\n        // if not arr, add immediate subelements of root\r\n        else {\r\n            this.node = roots as T;\r\n            if (!childKey) return;\r\n            let child: T | T[] = this.node[childKey];\r\n            if (Array.isArray(child)) {\r\n                for (let c of child) this.add(c, childKey, loopdetector);\r\n            }\r\n            else this.add(child, childKey, loopdetector);\r\n        }\r\n    }\r\n\r\n\r\n}\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\collaborative\\Collaborative.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\DSL\\DSL.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\redux\\VersionFixer.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\iot\\IoT.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\redux\\defaults\\views.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\graph\\graphElement\\graphElement.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\Input.tsx",["883","884","885"],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\Selector.tsx",["886","887","888","889"],"import {DPointerTargetable, LClass, LModel, Defaults, U, Input} from '../../joiner';\r\nimport {DState, GObject, LEnumerator, LPointerTargetable, Overlap, Pointer} from '../../joiner';\r\nimport React, {Dispatch, LegacyRef, ReactElement, ReactNode} from 'react';\r\nimport {connect} from 'react-redux';\r\nimport {useStateIfMounted} from 'use-state-if-mounted';\r\nimport './inputselect.scss';\r\n\r\n\r\nfunction SelectorComponent(props: AllProps) {\r\n    const data = props.data;\r\n    const [showTooltip, setShowTooltip] = useStateIfMounted(false);\r\n    if (!data) return(<></>);\r\n    let d: DPointerTargetable = data.__raw || data;\r\n    let l: LPointerTargetable = LPointerTargetable.fromD(data);\r\n    let gdata: GObject<LPointerTargetable> = data;\r\n    const field: (keyof LPointerTargetable & keyof DPointerTargetable) = props.field as any;\r\n    const readOnly = props.readonly !== undefined ? props.readonly : !props.debugmode && Defaults.check(data.id);\r\n    const value: string | Pointer = d[field] as string;\r\n    const label: string|undefined = props.label;\r\n    const jsxLabel: ReactNode|undefined = props.jsxLabel;\r\n    let tooltip: string|undefined = (props.tooltip === true) ? ((gdata['__info_of__' + field]) ? gdata['__info_of__' + field].txt: '') : props.tooltip;\r\n    tooltip = tooltip || '';\r\n    let css = '';//'my-auto select ';\r\n   // css += (jsxLabel) ? 'ms-1' : 'ms-auto';\r\n    css += (props.hidden) ? ' hidden-input' : '';\r\n\r\n    \r\n    /* @ts-ignore */\r\n    const setter = (id) => {l[field].value=id} \r\n    \r\n    /* @ts-ignore */\r\n\r\n    const getter = () => l[field].value;//l.$type.__raw.values[0];\r\n    \r\n\r\n    function SelectorChange(evt: React.ChangeEvent<HTMLSelectElement>) {\r\n        if (readOnly) return;\r\n\r\n        \r\n        const newValue = evt.target.value; \r\n        const oldValue = getter(); \r\n        setter(newValue);\r\n    }\r\n\r\n    // \r\n\r\n    function getOptions(): any {\r\n\r\n\r\n        {/*@ts-ignore*/}\r\n        switch (l[field].type.className) {\r\n            case 'DClass':\r\n                return (<>\r\n\r\n                    {/*@ts-ignore*/}\r\n                    {l[field].type.allInstances.map(cl =><>\r\n                        {/*@ts-ignore*/}\r\n                        {typeof(l[field].value) === 'undefined' ? \r\n                            <option value={cl.id}>{cl.name}</option> \r\n                            :\r\n                            <>\r\n                                {/*@ts-ignore*/}\r\n                                {l[field].value.id === cl.id ?\r\n                                <option value={cl.id} selected>{cl.name}</option> \r\n                                :\r\n                                <option value={cl.id}>{cl.name}</option>  \r\n                            }\r\n                            </>\r\n                        }\r\n        \r\n                    </>)}\r\n                </>); \r\n            break;\r\n            case 'DEnumerator':\r\n                \r\n                return (<>\r\n                    <option value=\"\" disabled selected>Select your option</option>\r\n                    {/*@ts-ignore*/}\r\n                    {l[field].type.literals.map(lit =><>\r\n                        \r\n                        {/*@ts-ignore*/}\r\n                        {typeof(l[field].value) === 'undefined' ? \r\n                            \r\n                            <option value={lit.id}>{lit.name}</option>\r\n                            :\r\n                            <>\r\n                                {/*@ts-ignore*/}\r\n                                {l[field].value.name === lit.name ?\r\n                                    <option value={lit.id} selected>{lit.name}</option> \r\n                                    :\r\n                                    <option value={lit.id}>{lit.name}</option>  \r\n                                }\r\n                            </>\r\n                        }\r\n        \r\n                    </>)}\r\n                </>);\r\n            break;\r\n            default:\r\n                return (U.alert('e', 'Unsupported type','Selector Component'));\r\n            break;\r\n\r\n        }\r\n\r\n\r\n\r\n        \r\n    }\r\n\r\n    const otherprops: GObject = {...props};\r\n    delete otherprops.data;\r\n    delete otherprops.getter;\r\n    delete otherprops.setter;\r\n    delete otherprops.jsxLabel;\r\n    delete otherprops.primitives;\r\n    delete otherprops.returns;\r\n    delete otherprops.hidden;\r\n    let cursor: string;\r\n    if (tooltip) cursor = 'help';\r\n    else if (readOnly) cursor = 'not-allowed';\r\n    else cursor = 'pointer';\r\n    let inputStyle = props.inputStyle || {};\r\n    if (!inputStyle.cursor && cursor === 'not-allowed') { inputStyle.cursor = cursor; }\r\n    U.objectMergeInPlace(inputStyle, props.inputStyle || {}, props.style || {});\r\n    let className = [props.className, props.inputClassName, css].join(' ');\r\n\r\n    let get_options = getOptions();\r\n\r\n    let select = (<select {...otherprops} className={className + ' model-select'} disabled={readOnly} placeholder={'-----'}\r\n            style={props.inputStyle}\r\n            value={value}\r\n            onChange={SelectorChange}>\r\n                {get_options ? get_options : U.alert('e', 'Error in Selector component', 'Something went wrong ...')}\r\n    </select>);\r\n\r\n\r\n    return select;\r\n}\r\n\r\nSelectorComponent.cname = 'SelectorComponent';\r\nexport interface SelectorOwnProps {\r\n    data?: DPointerTargetable | Pointer<DPointerTargetable, 1, 1, LPointerTargetable>;\r\n    field: string;\r\n    label?: string;\r\n    jsxLabel?: ReactNode;\r\n    tooltip?: boolean|string;\r\n    hidden?: boolean;\r\n    options?: JSX.Element;\r\n    key?: React.Key | null;\r\n    className?: string;\r\n    style?: GObject;\r\n    ref?: React.RefObject<HTMLElement> | LegacyRef<HTMLElement>;\r\n    readonly?: boolean;\r\n    inputClassName?: string;\r\n    inputStyle?: GObject;\r\n    // DANGER: use the data provided in parameters instead of using js closure, as the proxy accessed from using closure won't be updated in rerenders.\r\n    my_getter?: <T extends DPointerTargetable = any>(data: any | T | Pointer<T>, field: (string | number | symbol) | keyof T) => string;\r\n    // setter?: <T extends DPointerTargetable = any>(data: T | Pointer<T>, field: keyof T, selectedValue: string) => void;\r\n    // setter?: <T extends DPointerTargetable = any>(data: any | T | Pointer<T>, field: (string | number | symbol) | keyof T, selectedValue: string) => void;\r\n    my_setter?: (data: any, field: string, selectedValue: string) => void;\r\n\r\n}\r\ninterface StateProps {\r\n    debugmode: boolean,\r\n    data: LPointerTargetable;\r\n    primitives: LClass[];\r\n    returns: LClass[]; }\r\ninterface DispatchProps { }\r\n\r\ntype AllProps = Overlap<SelectorOwnProps, Overlap<StateProps, DispatchProps>>;\r\n\r\n\r\nfunction mapStateToProps(state: DState, ownProps: SelectorOwnProps): StateProps {\r\n    const ret: StateProps = {} as any;\r\n    if (!ownProps.data) return ret;\r\n    const pointer: Pointer = typeof ownProps.data === 'string' ? ownProps.data : ownProps.data.id;\r\n    ret.debugmode = state.debug;\r\n    ret.data = LPointerTargetable.fromPointer(pointer);\r\n    ret.primitives = LPointerTargetable.fromPointer(state.primitiveTypes);\r\n    ret.returns = LPointerTargetable.fromPointer(state.returnTypes);\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\n\r\nexport const SelectorConnected = connect<StateProps, DispatchProps, SelectorOwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(SelectorComponent);\r\n\r\nexport const Selector = (props: SelectorOwnProps, children: (string | React.Component)[] = []): ReactElement => {\r\n    return <SelectorConnected {...{...props, children}} />;\r\n}\r\n\r\n\r\nSelectorComponent.cname = 'SelectorComponent';\r\nSelectorConnected.cname = 'SelectorConnected';\r\nSelector.cname = 'Selector';\r\nexport default Selector;\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\Account.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\AllProjects.tsx",["890","891","892","893"],"/* DASHBOARD */\r\n/* ALLPROJECTS */\r\n\r\nimport React, {ChangeEvent, MouseEventHandler, Component, Dispatch, ReactElement, useState, useRef } from 'react';\r\nimport {connect} from 'react-redux';\r\nimport {DProject, DState, Log, LProject, SetRootFieldAction, Try, U} from '../joiner';\r\nimport {Dictionary, FakeStateProps} from '../joiner/types';\r\nimport {Dashboard, Project} from './components';\r\nimport Storage from \"../data/storage\";\r\n\r\nimport { Cards, Card } from './components/cards/Cards';\r\nimport { Catalog } from './components/catalog/Catalog';\r\n\r\nimport {ProjectsApi} from \"../api/persistance\";\r\nimport { LatestUpdates } from './components/LatestUpdates';\r\n\r\nfunction AllProjectsComponent(props: AllProps): JSX.Element {\r\n    const {projects} = props;\r\n    const [isDropping, setDropping] = useState(false);\r\n    const createProject = async(type: DProject['type']) => {\r\n        await ProjectsApi.create(type, undefined, undefined, undefined, projects);\r\n    }\r\n    function dropConfirm(e: React.DragEvent<HTMLElement>){\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n        console.log('dropevent', {e});\r\n\r\n        const droppedFiles = Array.from(e.dataTransfer.files);\r\n        if (droppedFiles.length > 0) {\r\n            for (let file of droppedFiles){\r\n            var reader = new FileReader();\r\n            reader.onload = function(e) {\r\n                if (!e.target) { Log.ee('invalid file', e); return; }\r\n                var contents = e.target.result;\r\n                console.log('read file', {contents, e, file});\r\n                let date: number = file.lastModified;\r\n                let name = file.name; // including extension\r\n                if (typeof contents === 'string') ProjectsApi.importFromText(contents, name, date);\r\n                else Log.ee('invalid file content', {e, contents});\r\n            };\r\n            reader.readAsText(file);\r\n            }\r\n        }\r\n        //let file = e.dataTransfer.getData('file');\r\n        setDropping(false);\r\n    }\r\n    function mouseleave(e: any){ // should use onDragLeave but it is flashing\r\n        setDropping(false);\r\n    }\r\n    function dropPreview(e: React.DragEvent<any>){\r\n        e.stopPropagation();\r\n        e.preventDefault();\r\n        setDropping(true);\r\n        e.dataTransfer.dropEffect = 'copy';\r\n    }\r\n    return(<Try>\r\n        <>\r\n        <Dashboard active={'All'} version={props.version}>\r\n            <div className={'droparea'} onDrop={dropConfirm} onDragOver={dropPreview} onMouseLeave={mouseleave}>\r\n                <div style={{opacity: isDropping ? 0.5 : 1}}>\r\n                <Cards>\r\n                    <Cards.Item\r\n                        title={'New Jjodel'}\r\n                        subtitle={'Create a new Jjodel project.'}\r\n                        icon={'add'}\r\n                        style={'green'}\r\n                        action={() => createProject('private')}\r\n                    />\r\n                    {!(U.isOffline()) && <Cards.Item\r\n                        title={'New Jjodel (Collaborative)'}\r\n                        subtitle={'Create a new Jjodel project.'}\r\n                        icon={'add'}\r\n                        style={'yellow'}\r\n                        action={() => createProject('collaborative')}\r\n                    />}\r\n                    <Cards.Item\r\n                        title={'Import Jjodel'}\r\n                        subtitle={'Import an existing Jjodel project.'}\r\n                        icon={'import'}\r\n                        style={'dark'}\r\n                        action={ProjectsApi.import}\r\n                    />\r\n                    {true && <Cards.Item icon={'gettingstarted'} url={'https://www.jjodel.io/getting-started/'} style={'red-orange'} title={'Getting Started'} subtitle={'New to Jjodel? No worries'}/>}\r\n                </Cards>\r\n                <Catalog projects={projects} />\r\n            </div>\r\n                {isDropping ? <div style={{\r\n                    position: 'absolute',\r\n                    left: '50%',\r\n                    marginLeft: '-50px',\r\n                    top: '50%',\r\n                    marginTop: '-50px',}}>Drop the file to import a .jJodel project</div> : null}\r\n            </div>\r\n        </Dashboard>\r\n        <LatestUpdates page={'AllProjects'}/>\r\n        </>\r\n\r\n    </Try>);\r\n}\r\n\r\ninterface OwnProps {}\r\ninterface StateProps {\r\n    projects: LProject[];\r\n    version: DState[\"version\"];\r\n}\r\ninterface DispatchProps {}\r\n\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as FakeStateProps;\r\n    ret.projects = LProject.fromArr(state.projects);\r\n    ret.version = state.version;\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\nconst AllProjectsConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(AllProjectsComponent);\r\n\r\nconst AllProjectsPage = (props: OwnProps, children: (string | Component)[] = []): ReactElement => {\r\n    return <AllProjectsConnected {...{...props, children}} />;\r\n}\r\n\r\nexport {AllProjectsPage};\r\n\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\Auth.tsx",["894"],"import {FormEvent} from 'react';\r\nimport {useStateIfMounted} from 'use-state-if-mounted';\r\nimport {DUser, R, SetRootFieldAction, U} from '../joiner';\r\nimport Storage from '../data/storage';\r\nimport {AuthApi} from \"../api/persistance\";\r\nimport logo from '../static/img/jjodel.jpg';\r\nimport {Tooltip} from '../components/forEndUser/Tooltip';\r\n\r\nfunction AuthPage(): JSX.Element {\r\n\r\n    const [action, setAction] = useStateIfMounted<'login'|'register'|'retrieve-password'>('login');\r\n\r\n    const [nickname, setNickname] = useStateIfMounted('');\r\n    const [name, setName] = useStateIfMounted('');\r\n    const [surname, setSurname] = useStateIfMounted('');\r\n    const [affiliation, setAffiliation] = useStateIfMounted('');\r\n    const [country, setCountry] = useStateIfMounted('Italy');\r\n    const [email, setEmail] = useStateIfMounted('');\r\n    const [password, setPassword] = useStateIfMounted('');\r\n    const [passwordCheck, setPasswordCheck] = useStateIfMounted('');\r\n    const [newsletter, setNewsletter] = useStateIfMounted(false);\r\n\r\n\r\n    const onSubmit = async(e: FormEvent<HTMLFormElement>) => {\r\n        e.preventDefault();\r\n        SetRootFieldAction.new('isLoading', true);\r\n\r\n        switch (action) {\r\n            case 'login':\r\n                await login();\r\n                break;\r\n            case 'register':\r\n                await register();\r\n                break;\r\n            case 'retrieve-password':\r\n                await retrieve_password();\r\n                break;\r\n        }\r\n\r\n        SetRootFieldAction.new('isLoading', false);\r\n    }\r\n\r\n    const retrieve_password = async() => {\r\n        /* something to be provided here */\r\n    }\r\n\r\n    const login = async() => {\r\n        const response = await AuthApi.login(email, password);\r\n        if (response.code !== 200) {\r\n            U.alert('e', 'Login failed.','');\r\n            return;\r\n        }\r\n\r\n        const data = U.wrapper<DUser>(response.data);\r\n\r\n        const user = DUser.new(data.name, data.surname, data.nickname, data.affiliation, data.country, data.newsletter || false, data.email, data.token, data.id);\r\n        Storage.write('user', user);\r\n        Storage.write('token', user.token);\r\n        Storage.write('offline', false);\r\n        //R.navigate('/dashboard');\r\n        R.navigate('/allProjects');\r\n        U.resetState();\r\n    }\r\n\r\n    const register = async() => {\r\n        if (password !== passwordCheck) {\r\n            U.alert('e', 'The two passwords are different','');\r\n            return;\r\n        }\r\n        const response = await AuthApi.register(name, surname, country, affiliation, newsletter, nickname, email, password);\r\n        if (response.code !== 200) {\r\n            U.alert('e', 'Registration failed.', '');\r\n            return;\r\n        }\r\n        const data = U.wrapper<DUser>(response.data);\r\n        Storage.write('token', data.token);\r\n        const user = DUser.new(data.name, data.surname, data.nickname, data.affiliation, data.country, data.newsletter || false, data.email, data.token, data.id);\r\n        Storage.write('user', user);\r\n        Storage.write('offline', false);\r\n        R.navigate('/allProjects');\r\n        U.resetState();\r\n    }\r\n\r\n    const offline = () => {\r\n        AuthApi.offline();\r\n        R.navigate('/allProjects');\r\n        U.resetState();\r\n    }\r\n\r\n    return(<section className={`w-100 h-100 login bg ${action === 'register' ? 'register' : action === 'retrieve-password' && 'retrieve' } `}>\r\n\r\n        <form className={'d-block bg-white rounded border mx-auto w-fit px-5 py-4 mt-5'} onSubmit={onSubmit}>\r\n            <label className={'fs-1 d-block text-center text-primary login-header'}>\r\n\r\n                {action === 'register' && 'Create an Account'}\r\n                {action === 'login' && 'Sign In'}\r\n                {action === 'retrieve-password' && 'Retrieve your Password'}\r\n\r\n\r\n            </label>\r\n\r\n            {action === 'register' && <>\r\n\r\n                {/* REGISTRATION */}\r\n\r\n                <Tooltip tooltip={<div style={{padding: '10px', maxWidth: '600px'}}><h6>First Name</h6>Your first name will be visible to others whenever you interact with them, such as during collaboration on shared projects.</div>} >\r\n                    <label>\r\n                        First Name\r\n                        <input className={'w-100 input w-fit d-block mx-auto mt-2'}\r\n                            placeholder={'john'}\r\n                            value={name}\r\n                            onChange={e => setName(e.target.value)}\r\n                            type={'text'} required={true}\r\n                        />\r\n                    </label>\r\n                </Tooltip>\r\n\r\n                <Tooltip tooltip={<div style={{padding: '10px', maxWidth: '600px'}}><h6>Last Name</h6>Your last name will be visible to others whenever you interact with them, such as during collaboration on shared projects.</div>} >\r\n                    <label>\r\n                        Last Name\r\n                        <input className={'w-100 input w-fit d-block mx-auto mt-2'}\r\n                               placeholder={'doe'}\r\n                               value={surname}\r\n                               onChange={e => setSurname(e.target.value)}\r\n                               type={'text'} required={true}\r\n                        />\r\n                    </label>\r\n                </Tooltip>\r\n\r\n                    <Tooltip tooltip={<div style={{padding: '10px', maxWidth: '600px'}}><h6>Nickname</h6>Your nickname will be visible to others whenever you interact with them, such as during collaboration on shared projects.</div>} >\r\n                        <label>\r\n                            Nickname\r\n                            <input className={'w-100 input w-fit d-block mx-auto mt-2'}\r\n                                   placeholder={''}\r\n                                   value={nickname}\r\n                                   onChange={e => setNickname(e.target.value)}\r\n                                   type={'text'} required={true}\r\n                            />\r\n                        </label>\r\n                    </Tooltip>\r\n\r\n                <Tooltip tooltip={<div style={{padding: '10px', maxWidth: '600px'}}><h6>Affiliation</h6>Your affiliation refers to the organization, institution, or company you’re associated with, will be displayed in relevant contexts like project collaborations or professional interactions, and will help us keep track of where jjodel is being used.</div>} ><label>\r\n                    Affiliation\r\n                    <input className={'w-100 input w-fit d-block mx-auto mt-2'}\r\n                        placeholder={'eg: univaq'}\r\n                        value={affiliation}\r\n                        onChange={e => setAffiliation(e.target.value)}\r\n                        type={'text'} required={false}\r\n                    />\r\n                    </label>\r\n                </Tooltip>\r\n                <label>\r\n                    <label>Country</label>\r\n                    <select className={\"form-control\"} defaultValue={country} onChange={e => setCountry(e.target.value)}>\r\n                        <option value=\"Afghanistan\">Afghanistan</option>\r\n                        <option value=\"Åland Islands\">Åland Islands</option>\r\n                        <option value=\"Albania\">Albania</option>\r\n                        <option value=\"Algeria\">Algeria</option>\r\n                        <option value=\"American Samoa\">American Samoa</option>\r\n                        <option value=\"Andorra\">Andorra</option>\r\n                        <option value=\"Angola\">Angola</option>\r\n                        <option value=\"Anguilla\">Anguilla</option>\r\n                        <option value=\"Antarctica\">Antarctica</option>\r\n                        <option value=\"Antigua and Barbuda\">Antigua and Barbuda</option>\r\n                        <option value=\"Argentina\">Argentina</option>\r\n                        <option value=\"Armenia\">Armenia</option>\r\n                        <option value=\"Aruba\">Aruba</option>\r\n                        <option value=\"Australia\">Australia</option>\r\n                        <option value=\"Austria\">Austria</option>\r\n                        <option value=\"Azerbaijan\">Azerbaijan</option>\r\n                        <option value=\"Bahamas\">Bahamas</option>\r\n                        <option value=\"Bahrain\">Bahrain</option>\r\n                        <option value=\"Bangladesh\">Bangladesh</option>\r\n                        <option value=\"Barbados\">Barbados</option>\r\n                        <option value=\"Belarus\">Belarus</option>\r\n                        <option value=\"Belgium\">Belgium</option>\r\n                        <option value=\"Belize\">Belize</option>\r\n                        <option value=\"Benin\">Benin</option>\r\n                        <option value=\"Bermuda\">Bermuda</option>\r\n                        <option value=\"Bhutan\">Bhutan</option>\r\n                        <option value=\"Bolivia\">Bolivia</option>\r\n                        <option value=\"Bosnia and Herzegovina\">Bosnia and Herzegovina</option>\r\n                        <option value=\"Botswana\">Botswana</option>\r\n                        <option value=\"Bouvet Island\">Bouvet Island</option>\r\n                        <option value=\"Brazil\">Brazil</option>\r\n                        <option value=\"British Indian Ocean Territory\">British Indian Ocean Territory</option>\r\n                        <option value=\"Brunei Darussalam\">Brunei Darussalam</option>\r\n                        <option value=\"Bulgaria\">Bulgaria</option>\r\n                        <option value=\"Burkina Faso\">Burkina Faso</option>\r\n                        <option value=\"Burundi\">Burundi</option>\r\n                        <option value=\"Cambodia\">Cambodia</option>\r\n                        <option value=\"Cameroon\">Cameroon</option>\r\n                        <option value=\"Canada\">Canada</option>\r\n                        <option value=\"Cape Verde\">Cape Verde</option>\r\n                        <option value=\"Cayman Islands\">Cayman Islands</option>\r\n                        <option value=\"Central African Republic\">Central African Republic</option>\r\n                        <option value=\"Chad\">Chad</option>\r\n                        <option value=\"Chile\">Chile</option>\r\n                        <option value=\"China\">China</option>\r\n                        <option value=\"Christmas Island\">Christmas Island</option>\r\n                        <option value=\"Cocos (Keeling) Islands\">Cocos (Keeling) Islands</option>\r\n                        <option value=\"Colombia\">Colombia</option>\r\n                        <option value=\"Comoros\">Comoros</option>\r\n                        <option value=\"Congo\">Congo</option>\r\n                        <option value=\"Congo, The Democratic Republic of The\">Congo, The Democratic Republic of The</option>\r\n                        <option value=\"Cook Islands\">Cook Islands</option>\r\n                        <option value=\"Costa Rica\">Costa Rica</option>\r\n                        <option value=\"Cote D'ivoire\">Cote D'ivoire</option>\r\n                        <option value=\"Croatia\">Croatia</option>\r\n                        <option value=\"Cuba\">Cuba</option>\r\n                        <option value=\"Cyprus\">Cyprus</option>\r\n                        <option value=\"Czech Republic\">Czech Republic</option>\r\n                        <option value=\"Denmark\">Denmark</option>\r\n                        <option value=\"Djibouti\">Djibouti</option>\r\n                        <option value=\"Dominica\">Dominica</option>\r\n                        <option value=\"Dominican Republic\">Dominican Republic</option>\r\n                        <option value=\"Ecuador\">Ecuador</option>\r\n                        <option value=\"Egypt\">Egypt</option>\r\n                        <option value=\"El Salvador\">El Salvador</option>\r\n                        <option value=\"Equatorial Guinea\">Equatorial Guinea</option>\r\n                        <option value=\"Eritrea\">Eritrea</option>\r\n                        <option value=\"Estonia\">Estonia</option>\r\n                        <option value=\"Ethiopia\">Ethiopia</option>\r\n                        <option value=\"Falkland Islands (Malvinas)\">Falkland Islands (Malvinas)</option>\r\n                        <option value=\"Faroe Islands\">Faroe Islands</option>\r\n                        <option value=\"Fiji\">Fiji</option>\r\n                        <option value=\"Finland\">Finland</option>\r\n                        <option value=\"France\">France</option>\r\n                        <option value=\"French Guiana\">French Guiana</option>\r\n                        <option value=\"French Polynesia\">French Polynesia</option>\r\n                        <option value=\"French Southern Territories\">French Southern Territories</option>\r\n                        <option value=\"Gabon\">Gabon</option>\r\n                        <option value=\"Gambia\">Gambia</option>\r\n                        <option value=\"Georgia\">Georgia</option>\r\n                        <option value=\"Germany\">Germany</option>\r\n                        <option value=\"Ghana\">Ghana</option>\r\n                        <option value=\"Gibraltar\">Gibraltar</option>\r\n                        <option value=\"Greece\">Greece</option>\r\n                        <option value=\"Greenland\">Greenland</option>\r\n                        <option value=\"Grenada\">Grenada</option>\r\n                        <option value=\"Guadeloupe\">Guadeloupe</option>\r\n                        <option value=\"Guam\">Guam</option>\r\n                        <option value=\"Guatemala\">Guatemala</option>\r\n                        <option value=\"Guernsey\">Guernsey</option>\r\n                        <option value=\"Guinea\">Guinea</option>\r\n                        <option value=\"Guinea-bissau\">Guinea-bissau</option>\r\n                        <option value=\"Guyana\">Guyana</option>\r\n                        <option value=\"Haiti\">Haiti</option>\r\n                        <option value=\"Heard Island and Mcdonald Islands\">Heard Island and Mcdonald Islands</option>\r\n                        <option value=\"Holy See (Vatican City State)\">Holy See (Vatican City State)</option>\r\n                        <option value=\"Honduras\">Honduras</option>\r\n                        <option value=\"Hong Kong\">Hong Kong</option>\r\n                        <option value=\"Hungary\">Hungary</option>\r\n                        <option value=\"Iceland\">Iceland</option>\r\n                        <option value=\"India\">India</option>\r\n                        <option value=\"Indonesia\">Indonesia</option>\r\n                        <option value=\"Iran, Islamic Republic of\">Iran, Islamic Republic of</option>\r\n                        <option value=\"Iraq\">Iraq</option>\r\n                        <option value=\"Ireland\">Ireland</option>\r\n                        <option value=\"Isle of Man\">Isle of Man</option>\r\n                        <option value=\"Israel\">Israel</option>\r\n                        <option value=\"Italy\">Italy</option>\r\n                        <option value=\"Jamaica\">Jamaica</option>\r\n                        <option value=\"Japan\">Japan</option>\r\n                        <option value=\"Jersey\">Jersey</option>\r\n                        <option value=\"Jordan\">Jordan</option>\r\n                        <option value=\"Kazakhstan\">Kazakhstan</option>\r\n                        <option value=\"Kenya\">Kenya</option>\r\n                        <option value=\"Kiribati\">Kiribati</option>\r\n                        <option value=\"Korea, Democratic People's Republic of\">Korea, Democratic People's Republic of</option>\r\n                        <option value=\"Korea, Republic of\">Korea, Republic of</option>\r\n                        <option value=\"Kuwait\">Kuwait</option>\r\n                        <option value=\"Kyrgyzstan\">Kyrgyzstan</option>\r\n                        <option value=\"Lao People's Democratic Republic\">Lao People's Democratic Republic</option>\r\n                        <option value=\"Latvia\">Latvia</option>\r\n                        <option value=\"Lebanon\">Lebanon</option>\r\n                        <option value=\"Lesotho\">Lesotho</option>\r\n                        <option value=\"Liberia\">Liberia</option>\r\n                        <option value=\"Libyan Arab Jamahiriya\">Libyan Arab Jamahiriya</option>\r\n                        <option value=\"Liechtenstein\">Liechtenstein</option>\r\n                        <option value=\"Lithuania\">Lithuania</option>\r\n                        <option value=\"Luxembourg\">Luxembourg</option>\r\n                        <option value=\"Macao\">Macao</option>\r\n                        <option value=\"Macedonia, The Former Yugoslav Republic of\">Macedonia, The Former Yugoslav Republic of</option>\r\n                        <option value=\"Madagascar\">Madagascar</option>\r\n                        <option value=\"Malawi\">Malawi</option>\r\n                        <option value=\"Malaysia\">Malaysia</option>\r\n                        <option value=\"Maldives\">Maldives</option>\r\n                        <option value=\"Mali\">Mali</option>\r\n                        <option value=\"Malta\">Malta</option>\r\n                        <option value=\"Marshall Islands\">Marshall Islands</option>\r\n                        <option value=\"Martinique\">Martinique</option>\r\n                        <option value=\"Mauritania\">Mauritania</option>\r\n                        <option value=\"Mauritius\">Mauritius</option>\r\n                        <option value=\"Mayotte\">Mayotte</option>\r\n                        <option value=\"Mexico\">Mexico</option>\r\n                        <option value=\"Micronesia, Federated States of\">Micronesia, Federated States of</option>\r\n                        <option value=\"Moldova, Republic of\">Moldova, Republic of</option>\r\n                        <option value=\"Monaco\">Monaco</option>\r\n                        <option value=\"Mongolia\">Mongolia</option>\r\n                        <option value=\"Montenegro\">Montenegro</option>\r\n                        <option value=\"Montserrat\">Montserrat</option>\r\n                        <option value=\"Morocco\">Morocco</option>\r\n                        <option value=\"Mozambique\">Mozambique</option>\r\n                        <option value=\"Myanmar\">Myanmar</option>\r\n                        <option value=\"Namibia\">Namibia</option>\r\n                        <option value=\"Nauru\">Nauru</option>\r\n                        <option value=\"Nepal\">Nepal</option>\r\n                        <option value=\"Netherlands\">Netherlands</option>\r\n                        <option value=\"Netherlands Antilles\">Netherlands Antilles</option>\r\n                        <option value=\"New Caledonia\">New Caledonia</option>\r\n                        <option value=\"New Zealand\">New Zealand</option>\r\n                        <option value=\"Nicaragua\">Nicaragua</option>\r\n                        <option value=\"Niger\">Niger</option>\r\n                        <option value=\"Nigeria\">Nigeria</option>\r\n                        <option value=\"Niue\">Niue</option>\r\n                        <option value=\"Norfolk Island\">Norfolk Island</option>\r\n                        <option value=\"Northern Mariana Islands\">Northern Mariana Islands</option>\r\n                        <option value=\"Norway\">Norway</option>\r\n                        <option value=\"Oman\">Oman</option>\r\n                        <option value=\"Pakistan\">Pakistan</option>\r\n                        <option value=\"Palau\">Palau</option>\r\n                        <option value=\"Palestinian Territory, Occupied\">Palestinian Territory, Occupied</option>\r\n                        <option value=\"Panama\">Panama</option>\r\n                        <option value=\"Papua New Guinea\">Papua New Guinea</option>\r\n                        <option value=\"Paraguay\">Paraguay</option>\r\n                        <option value=\"Peru\">Peru</option>\r\n                        <option value=\"Philippines\">Philippines</option>\r\n                        <option value=\"Pitcairn\">Pitcairn</option>\r\n                        <option value=\"Poland\">Poland</option>\r\n                        <option value=\"Portugal\">Portugal</option>\r\n                        <option value=\"Puerto Rico\">Puerto Rico</option>\r\n                        <option value=\"Qatar\">Qatar</option>\r\n                        <option value=\"Reunion\">Reunion</option>\r\n                        <option value=\"Romania\">Romania</option>\r\n                        <option value=\"Russian Federation\">Russian Federation</option>\r\n                        <option value=\"Rwanda\">Rwanda</option>\r\n                        <option value=\"Saint Helena\">Saint Helena</option>\r\n                        <option value=\"Saint Kitts and Nevis\">Saint Kitts and Nevis</option>\r\n                        <option value=\"Saint Lucia\">Saint Lucia</option>\r\n                        <option value=\"Saint Pierre and Miquelon\">Saint Pierre and Miquelon</option>\r\n                        <option value=\"Saint Vincent and The Grenadines\">Saint Vincent and The Grenadines</option>\r\n                        <option value=\"Samoa\">Samoa</option>\r\n                        <option value=\"San Marino\">San Marino</option>\r\n                        <option value=\"Sao Tome and Principe\">Sao Tome and Principe</option>\r\n                        <option value=\"Saudi Arabia\">Saudi Arabia</option>\r\n                        <option value=\"Senegal\">Senegal</option>\r\n                        <option value=\"Serbia\">Serbia</option>\r\n                        <option value=\"Seychelles\">Seychelles</option>\r\n                        <option value=\"Sierra Leone\">Sierra Leone</option>\r\n                        <option value=\"Singapore\">Singapore</option>\r\n                        <option value=\"Slovakia\">Slovakia</option>\r\n                        <option value=\"Slovenia\">Slovenia</option>\r\n                        <option value=\"Solomon Islands\">Solomon Islands</option>\r\n                        <option value=\"Somalia\">Somalia</option>\r\n                        <option value=\"South Africa\">South Africa</option>\r\n                        <option value=\"South Georgia and The South Sandwich Islands\">South Georgia and The South Sandwich Islands</option>\r\n                        <option value=\"Spain\">Spain</option>\r\n                        <option value=\"Sri Lanka\">Sri Lanka</option>\r\n                        <option value=\"Sudan\">Sudan</option>\r\n                        <option value=\"Suriname\">Suriname</option>\r\n                        <option value=\"Svalbard and Jan Mayen\">Svalbard and Jan Mayen</option>\r\n                        <option value=\"Swaziland\">Swaziland</option>\r\n                        <option value=\"Sweden\">Sweden</option>\r\n                        <option value=\"Switzerland\">Switzerland</option>\r\n                        <option value=\"Syrian Arab Republic\">Syrian Arab Republic</option>\r\n                        <option value=\"Taiwan\">Taiwan</option>\r\n                        <option value=\"Tajikistan\">Tajikistan</option>\r\n                        <option value=\"Tanzania, United Republic of\">Tanzania, United Republic of</option>\r\n                        <option value=\"Thailand\">Thailand</option>\r\n                        <option value=\"Timor-leste\">Timor-leste</option>\r\n                        <option value=\"Togo\">Togo</option>\r\n                        <option value=\"Tokelau\">Tokelau</option>\r\n                        <option value=\"Tonga\">Tonga</option>\r\n                        <option value=\"Trinidad and Tobago\">Trinidad and Tobago</option>\r\n                        <option value=\"Tunisia\">Tunisia</option>\r\n                        <option value=\"Turkey\">Turkey</option>\r\n                        <option value=\"Turkmenistan\">Turkmenistan</option>\r\n                        <option value=\"Turks and Caicos Islands\">Turks and Caicos Islands</option>\r\n                        <option value=\"Tuvalu\">Tuvalu</option>\r\n                        <option value=\"Uganda\">Uganda</option>\r\n                        <option value=\"Ukraine\">Ukraine</option>\r\n                        <option value=\"United Arab Emirates\">United Arab Emirates</option>\r\n                        <option value=\"United Kingdom\">United Kingdom</option>\r\n                        <option value=\"United States\">United States</option>\r\n                        <option value=\"United States Minor Outlying Islands\">United States Minor Outlying Islands</option>\r\n                        <option value=\"Uruguay\">Uruguay</option>\r\n                        <option value=\"Uzbekistan\">Uzbekistan</option>\r\n                        <option value=\"Vanuatu\">Vanuatu</option>\r\n                        <option value=\"Venezuela\">Venezuela</option>\r\n                        <option value=\"Viet Nam\">Viet Nam</option>\r\n                        <option value=\"Virgin Islands, British\">Virgin Islands, British</option>\r\n                        <option value=\"Virgin Islands, U.S.\">Virgin Islands, U.S.</option>\r\n                        <option value=\"Wallis and Futuna\">Wallis and Futuna</option>\r\n                        <option value=\"Western Sahara\">Western Sahara</option>\r\n                        <option value=\"Yemen\">Yemen</option>\r\n                        <option value=\"Zambia\">Zambia</option>\r\n                        <option value=\"Zimbabwe\">Zimbabwe</option>\r\n                    </select>\r\n                </label>\r\n                <Tooltip tooltip={<div style={{padding: '10px', maxWidth: '600px'}}><h6>Email</h6>Your email address will be used for communication, notifications, and to identify you in the system, but it won’t be shared publicly without your consent.</div>} >\r\n                    <label>\r\n                        Email\r\n                        <input className={'w-100 input w-fit d-block mx-auto mt-2'}\r\n                            placeholder={'johndoe@mail.com'}\r\n                            value={email}\r\n                            onChange={e => setEmail(e.target.value)}\r\n                            type={'email'} name='email' autoComplete={'on'} required={true}\r\n                        />\r\n                    </label>\r\n                </Tooltip>\r\n                <br /><br /><br />\r\n                <label>\r\n                    Password\r\n                    <input className={'w-100 input w-fit d-block mx-auto mt-2'}\r\n                        placeholder={'password'}\r\n                        value={password}\r\n                        onChange={e => setPassword(e.target.value)}\r\n                        type={'password'} required={true}\r\n                    />\r\n                </label>\r\n\r\n\r\n                <label>\r\n                    Confirm Password\r\n                    <input className={'w-100 input w-fit d-block mx-auto mt-2'}\r\n                        placeholder={'confirm password'}\r\n                        value={passwordCheck}\r\n                        onChange={e => setPasswordCheck(e.target.value)}\r\n                        type={'password'} required={true}\r\n                    />\r\n                </label>\r\n\r\n                <br /><br /><br />\r\n                <Tooltip tooltip={<div style={{padding: '10px', maxWidth: '600px'}}><h6>Newsletter</h6>Select this option for remaining updated about Jjodel new releases, updates, and initiatives.</div>} >\r\n                    <label>\r\n                        <input className={'checkbox'}\r\n                            placeholder={'newsletter'}\r\n                            checked={newsletter}\r\n                            onChange={e => setNewsletter(e.target.checked)}\r\n                            type={'checkbox'}\r\n                            style={{outline: 'none', marginTop: '10px', float: 'left'}}\r\n                        />\r\n                        <div style={{display: 'block', width: '90%', float: 'left', marginBottom: '10px', paddingLeft: '10px'}}>Newsletter. Subscribe to the newsletter to receive updates and news. You can manage your registration preferences at any time. </div>\r\n                    </label>\r\n\r\n                </Tooltip>\r\n                <br />\r\n                <div style={{width: '100%', textAlign: 'center'}}>\r\n                    By proceeding you accept the terms and conditions.\r\n                </div>\r\n                <button className={'d-block btn btn-primary p-1 mx-auto mt-3 login-button'} type={'submit'}>\r\n                    Create\r\n                </button>\r\n            </>}\r\n\r\n            {action === 'login' &&\r\n\r\n            <>\r\n                {/* LOGIN */}\r\n                <label>\r\n                    Email\r\n                    <input className={'w-100 input w-fit d-block mx-auto mt-3'}\r\n                        placeholder={'e-mail'}\r\n                        value={email}\r\n                        onChange={e => setEmail(e.target.value)} type={'email'}\r\n                        required={true}\r\n                    />\r\n                </label>\r\n                <label>\r\n                    Password\r\n                    <input className={'w-100 input w-fit d-block mx-auto  mt-2'}\r\n                        placeholder={'password'}\r\n                        value={password}\r\n                        onChange={e => setPassword(e.target.value)}\r\n                        type={'password'}\r\n                        required={true}\r\n                />\r\n                </label>\r\n                <button className={'d-block btn btn-primary p-1 mx-auto mt-3 login-button'} type={'submit'}>\r\n                    Login\r\n                </button>\r\n                {(true || window.location.host.includes('localhost')) &&\r\n                    <button className={'d-block btn btn-primary p-1 mx-auto mt-3 login-button'} onClick={(e) => offline()}>Offline mode</button>\r\n                }\r\n            </>}\r\n\r\n            {action === 'retrieve-password' &&\r\n\r\n            <>\r\n                {/* RETRIEVE PASSWORD */}\r\n                <label>\r\n                    Enter your email\r\n                    <input className={'w-100 input w-fit d-block mx-auto mt-3'}\r\n                        placeholder={'e-mail'}\r\n                        value={email}\r\n                        onChange={e => setEmail(e.target.value)} type={'email'}\r\n                        required={true}\r\n                    />\r\n                </label>\r\n\r\n                <button className={'d-block btn btn-primary p-1 mx-auto mt-3 login-button'} type={'submit'}>\r\n                    Retrieve\r\n                </button>\r\n            </>}\r\n\r\n\r\n            <label className={'mt-3 d-block text-center'}>\r\n                {action === 'register' && <>Already have an account? <span tabIndex={-1} onClick={e => {setAction('login')}} className={'ms-1 text-primary text-decoration-none cursor-pointer login-link'}>Sign In</span></>}\r\n                {action === 'login' &&\r\n                    <>\r\n                        Don't have an account? <span tabIndex={-1} onClick={e => {setAction('register')}} className={'ms-1 text-primary text-decoration-none cursor-pointer login-link'}>Register</span><br/>\r\n                        <span tabIndex={-1} onClick={e => {setAction('retrieve-password')}} className={'ms-1 text-primary text-decoration-none cursor-pointer login-link'}>Forgot your password?</span>\r\n                    </>\r\n                }\r\n                {action === 'retrieve-password' &&\r\n                    <>\r\n                        Go back to the <span tabIndex={-1} onClick={e => {setAction('login')}} className={'ms-1 text-primary text-decoration-none cursor-pointer login-link'}>Sign In</span> page<br/>\r\n                        Don't have an account? <span tabIndex={-1} onClick={e => {setAction('register')}} className={'ms-1 text-primary text-decoration-none cursor-pointer login-link'}>Register</span><br/>\r\n                    </>\r\n                }\r\n\r\n            </label>\r\n            <div className='login-logo'><img src={logo}></img></div>\r\n        </form>\r\n    </section>);\r\n}\r\n\r\nexport {AuthPage};\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\Project.tsx",["895","896","897","898","899"],"import React, {Dispatch, ReactElement, useEffect,  useState} from 'react';\r\nimport {connect} from 'react-redux';\r\nimport {\r\n    CreateElementAction,\r\n    Dictionary,\r\n    DState,\r\n    DUser,\r\n    DViewElement, GObject,\r\n    LProject,\r\n    LUser,\r\n    LViewElement,\r\n    LViewPoint,\r\n    Pointer,\r\n    R,\r\n    Try,\r\n    U\r\n} from '../joiner';\r\nimport {FakeStateProps} from '../joiner/types';\r\nimport useQuery from '../hooks/useQuery';\r\nimport {ProjectsApi} from '../api/persistance';\r\nimport {SaveManager} from '../components/topbar/SaveManager';\r\nimport {Dashboard} from \"./components\";\r\nimport CollaborativeAttacher from \"../components/collaborative/CollaborativeAttacher\";\r\nimport {Cards} from './components/cards/Cards';\r\nimport Storage from \"../data/storage\";\r\nimport Loader from '../components/loader/Loader';\r\nimport {Navbar} from \"./components\";\r\nimport {CSS_Units} from \"../view/viewElement/view\";\r\nimport {useEffectOnce} from \"usehooks-ts\";\r\n\r\nfunction ProjectComponent(props: AllProps): JSX.Element {\r\n    const {user} = props;\r\n    const query = useQuery();\r\n    const id = query.get('id') || '';\r\n\r\n    useEffect(() => {\r\n        (async function() {\r\n            const project = await ProjectsApi.getOne(id); \r\n            if(!project) {\r\n                U.resetState();\r\n                R.navigate('/allProject');\r\n                return;\r\n            }\r\n            if(project.state) {\r\n                const state = JSON.parse(await U.decompressState(project.state));\r\n                state['idlookup'][DUser.current] = user.__raw;\r\n                if(!state['users'].includes(DUser.current)) state['users'].push(DUser.current);\r\n                SaveManager.load(state);\r\n            }\r\n\r\n            user.project = LProject.fromPointer(project.id);\r\n        })();\r\n    }, [id]);\r\n\r\n    let vparr = user?.project?.viewpoints || [];\r\n    let allViews = vparr.flatMap((vp: LViewPoint) => vp && vp.allSubViews);\r\n    allViews.push(...vparr as LViewElement[]);\r\n    allViews = allViews.filter(v => v);\r\n    const viewsDeDuplicator: Dictionary<Pointer<DViewElement>, LViewElement> = {};\r\n    for (let v of allViews) viewsDeDuplicator[v.id] = v;\r\n    if (!user?.project) {\r\n        return (\r\n            <div className={'w-100 h-100 d-flex'}>\r\n                <div className={'m-auto d-flex p-5'} style={{flexFlow: 'column', cursor:'pointer'}}onClick={(e) => R.navigate('/allProjects')}>\r\n                    <h4 className={'mx-auto'}>Project loading...</h4>\r\n                    <div className={'mx-auto'}>if it takes too long try refreshing the page, or click to go back</div>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n\r\n    return (<>\r\n        <Try>\r\n        <Dashboard active={'Project'} version={props.version} project={user.project}>\r\n            <React.Fragment>\r\n                <style id={\"views-css-injector-p\"}>\r\n                    {Object.values(viewsDeDuplicator).map(v => v.compiled_css).join('\\n\\n')}\r\n                </style>\r\n                {CSS_Units.jsx}\r\n\r\n                <Cards>\r\n                    {user.project.metamodels.length === 0 ?\r\n                        <Cards.Item\r\n                            title={'Your first metamodel ?'}\r\n                            subtitle={'Create a new metamodel.'}\r\n                            icon={'add'}\r\n                            style={'red'}\r\n                            action={() => {\r\n                                alert('new metamodel')\r\n                            }}\r\n                        />\r\n                        :\r\n                        <React.Fragment>\r\n                            <Cards.Item\r\n                                title={'Create another metamodel ?'}\r\n                                subtitle={'Create a new metamodel.'}\r\n                                icon={'add'}\r\n                                style={'red'}\r\n                                action={() => {\r\n                                    alert('another metamodel')\r\n                                }}\r\n                            />\r\n                            <Cards.Item\r\n                                title={'Create a model ?'}\r\n                                subtitle={'Create a new model.'}\r\n                                icon={'add'}\r\n                                style={'red'}\r\n                                action={() => {\r\n                                    alert('new model')\r\n                                }}\r\n                            />\r\n                        </React.Fragment>\r\n                    }\r\n                    <Cards.Item icon={'question'} style={'clear'} title={'Ehy!'}\r\n                                subtitle={'What do you want to do today?'}/>\r\n                </Cards>\r\n\r\n            </React.Fragment>\r\n        </Dashboard>\r\n        </Try>\r\n\r\n        {/*<Try><Dock /></Try>*/}\r\n        {user.project.type === 'collaborative' && <CollaborativeAttacher project={user.project}/>}\r\n    </>);\r\n\r\n}\r\n\r\ninterface OwnProps {\r\n}\r\n\r\ninterface StateProps {\r\n    user: LUser,\r\n    version: DState[\"version\"],\r\n}\r\ninterface DispatchProps {}\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as FakeStateProps;\r\n    ret.user = LUser.fromPointer(DUser.current);\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\nexport const ProjectConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(ProjectComponent);\r\n\r\nconst ProjectPage = (props: OwnProps, children: (string | React.Component)[] = []): ReactElement => {\r\n    return <ProjectConnected {...{...props, children}} />;\r\n}\r\n\r\nexport {ProjectPage};\r\n\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\Updates.tsx",["900","901"],"import {Dictionary, R, Try, windoww} from '../joiner';\r\nimport {Dashboard} from './components';\r\n\r\nimport {Cards, Card} from './components/cards/Cards';\r\nimport {Catalog} from './components/catalog/Catalog';\r\nimport {ReactNode, useState} from \"react\";\r\nimport \"./DashStyles/updates.scss\"\r\n\r\ntype keys = 'fix' | 'newbug' | 'opt' | 'feat' | 'info';\r\n\r\nclass InfoEntry {\r\n    constructor(public title: ReactNode, public content: ReactNode, public key: keys) {\r\n    }\r\n}\r\n\r\nclass Version {\r\n    static all: Version[] = [];\r\n    entries: Dictionary<keys, InfoEntry[]>;\r\n    majorEntries: InfoEntry[];\r\n    minorEntries: InfoEntry[];\r\n    _minor: boolean;\r\n    number: string;\r\n    name: string;\r\n    date: string;\r\n\r\n    constructor(number: string, name: string, date: string) {\r\n        this.number = number;\r\n        this.name = name;\r\n        this.date = date;\r\n        this.entries = {fix: [], newbug: [], opt: [], feat: [], info: []};\r\n        this.majorEntries = [];\r\n        this.minorEntries = [];\r\n        this._minor = false;\r\n        Version.all.push(this);\r\n    }\r\n\r\n    add(key: keys, title: ReactNode, node: ReactNode = null): this {\r\n        let entry = new InfoEntry(title, node, key);\r\n        this.entries[key].push(entry);\r\n        // if (this._minor) this.minorEntries.push(entry) else\r\n        this.majorEntries.push(entry);\r\n        return this;\r\n    }\r\n\r\n    fix(title: ReactNode, node: ReactNode = null): this {\r\n        this.add('fix', title, node);\r\n        return this;\r\n    }\r\n\r\n    newbug(title: ReactNode, node: ReactNode = null): this {\r\n        this.add('newbug', title, node);\r\n        return this;\r\n    }\r\n\r\n    opt(title: ReactNode, node: ReactNode = null): this {\r\n        this.add('opt', title, node);\r\n        return this;\r\n    }\r\n\r\n    feat(title: ReactNode, node: ReactNode = null): this {\r\n        this.add('feat', title, node);\r\n        return this;\r\n    }\r\n\r\n    engine(title: ReactNode, node: ReactNode = null): this {\r\n        this.add('feat', title, node);\r\n        return this;\r\n    }\r\n\r\n    info(title: ReactNode, node: ReactNode = null): this {\r\n        this.add('info', title, node);\r\n        return this;\r\n    }\r\n\r\n    minor(): this {\r\n        this._minor = true;\r\n        return this;\r\n    }\r\n}\r\n\r\nlet warnicon = <i className=\"bi bi-exclamation-triangle-fill\"/>\r\n// <i className=\"bi bi-exclamation-diamond-fill\" />;\r\n// <i className=\"bi bi-exclamation-square-fill\" />;\r\n\r\nfunction versionsetup() {\r\n    localStorage.setItem('_jj_update_date', '' + Math.min(Date.now(), new Date('2024-11-19').getTime()));\r\n    new Version('2.2', 'manatee', '19/nov/2024')\r\n        .newbug(<>{warnicon} Edges</>, <>Some update were made on edge's internal behaviour, old saves might have side effects.\r\n            If edges are not behaving properly create a new project, copy the default model's JSX and paste it in the old project.\r\n            <br/>To enable edits on default views right-click on the jjodel logo at the top-center of the page.\r\n            <br/>On custom views try to make start and end point to vertexes (draggable items) instead of fields (inline items).</>)\r\n        .feat('console tips', 'When hovering a console output or suggested keys a tooltip will show documentation.')\r\n        .fix('delete viewpoints', 'But cannot delete the active viewpoint.') // what if i delete a non-exclusive vp?\r\n        .fix('delete models')\r\n        .fix('containment & parent', 'Containment references were inconsistently updating the .parent property of contained elements.')\r\n        .feat('model dependencies', <>Models can now \"depend\" on other models in a extend-like style. if A depends on B\r\n            (A→B), A can use concepts from B.\r\n            <br/>Dependency chains (A→B→C) and loops (A→B, B→A) are also supported\r\n            <br/>Cross-reference activation is required too.</>)\r\n        .feat('cross-Reference', <>Cross-reference can be activated for: classes (inheritance), features (type).<br/>\r\n            To reduce cluttering in the options, normally you can only reference concepts in the same model.<br/>\r\n            If Cross-Reference is enabled you can reference valid concepts from all model dependencies.\r\n        </>)\r\n        .feat('context-menu containment', <>The option to add containment objects has been expanded, it is now available\r\n            to individual features too.</>)\r\n        .engine('data.validTargets (JDL Engine)', <>Can be used to create custom DSL and filtered to restrict model transformations, it\r\n            provides a list of valid targets for:\r\n            <ul>\r\n                <li>class extension</li>\r\n                <li>parameter, operation and m2-feature type</li>\r\n                <li>m1-values</li>\r\n                <li>model-dependencies</li>\r\n            </ul>\r\n        </>)\r\n        .minor()\r\n        .feat('U.clickedOutside()',\r\n            <>Utility for interactive graphs: When a click is detected outside the first parameter (HTMLElement or Event), it triggers a callback function in the first parameter.\r\n                <br/>\r\n                Example: {\"<div onClick={(evt)=>{data.$active=true; U.clickedOutside(evt, ()=>data.$active=false)}} ></div>\"} where\r\n                data is a m1-object holding a boolean feature \"active\"\r\n                {warnicon} To ensure the node is properly updated, remember to add \"Listed dependencies\" accordingly to\r\n                the value edited in the view.\r\n                <br/>In this example you need the dependency \"active = data.$active\" or equivalent ones.\r\n                <br/>Without it the value would update immediately but the graphical representation would always be 1 state behind.\r\n            </>)\r\n        .fix('structure editor', 'The layout was occasionally breaking')\r\n        .feat('changelog', 'Yes, this one. It deserved a mention.')\r\n}\r\n\r\nfunction UpdatesPage(): JSX.Element {\r\n    // NB: this works only in production if you put subfolders with past builds in the new build root.\r\n    let [info, setInfo] = useState(true);\r\n    let [feat, setFeat] = useState(true);\r\n    let [fix, setFix] = useState(true);\r\n    let [newbug, setNewbug] = useState(true);\r\n    let [opt, setOpt] = useState(false);\r\n    let [versionCollapse, setVersionCollapse] = useState({} as Dictionary<string, boolean>);\r\n\r\n    if (!Version.all.length) versionsetup();\r\n    let allowedDict: Dictionary<keys, boolean> = {info, feat, fix, newbug, opt};\r\n    let cards: ReactNode =\r\n        <Cards>\r\n            <Cards.Item\r\n                title={'Getting started'}\r\n                subtitle={'Create your first notation.'}\r\n                icon={'gettingstarted'}\r\n                style={'rainbow'}\r\n            />\r\n            {true && <Cards.Item icon={'question'} style={'clear'} title={'Ehy!'}\r\n                                 subtitle={'What do you want to do today?'}/>}\r\n        </Cards>;\r\n    cards = null;\r\n\r\n    return (<Try>\r\n        <Dashboard active={'Updates'} version={{n: 0, date: 'fake-date'}}>\r\n            <div id={'updates-page'}>{cards}\r\n                <h2>Past versions\r\n                    <select className={'ms-2'}\r\n                            onChange={(e) => R.navigate(e.target.value)}>\r\n                        <option value='/jjodel/2.2' title={'13/nov/2024'}>2.2</option>\r\n                        <option value='/jjodel/2.1' disabled>2.1</option>\r\n                        <option value='/jjodel/2.0' disabled>2.0</option>\r\n                    </select>\r\n                </h2>\r\n                <div className={'filter-container'}>\r\n                    <button className={'feat btn btn-' + (feat ? '' : 'outline-') + 'info'}\r\n                            onClick={e => setFeat(!feat)}>Feature\r\n                    </button>\r\n                    <button className={'fix btn btn-' + (fix ? '' : 'outline-') + 'success'}\r\n                            onClick={e => setFix(!fix)}>Bugfix\r\n                    </button>\r\n                    <button className={'newbug btn btn-' + (newbug ? '' : 'outline-') + 'danger'}\r\n                            onClick={e => setNewbug(!newbug)}>New known bug\r\n                    </button>\r\n                    <button className={'info btn btn-' + (info ? '' : 'outline-') + 'secondary'}\r\n                            onClick={e => setInfo(!info)}>Information\r\n                    </button>\r\n                    <button className={'opt btn btn-' + (opt ? '' : 'outline-') + 'warning'}\r\n                            onClick={e => setOpt(!opt)}>Optimization\r\n                    </button>\r\n                </div>\r\n                <ul className={'version-list'}>\r\n                    {Version.all.map(v=>\r\n                    <li className={'version'}>\r\n                        <h2 className={'version-name'} onClick={()=>{setVersionCollapse({...versionCollapse, [v.number]: !versionCollapse[v.number]})}}>{\r\n                            <i className={\"bi bi-chevron-\" + (!versionCollapse[v.number] ? 'up' : 'down')}/>\r\n                        } {v.number} {v.name} {v.date}\r\n                        </h2>\r\n                        {!versionCollapse[v.number] && <ul className={'entry-list'}>\r\n                            {v.majorEntries.map(e => {\r\n                                if (!allowedDict[e.key]) return null;\r\n                                return <li className={'entry ' + e.key}>\r\n                                    <span className={'title'}>{e.title}</span>\r\n                                    <span className={'content'}>{e.content}</span>\r\n                                </li>\r\n                            })\r\n                            }\r\n                        </ul>}\r\n                    </li>)\r\n                    }\r\n                </ul>\r\n            </div>\r\n        </Dashboard>\r\n    </Try>)\r\n        ;\r\n}\r\n\r\nexport {UpdatesPage};\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\Dashboard.tsx",["902"],"import {\r\n    Dictionary, DProject,\r\n    DState,\r\n    DUser,\r\n    DViewElement,\r\n    Input,\r\n    LPointerTargetable,\r\n    LProject,\r\n    LUser,\r\n    LViewElement,\r\n    LViewPoint,\r\n    Pointer,\r\n    SetFieldAction,\r\n    SetRootFieldAction,\r\n    U,\r\n    Try, TRANSACTION, L\r\n} from '../../joiner';\r\nimport {LeftBar, Navbar} from './';\r\n\r\nimport '../dashboard.scss'\r\nimport {ReactElement, useRef} from \"react\";\r\nimport {Btn, CommandBar, Sep} from '../../components/commandbar/CommandBar';\r\n\r\nimport colors from '../../static/img/colors.png';\r\nimport useQuery from '../../hooks/useQuery';\r\n\r\nimport {\r\n    TbSquareRoundedLetterM,\r\n    TbSquareRoundedLetterMFilled,\r\n    TbSquareRoundedLetterV,\r\n    TbSquareRoundedLetterVFilled,\r\n    TbSquareRoundedLetterE\r\n} from \"react-icons/tb\";\r\nimport DockManager from '../../components/abstract/DockManager';\r\nimport Dock from \"../../components/abstract/Dock\";\r\nimport {CSS_Units} from \"../../view/viewElement/view\";\r\nimport {useStateIfMounted} from 'use-state-if-mounted';\r\nimport { Tooltip } from '../../components/forEndUser/Tooltip';\r\nimport { ProjectsApi } from '../../api/persistance';\r\n\r\n\r\ntype UserProps = {\r\n    name: string;\r\n    initials: string;\r\n};\r\n\r\nconst User = (props: UserProps) => {\r\n    return (<>\r\n        <div className={'user'}>\r\n            <div className={'initials'}>{props.initials}</div>\r\n            <div className={'name'}><h2>{props.name}'s projects</h2></div>\r\n        </div>\r\n    </>);\r\n};\r\n\r\ntype TitleProps = {\r\n    projectID?: Pointer<DProject>;\r\n    active: string;\r\n    title: string;\r\n    icon: ReactElement;\r\n    description?: string;\r\n    type?: 'private'|'public'|'collaborative';\r\n}\r\n\r\n\r\nconst Title = (props: TitleProps) => {\r\n\r\n    let [title, setTitle] = useStateIfMounted(props.title);\r\n    let [description, setDescription] = useStateIfMounted(props.description);\r\n\r\n\r\n    const [editTitle, setEditTitle] = useStateIfMounted(false);\r\n    const [editDes, setEditDes] = useStateIfMounted(false);\r\n    //if (!editTitle && title !== props.title) setTitle(props.title);\r\n    //if (!editDes && description !== props.description) setDescription(props.description);\r\n\r\n    const titleRef = useRef();\r\n    const desRef = useRef();\r\n\r\n    const ProjectProperties = () => {\r\n\r\n        const server = 'http://app.jjodel.io';\r\n        const projectLink = '/#/project?id='+props.projectID;\r\n\r\n        function copyToClipboard(e: any) {\r\n            //const server = document.getElementById('server');\r\n            //const link = document.getElementById('link');\r\n            let full_link = server + projectLink;\r\n            console.log('copy to clipboard');\r\n            U.clipboardCopy(full_link, ()=>U.alert('i', \"Copied\", \"The project link has been copied to the Clipboard.\"));\r\n        }\r\n\r\n        let type = (props.type === \"public\");\r\n            return (<><label className='text-end nav-commands d-flex' \r\n                        style={{float: `${props.type === 'public' ? 'left': 'none'}`}}>\r\n                {props.type && <>\r\n                    <span className={\"my-auto me-1\"}>{props.type === \"public\" ? \"public\" : props.type === \"private\" ? \"private\" : \"collaborative\"}</span>\r\n                    \r\n                    {props.type !== \"collaborative\" && \r\n                        <Input type=\"toggle\"\r\n                            className={\"my-auto\"}\r\n                            style={{fontSize:'1.25em'}}\r\n                            setter={(v) => {\r\n                                if (!props.projectID) return;\r\n                                let project: LProject = L.fromPointer(props.projectID);\r\n                                project.type = v ? \"public\" : \"private\";\r\n                                if (v) U.alert('i', \"The project \"+title+\" is public\", \"It can be accessed only by those who have the public link.\");\r\n                            }}\r\n                            getter={() => type}\r\n                        />    \r\n                    }\r\n                </>\r\n                }\r\n            </label>\r\n            {props.type === \"public\" &&\r\n                <Tooltip tooltip={'Copy to Clipboard'} inline={true} position={'top'} offsetY={10}>\r\n                    <span onClick={(e) => copyToClipboard(e)}className={'project-link'}>\r\n                        <span id={'server'}>{server}</span><span id={'link'}>{projectLink}</span>\r\n                    </span>\r\n                </Tooltip>\r\n            }\r\n            </>\r\n            );\r\n        };\r\n\r\n        // <h2 onBlur={() => setEditTitle(!editTitle)} >\r\n\r\n        // function setTitle(e: any) {\r\n        //     if (title === '') {\r\n        //         U.alert('e', 'Title cannot be empty', 'Please enter a title for the project.');\r\n        //         e.target.focus();\r\n        //         return;\r\n        //     }\r\n        //     setProjectModified();\r\n        //     setEditTitle(!editTitle);\r\n        // }\r\n\r\n        // function setDescription(e: any) {\r\n\r\n        //     if (description === '') {\r\n        //         U.alert('e', 'Description cannot be empty', 'Please enter a description for the project.');\r\n        //         e.target.focus();\r\n        //         return;\r\n        //     }\r\n        //     setProjectModified();\r\n        //     setEditDes(!editDes);\r\n        // }\r\n\r\n        // function setPrivacy(e: any) {\r\n        //     setProjectModified();\r\n        // }\r\n\r\n\r\n\r\n    return (<>\r\n        <div className={'title'}>\r\n            {props.active === 'Project' ?\r\n                <div className={'project-list'}> {/* name */}\r\n                    {editTitle ?\r\n                        <h2>\r\n                            <div>\r\n                                {props.icon}\r\n                                <input\r\n                                    autoFocus\r\n                                    type={'text'}\r\n                                    value={title}\r\n                                    onChange={(e)=>setTitle(e.target.value)}\r\n                                    style={{padding: '0px', margin: '0'}}\r\n                                    onBlur={(e) => {\r\n                                        if (!props.projectID) return;\r\n                                        if (!e.target.value) {\r\n                                            U.alert('e', 'A Project Name is required.', 'Please provide a name to identify and organize your project effectively.');\r\n                                            e.target.focus();\r\n                                            return;\r\n                                        }\r\n                                        let project: LProject = L.fromPointer(props.projectID);\r\n                                        project.name = e.target.value;\r\n                                        setEditTitle(false);\r\n                                    }}\r\n                                />\r\n                            </div>\r\n                        </h2> :\r\n                        <>\r\n                        <Tooltip tooltip={'DoubleClick to edit'} inline={true} position={'left'} offsetX={10}>\r\n                            <h2 onDoubleClick={() => {setEditTitle(true)}}>\r\n                            {props.icon} {props.title}\r\n                        </h2></Tooltip>\r\n                         </>\r\n                    }\r\n                    <h6><ProjectProperties/></h6>\r\n                    \r\n                    {editDes ? \r\n                        <h3>\r\n                            <textarea\r\n                                autoFocus\r\n                                rows={4}\r\n                                cols={80}\r\n                                value={description}\r\n                                onChange={(e)=> {\r\n                                    console.log('onchange', {e, tv:e.target.value, pv:props.description, sv:description})\r\n                                    setDescription(e.target.value)\r\n                                }}\r\n                                onInput={(e)=> {\r\n                                    console.log('onInput', {e, tv:e.target, pv:props.description, sv:description})\r\n                                }}\r\n                                onBlur={e => {\r\n                                    if (!props.projectID) return;\r\n                                    if (!e.target.value) {\r\n                                        e.target.focus();\r\n                                        U.alert('e', 'A Project Description is required.', 'Adding a description helps provide clarity and context for your project.');\r\n                                        return;}\r\n                                    let project: LProject = L.fromPointer(props.projectID);\r\n                                    project.description = e.target.value;\r\n                                    setEditDes(false);\r\n                                }}\r\n                            />\r\n                        </h3>\r\n                        :\r\n                        <>\r\n                            {props.description && <Tooltip tooltip={'DoubleClick to edit'} inline={true} position={'left'} offsetX={10}>\r\n                                <h3 onDoubleClick={() => setEditDes(!editDes)}>{props.description}</h3>\r\n                            </Tooltip>}\r\n                        </>\r\n                    }\r\n                    \r\n                </div>\r\n                :\r\n                <div className={'header'}>\r\n                    <h2>{props.icon} {props.title}</h2>\r\n                    {props.description && <h3>{props.description}</h3>}\r\n                </div>\r\n            }\r\n        </div>\r\n    </>);\r\n};\r\n\r\n\r\nexport type DashProps = {\r\n    children?: JSX.Element,\r\n    className?: string;\r\n    // NB: account and profile are both used, i don't know which to keep\r\n    active: 'Account'|'Profile'|'Settings'|'Updates'|'Community'|'All'|'Archive'|'Templates'|'Recent' | 'Notes' | 'Project' | 'UsersInfo' | 'ProjectsInfo' | 'News';\r\n    version?: Partial<DState[\"version\"]>;\r\n    project?: LProject;\r\n    projects?:LProject[];\r\n    style?: any;\r\n};\r\n\r\n\r\ntype CatalogProps = {\r\n    children: any;\r\n}\r\n\r\nconst Catalog = (props: CatalogProps) => {\r\n\r\n    return props.children;\r\n};\r\n\r\ntype ProjectDashboardProps = {\r\n    children?: JSX.Element,\r\n    // NB: account and profile are both used, i don't know which to keep\r\n    active: 'Account'|'Profile'|'Settings'|'Updates'|'Community'|'All'|'Archive'|'Templates'|'Recent' | 'Notes' | 'Project';\r\n    version: Partial<DState[\"version\"]>;\r\n    project?: LProject;\r\n}\r\n\r\nfunction GenericDashboard(props: DashProps): any {\r\n    const {children, active} = props;\r\n    const user: LUser = LPointerTargetable.fromPointer(DUser.current);\r\n\r\n    return (<>\r\n        <Navbar />\r\n        <div className={\"dashboard-container\"} tabIndex={-1}>\r\n            <LeftBar active={active} projects={user?.projects}/>\r\n            <div className={`dash-content user ${props.style && props.style}`}>\r\n                <div>\r\n                    <>\r\n                        {active === \"All\" && <Title active={active} title={'Dashboard'} icon={<i className=\"bi bi-columns-gap\"></i>} />}\r\n                        {active === \"Recent\" && <Title  active={active} title={'Recent'} icon={<i className=\"bi bi-clock\"></i>} />}\r\n                        {active === \"Templates\" && <Title  active={active} title={'Templates'} icon={<i className=\"bi bi-lightbulb\"></i>} />}\r\n                        {active === \"Notes\" && <Title  active={active} title={'Project Notes'} icon={<i className=\"bi bi-pencil-square\"></i>} />}\r\n                        {active === \"Updates\" && <Title  active={active} title={'What\\'s new'} icon={<i className=\"bi bi-clock-history\"></i>} />}\r\n                        {active === \"Profile\" && <Title  active={active} title={'Profile'} icon={<i className=\"bi bi-clock-history\"></i>} />}\r\n                    </>\r\n                </div>\r\n                <Catalog children={children}/>\r\n            </div>\r\n        </div>\r\n    </>);\r\n}\r\n\r\ntype ProjectProps = {\r\n    project: LProject;\r\n}\r\n\r\nconst ProjectInfoCard = (props: ProjectProps) => {\r\n\r\n    const {project} = props;\r\n\r\n    /* to be refined */\r\n\r\n    return (\r\n        <div className={'details'}>\r\n            <>\r\n                <h5>{project.name ? project.name : 'Unnamed Project'}</h5>\r\n                {project.description && <p>{project.description}</p>}\r\n                <img src={colors} width={220} style={{paddingBottom: '10px'}}/>\r\n\r\n                {project.metamodels.length === 0 ?\r\n                    <p>This project does not contain any metamodel and consequently no models yet; it only contains the default viewpoints.</p>\r\n                    :\r\n                    <p>\r\n                    {project.metamodels.length === 1 && <>In this project, <b>one metamodel</b> is defined</>}\r\n                    {project.metamodels.length > 1 && <>In this project, <b>{project.metamodels.length} metamodels</b> are defined </>}\r\n                    {project.models.length === 0  ?\r\n                        <> and does not contain any model (it only includes the default viewpoints).</>\r\n                        :\r\n                        <>\r\n                        {project.models.length === 1  && <>, from which <b>one model</b> is instantiated. </>}\r\n                        {project.models.length > 1  && <>, from which <b>{project.models.length}</b> models are instantiated. </>}\r\n\r\n                        <>These models are explored and analyzed through <b>{project.viewpoints.length} viewpoints</b> (including the default ones), each offering a distinct perspective on different system concerns. </>\r\n                        </>\r\n                    }\r\n\r\n\r\n                    </p>\r\n                }\r\n            </>\r\n        </div>\r\n    );\r\n}\r\n\r\n/* Project Details / Project Summary */\r\n\r\nfunction ProjectCatalog(props: ProjectProps) {\r\n\r\n    const {project} = props;\r\n\r\n    return (<>\r\n        <ProjectInfoCard project={project} key={'info'} />\r\n        <div className={'row project-list'} key={'list'}>\r\n            <div className='row header' key={'header'}>\r\n                <div className={'col-4 '}>Name</div>\r\n                <div className={'col-2 artifact-type'}>Type</div>\r\n                <div className={'col-1'}>Operation</div>\r\n            </div>\r\n\r\n            {project.metamodels.map((mm) =>{\r\n                let name = mm.name\r\n                return (\r\n                <div className=\"row data\" key={name}>\r\n                    <div className={'col-4 '} onClick={async () => await DockManager.open2(mm)}>\r\n                        <TbSquareRoundedLetterMFilled style={{fontSize: '1.5em'}}/> {name}</div>\r\n                    <div className={'col-2 artifact-type'}>Metamodel</div>\r\n                    <div className={'buttons'}>\r\n                        <CommandBar noBorder={true} style={{marginBottom: '0'}}>\r\n                            <Btn icon={'open'} action={async () => await DockManager.open2(mm)}\r\n                                 tip={'Open metamodel'}/>\r\n                            <Btn icon={'minispace'}/>\r\n                            <Btn icon={'copy'} action={e => {\r\n                            }} tip={'Duplicate metamodel'}/>\r\n                            <Sep/>\r\n                            <Btn icon={'delete'} action={e => mm.delete()} tip={`Delete model \"${name}\"`}/>\r\n                        </CommandBar>\r\n                    </div>\r\n                </div>)\r\n            })\r\n            }\r\n            {project.models.map(model => {\r\n                let name = model.name;\r\n                return (\r\n                <div className=\"row data\" key={name}>\r\n                    <div className={'col-4 '} onClick={async () => await DockManager.open2(model)}>\r\n                        <TbSquareRoundedLetterM style={{fontSize: '1.5em'}}/> {name}</div>\r\n                    <div className={'col-2 artifact-type'}>Model</div>\r\n                    <div className={'buttons'}>\r\n                        <CommandBar noBorder={true} style={{marginBottom: '0'}}>\r\n                            <Btn icon={'open'} action={async () => await DockManager.open2(model)}\r\n                                 tip={'Open model'}/>\r\n                            <Btn icon={'minispace'}/>\r\n                            <Btn icon={'copy'} action={e => {\r\n                            }} tip={'Duplicate model'}/>\r\n                            <Sep/>\r\n                            <Btn icon={'delete'} action={e => model.delete()} tip={`Delete model \"${name}\"`}/>\r\n                        </CommandBar>\r\n                    </div>\r\n                </div>)\r\n            })\r\n            }\r\n            {project.viewpoints.map(vp => {\r\n                let name = vp?.name;\r\n                return (!vp ? <div key={name||'error_'+vp}>errorvp: {vp + ''}</div> :\r\n                    <div className=\"row data viewpoint\" key={name}>\r\n                        <div className={'col-4'}>{vp.isOverlay ?\r\n                            <TbSquareRoundedLetterVFilled style={{fontSize: '1.5em'}}/> :\r\n                            <TbSquareRoundedLetterV style={{fontSize: '1.5em'}}/>} {name}</div>\r\n                        <div className={'col-2 artifact-type'}>Viewpoint</div>\r\n                        <div className={'buttons'}>\r\n                            <CommandBar noBorder={true} style={{marginBottom: '0'}}>\r\n                                <Btn icon={'open'} tip={'Open viewpoint'} disabled={true}/>\r\n                                <Btn icon={'minispace'}/>\r\n                                <Btn icon={'copy'} action={e => vp.duplicate()} tip={'Duplicate viewpoint'}/>\r\n                                <Sep/>\r\n                                <Btn icon={'delete'} action={e => vp.delete()} tip={'Delete viewpoint'}\r\n                                     disabled={name === 'Default' || name === 'Validation default'}/>\r\n                            </CommandBar>\r\n                        </div>\r\n                    </div>)\r\n            })\r\n            }\r\n            <div className={'legenda'} key={'legenda'}>\r\n                <h1>Legenda</h1>\r\n                <div className={'row'}>\r\n                    <div className={'col'}>\r\n                        <TbSquareRoundedLetterMFilled style={{fontSize: '1.3em'}}/> Metamodels\r\n                    </div>\r\n                    <div className={'col'}>\r\n                        <TbSquareRoundedLetterM style={{fontSize: '1.3em'}}/> Models\r\n                    </div>\r\n                    <div className={'col'}>\r\n                        <TbSquareRoundedLetterVFilled style={{fontSize: '1.3em'}}/> Viewpoints\r\n                    </div>\r\n                    <div className={'col'}>\r\n                        <TbSquareRoundedLetterV style={{fontSize: '1.3em'}}/> Overlay Viewpoints\r\n                    </div>\r\n                    <div className={'col disabled'}>\r\n                        <TbSquareRoundedLetterE className={'disabled'} style={{fontSize: '1.3em'}}/> Epsilon Transformations\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    </>)}\r\n\r\n\r\nfunction ProjectDashboard(props: DashProps): any {\r\n\r\n    const {children, active} = props;\r\n    const user: LUser = LPointerTargetable.fromPointer(DUser.current);\r\n    const query = useQuery();\r\n    const id = query.get('id') || '';\r\n    const project: LProject = LProject.fromPointer(id);\r\n\r\n    let vparr = project?.viewpoints || [];\r\n    let allViews = vparr.flatMap((vp: LViewPoint) => vp && vp.allSubViews);\r\n    allViews.push(...vparr as LViewElement[]);\r\n    allViews = allViews.filter(v => v);\r\n    const viewsDeDuplicator: Dictionary<Pointer<DViewElement>, LViewElement> = {};\r\n    for (let v of allViews) viewsDeDuplicator[v.id] = v;\r\n\r\n    return (<>\r\n        <Try>\r\n            <>\r\n                <style id={\"views-css-injector-d\"}>\r\n                    {Object.values(viewsDeDuplicator).map(v => v.compiled_css).join('\\n\\n')}\r\n                </style>\r\n                {CSS_Units.jsx}\r\n            </>\r\n        </Try>\r\n        <Navbar />\r\n        <Try><Dock /></Try>\r\n    </>);\r\n}\r\n\r\nfunction Dashboard(props: DashProps): any {\r\n\r\n    return props.active === 'Project' ?\r\n            <ProjectDashboard {...props} className={(props.className||'') + ' bg'} /> :\r\n            <GenericDashboard {...props} />\r\n}\r\n\r\nexport {Dashboard, ProjectCatalog, Title};\r\n\r\n\r\n\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\LeftBar.tsx",["903"],"import { meanBy } from 'lodash';\r\nimport { useState, MouseEventHandler } from 'react';\r\nimport { IconTheme } from 'react-hot-toast';\r\nimport {DProject, DUser, L, LProject, LUser, R, SetRootFieldAction, U, windoww} from '../../joiner';\r\n\r\nimport { icon } from './icons/Icons';\r\nimport {DashProps} from \"./Dashboard\";\r\nimport Collaborative from \"../../components/collaborative/Collaborative\";\r\nimport {ProjectsApi} from \"../../api/persistance\";\r\nimport storage from \"../../data/storage\";\r\nimport { isProjectModified } from '../../common/libraries/projectModified';\r\nimport { Tooltip } from '../../components/forEndUser/Tooltip';\r\nimport {SaveManager} from \"../../components/topbar/SaveManager\";\r\nimport {Link, useNavigate} from \"react-router-dom\";\r\n\r\ninterface StateProps {\r\n    projects: LProject[];\r\n}\r\n\r\n\r\nexport type LeftBarProps = {\r\n    user?: LUser;\r\n    active: DashProps['active']; // prende il tipo dal parent-component, così si evita di aggiornare entrambi o avere tipi discordanti.\r\n    projects?: LProject[];\r\n    project?: LProject;\r\n\r\n};\r\n\r\n\r\ntype ItemProps = {\r\n    children: string;\r\n    icon?: any;\r\n    action?: string | MouseEventHandler;\r\n    dot?: boolean;\r\n    onClick?: MouseEventHandler\r\n};\r\n\r\nconst Item = (props: ItemProps) => {\r\n    let action: (e:any)=>any = props.action as any;\r\n    let navigate = useNavigate();\r\n    if (typeof action === 'string') action = (e => R.navigate(`/${props.action}`, navigate));\r\n    let finalaction = (e:any) =>{ props.onClick?.(e); action(e); }\r\n/*\r\n    let url: string = '';\r\n    if (typeof props.action === 'string') url = props.action;*/\r\n    return (<>\r\n\r\n        {/*<Link to={url} className={'item ' + (props.dot ? 'red-dot' : '')}>{props.icon && props.icon}&nbsp;{props.children}</Link>*/}\r\n            <div onClick={finalaction} className={'item ' + (props.dot ? 'red-dot' : '')}>\r\n                {props.icon && props.icon}&nbsp;<span>{props.children}</span>\r\n            </div>\r\n    </>);\r\n}\r\n\r\nconst Upload = () => {\r\n    return(<></>);\r\n    return(\r\n        <div className={'upload'}>\r\n            <i className=\"bi bi-arrow-up-circle\"></i>\r\n            <p>Drop your jjodel project archive here to import it.</p>\r\n        </div>\r\n    );\r\n};\r\n\r\ntype MenuProps = {\r\n    children: any;\r\n    title?: string;\r\n    mode?: \"collapsable\";\r\n    project?: boolean;\r\n};\r\n\r\nconst Menu = (props: MenuProps) => {\r\n    const [open,setOpen] = useState(true);\r\n\r\n    return (<>\r\n\r\n        {props.title && props.mode && open && <i className={'bi bi-chevron-down'} onClick={(e) => setOpen(!open)}></i>}\r\n        {props.title && props.mode && !open && <i className={'bi bi-chevron-right'} onClick={(e) => setOpen(!open)}></i>}\r\n        \r\n\r\n        <div className='menu border-bottom'>\r\n            {isProjectModified() && props.title ? <h1>{props.title} <i className=\"bi bi-circle-fill modified\"></i> </h1> : <h1> {props.title} </h1>}\r\n            <div>\r\n                {open && props.children}\r\n            </div>\r\n        </div>\r\n    </>);\r\n}\r\n\r\nconst Divisor = () => {\r\n    return (<hr className='my-1' />);\r\n};\r\n\r\nMenu.Item = Item;\r\n\r\nfunction LeftBar(props: LeftBarProps): JSX.Element {\r\n\r\n    // export type LeftBarProps = {\r\n    //     active: DashProps['active']; // prende il tipo dal parent-component, così si evita di aggiornare entrambi o avere tipi discordanti.\r\n    //     projects: LProject[];\r\n    //     project?: LProject;\r\n\r\n    // };\r\n\r\n    const {active, project} = props;\r\n    let user: LUser = props.user || L.fromPointer(DUser.current);\r\n\r\n    const selectProject= (project: LProject) => {\r\n        R.navigate(`/project?id=${project.id}`, true);\r\n        U.resetState();\r\n    };\r\n\r\n    const closeProject = () => {\r\n        function doclose(){\r\n            R.navigate('/allProjects', true);\r\n            Collaborative.client.off('pullAction');\r\n            Collaborative.client.disconnect();\r\n            SetRootFieldAction.new('collaborativeSession', false);\r\n            U.resetState();\r\n        }\r\n        /*\r\n        if (isProjectModified()) {\r\n            U.dialog('Close the project without saving?', 'close project', ()=>{\r\n                doclose();\r\n            })\r\n        }\r\n        else doclose();*/\r\n        doclose();\r\n    }\r\n    const toggleFavorite = async() => {\r\n        await ProjectsApi.favorite(project?.__raw as DProject);\r\n    };\r\n    const exportProject = async() => {\r\n        if(project) {\r\n            await ProjectsApi.save(project);\r\n            U.download(`${project?.name}.jjodel`, JSON.stringify(project?.__raw));\r\n        }\r\n    }\r\n\r\n    \r\n\r\n    return(<>\r\n\r\n        {active === 'Project' ?\r\n            <div className={'leftbar border-end border-light-subtle '}>\r\n\r\n                <i className=\"bi bi-search\"></i>\r\n                <input placeholder={'Search for anything'} type={'text'} name='search-text' />\r\n                {/* @ts-ignore */}\r\n                <Menu title={props.project.name ? props.project.name : 'Unnamed Project'} project>\r\n                    {/*<Item icon={icon['edit']}>Edit </Item>*/}\r\n                    <Item action={exportProject} icon={icon['download']}>Download</Item>\r\n                    {/*<Item icon={icon['duplicate']}>Duplicate </Item>*/}\r\n                    <Item action={toggleFavorite} icon={!project?.isFavorite ? icon['favorite'] : icon['favoriteFill']}>{!project?.isFavorite ? 'Add to favorites ' : 'Remove from favorites '}</Item>\r\n                    {/*<Item icon={icon['share']}>Public link </Item>*/}\r\n                    {/*<Item icon={icon['delete']}>Delete </Item>*/}\r\n                    <Item action={closeProject} icon={icon['close']}>Close project </Item>\r\n                </Menu>\r\n\r\n                {/* {props.projects.filter(p => p.favorite).length > 0 &&\r\n                    <Menu title={\"Starred\"} mode={'collapsable'}>\r\n                        {props.projects.filter(p => p.favorite).map(p => <Item icon={icon['folder']} action={e => selectProject()}>{p.name}</Item>)}\r\n                    </Menu>\r\n                } *//*}\r\n\r\n                { <Menu>\r\n                    <Item action={'templates'} icon={icon['template2']}>Templates</Item>\r\n                    <Item action={'notes'} icon={icon['edit']}>Notes</Item>\r\n                </Menu>}\r\n\r\n                <Menu title={'Support'} mode={'collapsable'}>\r\n                    <Item icon={icon['whats-new']}>What's newwew</Item>\r\n                    <Item icon={icon['getting-started']}>Getting started</Item>\r\n                    <Item icon={icon['manual']}>User guide</Item>\r\n                </Menu>*/\r\n                }\r\n\r\n            </div>\r\n            :\r\n            <div className={'leftbar border-end border-light-subtle '}>\r\n\r\n                <i className=\"bi bi-search\"></i>\r\n                <input placeholder={'Search for anything'} type={'text'} name='search-text' />\r\n\r\n\r\n                {user && user.email === 'admin@gmail.it' && <Menu title={'Administration'} mode={'collapsable'}>\r\n                    <Item action={'usersInfo'} icon={icon['profile']}>Users</Item>\r\n                    <Item action={'projectsInfo'} icon={icon['folder']}>Projects</Item>\r\n                    <Item action={'news'} icon={icon['manual']}>News</Item>\r\n                </Menu>}\r\n\r\n                <Menu>\r\n                    <Item action={'allProjects'} icon={icon['dashboard']}>All projects </Item>\r\n                </Menu>\r\n                {props.projects && props.projects.filter(p => p.isFavorite).length > 0 &&\r\n                    <Menu title={\"Starred\"} mode={'collapsable'}>\r\n                        {props.projects\r\n                            .filter(p => p.isFavorite)\r\n                            .map(p => \r\n                                <Item icon={icon['folder']} action={e => selectProject(p)}>{p.name}</Item>\r\n                            )\r\n                        }\r\n                    </Menu>\r\n                }\r\n\r\n                {props.projects && props.projects.filter(p => p.isFavorite).length > 0 &&\r\n                    <Menu title={\"Recent\"} mode={'collapsable'}>\r\n                        {props.projects\r\n                            .sort((a,b) => (b.lastModified > a.lastModified) ?  1 : -1)\r\n                            .slice(0,5)\r\n                            .map(p => <Item icon={icon['folder']} action={e => selectProject(p)}>{p.name}</Item>)}\r\n                    </Menu>\r\n                }\r\n                \r\n                <Menu title={'Support'} mode={'collapsable'}>\r\n                    {/* <Item action={'updates'} icon={icon['whats-new']}\r\n                          dot={+(localStorage.getItem('_jj_update_seen')||0)<+(localStorage.getItem('_jj_update_date')||Number.POSITIVE_INFINITY)}\r\n                          onClick={()=>localStorage.setItem('_jj_update_seen', ''+Date.now())}\r\n                    >What's new</Item>*/}\r\n                    <Item \r\n                        action={() => {R.navigate(\"https://www.jjodel.io/whats-new/\")}}\r\n                        icon={icon['whats-new']}\r\n                    >What's new</Item>\r\n                    <Item \r\n                        action={() => {R.navigate(\"https://www.jjodel.io/getting-started/\")}}\r\n                        icon={icon['getting-started']}\r\n                    >Getting started</Item>\r\n                    <Item \r\n                        action={() => {R.navigate(\"https://www.jjodel.io/manual/\")}}\r\n                        icon={icon['manual']}\r\n                    >User guide</Item>\r\n                </Menu>\r\n\r\n                <Upload />\r\n\r\n            </div>\r\n        }\r\n\r\n    </>)\r\n}\r\n\r\nexport {LeftBar};\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\Project.tsx",["904","905"],"import {DProject, LProject, R, U} from '../../joiner';\r\nimport React from \"react\";\r\n\r\nimport {ProjectsApi} from '../../api/persistance';\r\nimport {Divisor, Item, Menu} from './menu/Menu';\r\n\r\nimport card from '../../static/img/card.png';\r\nimport {icon} from './icons/Icons';\r\nimport {Btn, CommandBar, Sep} from '../../components/commandbar/CommandBar';\r\nimport { int } from '../../joiner/types';\r\n\r\nimport { \r\n    VscLock as Lock,\r\n    VscUnlock as UnLock,\r\n    VscBroadcast as Share\r\n} from \"react-icons/vsc\";\r\n\r\nimport { SlShare as Share2 } from \"react-icons/sl\";\r\nimport { Tooltip } from '../../components/forEndUser/Tooltip';\r\nimport { time } from 'console';\r\nimport { Logo } from '../../components/logo';\r\n\r\n\r\nfunction formatDate(lastModified: number){\r\n    \r\n    let timeago = Date.now() - lastModified;\r\n    let timeunit: string;\r\n    let sec = 1000;\r\n    let min = sec*60;\r\n    let hr = min*60;\r\n    let day = hr*24;\r\n    let week = day*7;\r\n    let month = day*24;\r\n    let year = day*365;\r\n\r\n    if (timeago < min) { timeago /= sec; timeunit = 'seconds'; }\r\n    else if (timeago >= min && timeago < hr) { timeago /= min; timeunit = 'minutes'; }\r\n    else if (timeago >= hr && timeago < day) { timeago /= hr; timeunit = 'hours'; }\r\n    else if (timeago >= day && timeago < week) { timeago /= day; timeunit = 'days'; }\r\n    else if (timeago >= week && timeago < month) { timeago /= week; timeunit = 'weeks'; }\r\n    else if (timeago >= month && timeago < year) { timeago /= month; timeunit = 'months'; }\r\n    else { timeago/= min; timeunit = 'years'; }\r\n\r\n    return Math.round(timeago) + ' ' + timeunit + ' ago';\r\n}\r\n\r\n\r\ntype Props = {\r\n    data: LProject;\r\n    mode?: string;\r\n    key: any;\r\n    index?: number; // a che serve? si può togliere?\r\n};\r\n\r\ntype ProjectTypeType = {\r\n    type: string;\r\n}\r\n\r\nfunction ProjectType(props: ProjectTypeType){\r\n    return (<>\r\n        {props.type === \"public\" && <i className=\"bi bi-unlock\"></i>}\r\n        {props.type === \"private\" && <i className=\"bi bi-lock\"></i>}\r\n        {props.type === \"collaborative\" && <i className=\"bi bi-diagram-3\"></i>}\r\n    </>);\r\n}\r\n\r\nfunction Project(props: Props): JSX.Element {\r\n    const {data} = props;\r\n\r\n    // const [favorite, setFavorite] = useState(false);\r\n\r\n    const toggleFavorite = async(project: LProject) => {\r\n        await ProjectsApi.favorite(project.__raw as DProject);\r\n    };\r\n    const selectProject = () => {\r\n        R.navigate(`/project?id=${data.id}`, true);\r\n        //U.resetState();\r\n    }\r\n    const exportProject = async() => {\r\n        // await ProjectsApi.save(data);\r\n        U.download(`${data.name}.jjodel`, JSON.stringify(data.__raw));\r\n    }\r\n    const deleteProject = async() => {\r\n        await ProjectsApi.delete(data);\r\n    }\r\n\r\n    const typeIcon = (type: string) => {\r\n    \r\n        var icon = <></>;\r\n\r\n        switch(type){\r\n            case 'public':\r\n                icon = <UnLock className={'type-icon'} style={{fontSize: '1.2em'}}/>;\r\n                break;\r\n            case 'private':\r\n                icon = <Lock className={'type-icon'} style={{fontSize: '1.2em'}}/>;\r\n                break;\r\n            case 'collaborative':\r\n                icon = <Share2 className={'type-icon'} style={{fontSize: '1.2em'}}/>;\r\n                break;\r\n        }\r\n\r\n        return(\r\n            icon\r\n        );\r\n    \r\n    \r\n    }\r\n\r\n    /* CARDS */\r\n\r\n    var sectionStyle = {\r\n        backgroundImage: `url(${card})`,\r\n        backgroundSize: 'contain'\r\n     }\r\n\r\n    type ProjectProps = {\r\n        project: LProject\r\n    }\r\n\r\n    const Empty = (props: ProjectProps) => {\r\n        return (<>\r\n            {props.project.metamodelsNumber == 0 && props.project.modelsNumber == 0 && <><i title=\"empty project\" className=\"bi bi-exclamation-circle\"></i> <span>Empty</span></>}\r\n            {/* {props.project.metamodels.length == 0 && props.project.models.length != 0 && <i style={{float: 'left'}} title=\"no models\" className=\"bi bi-circle-half\"></i>}\r\n            {props.project.metamodels.length != 0 && props.project.models.length != 0 && <i style={{float: 'left'}} title=\"artifacts present\" className=\"bi bi-circle-fill\"></i>}*/}\r\n        </>);\r\n    }\r\n\r\n    function ProjectCard(props: Props): JSX.Element {\r\n\r\n\r\n        function multiplicity(n: int, none: string, one: string, many: string){\r\n            if (n <= 0) return none;\r\n            if (n === 1) return n + ' ' + one;\r\n            if (n > 1) return n + ' ' + many;\r\n        }\r\n\r\n        function getClickedElement(e: any){\r\n\r\n            if(e.target.className === 'bi bi-star-fill' || e.target.className === 'bi bi-star' || e.target.className === 'bi bi-chevron-down' || e.target.className === 'item') {\r\n                return;\r\n            } else {\r\n                selectProject(); \r\n            }\r\n        }\r\n\r\n        return (\r\n            <Tooltip tooltip={`${props.data.type} project with ${multiplicity(props.data.metamodelsNumber,'no metamodels', 'metamodel', 'metamodels')}, \r\n                ${multiplicity(props.data.modelsNumber,'no models', 'model', 'models')}, \r\n                ${multiplicity(props.data.viewpointsNumber -2, 'no (custom) viewpoints', '(custom) viewpoint', '(custom) viewpoints')}` } position={'top'} offsetY={10} theme={'dark'} inline><div className={`project-card-v2 ${data.type}`} \r\n                onClick={e => getClickedElement(e)}>\r\n                <div className=\"project-actions d-flex\" style={{position: 'absolute', top: 10, right: 5}}>\r\n                    {data.isFavorite ? <i onClick={(e) => toggleFavorite(data)} className=\"bi bi-star-fill\" />\r\n                        :\r\n                        <i onClick={(e) => toggleFavorite(data)} className=\"bi bi-star\" />\r\n                    }\r\n                    \r\n                    <Menu>\r\n                            <Item icon={icon['new']} keystroke={'<i class=\"bi bi-command\"></i>'} action={e => {selectProject()}}>Open</Item>\r\n                            <Item icon={icon['duplicate']}>Duplicate</Item>\r\n                            <Item icon={icon['download']} action={e => exportProject()}>Download</Item>\r\n                            <Divisor />\r\n                            <Item icon={icon['favorite']} action={(e => toggleFavorite(data))}>{!data.isFavorite ? 'Add to favorites' : 'Remove from favorites'}</Item>\r\n                            <Divisor />\r\n                            <Item icon={icon['delete']} action={async e => await deleteProject()}>Delete</Item>\r\n                    </Menu>\r\n                </div>\r\n                <div className='header'>\r\n                    <Logo style={{fontSize: '2em', float: 'left', marginTop: '0px', marginBottom: '20px', marginRight: '10px'}}/>\r\n                    <h5 className={'d-block'} style={{cursor: 'pointer'}} onClick={e => selectProject()}>\r\n                        {data.name}\r\n                    </h5>\r\n                    <p className={'description'}>{data.description}</p>\r\n                    <div className={'last-updated'}>\r\n                        <div className='date'><i className=\"bi bi-clock-history\"></i> Last updated {formatDate(data.lastModified)}</div>\r\n                        \r\n                        <div className={'type'}>\r\n                            {data.type === 'public' && <UnLock className={'type-icon'} style={{fontSize: '1.2em', color: 'var(--bg-4)'}}/>}\r\n                            {data.type === 'private' && <Lock  className={'type-icon'} style={{fontSize: '1.2em', color: 'var(--bg-4)'}}/>} \r\n                            {data.type === 'collaborative' && <Share2 className={'type-icon'} style={{fontSize: '1.2em', color: 'var(--bg-4)'}}/>} \r\n                        </div>\r\n                    </div>                   \r\n                </div>\r\n            </div></Tooltip>);\r\n        }\r\n\r\n\r\n    /* LIST */\r\n\r\n    function ProjectList(props: Props): JSX.Element {\r\n\r\n        let timeago = Date.now() - data.lastModified;\r\n        let timeunit: string;\r\n        let sec = 1000;\r\n        let min = sec*60;\r\n        let hr = min*60;\r\n        let day = hr*24;\r\n        let week = day*7;\r\n        let month = day*24;\r\n        let year = day*365;\r\n\r\n        if (timeago < min) { timeago /= sec; timeunit = 'seconds'; }\r\n        else if (timeago >= min && timeago < hr) { timeago /= min; timeunit = 'minutes'; }\r\n        else if (timeago >= hr && timeago < day) { timeago /= hr; timeunit = 'hours'; }\r\n        else if (timeago >= day && timeago < week) { timeago /= day; timeunit = 'days'; }\r\n        else if (timeago >= week && timeago < month) { timeago /= week; timeunit = 'weeks'; }\r\n        else if (timeago >= month && timeago < year) { timeago /= month; timeunit = 'months'; }\r\n        else { timeago/= min; timeunit = 'years'; }\r\n\r\n\r\n        function timeConverter(UNIX_timestamp: int){\r\n            var a = new Date(UNIX_timestamp);\r\n            \r\n            const formattedDate2 = a.toISOString();\r\n\r\n            const formattedDate = new Intl.DateTimeFormat('en-US', {\r\n                day: '2-digit',\r\n                month: 'short', // \"long\" for full month name\r\n                year: 'numeric',\r\n                hour: '2-digit',\r\n                minute: '2-digit',\r\n                //second: '2-digit',\r\n                //fractionalSecondDigits: 3, // Includes milliseconds\r\n                //timeZone: 'UTC', // Optional, set the timezone\r\n              }).format(a);\r\n\r\n            return formattedDate;\r\n        }\r\n\r\n        return (<>\r\n            <div className=\"row data\">\r\n                \r\n                <div style={{paddingLeft: '15px'}} className={'col-4'} onClick={()=> {selectProject()}}>{data.name}</div>\r\n                <div className={'col-1'} onClick={()=> {selectProject()}}>{typeIcon(data.type)}</div>\r\n                <div className={'col-3'} onClick={()=> {selectProject()}}>{timeConverter(data.creation+0)}</div>\r\n                <div className={'col-2'} onClick={()=> {selectProject()}}>{Math.floor(timeago)} {timeunit} ago</div>\r\n                <div className={'col-2'}>\r\n                    <CommandBar noBorder={true} style={{marginBottom: '0'}}>\r\n                        <Btn icon={'favorite'} action={(e => toggleFavorite(data))} tip={!data.isFavorite ? 'Add to favorites' : 'Remove from favorites'} />\r\n                        <Btn icon={'minispace'} />\r\n                        <Btn icon={'copy'} action={e => props.data.duplicate()} tip={'Duplicate project'}/>\r\n                        <Btn icon={'minispace'} />\r\n                        <Btn icon={'download'} action={e => exportProject()} tip={'Download project'}/>\r\n                        <Sep />\r\n                        <Btn icon={'delete'} action={async e => await deleteProject()} tip={'Delete project'}/>\r\n                    </CommandBar>\r\n                </div>\r\n            </div>\r\n        </>);\r\n    }\r\n\r\n\r\n    return(<>\r\n        {props.mode === \"cards\" ?\r\n            <ProjectCard index={props.index} key={props.key} data={props.data} /> :\r\n            <ProjectList index={props.index}  key={props.key} data={props.data} />\r\n        }\r\n    </>);\r\n}\r\n\r\nexport {Project};\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\Navbar.tsx",["906"],"import './style.scss';\r\nimport './navbar.scss';\r\nimport {\r\n    Dictionary,\r\n    DModel,\r\n    DProject,\r\n    DState,\r\n    DUser,\r\n    Input,\r\n    Keystrokes,\r\n    L,\r\n    LGraph,\r\n    LModel,\r\n    LPackage,\r\n    LProject,\r\n    LUser,\r\n    Selectors,\r\n    SetRootFieldAction,\r\n    TRANSACTION,\r\n    store,\r\n    U,\r\n    R\r\n} from '../../joiner';\r\n\r\nimport {icon} from '../components/icons/Icons';\r\n\r\nimport {useNavigate} from 'react-router-dom';\r\n\r\nimport React, {Component, Dispatch, ReactElement, useState} from 'react';\r\nimport {FakeStateProps} from '../../joiner/types';\r\nimport {connect} from 'react-redux';\r\nimport {MetamodelPopup, ModelPopup} from './popups';\r\nimport {AuthApi, ProjectsApi} from '../../api/persistance';\r\nimport TabDataMaker from \"../../../src/components/abstract/tabs/TabDataMaker\";\r\nimport DockManager from \"../../../src/components/abstract/DockManager\";\r\n\r\nimport {Divisor, Item, Menu} from '../components/menu/Menu';\r\n\r\nimport Collaborative from \"../../components/collaborative/Collaborative\";\r\nimport { isProjectModified } from '../../common/libraries/projectModified';\r\nimport { AboutModal } from './about/About';\r\nimport { MetricsPanelManager } from '../../components/metrics/Metrics';\r\nimport Api from '../../data/api';\r\nimport {Undoredocomponent} from \"../../components/topbar/undoredocomponent\";\r\n\r\n\r\nlet windoww = window as any;\r\n\r\nfunction createM2(project: LProject) {\r\n    let name = 'metamodel_' + 1;\r\n    let names: string[] = Selectors.getAllMetamodels().map(m => m.name);\r\n    name = U.increaseEndingNumber(name, false, false, newName => names.indexOf(newName) >= 0);\r\n    const dModel = DModel.new(name, undefined, true);\r\n    const lModel: LModel = LModel.fromD(dModel);\r\n    project.metamodels = [...project.metamodels, lModel];\r\n    project.graphs = [...project.graphs, lModel.node as LGraph];\r\n    const dPackage = lModel.addChild('package');\r\n    const lPackage: LPackage = LPackage.fromD(dPackage);\r\n    lPackage.name = 'default';\r\n    const tab = TabDataMaker.metamodel(dModel);\r\n    DockManager.open('models', tab);\r\n}\r\n\r\nconst createM1 = (project: LProject, metamodel: LModel) => {\r\n    let name = 'model_' + 1;\r\n    let modelNames: (string)[] = metamodel.models.map(m => m.name);\r\n    name = U.increaseEndingNumber(name, false, false, newName => modelNames.indexOf(newName) >= 0);\r\n    const dModel: DModel = DModel.new(name, metamodel.id, false, true);\r\n    const lModel: LModel = LModel.fromD(dModel);\r\n    project.models = [...project.models, lModel];\r\n    project.graphs = [...project.graphs, lModel.node as LGraph];\r\n    const tab = TabDataMaker.model(dModel);\r\n    DockManager.open('models', tab);\r\n}\r\nfunction getKeyStrokes(keys?: string[]){\r\n    if (!keys || !keys.length) return undefined;\r\n    return <div className={\"keystrokes\"}>\r\n        {keys.map(k => Keystrokes.getKeystrokeJsx(k))}\r\n    </div>\r\n}\r\n\r\nlet globalProject: LProject|undefined = undefined as any;\r\nfunction makeEntry(i: MenuEntry, index: number) {\r\n    if (!i) return;\r\n    let isUndo = (i.name === \"Undo\" || i.name === \"Redo\");\r\n    // if (true as any) return <li >{i.name}</li>;\r\n\r\n    if (i.name === \"Redo\") { return null; }\r\n    if (i.name === \"Undo\") {\r\n        if (!globalProject) return null;\r\n        return <Undoredocomponent key={'undo'} project={globalProject} />\r\n    }\r\n    if (i.name === \"divisor\") {\r\n        return (\r\n            <li key={index} className='divisor'>\r\n                <hr />\r\n            </li>\r\n        );\r\n    } else {\r\n        if (i.subItems && i.subItems.length === 0) return undefined;\r\n        let slength = i.subItems ? i.subItems.length : 0;\r\n\r\n        let hasSubItems = (!i.disabled && slength > 0) || isUndo;\r\n\r\n        return (\r\n            <li className={hasSubItems ? \"hoverable\" : \"\"} key={i.name} tabIndex={0} onClick={()=>i.function?.()}>\r\n                <label className={`highlight ${i.disabled ? 'disabled' : ''}`}>\r\n                    <span>{i.icon || <i className=\"bi bi-app hidden\"/>} <span>{i.name}</span></span>\r\n                    {!i.disabled && slength > 0 ?\r\n                        <i className='bi bi-chevron-right icon-expand-submenu'/> :\r\n                        getKeyStrokes(i.keystroke)\r\n                    }\r\n                </label>\r\n            {hasSubItems &&\r\n                <div className='content right'>\r\n                    <ul className='context-menu right'>\r\n                        {i.subItems && i.subItems.map((si, index) => makeEntry(si, index))}\r\n                    </ul>\r\n                </div>\r\n            }\r\n            </li>\r\n        );\r\n    }\r\n}\r\n\r\n\r\n\r\ntype UserProps = {}\r\nconst User = (props: UserProps) => {\r\n    const user: LUser = LUser.fromPointer(DUser.current);\r\n    const name = `${user?.name} ${user?.surname}`;\r\n    const initials = name.split(' ').map(n=>n[0]).join('');\r\n    return (<div className={'user text-end'}>\r\n        <div className={'initials'}>\r\n            {initials.toUpperCase()}\r\n        </div>\r\n        &nbsp;&nbsp;\r\n        <span>{name}</span>\r\n    </div>);\r\n};\r\n\r\ntype MenuEntry = {\r\n    name: string,\r\n    icon?: any,\r\n    function?: ()=>any,\r\n    keystroke?: string[],\r\n    subItems?:MenuEntry[],\r\n    disabled?: boolean;\r\n} | null;\r\n\r\nfunction NavbarComponent(props: AllProps) {\r\n    const {version, metamodels, advanced, debug, project} = props;\r\n    const [focussed, setFocussed] = useState('');\r\n    const [clicked, setClicked] = useState('');\r\n    const navigate = useNavigate();\r\n    globalProject = project;\r\n\r\n    const open = (url: string) => { window.open(url, '_blank'); }\r\n\r\n    const Key = Keystrokes;\r\n    let projectItems2: MenuEntry[] = [];\r\n\r\n    if (project){\r\n        projectItems2 = [\r\n\r\n            /* New Metamodel */\r\n\r\n            {name: 'New metamodel', icon: icon['new'], function: () => createM2(project), keystroke: [Key.alt, Key.cmd, 'M']},\r\n\r\n            /* New Model */\r\n            {\r\n                name: 'New model',\r\n                icon: icon['new'],\r\n                subItems: project.metamodels.filter(m2=>!!m2).map((m2, i)=>({\r\n                    name: m2.name, function: () => createM1(project, m2), keystroke: []\r\n                })),\r\n                disabled: project.metamodels.length == 0\r\n            },\r\n\r\n            /* ----- */\r\n\r\n            {name: 'divisor', function: () => {}, keystroke: []},\r\n\r\n            /* Close */\r\n\r\n            {name: 'Close', icon: icon['close'], function: () => {\r\n                if (isProjectModified()) {\r\n                    U.dialog('Close the project without saving?', 'close project', ()=>{\r\n                        R.navigate('/allProjects');\r\n                        Collaborative.client.off('pullAction');\r\n                        Collaborative.client.disconnect();\r\n                        SetRootFieldAction.new('collaborativeSession', false);\r\n                        U.resetState();\r\n                    });\r\n                } else {\r\n                    R.navigate('/allProjects');\r\n                    Collaborative.client.off('pullAction');\r\n                    Collaborative.client.disconnect();\r\n                    SetRootFieldAction.new('collaborativeSession', false);\r\n                    U.resetState();\r\n                }\r\n            }, keystroke: [Key.cmd, 'W']},\r\n\r\n            /* ----- */\r\n\r\n            {name: 'divisor', function: () => {}, keystroke: []},\r\n\r\n            /* Save & Close */\r\n\r\n            {name: 'Save & Close', icon: icon['close'], function: async () => {\r\n                if (isProjectModified()) {\r\n                    await ProjectsApi.save(project);\r\n                }\r\n\r\n                R.navigate('/allProjects');\r\n                Collaborative.client.off('pullAction');\r\n                Collaborative.client.disconnect();\r\n                SetRootFieldAction.new('collaborativeSession', false);\r\n                U.resetState();\r\n            }, keystroke: []},\r\n\r\n            /* Save */\r\n\r\n            {name: 'Save', icon: icon['save'], function: async() => {\r\n                await ProjectsApi.save(project);\r\n            }, keystroke: [Key.cmd, 'S']},\r\n\r\n\r\n\r\n            /* Download */\r\n\r\n            {name: 'Download', icon: icon['download'], function: async() => {\r\n                await ProjectsApi.save(project);\r\n                U.download(`${project.name}.jjodel`, JSON.stringify(project.__raw));\r\n            }, keystroke: []},\r\n\r\n\r\n\r\n            /* ----- */\r\n\r\n            {name: 'divisor', function: () => {}, keystroke: []},\r\n\r\n            /* Help */\r\n\r\n            {name: 'Help', icon: icon['help'], subItems: [\r\n                {name: 'What\\'s new', icon: icon['whats-new'], function: async() => {R.navigate(\"https://www.jjodel.io/whats-new/\")}, keystroke: []},\r\n                {name: 'divisor', function: async() => {}, keystroke: []},\r\n                {name: 'Homepage', icon: icon['home'], function: async() => {R.navigate(\"https://www.jjodel.io/\")}, keystroke: []},\r\n                {name: 'Getting started', icon: icon['getting-started'], function: async() => {R.navigate(\"https://www.jjodel.io/getting-started/\")}, keystroke: []},\r\n                {name: 'User guide', icon: icon['manual'], function: async() => {R.navigate(\"https://www.jjodel.io/manual/\")}, keystroke: []},\r\n                {name: 'divisor', function: async() => {}, keystroke: []},\r\n                {name: 'Legal terms', icon: icon['legal'], function: async() => {R.navigate(\"https://www.jjodel.io/terms-conditions-page/\")}, keystroke: []}\r\n            ],\r\n            keystroke: []}\r\n        ];\r\n    }\r\n\r\n    const dashboardItems2: MenuEntry[] = [\r\n\r\n        {name: 'New project', icon: <i className=\"bi bi-plus-square\"></i>, function:\r\n            async()=>{\r\n                R.navigate('/allProjects');\r\n                await ProjectsApi.create('public', undefined, undefined, undefined, props.user?.projects);\r\n                /*\r\n                SetRootFieldAction.new('isLoading', true);\r\n                await U.sleep(1);\r\n                await ProjectsApi.create('public', 'Unnamed Project');\r\n                SetRootFieldAction.new('isLoading', false);*/\r\n            },\r\n            keystroke: [Key.cmd, 'M']},\r\n            {name: 'divisor', function: () => {}, keystroke: []},\r\n\r\n        {name: 'Import...', icon: <i className=\"bi bi-arrow-bar-left\"></i>, function: ProjectsApi.import, keystroke: []},\r\n        {name: 'divisor', function: () => {}, keystroke: []},\r\n        {name: 'Help', icon: <i className=\"bi bi-question-square\"></i>, subItems: [\r\n            {name: 'What\\'s new', icon: <i className=\"bi bi-clock\"></i>, function: () => {R.navigate(\"https://www.jjodel.io/whats-new/\", navigate)}, keystroke: []},\r\n            {name: 'divisor', function: () => {}, keystroke: []},\r\n            {name: 'Homepage', icon: <i className=\"bi bi-house\"></i>, function: () => {R.navigate(\"https://www.jjodel.io/\", navigate)}, keystroke: []},\r\n            {name: 'Getting started', icon: <i className=\"bi bi-airplane\"></i>, function: () => {R.navigate(\"https://www.jjodel.io/getting-started/\", navigate)}, keystroke: []},\r\n            {name: 'User guide', icon: <i className=\"bi bi-journals\"></i>, function: () => {R.navigate(\"https://www.jjodel.io/manual/\", navigate)}, keystroke: []},\r\n            {name: 'divisor', function: () => {}, keystroke: []},\r\n            {name: 'Legal terms', icon: <i className=\"bi bi-mortarboard\"></i>, function: () => {R.navigate(\"https://www.jjodel.io/terms-conditions-page/\", navigate)}, keystroke: []}\r\n        ],\r\n        keystroke: []},\r\n\r\n        {name: 'About jjodel', icon: <i className=\"bi bi-info-square\"></i>, function: () => {}, keystroke: []},\r\n        {name: 'divisor', function: () => {}, keystroke: []},\r\n        {name: 'Logout', icon: <i className=\"bi bi-box-arrow-right\"></i>, function: async() => {\r\n                await AuthApi.logout();\r\n                R.navigate('/auth', true);\r\n            }, keystroke: [Key.cmd, 'Q']}\r\n    ];\r\n\r\n\r\n\r\n    /* -- */\r\n\r\n    const recentProjects: MenuEntry[] = [];\r\n    const recentProjectsDisabled: MenuEntry[] = [];\r\n    let user: LUser = L.fromPointer(DUser.current); // props.user || L.fromPointer(DUser.current);\r\n\r\n\r\n\r\n    /*\r\n\r\n        The following is used for toggling fullscreen mode from the View menu\r\n\r\n    */\r\n\r\n    const [fullscreen, setFullscreen] = useState(false);\r\n\r\n    function isFullscreen() {\r\n        return fullscreen;\r\n    }\r\n\r\n    function toggleFullScreen() {\r\n        const elem = document.body;\r\n        setFullscreen(U.toggleFullscreen(elem));\r\n    }\r\n\r\n    /*\r\n\r\n        An error occurs in 'Recent projects' when a project is selected, then is saved - at this points all projects in user.projects are lost\r\n\r\n    */\r\n\r\n    /* retrieve all projects */\r\n\r\n    // if (user.projects[0]) {\r\n    //     localStorage.setItem('projects', JSON.stringify(user.projects));\r\n    //     let projects = user.projects;\r\n    // } else {\r\n    //     let projects = JSON.parse(localStorage.getItem('projects') || '[]');\r\n    // }\r\n\r\n\r\n    /* -- */\r\n\r\n    if (user?.projects) {\r\n\r\n        user.projects\r\n            .sort((a,b) => (b.lastModified > a.lastModified) ?  1 : -1)\r\n            .slice(0,20)\r\n            .map(p =>\r\n                recentProjects.push({name: p.name, function: ()=>{alert(p.name)}, icon: icon['project']})\r\n            );\r\n\r\n        user.projects\r\n            .sort((a,b) => (b.lastModified > a.lastModified) ?  1 : -1)\r\n            .slice(0,20)\r\n            .map(p =>\r\n                recentProjectsDisabled.push({name: p.name, function: ()=>{alert(p.name)}, icon: icon['project'], disabled: true})\r\n            );\r\n    }\r\n\r\n    let newModel: MenuEntry[] = [];\r\n\r\n    if (project && project.metamodels.length > 0) {\r\n        newModel.push({\r\n            name: 'Model',\r\n            icon: icon['model'],\r\n            subItems: project.metamodels.filter(m2=>!!m2).map((m2, i)=>({\r\n                name: m2.name, function: () => createM1(project, m2), keystroke: []\r\n            }))\r\n        });\r\n    } else {\r\n        newModel.push({\r\n            name: 'Model',\r\n            icon: icon['model'],\r\n            disabled: true\r\n        });\r\n    }\r\n\r\n\r\n    const isDashboard = !project;\r\n    const isProject = !!project;\r\n\r\n    const items: MenuEntry[] = [\r\n\r\n        // Jjodel OK\r\n\r\n        {name: 'Jjodel',\r\n            subItems: [\r\n                {name: 'About Jjodel',function: () => {AboutModal.open();}, icon: icon['jjodel']},\r\n                {name: 'Roadmap',function: () => open('https://www.jjodel.io/roadmap/'), icon: icon['roadmap']},\r\n                {name: 'divisor'},\r\n\r\n                {name: 'Settings', function: ()=> alert(), icon: icon['settings'], disabled: true}, // TO-DO\r\n                {name: 'divisor'},\r\n                {name: 'Logout', function: async() => {\r\n                        if (isProjectModified()) {\r\n                            U.dialog('You are about to log out without saving your project. Do you want to proceed?', 'logout', async ()=>{\r\n                                await AuthApi.logout();\r\n                                R.navigate('/auth');\r\n                            });\r\n                        } else {\r\n                            await AuthApi.logout();\r\n                            R.navigate('/auth');\r\n                        }},\r\n                    icon: icon['logout']}\r\n            ]},\r\n\r\n        /* File */\r\n\r\n        {name: 'File',\r\n            subItems: [\r\n                {name: 'New',function: () => {}, icon: icon['new'],\r\n                    subItems: [\r\n                        {name: 'Project', function: () => {}, icon: icon['project'], disabled: true},\r\n                        isDashboard ? null : {name: 'Metamodel', icon: icon['metamodel'], function: ()=>{ project && createM2(project); }, keystroke: [Key.alt, Key.cmd, 'M']},\r\n                        isDashboard ? null : newModel[0]\r\n                    ]\r\n                },\r\n                /* Recent Projects OK - va sistemato il refersh dei progetti */\r\n                {name: 'Recent Projects',function: () => {}, icon: icon['recent'], subItems: recentProjects},\r\n\r\n                /* Import Project OK */\r\n                isProject ? null : {name: 'Import Project', function: ProjectsApi.import, icon: icon['import']},\r\n                {name: 'divisor'},\r\n\r\n                /* Save Project OK */\r\n\r\n                isDashboard ? null : {name: 'Save Project',\r\n                    function: async () => {\r\n                        if (project) {\r\n                            try {\r\n                                await ProjectsApi.save(project);\r\n                            } catch (error: any) {\r\n                                U.alert('e', 'Error while Saving Project', error.message);\r\n                            }\r\n                        }\r\n                    }\r\n                    , icon: icon['save'], keystroke: [Key.cmd, 'S']},\r\n\r\n                /* Close Project OK */\r\n\r\n                isDashboard ? null : {name: 'Close Project',function: async() => {\r\n                        if (isProjectModified()) {\r\n                            U.dialog('Close the project without saving?', 'close project', async()=>{\r\n                                Collaborative.client.off('pullAction');\r\n                                await Collaborative.client.disconnect();\r\n                                SetRootFieldAction.new('collaborativeSession', false);\r\n                                U.resetState();\r\n                                R.navigate('/allProjects', true);\r\n                            });\r\n                        } else {\r\n                            Collaborative.client.off('pullAction');\r\n                            await Collaborative.client.disconnect();\r\n                            SetRootFieldAction.new('collaborativeSession', false);\r\n                            U.resetState();\r\n                            R.navigate('/allProjects', true);\r\n                        }\r\n                    }, icon: icon['close'], keystroke: [Key.cmd, 'E']},\r\n\r\n                /* Delete Project - vedere come fare  TEMPORARLY DISABLED */\r\n                true as any ? null : {name: 'Delete Project', function: ()=>{}, icon: icon['delete'], disabled: true},\r\n\r\n                /* Download Project OK */\r\n\r\n                isDashboard ? null : {name: 'Download Project', function: async() => {\r\n                        if (project) {\r\n                            await ProjectsApi.save(project);\r\n                            U.download(`${project.name}.jjodel`, JSON.stringify(project.__raw));\r\n                        }\r\n                    }, icon: icon['download']}\r\n            ]},\r\n\r\n        /* Edit: Damiano aggiungere funzioni undo/redo */\r\n\r\n        isDashboard ? null : {name: 'Edit',\r\n            subItems: [\r\n                {name: 'Undo',function: () => {}, icon: icon['undo'], keystroke: [Key.cmd, 'Z']},\r\n                {name: 'Redo',function: () => {}, icon: icon['redo'], keystroke: [Key.cmd, 'Y'], subItems:[{name:\"i\"}]},\r\n                /*\r\n                {name: 'Undo',function:()=>{undo(1)}, disabled:disabledUndo, icon: icon['undo'],\r\n                    keystroke: [Key.cmd, 'Z'], subItems:hoverUndo},\r\n                {name: 'Redo',function:()=>{redo(1)}, disabled:disabledRedo, icon: icon['redo'],\r\n                    keystroke: [Key.shift, Key.cmd, 'Z'], subItems:hoverRedo},\r\n                */\r\n                {name: 'divisor'},\r\n                {name: 'Add to Favorites', function: () => {}, icon: icon['favorite']}, // vedere in leftbar // TODO\r\n                {name: 'Copy Public Link', function: () =>{}, icon: icon['link'], keystroke: [Key.cmd, Key.shift, 'S']} // vedere in scheda progetto // TODO\r\n            ]\r\n        },\r\n\r\n        /* View - da fare */\r\n        isDashboard ? null : {name: 'View',\r\n            subItems: [\r\n                {name: 'Zoom-in', function: ()=>{}, icon: icon['zoom-in'], disabled: true}, // TODO\r\n                {name: 'Zoom-out', function: ()=>{}, icon: icon['zoom-out'], disabled: true}, // TODO\r\n\r\n                {name: 'divisor'},\r\n                {name: 'Toggle Grid', function: ()=>{}, icon: icon['toggle-grid'], disabled: true}, // TODO\r\n                {name: 'Toggle Snap-to-Grid', function: ()=>{}, icon: icon['toggle-snap'], disabled: true}, // TODO\r\n\r\n                {name: 'divisor'},\r\n                {name: 'Show/Hide Sidebar', function: ()=>{}, icon: icon['sidebar'], disabled: true}, // TODO\r\n                {name: 'Show/Hide Toolbar', function: ()=>{}, icon: icon['toolbar2'], disabled: true}, // TODO\r\n\r\n                {name: `${isFullscreen() ? 'Exit Fullscreen Mode' : 'Fullscreen Mode'}`, function: ()=>{toggleFullScreen()}, icon: icon['fullscreen']},\r\n                {name: 'Reset Layout', function: ()=>{}, icon: icon['reset-layout'], disabled: true} // TODO\r\n            ]\r\n        },\r\n        /* ANALYZE - da fare */\r\n\r\n        isDashboard ? null : {name: 'Analyze',\r\n            subItems: [\r\n                {name: 'Live Validation',function: () => {},icon: icon['validation'], disabled: true}, // TODO\r\n                {name: 'Validate',function: () => {}, icon: icon['validate'], disabled: true}, // TODO\r\n                {name: 'divisor'},\r\n                {name: 'Analytics', function: () => {}, icon: icon['metrics'], disabled: true} // TODO\r\n\r\n            ]\r\n        },\r\n\r\n        /* HELP ok */\r\n\r\n        {name: 'Help',\r\n            subItems: [\r\n                {name: 'What\\'s New in Jjodel',function: () => open(\"https://www.jjodel.io/whats-new/\"),icon: <i className=\"bi bi-bell\" />},\r\n                {name: 'divisor'},\r\n                {name: 'Homepage',function: () => open(\"https://www.jjodel.io\"), icon: <i className=\"bi bi-house\" />},\r\n                {name: 'divisor'},\r\n                {name: 'Learn Jjodel', function: () => open(\"https://www.jjodel.io/learn-jjodel/\"), icon: icon['learn']},\r\n                {name: 'Getting Started', function: ()=> open(\"https://www.jjodel.io/getting-started/\"), icon: icon['getting-started']},\r\n                {name: 'Video Tutorials', function: ()=> open(\"https://www.jjodel.io/video-tutorials/\"), icon: icon['video']},\r\n                {name: 'User Guide', function: ()=> open('https://www.jjodel.io/getting-started/'), icon: <i className=\"bi bi-journal-text\" />},\r\n                {name: 'Glossary', function: ()=> open('https://www.jjodel.io/glossary/'), icon: <i className=\"bi bi-book\" />},\r\n                {name: 'FAQ',function: () => {}, icon: icon['faq'], disabled: true},\r\n                {name: 'divisor'},\r\n                {name: 'Support', function: ()=>{}, icon: icon['support'],\r\n                    subItems: [\r\n                        {name: 'Report a Bug', function: ()=>{}, icon: icon['report-bug'], disabled: true}, // TODO\r\n                        {name: 'Request a Feature', function: ()=>{}, icon: icon['feature-request'], disabled: true}, // TODO\r\n                        {name: 'Contact', function: ()=>{}, icon: icon['contact'], disabled: true} // TODO\r\n                    ]}\r\n            ]}\r\n\r\n    ];\r\n\r\n\r\n    let itemsToRegister: MenuEntry[] = items; // [...items]; // [...dashboardItems, ...projectItems];\r\n    let keybindings = U.flattenObjectByKey(itemsToRegister, 'subItems')\r\n        .filter(e=> e && (e.keystroke?.length));\r\n    Keystrokes.register('#root', keybindings);\r\n\r\n    type MenuProps = {\r\n        title?: string;\r\n        items: MenuEntry[];\r\n    }\r\n\r\n    const MainMenu = (props: MenuProps) => {\r\n        return(<>\r\n                { props.items.map(m => !m || !m.subItems?.length ? null : <Submenu key={m.name} title={m.name} items={m.subItems} />) }\r\n            </>\r\n        );\r\n    }\r\n\r\n    const Submenu = (props: MenuProps) => {\r\n        return (<div className='nav-hamburger hoverable inline' key={props.title} tabIndex={0}>\r\n            {props.title && <span className={'menu-title'} key={'title'}>{props.title}</span>}\r\n            <div className={'content context-menu'} key={'content'}>\r\n                <ul>\r\n                    {props.items && props.items.map((i, index) => makeEntry(i, index))}\r\n                </ul>\r\n            </div>\r\n        </div>\r\n    )}\r\n\r\n    const MainMenu2 = (props: MenuProps) => {\r\n\r\n        return(\r\n            <div className='nav-hamburger hoverable' tabIndex={0}>\r\n                <i className=\"bi bi-grid-3x3-gap-fill list\"></i>\r\n                <div className={'content context-menu'}>\r\n                    <ul>\r\n                        { props.items.map((i, index) => makeEntry(i, index)) }\r\n                    </ul>\r\n                </div>\r\n            </div>\r\n        );\r\n    };\r\n\r\n    const MainLogo = () => {\r\n        let toggleDebug = (e: any)=>{\r\n            e.preventDefault();\r\n            TRANSACTION('debug', ()=>SetRootFieldAction.new('debug', !props.debug), props.debug, !props.debug);\r\n            U.debug = !props.debug;\r\n        }\r\n        return (\r\n        <div className='nav-logo'>\r\n            <div className={\"aligner\"}>\r\n\r\n                {props.debug ?\r\n                    <div className='logo-on' onContextMenu={toggleDebug}></div>\r\n                    :\r\n                    <div className='logo' onContextMenu={toggleDebug}></div>\r\n                }\r\n                {props.debug && <i className=\"bi bi-bug-fill\"></i>}\r\n\r\n            </div>\r\n        </div>\r\n        );\r\n    }\r\n\r\n    const Commands = () => {\r\n        return (<label className='text-end nav-commands d-flex'>\r\n            {project && <>\r\n                <span className={\"my-auto me-1\"}>{props.advanced ? \"advanced\" : \"base\"}</span>\r\n                <Input type=\"toggle\"\r\n                       className={\"my-auto\"}\r\n                       style={{fontSize:'1.25em'}}\r\n                       setter={(v) => {\r\n                           SetRootFieldAction.new('advanced', v);\r\n                           windoww.advanced = v;\r\n                       }}\r\n                       getter={() => props.advanced}/>\r\n            </>\r\n            }\r\n        </label>);\r\n    };\r\n\r\n    const UserMenu = () => {\r\n        return (<>\r\n        <div className='text-end nav-side'>\r\n                <div style={{float: 'right', left: '300px!important', marginTop: '2px'}}>\r\n                    <Menu position={'left'}>\r\n                        <Item icon={icon['dashboard']} action={async() => {\r\n                            Collaborative.client.off('pullAction');\r\n                            await Collaborative.client.disconnect();\r\n                            SetRootFieldAction.new('collaborativeSession', false);\r\n                            U.resetState();\r\n                            R.navigate('/allProjects');\r\n                        }}>Dashboard</Item>\r\n                        <Divisor />\r\n                        <Item icon={icon['profile']} action={()=> {\r\n                            R.navigate('/account');\r\n                            U.resetState();\r\n                        }}>Profile</Item>\r\n                        <Item icon={icon['settings']} action={(e)=> {alert('')}}>Settings</Item>\r\n                        <Divisor />\r\n                        <Item icon={icon['logout']} action={async () => {\r\n                            if (isProjectModified()) {\r\n                                U.dialog('You are about to log out without saving your project. Do you want to proceed?', 'logout', async ()=>{\r\n                                    await AuthApi.logout();\r\n                                    R.navigate('/auth');\r\n                                });\r\n                            } else {\r\n                                await AuthApi.logout();\r\n                                R.navigate('/auth');\r\n                            }\r\n                        }}>Logout</Item>\r\n                    </Menu>\r\n                </div>\r\n            </div>\r\n        </>);\r\n    }\r\n\r\n    return(<>\r\n        <nav className={'w-100 nav-container d-flex'} style={{zIndex: 99}}>\r\n            <MainMenu items={items} />\r\n            <MainLogo />\r\n            <UserMenu />\r\n            <Commands />\r\n            <User />\r\n        </nav>\r\n\r\n        {project && clicked === 'new.metamodel' && <MetamodelPopup {...{project, setClicked}} />}\r\n        {project && clicked === 'new.model' && <ModelPopup {...{metamodels, project, setClicked}} />}\r\n    </>);\r\n}\r\n\r\ninterface OwnProps {}\r\ninterface StateProps {\r\n    user: LUser;\r\n    project?: LProject;\r\n    metamodels: LModel[];\r\n    version: DState['version'];\r\n    advanced: boolean;\r\n    debug: boolean;\r\n}\r\ninterface DispatchProps {}\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as FakeStateProps;\r\n    ret.user = LUser.fromPointer(DUser.current);\r\n    ret.project = ret.user?.project || undefined;\r\n    ret.metamodels = LModel.fromArr(state.m2models);\r\n    ret.version = state.version;\r\n    ret.advanced = state.advanced;\r\n    ret.debug = state.debug;\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\nconst NavbarConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(NavbarComponent);\r\n\r\nconst Navbar = (props: OwnProps, children: (string | Component)[] = []): ReactElement => {\r\n    return <NavbarConnected {...{...props, children}} />;\r\n}\r\n\r\nexport {Navbar};\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\BottomBar.tsx",["907"],"import './style.scss';\r\nimport {DState, DUser, LGraphElement, LModelElement, LUser, U} from \"../../joiner\";\r\nimport {FakeStateProps} from \"../../joiner/types\";\r\nimport React, {Dispatch, ReactElement, useState} from \"react\";\r\nimport {connect} from \"react-redux\";\r\n\r\n\r\nimport swen from '../../static/img/swen-splash.png';\r\nimport { About } from './about/About';\r\n\r\nenum notificationType {\r\n    Clients = 0,\r\n    Terminal = 1,\r\n    Messages = 2\r\n  }\r\n\r\nenum alertType {\r\n    Normal = 0,\r\n    Success = 1,\r\n    RequireAttention = 2,\r\n    Alert = 3,\r\n    Error = 4\r\n}\r\n\r\ntype Props = {\r\n    type: notificationType;\r\n    alert: alertType;\r\n    message: string;\r\n\r\n};\r\n\r\n\r\nconst JjodelName = () => {\r\nconst [animal, setAnimal] = useState(false);\r\n\r\n\r\n    return (<>\r\n        <div className={'jjodel'}>\r\n            <span><About ver={'1.6'} name={'manatee'} /></span>\r\n        </div>\r\n        </>);\r\n}\r\n\r\nfunction BottomBarComponent(props: AllProps): JSX.Element {\r\n    const [swenOpen, setSwen] = useState(false);\r\n    const {node,data} = props;\r\n    let nodepos: string | undefined;\r\n    if (node) {\r\n        let size = {...node.size};\r\n        if (size && typeof size === 'object'){\r\n            let ret = [\r\n                '', U.cropNum(+(+size.x||0).toFixed(2)),\r\n                ', ', U.cropNum(+(+size.y||0).toFixed(2)),\r\n                ', ', U.cropNum(+(+node.zIndex||0).toFixed(2)),\r\n                ' w:', U.cropNum(+(+size.w||0).toFixed(2)),\r\n                ' h:', U.cropNum(+(+size.h||0).toFixed(2)),\r\n            ]\r\n            nodepos = ret.join('');\r\n        }\r\n    }\r\n\r\n    return(<footer className={'footer'}>\r\n        <label className={'me-3'}>\r\n            Made with <i className=\"bi bi-heart-fill\" /> in the swen group\r\n        </label>\r\n        <div style={{width: '100px'}}></div>\r\n        <div className={'coordinates'} hidden={!node}>\r\n            {data?.name}&nbsp;\r\n            {nodepos}\r\n        </div>\r\n        {swenOpen && \r\n                <>\r\n                    <div className='modal-container'></div>\r\n                    <div className='swen'>\r\n                        <img src={swen} onClick={(e) => setSwen(false)} />\r\n                    </div>\r\n                </>\r\n        }\r\n        <JjodelName />\r\n\r\n    </footer>)\r\n}\r\n\r\ninterface OwnProps {}\r\ninterface StateProps {\r\n    node?: LGraphElement;\r\n    data?: LModelElement\r\n}\r\ninterface DispatchProps {}\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as FakeStateProps;\r\n    const selected = state._lastSelected;\r\n    if(selected?.node) ret.node = LGraphElement.fromPointer(selected.node);\r\n    if(selected?.modelElement) ret.data = LModelElement.fromPointer(selected.modelElement);\r\n\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\nexport const BottomBarConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(BottomBarComponent);\r\n\r\nconst BottomBar = (props: OwnProps, children: (string | React.Component)[] = []): ReactElement => {\r\n    return <BottomBarConnected {...{...props, children}} />;\r\n}\r\n\r\nexport {BottomBar};\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\Aliases.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\GenericInput.tsx",["908","909"],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\Try.tsx",["910"],"import React, {Dispatch, ErrorInfo, KeyboardEvent, ReactElement, ReactNode} from 'react';\r\nimport {connect} from 'react-redux';\r\nimport {DState} from '../../redux/store';\r\nimport {compressToBase64, compressToUTF16, decompressFromBase64, decompressFromUTF16} from \"async-lz-string\";\r\nimport {\r\n    Defaults,\r\n    DPointerTargetable,\r\n    DV,\r\n    GObject,\r\n    Keystrokes,\r\n    Log,\r\n    LPointerTargetable,\r\n    Overlap,\r\n    Pointer, store,\r\n    U, LoggerCategoryState\r\n} from '../../joiner';\r\nimport { DefaultView } from '../../common/DV';\r\n/*\r\n*   What's uncatched:\r\n*   - reducer\r\n*   - mapstatetoprops, if reducer doesn't do his job\r\n*\r\n*\r\n*\r\n*\r\n*\r\n* */\r\n\r\n// todo: after we have a server, instead of this, make an automatic error report with POST requests to the server without having the uri char limit\r\nclass TryComponent extends React.Component<AllProps, State> {\r\n    static cname: string = \"TryComponent\";\r\n    static mailRecipients = [\"damiano.divincenzo@student.univaq.it\", \"giordano.tinella@student.univaq.it\"];\r\n\r\n    constructor(props: AllProps) {\r\n        super(props);\r\n        this.state = { error: undefined, info: undefined, stateUpdateTime: 0, canUseClipboard: true};\r\n    }\r\n\r\n    static getDerivedStateFromError(error: Error) {\r\n        // Update state so the next render will show the fallback UI.\r\n        return { error, info: undefined }; // this first set an error and stops error propagation\r\n    }\r\n\r\n    private postGitIssue(content: string){\r\n        let owner = 'MDEGroup';\r\n        let repo = 'jjodel';\r\n        let obj = {\r\n            owner,\r\n            repo,\r\n            title: 'Automatic bug report',\r\n            body: content,\r\n            labels: [\r\n                'bug', 'auto-bug'\r\n            ],\r\n            headers: {\r\n                'X-GitHub-Api-Version': '2022-11-28'\r\n            }\r\n        }\r\n        this.postBugReport(`https://api.github.com/repos/${owner}/${repo}/issues`, JSON.stringify(obj));\r\n\r\n    }\r\n    private postBugReport(url: string, content: string){\r\n        var xhr = new XMLHttpRequest();\r\n        xhr.open(\"POST\", url, true);\r\n        xhr.setRequestHeader('Content-Type', 'application/json');\r\n        xhr.send(content);\r\n    }\r\n\r\n    componentDidCatch(error: Error, info: React.ErrorInfo): void {\r\n        console.error(\"uncatched error didcatch:\", {info});\r\n        // this is called after error propagation and a full render cycle is complete, i use it to trigger a rerender with more accurate infos.\r\n        this.setState({error, info, stateUpdateTime: this.props.stateUpdateTime});\r\n    }\r\n\r\n    render() {\r\n        /*\r\n        if (this.props.stateUpdateTime !== this.state.stateUpdateTime) {\r\n            // after a redux state update try checking if error is gone\r\n            return this.props.children;\r\n        }*/\r\n        if (this.state.error) {\r\n            // You can render any custom fallback UI\r\n            return this.catch(this.state.error, this.state.info);\r\n        }\r\n        if (Array.isArray(this.props.children)) {\r\n            console.error(\"<Try /> can have only 1 subcomponent\", this.props.children, this);\r\n            return this.catch({message: \"<Try /> can have only 1 subcomponent. If you need more wrap them inside a <>React.fragment</>\"} as any, undefined);\r\n        }\r\n        if (!React.isValidElement(this.props.children)) {\r\n            // You can render any custom fallback UI\r\n            console.error(\"Children is not a valid React Element\", this.props.children, this);\r\n            return this.catch({message: \"Children is not a valid React Element\"} as any, undefined);\r\n        }\r\n        return this.props.children;\r\n    }\r\n    reset(){\r\n        this.setState({error:undefined, info: undefined, lz: undefined});\r\n    }\r\n\r\n    catch(error: Error, info?: React.ErrorInfo): ReactNode{\r\n        console.error(\"uncatched error:\", {state:{...this.state}});\r\n        let debug = false;\r\n        if (debug) return<div>error</div>;\r\n        if (this.props.catch) {\r\n            try {\r\n                if (typeof this.props.catch === \"function\") return this.props.catch(error, info);\r\n                if (React.isValidElement(this.props.catch)) return this.props.catch;\r\n            }\r\n            catch (e) {\r\n                console.error(\"uncatched error WITH INVALID CATCHING FUNC\", {catcherFuncError:e});\r\n            }\r\n        }\r\n\r\n\r\n        let state: DState = store.getState();\r\n        let title = \"Jodel assisted error report V\"+state?.version?.n;\r\n        (window as any).tryerror = error;\r\n        let reportstr = this.state.lz || this.stringreport(Log.getByError(error));\r\n        let mongoreport = {state: state, when: new Date()+'', e:{'stack':error.stack, 'msg':error.message}, compostack: info?.componentStack};\r\n        // todo giordano: salva report su mongodb\r\n\r\n        const msgbody_notencoded: string = \"This mail is auto-generated, it might contain data of your views or model.\\n\" +\r\n            \"If your project have sensitive personal information please do a manual report instead.\"+// check the report below to omit them.\\n\\n\" +\r\n            \"\" + error?.message + \"\\n\\n\" +\r\n            (reportstr ? 'logger report'+(this.state.lz ? ' (lz-base64)' : '')+':\\n' + encodeURIComponent(reportstr) +'\\n\\n' : '') +\r\n            \"_stack:\\n\" + U.cropStr(error.stack || '', 30, 0, 35, 15) + '\\n\\n'+\r\n            \"_component_stack:\\n\" + (info ? U.cropStr(info.componentStack, 10, 0, 35, 5) : '');\r\n\r\n        let {mailto, gitissue} = U.mailerror(TryComponent.mailRecipients, title, msgbody_notencoded, this.state.canUseClipboard,\r\n            undefined, ()=>{this.setState({canUseClipboard: false})});\r\n\r\n        let shortErrorBody = (error?.message || \"\\n\").split(\"\\n\")[0];\r\n        let visibleMessage: ReactNode = <div onClick={()=> this.reset()}>\r\n            <div>{info ? \"has info\": \"###########\"}</div>\r\n            <div>ut:{this.state.stateUpdateTime}, { shortErrorBody }</div>\r\n            <div>What you can try:</div>\r\n            <ul>\r\n                <li>- Undo the last change</li>\r\n                <li>- {mailto && [<a href={mailto}>Mail the developers</a>, \" or\"]} <a href={gitissue} target=\"_blank\">open an issue</a></li>\r\n            </ul>\r\n            {state.debug ? this.decompress() : undefined}\r\n        </div>\r\n        return DefaultView.error(visibleMessage, \"unhandled\");\r\n    }\r\n\r\n    decompress(){\r\n        function dec(e:any){\r\n            e.stopPropagation();\r\n            let s: any=undefined, s1: any=undefined, s2:Promise<string>=undefined as any, o: any=undefined;\r\n            try { s = e.target.value; } catch (e) {\r\n                console.error(\"crashed decompress\", e);\r\n            }\r\n            try { s1 = decodeURIComponent(s); } catch (e) {\r\n                console.error(\"crashed decompress uri\", e);\r\n            }\r\n            try { s2 = decompressFromBase64(s1); } catch (e) {\r\n                console.error(\"crashed decompress lz\", e);\r\n            }\r\n            if (s2) {s2.then(v=> {\r\n                try { o = JSON.parse(s2=v as any) } catch (e) { console.error(\"crashed decompress p\", e, v); }\r\n            }).finally(()=>{\r\n                let out = {s, uri:s1, lz:s2, o};\r\n                console.log('decompress final', out);\r\n                $('#decompress')[0].innerText = JSON.stringify(o ||  out, null, 4);\r\n\r\n            })} else {\r\n                let out = {s, uri:s1, lz:s2, o};\r\n                console.log('decompress else', out);\r\n                $('#decompress')[0].innerText = JSON.stringify(o ||  out, null, 4);\r\n            }\r\n        }\r\n        return (<><span>Debug mode: paste error report to decompress it.</span><textarea className={\"w-100\"} onChange={dec}></textarea><textarea id={\"decompress\"} className={\"w-100\"} /></>);\r\n    }\r\n\r\n\r\n    private stringreport(loggerReport0?: GObject): string | undefined{\r\n        if (!loggerReport0) return undefined;\r\n        let loggerReport = {...loggerReport0};\r\n        (window as any).loggerReport = loggerReport;\r\n        delete loggerReport.exception;\r\n        loggerReport = U.cropDeepObject(loggerReport);\r\n        loggerReport.time = loggerReport0.time; // do not \"crop\" timestamp\r\n        delete loggerReport.short_string\r\n        let s = JSON.stringify(U.cropDeepObject(loggerReport));\r\n        /*(window as any).compressToUTF16 = compressToUTF16;\r\n        (window as any).decompressFromUTF16 = decompressFromUTF16;\r\n        (window as any).compressToBase64 = compressToBase64;\r\n        (window as any).decompressFromBase64 = decompressFromBase64;\r\n        (window as any).ss = s;*/\r\n        // or: LZString.compressToBase64()\r\n        if (s.length > 100) compressToBase64(s).then((v)=> this.setState({lz:v}));\r\n        return s;\r\n    }\r\n}\r\ninterface State{\r\n    error?: Error;\r\n    info?: React.ErrorInfo;\r\n    stateUpdateTime: number;\r\n    canUseClipboard: boolean;\r\n    lz?: string;\r\n}\r\ninterface OwnProps {\r\n    key?: React.Key | null;\r\n    catch?: ReactNode | ((error: Error, info?: React.ErrorInfo) => ReactNode);\r\n    children: ReactNode;\r\n}\r\ninterface StateProps {\r\n    stateUpdateTime: number;\r\n}\r\ninterface DispatchProps { }\r\ntype AllProps = Overlap<OwnProps, Overlap<StateProps, DispatchProps>>;\r\n\r\nlet rendercount: number = 0;\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as any;\r\n    ret.stateUpdateTime = rendercount++; // new Date().getTime();\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\nconst TryConnected =\r\n    connect<StateProps, DispatchProps, OwnProps, DState>(mapStateToProps, mapDispatchToProps)(TryComponent);\r\n\r\n\r\nexport function Try(props: OwnProps): ReactElement {\r\n    return <TryConnected {...{...props}}>{props.children}</TryConnected>;\r\n}\r\n\r\nTryComponent.cname = 'TryComponent';\r\nTryConnected.cname = 'TryConnected';\r\nTry.cname = 'Try';\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\ControlPanel.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\Overlap.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\Control.tsx",["911","912"],"import {ClickEvent, ControlPanel, LGraphElement, SetRootFieldAction, U} from \"../../joiner\";\r\nimport { ReactElement, ReactNode, useEffect, useRef, useState } from \"react\";\r\n\r\nimport \"./control.scss\";\r\nimport { useStateIfMounted } from \"use-state-if-mounted\";\r\nimport { Tooltip } from \"./Tooltip\";\r\nimport { VertexOwnProps } from \"../../graph/graphElement/sharedTypes/sharedTypes\";\r\nimport { useEffectOnce } from \"usehooks-ts\";\r\n\r\n\r\n/* Notification */\r\n\r\ntype Widget = 'control'|'slider'|null;\r\ntype Field = 'node'|'name'|'children'|null;\r\ntype ErrorType = 'missing'|null;\r\n\r\ntype NotificationProps = {\r\n    widget: Widget,\r\n    field: Field,\r\n    type: ErrorType,\r\n    suggestion?: string\r\n}\r\nconst Notification = (props: NotificationProps) => {\r\n\r\n    return (\r\n        <div className=\"control-widget control-notification\">\r\n            <div className=\"control-header\">\r\n                <h1>You forgot something...</h1>\r\n                {props.type && <h2>Missing '{props.field}'' in '{props.widget}' in template definition.</h2>}\r\n            </div>\r\n\r\n            {props.suggestion && <p>{props.suggestion}</p>}\r\n        </div>\r\n    );\r\n\r\n}\r\n\r\ntype CheckReturnTYpe = {\r\n    error: boolean;\r\n    notification: any;\r\n}\r\n\r\nconst CheckProps = (widget: Widget, props: any): any => {\r\n\r\n    let result:any = false;\r\n    let notification: any|null = null;\r\n    let field: Field = null;\r\n    let type: ErrorType = null;\r\n    let suggestion = '';\r\n\r\n    switch(widget) {\r\n        case 'control':\r\n            if (!props.children) {\r\n                alert('You did not specify any children in <Control ...> </Control>');\r\n                // field = 'children';\r\n                // type = 'missing';\r\n                // suggestion = 'You did not specify any children in <Control ...> </Control>';\r\n                // notification = <Notification widget={widget} field={field} type={type} suggestion={suggestion}/>;\r\n                result = true;\r\n            }\r\n        break;\r\n        case 'slider':\r\n            if (!props.node) {\r\n                alert('You did not specify node in <Slider .../>');\r\n                // field = 'node';\r\n                // type = 'missing';\r\n                // suggestion = '';\r\n                // notification = <Notification widget={widget} field={field} type={type} suggestion={suggestion}/>;\r\n                result = true;\r\n\r\n            }\r\n            if (!props.name) {\r\n                alert('You did not specify name in <Slider .../>');\r\n                field = 'name';\r\n                type = 'missing';\r\n                suggestion = 'You did not specify name in <Slider .../>';\r\n                notification = <Notification widget={widget} field={field} type={type} suggestion={suggestion}/>;\r\n                result = true;\r\n            }\r\n        break;\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n\r\ntype ControlProps = {\r\n    children: any;\r\n    title?: string;\r\n    payoff?: string;\r\n    icon?: boolean;\r\n}\r\n\r\nfunction useClickOutside(ref: any, onClickOutside: any) {\r\n    useEffect(() => {\r\n\r\n        function handleClickOutside(event: Event) {\r\n            if (ref.current && !ref.current.contains(event.target)) {\r\n                onClickOutside();\r\n            }\r\n        }\r\n\r\n      // Bind\r\n      document.addEventListener(\"mousedown\", handleClickOutside);\r\n      return () => {\r\n        // dispose\r\n        document.removeEventListener(\"mousedown\", handleClickOutside);\r\n      };\r\n    }, [ref, onClickOutside]);\r\n  }\r\n\r\n\r\n/*  Control */\r\n\r\nconst ControlComponent = (props: ControlProps, children?:ReactNode) => {\r\n    \r\n    const [controlOpen, setControlOpen] = useStateIfMounted(false);\r\n\r\n    const toggleValue = () => {\r\n        setControlOpen(!controlOpen);\r\n\r\n    }\r\n\r\n\r\n    function onClick(e: any){\r\n        console.log('setup hide control');\r\n        U.clickedOutside(e, ()=> {\r\n            console.log('hide control');\r\n            setControlOpen(false)\r\n        });\r\n    }\r\n    return (<div className={`jjodel-control-root`} onClick={onClick}>\r\n        <div className={`jjodel-control d-flex flex-row ${controlOpen ? 'opened' : 'closed'}`}>\r\n            <div className={'control-header'}>\r\n                <h1>{props.title}</h1>\r\n                <h2>{props.payoff}</h2>\r\n            </div>\r\n            {props.children || children}\r\n        </div>\r\n        <div className={'jjodel-control-icon'}>\r\n            <i onClick={(e) => {toggleValue()}} className=\"bi bi-toggles\"/>\r\n        </div>\r\n    </div>);\r\n}\r\n\r\nconst Control = (props: VertexOwnProps, children: ReactNode = []): ReactElement => {\r\n    return <ControlComponent {...props}>{children || props.children}</ControlComponent>;\r\n}\r\n\r\n\r\n/* Slider */\r\n\r\ntype SliderProps = {\r\n    node: LGraphElement;\r\n    name?: string;\r\n    defaultValue?:number;\r\n    title?:string;\r\n    min?: number;\r\n    max?: number;\r\n    step?: number;\r\n    label?: string;\r\n}\r\n\r\nconst SliderComponent = (props: SliderProps) => {\r\n\r\n    const min = props.min ? props.min : 0;\r\n    const max = props.max ? props.max : 10;\r\n    const step = props.step ? props.step : 1;\r\n    const defaultValue = props.defaultValue ? props.defaultValue : max;\r\n    const name = props.name;\r\n\r\n    useEffectOnce(\r\n        () => {\r\n            {/* @ts-ignore */}\r\n            props.node.state = {[name] : defaultValue};\r\n        }\r\n    );\r\n\r\n    function updateValue(value: number) {\r\n        // @ts-ignore\r\n        props.node.state = {[name]: value};\r\n    }\r\n\r\n\r\n    return (\r\n        <>\r\n            {CheckProps('slider', props) || <div className={'control-widget control-slider'}>\r\n\r\n                <div className={'track'}\r\n                    style={{transition: 'width 0.3s', position: 'relative', left: '10px',\r\n                        width: `calc(((100%/${max} - 8px) * ${props.node.state[name as string]}))`}}\r\n                >\r\n\r\n                </div>\r\n\r\n                <input\r\n                    type={'range'}\r\n                    min={min}\r\n                    max={max}\r\n                    step={step}\r\n                    onChange={(e)=>{updateValue(+e.target.value)}} />\r\n\r\n                {/* @ts-ignore */}\r\n                {props.title && <div className={'tip'}>{props.title} <label>{props.node.state[name]}</label></div>}\r\n                </div>\r\n            }\r\n        </>);\r\n}\r\n\r\nconst Slider = (props: SliderProps, children: ReactNode = []): ReactElement => {\r\n    return <SliderComponent {...props} />;\r\n}\r\n\r\n\r\n/* Toggle */\r\n\r\ntype ToggleValues = {\r\n    true: string;\r\n    false: string;\r\n}\r\n\r\ntype ToggleProps = {\r\n    name: string;\r\n    values?: ToggleValues;\r\n    labels?: ToggleValues;\r\n    size?: string;\r\n    style?: React.CSSProperties;\r\n    title?: string;\r\n};\r\n\r\nconst ToggleComponent = (props: ToggleProps) => {\r\n    const [value, setValue] = useState<boolean>(false);\r\n    const defaultValue = false;\r\n\r\n    const labels = props.labels ? props.labels : {true: 'On', false: 'Off'};\r\n\r\n    useEffectOnce(\r\n        () => {\r\n            {/* @ts-ignore */}\r\n            props.node.state = {[props.name] : defaultValue};\r\n        }\r\n    );\r\n\r\n    function updateValue(value: boolean) {\r\n        // @ts-ignore\r\n        props.node.state = {[props.name]: value};\r\n    }\r\n\r\n    function toggleValue() {\r\n        const newValue = !value;\r\n        setValue(newValue);\r\n\r\n        // @ts-ignore\r\n        props.node.state = {[props.name]: newValue};\r\n    }\r\n    // // updateValue(+e.target.value) \r\n\r\n    return (<>\r\n        \r\n        <div className={'toggle'} onClick={(e) => {toggleValue()}}>\r\n            <input type={'checkbox'} className={'toggle-input'} id={props.name} checked={value} onChange={(e)=>{alert(e.target.value)}}  onClick={(e) => alert('input, click')} /> \r\n\r\n            <label onClick={() => alert()} className={'toggle-label'}></label>\r\n\r\n            <div className={\"toggle-labels\"}>\r\n                {value ?\r\n                    <span className={\"toggle-on\"}>{labels['true']}</span>\r\n                    :\r\n                    <span className={\"toggle-off\"}>{labels['false']}</span>\r\n                }\r\n            </div>\r\n            <div className={\"tip\"}>{props.title}</div>\r\n\r\n        </div></>\r\n    );\r\n}\r\n\r\nconst Toggle = (props: ToggleProps, children: ReactNode = []): ReactElement => {\r\n    return <ToggleComponent {...props} />;\r\n}\r\n\r\nexport {Control, Slider, Toggle};\r\n\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\Archive.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\Measurable.tsx",["913"],"import React, {Component, CSSProperties, PureComponent, ReactChild, ReactElement, ReactNode} from \"react\";\r\nimport {DGraphElement, Dictionary, GObject, GraphSize, LGraph, Log, RuntimeAccessible, Size, TRANSACTION, U} from \"../../joiner\";\r\nimport $ from \"jquery\";\r\n/// <reference path=\"../../common/libraries/jqui-types.ts\" />\r\nimport {JQueryUI} from \"../../common/libraries/jqui-types\"\r\nimport \"./Measurable.scss\";\r\n\r\ntype ResizableEvent = JQueryUI.ResizableEvent;\r\ntype DraggableEvent = JQueryUI.DraggableEvent;\r\ntype RotatableEvent = JQueryUI.RotatableEvent;\r\ntype DraggableOptions = JQueryUI.DraggableOptions;\r\ntype ResizableOptions = JQueryUI.ResizableOptions;\r\ntype RotatabeOptions = JQueryUI.RotatableOptions;\r\n// private\r\ninterface MeasurableState {\r\n}\r\ninterface ScrollState {\r\n}\r\n\r\ntype EventLetter = 's'|'ing'|'e';\r\ntype MeasurableUIEvent = ResizableEvent | DraggableEvent | RotatableEvent;\r\n\r\n@RuntimeAccessible('MeasurableComponent')\r\nexport class MeasurableComponent extends Component<MeasurableAllProps, MeasurableState>{\r\n    static cname: string = \"MeasurableComponent\";\r\n    static childmodekeys: (keyof CSSStyleDeclaration)[] = ['left', 'top', 'transform', 'position'];\r\n\r\n\r\n    private html: Element | null = null;\r\n    private $html!:  JQuery<Element>;\r\n    dragOptionsChanged: boolean = true;\r\n    resizeOptionsChanged: boolean = true;\r\n    rotateOptionsChanged: boolean = true;\r\n    defaultOptions: {\"draggable\": JQueryUI.DraggableOptions, resizable: JQueryUI.ResizableOptions, rotatable: GObject} = {\r\n        draggable: {\r\n            cancel: '.no-drag,[contenteditable=\"true\"],input,textarea,button,select,option',\r\n            cursor: 'grabbing',\r\n            // containment: 'parent',\r\n            distance: 5,\r\n            // helper: 'clone', // 'original' or 'csselector'? or func=>html\r\n            // disabled: !(view.draggable),}\r\n        },\r\n        resizable: {},\r\n        rotatable: {},\r\n    }\r\n    oldPos: Dictionary<string, number> = {left: undefined, top: undefined} as any;\r\n\r\n    componentDidMount() {\r\n        this.afterUpdate();\r\n    }\r\n    componentDidUpdate(prevProps: Readonly<MeasurableAllProps>, prevState: Readonly<MeasurableState>, snapshot?: any) {\r\n        this.afterUpdate();\r\n    }\r\n\r\n    afterUpdate(): void{\r\n        if (!this.html) return;\r\n        this.$html = $(this.html);\r\n        if (this.dragOptionsChanged) { this.afterUpdateSingle(\"draggable\"); }\r\n        if (this.resizeOptionsChanged) { this.afterUpdateSingle(\"resizable\"); }\r\n        if (this.rotateOptionsChanged) { this.afterUpdateSingle(\"rotatable\"); }\r\n    }\r\n    /*\r\n        afterUpdateSingle(type: \"draggable\" | \"resizable\" | \"rotatable\"): void{\r\n            if (this.props.draggable) this.afterUpdateDraggable\r\n        }/*\r\n        afterUpdateDraggable_old(): void{\r\n            nope, erase this and just make the previous _old genericversion with inner dynamic functions called 9 times like event('drag', 'while'); event('drag', 'end'); event('resize', 'while');...\r\n            make and extract new functions from code so that it dinamically build the jqui options object\r\n            if (!this.$html) return;\r\n            let $measurable = this.$html;\r\n            let jqui_options = this.props.draggable;\r\n            let jqui_start = jqui_options === 'object' ? jqui_options.start : undefined;\r\n            let jqui_end = jqui_options === 'object' ? jqui_options.stop : undefined;\r\n            let jqui_ing = jqui_options === 'object' ? jqui_options.drag : undefined;\r\n            let props_start = this.props.onDragStart;\r\n            let props_end = this.props.onDragEnd;\r\n            let props_ing = this.props.whileDragging;\r\n            let type = 'draggable';\r\n\r\n\r\n            //let positionMap = new WeakMap<HTMLElement, {left: number; top: number}>();\r\n            let childmode_drag = (e: HTMLElement, evt?: any, evtkind?: EventLetter, ui?:any): void => {\r\n                let oc = this.props.onChildren;\r\n                if (!oc) {\r\n                    Log.ee('not oc', {evt, oc, e, p: this.props}); return;\r\n                }\r\n                let child: HTMLElement;\r\n                if (typeof oc === 'function') child = oc(e);\r\n                else child = e.children[0] as HTMLElement;\r\n                if (!child) {\r\n                    Log.ee('child not found', {child, evt, oc, e}); return;\r\n                }\r\n                let oldpos = this.oldPos; // positionMap.get(e);\r\n                console.log('measurable default event child ' + evtkind, {ui, e, oc, oldpos});\r\n                //if (evtkind === 'e') { positionMap.set(e, ui.position); }\r\n\r\n                /*if (evtkind === 's') {\r\n                    ui.originalPosition.left = 300;\r\n                    ui.offset.left = 300;\r\n                    ui.position.left = 300;\r\n                    console.log('measurable sstart ', {type, e, oc, ui, el: e.style.left, cl: child.style.left});\r\n                }* /\r\n\r\n                let key: any;\r\n                for (key of childmodekeys) {\r\n                    let fixpos = () => {\r\n                        if (oldpos && (oldpos as any)[key] !== undefined) {\r\n                            if (key ==='left') console.log('measurable fixpos ' + evtkind, (oldpos as any)[key] + ui.position[key] + 'px', (oldpos as any)[key]);\r\n                            let newpos = (oldpos as any)[key] + ui.position[key];\r\n                            child.style[key] = (newpos) + 'px';\r\n                            if (evtkind === 'e') this.oldPos[key] = newpos;\r\n                        }\r\n                        else child.style[key] = e.style[key];\r\n                    }\r\n                    fixpos();\r\n                    if (evtkind === 'e')  setTimeout(fixpos, 1000);\r\n                    if (evtkind === 's' && !e.classList.contains('draggable-child-mode')) e.classList.add('draggable-child-mode');\r\n                    // delete e.style[key]\r\n                }\r\n            }\r\n\r\n            let translateeevents: Dictionary<string, Dictionary<string, DraggableEvent>> = {\r\n                'draggable': {\r\n                    's': (e, ui)=>{ this.absoluteToTransform(e.target as HTMLElement, e, 's'); },\r\n                    'ing': (e, ui)=>{ this.absoluteToTransform(e.target as HTMLElement, e, 'ing'); },\r\n                    'e': (e, ui)=>{ this.absoluteToTransform(e.target as HTMLElement, e, 'e'); }},\r\n            };\r\n            let defaulteevent = (evtkind: EventLetter): MeasurableUIEvent | null =>{\r\n                if (!this.props.transformMode && !this.props.onChildren) return null;\r\n                return (e: any, ui: any) => {\r\n                    //console.log('measurable default event', {type, evtkind, translateeevents, e, t: e.target});\r\n                    if (this.props.transformMode === true) translateeevents[type][evtkind](e, ui);\r\n                    childmode_drag(e.target, e, evtkind, ui);\r\n                }\r\n            };\r\n\r\n            if (props[optionkey] === false || !props[optionkey]) {\r\n                console.log(\"measurable off \" + type, {$measurable, type, datamap, optionkey, props});\r\n                if ($measurable.data(datamap[type])) ($measurable as GObject)[type]('disable');\r\n                return;\r\n            }\r\n            if (props[optionkey] === true) {\r\n                options = {};\r\n            } else options = {...props[optionkey]};\r\n\r\n            if (props_start && typeof props_start !== \"function\") { return Log.ee(\"<Measurable /> onDragStart props must be a function\"); }\r\n            if (props_end && typeof props_end !== \"function\") { return Log.ee(\"<Measurable /> onDragEnd props must be a function\"); }\r\n            if (props_ing && typeof props_ing !== \"function\") { return Log.ee(\"<Measurable /> whileDragging props must be a function\"); }\r\n            if (!jqui_start && !props_start && ! default_start) delete options.start,\r\n                else options.start = (evt, ui) => { default_start?.(evt, ui); jqui_start?.(evt, ui); props_start?.(thiss.getCoords(evt, ui), evt, ui); }\r\n\r\n            let propsOptions = {...options};\r\n            let defaultOptions = this.defaultOptions[type];\r\n            U.objectMergeInPlace(options, defaultOptions);\r\n            //console.log(\"measurable\", {type, $measurable, options, propsOptions, defaultOptions});\r\n            ($measurable as GObject)[type](options);\r\n        }*/\r\n\r\n    absoluteToTransform(e: HTMLElement, evt?: any, evtkind?: EventLetter): any {\r\n        let x = e.style.left;\r\n        let y = e.style.top;\r\n        /*\r\n            e.style.left = '0px';\r\n            e.style.top = '0px';*/\r\n        //e.style.position = 'unset';\r\n        e.style.transform = `translate(${x}, ${y})`;\r\n    }\r\n    childmode(e: HTMLElement, evt?: any, evtkind?: EventLetter, ui?:any): void{\r\n        let oc = this.props.onChildren;\r\n        if (!oc) {\r\n            Log.ee('not oc', {evt, oc, e, p: this.props}); return;\r\n        }\r\n        let child: HTMLElement;\r\n        console.log('cchild', {e, evt,  evtkind, ui});\r\n        if (typeof oc === 'function') child = oc(e);\r\n        else child = e.children[0] as HTMLElement;\r\n        if (!child) {\r\n            Log.ee('child not found', {child, evt, oc, e}); return;\r\n        }\r\n        console.log('measurable default event child ' + evtkind, {ui, e, oc, oldpos: this.oldPos});\r\n        //if (evtkind === 'e') { positionMap.set(e, ui.position); }\r\n\r\n        /*if (evtkind === 's') {\r\n            ui.originalPosition.left = 300;\r\n            ui.offset.left = 300;\r\n            ui.position.left = 300;\r\n            console.log('measurable sstart ', {type, e, oc, ui, el: e.style.left, cl: child.style.left});\r\n        }*/\r\n\r\n        let key: any;\r\n        for (key of MeasurableComponent.childmodekeys) {\r\n            let fixpos = () => {\r\n                let oldpos = this.oldPos; // positionMap.get(e); {x:-1000, y:-3000};//\r\n                if (oldpos && (oldpos as any)[key] !== undefined) {\r\n                    let newpos = (oldpos as any)[key] + ui.position[key];\r\n                    if (key ==='left') console.log('measurable fixpos ' + newpos + 'px', (oldpos as any)[key], {oldpos, uipos:ui.position, newpos});\r\n                    child.style[key] = (newpos) + 'px';\r\n                    if (evtkind === 'e') this.oldPos[key] = newpos;\r\n                }\r\n                else child.style[key] = e.style[key];\r\n            }\r\n            if (evtkind === 'e') setTimeout(fixpos, 1000);\r\n            if (evtkind === 's') {\r\n                let graph = this.props.isPanning;\r\n                if (this.oldPos.left === undefined && graph) {\r\n                    console.log('measurable fixposss ',{oldpos:{...this.oldPos}});\r\n                    this.oldPos.left = ui.position.left = graph.offset.x;\r\n                    this.oldPos.top = ui.position.top = graph.offset.y;\r\n                }\r\n                if (!e.classList.contains('draggable-child-mode')) e.classList.add('draggable-child-mode');\r\n            }\r\n            fixpos();\r\n            // delete e.style[key]\r\n        }\r\n    }\r\n    getDefaultEvent(type: \"draggable\" | \"resizable\" | \"rotatable\", evtkind: EventLetter): MeasurableUIEvent | null {\r\n        if (!this.props.transformMode && !(this.props.onChildren && type === 'draggable')) return null;\r\n        switch (type) {\r\n            case 'draggable': if (!this.props.transformMode && !this.props.onChildren) return null; break\r\n            case 'resizable': break\r\n            case 'rotatable': break\r\n        }\r\n\r\n        let translateeevents: Dictionary<string, Dictionary<string, DraggableEvent>> = {\r\n            'draggable': {\r\n                's': (e, ui)=>{ this.absoluteToTransform(e.target as HTMLElement, e, 's'); },\r\n                'ing': (e, ui)=>{ this.absoluteToTransform(e.target as HTMLElement, e, 'ing'); },\r\n                'e': (e, ui)=>{ this.absoluteToTransform(e.target as HTMLElement, e, 'e'); }},\r\n            /*'resizable': {\r\n                's': (e, ui)=>{ },\r\n                'ing': (e, ui)=>{ },\r\n                'e': (e, ui)=>{ }},\r\n            'rotatable': {\r\n                's': (e, ui)=>{ },\r\n                'ing': (e, ui)=>{ },\r\n                'e': (e, ui)=>{ }},*/\r\n        };\r\n        return (e: any, ui: any) => {\r\n            console.log('measurable default event', {type, evtkind, translateeevents, e, t: e.target});\r\n            if (this.props.transformMode === true) translateeevents[type]?.[evtkind]?.(e, ui);\r\n            this.childmode(e.target, e, evtkind, ui);\r\n        }\r\n    }\r\n    makeEvent(options: GObject<DraggableOptions>, type: string, evtkey: keyof typeof jquievent) {\r\n        let eventmap = {\r\n            's':    {'draggable': 'onDragStart',    'rotatable': 'onRotateStart',   'resizable': 'onResizeStart'},\r\n            'ing':  {'draggable': 'whileDragging',  'rotatable': 'whileRotating',   'resizable': 'whileResizing'},\r\n            'e':    {'draggable': 'onDragEnd',      'rotatable': 'onRotateEnd',     'resizable': 'onResizeEnd'  },\r\n        }\r\n        let jqui_ing: string;\r\n        switch (type){\r\n            default: jqui_ing = Log.eDevv(\"unexpected measurable event: \" + type); return;\r\n            case \"draggable\": jqui_ing = 'drag'; break;\r\n            case \"resizable\": jqui_ing = 'resize'; break;\r\n            case \"rotatable\": jqui_ing = 'rotate'; break;\r\n        }\r\n        //let jodelevent = {'s': eventmap.s[type], 'ing': eventmap.ing[type], 'e': eventmap.e[type]};\r\n        let jquievent = {'s': 'start', 'ing': jqui_ing, 'e':'stop'};\r\n\r\n        let jqkey = jquievent[evtkey] || '';\r\n        let props: GObject<MeasurableAllProps> = this.props;\r\n        let propsevent = props[eventmap[evtkey][type]];\r\n\r\n        if (propsevent && typeof propsevent !== \"function\") {\r\n            Log.ee(\"<Measurable /> \" + eventmap[evtkey][type] + \" props must be a function\");\r\n            return;\r\n        }\r\n        // call ondragend... jodel events\r\n        let jquievt = options[jqkey];\r\n        // let jodelevt = propsevent; // (...params: any) => propsevent(...params); // was made to preserve \"this\"?\r\n        let defaultevt: null | MeasurableUIEvent = this.getDefaultEvent(type, evtkey);\r\n        let allevents = [defaultevt, jquievt, propsevent].filter((e)=>!!e);\r\n        if (allevents.length) options[jqkey] = ((evt, ui)=>{\r\n            for (let e of allevents) {\r\n                propsevent = props[eventmap[evtkey][type]]; // if i don't redeclare it here, closure makes a mess taking always the last jodelevt for all iterations.\r\n                if (e === propsevent) { e(this.getCoords(evt, ui, this.props.isPanning), evt, ui); }\r\n                else e(evt, ui);\r\n            }\r\n        }) as DraggableEvent;\r\n    }\r\n    afterUpdateSingle(type: \"draggable\" | \"resizable\" | \"rotatable\"): void{\r\n        // was forced to move from general loop-style implementation to individual redundant stuff because of closure messes.\r\n        if (!this.$html) return;\r\n        let $measurable = this.$html;\r\n        let options: GObject;\r\n        const props: GObject = this.props;\r\n        const datamap = {draggable: \"uiDraggable\", resizable: \"uiResizable\", rotatable: \"uiRotatable\"};\r\n        const optionmap = {draggable: \"draggable\", resizable: \"resizable\", rotatable: \"rotatable\"};\r\n        const optionkey = optionmap[type];\r\n        if (props[optionkey] === false || !props[optionkey]) {\r\n            // console.log(\"measurable off \" + type, {$measurable, type, datamap, optionkey, props});\r\n            if ($measurable.data(datamap[type])) ($measurable as GObject)[type]('disable');\r\n            return;\r\n        }\r\n        if (props[optionkey] === true) {\r\n            options = {};\r\n        } else options = {...props[optionkey]};\r\n\r\n        // todo: changing options at runtime works, but changing children does not update\r\n\r\n        let jqui_ing: string;\r\n        switch (type){\r\n            default: jqui_ing = Log.eDevv(\"unexpected measurable event: \" + type); return;\r\n            case \"draggable\": jqui_ing = 'drag'; break;\r\n            case \"resizable\": jqui_ing = 'resize'; break;\r\n            case \"rotatable\": jqui_ing = 'rotate'; break;\r\n        }\r\n        let jquievent = {'s': 'start', 'ing': jqui_ing, 'e':'stop'};\r\n        let evtkey: keyof typeof jquievent;\r\n        for (evtkey in jquievent) { this.makeEvent(options, type, evtkey); }\r\n        let defaultOptions = this.defaultOptions[type];\r\n        U.objectMergeInPlace(options, defaultOptions);\r\n        ($measurable as GObject)[type](options);\r\n    }\r\n    shouldComponentUpdate(nextProps: Readonly<MeasurableAllProps>, nextState: Readonly<MeasurableState>, nextContext: any): boolean {\r\n        //console.log(\"measurable shouldup\", {nc:nextProps.children, tc:this.props.children, eq: nextProps.children == this.props.children});\r\n        // todo: would need to check if pros.children has changed, but that requires a deep search of subcomponents props and state.\r\n        // currently with just return true it works and rerenders every time the parent component rerenders. not when other elements are interacted.\r\n        // it works also with <Input> as direct child and it updates.\r\n        if (window) return true;\r\n        const oldProps = this.props || {};\r\n        this.dragOptionsChanged = false;\r\n        this.resizeOptionsChanged = false;\r\n        this.rotateOptionsChanged = false;\r\n        let ret: boolean = false;\r\n        const nestederr = \"Options cannot contain functions or nested objects\";\r\n        if (!U.isShallowEqualWithProxies(oldProps.draggable, nextProps.draggable)) {\r\n            const opt: GObject = oldProps.draggable as any;\r\n            if (opt && typeof opt === \"object\") for(let k in opt){ switch (typeof opt[k]){ case \"function\": case \"object\": Log.ee(\"drag\" + nestederr, k); } }\r\n            this.dragOptionsChanged = true;\r\n            ret = true;\r\n        }\r\n        if (!U.isShallowEqualWithProxies(oldProps.resizable, nextProps.resizable)) {\r\n            const opt: GObject = oldProps.resizable as any;\r\n            if (opt && typeof opt === \"object\") for(let k in opt){ switch (typeof opt[k]){ case \"function\": case \"object\": Log.ee(\"resize\" + nestederr, k); } }\r\n            this.resizeOptionsChanged = true;\r\n            ret = true;\r\n        }\r\n        if (!U.isShallowEqualWithProxies(oldProps.rotatable, nextProps.rotatable)) {\r\n            const opt: GObject = oldProps.rotatable as any;\r\n            if (opt && typeof opt === \"object\") for(let k in opt){ switch (typeof opt[k]){ case \"function\": case \"object\": Log.ee(\"rotate\" + nestederr, k); } }\r\n            this.rotateOptionsChanged = true;\r\n            return true;\r\n        }\r\n        if (ret) return true; // i don't need to set more this.variable stuff and i already determined something changed.\r\n        if (Object.keys(oldProps).length !== Object.keys(nextProps).length) return true;\r\n        let k: keyof typeof nextProps;\r\n        for (k in oldProps){\r\n            switch(k){\r\n                //case \"axis\": if (ok)\r\n                case \"draggable\": case \"resizable\": case \"rotatable\": continue;\r\n                case \"children\": continue;\r\n            }\r\n            if (!(k in nextProps)) return false;\r\n            let ok = oldProps[k];\r\n            let nk = nextProps[k];\r\n            if (ok === nk) continue;\r\n            let tk = typeof ok;\r\n            if (tk !== typeof nk) return false;\r\n            switch (tk) {\r\n                case \"object\": Log.ee(\"unexpected object in <Measurable/> props\", {k, nk, ok}); return true;\r\n                case \"function\": if (ok!.toString() !== nk!.toString()) return true; break;\r\n                default: return false; // already checked they are !==\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    updateDefaultOptions(){\r\n        /*let addClasses = this.props.children ? 'on-children' as any : undefined;\r\n                                          jqui.classes does not owrk? and addclass is only for draggable?\r\n        if (this.defaultOptions.draggable.addClasses !== addClasses) {\r\n            this.defaultOptions.resizable.classes = addClasses;\r\n            // this.defaultOptions.rotatable.classes = addClasses;\r\n        }*/\r\n    }\r\n    render(): ReactNode {\r\n        let child: ReactElement = this.props.children as any;\r\n\r\n        this.updateDefaultOptions();\r\n        if (!child) return child || null; // sometimes react passes {} as props.children?\r\n        if (!Object.keys(child).length) return Log.ee(\"Measurable can have only 1 subelement and it cannot be an array or a <>React.fragment</>\", child, this.props);\r\n        if (Array.isArray(child)) {\r\n            if (child.length !== 1) {\r\n                Log.ee(\"Measurable can have only 1 subelement and it cannot be an array or a <>React.fragment</>\", child, this.props);\r\n                return child;\r\n            }\r\n            else child = child[0];\r\n        }\r\n        if (child.type.toString() === React.Fragment.toString()) {\r\n            Log.ee(\"Measurable can have only 1 subelement and it cannot be an array or a <>React.fragment</>\", child, this.props);\r\n            return child; }\r\n\r\n        let oldProps = child.props;\r\n        let newProps = {\r\n            ref: (html: Element | null)=>{\r\n                if (html && !U.isHtmlNode(html)) {\r\n                    Log.ee('ref tring to set non-html element', html);\r\n                    return;\r\n                }\r\n                this.html = html;\r\n            }\r\n        };\r\n        U.objectMergeInPlace(newProps, oldProps);\r\n        let clonedChild = React.cloneElement(child, newProps);\r\n        return clonedChild;\r\n    }\r\n\r\n    private getCoords(evt: JQueryEventObject, ui: JQueryUI.DraggableEventUIParams, isPanning?: LGraph): GraphSize {\r\n        let size = Size.of(evt.target);\r\n        let graph: LGraph = DGraphElement.graphLFromHtml(evt.target) as LGraph;\r\n        let gsize: GraphSize = graph?.translateHtmlSize(size);\r\n        if (isPanning) {\r\n            let position = this.props.onChildren ? this.oldPos : ui.position;\r\n            gsize.x = position.left;\r\n            gsize.y = position.top;\r\n        }\r\n        return gsize;\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('ScrollableComponent')\r\nexport class ScrollableComponent extends Component<ScrollOwnProps, ScrollState>{\r\n    static cname: string = \"ScrollableComponent\";\r\n    render(){\r\n        let graph = this.props.graph;\r\n        let create = (e: JQueryEventObject) => {/*\r\n            let target: HTMLElement = e.target.children[0] as HTMLElement;\r\n            target.style.left = graph.offset.x+'px';\r\n            target.style.top = graph.offset.y+'px';*/\r\n            // $(target).data({uiDraggable:{offset:{left: graph.offset.x, top: graph.offset.y}}});\r\n        }\r\n        return (\r\n            <div className={\"scrollable\"}>\r\n                <Measurable draggable={{create}}\r\n                            isPanning={graph}\r\n                            onDragEnd={graph ? (coords, ...args: any)=>{\r\n                                if (!graph) return; // just for ts-lint\r\n                                console.log(\"drag odee\", {coords, graph, args});\r\n                                let offset = graph.offset;\r\n                                if (!offset.equals(coords)) graph.offset = coords as any;\r\n                            } : undefined}\r\n                            onChildren={true}>\r\n                    <div className=\"panning-handle\">\r\n                        <div className=\"panning-content\">{ this.props.children }</div>\r\n                    </div>\r\n                </Measurable>\r\n            </div>);\r\n    }\r\n}\r\n\r\n// private\r\ninterface ScrollOwnProps {\r\n    children: ReactChild[] | ReactChild;\r\n    graph: LGraph;\r\n}\r\ninterface MeasurableOwnProps {\r\n    isPanning?: LGraph;\r\n    children: ReactChild[] | ReactChild;\r\n    //dragOptions?: Options;\r\n    //drag?: Options;\r\n    draggable?: JQueryUI.DraggableOptions | boolean;\r\n    onDragStart?: DraggableEvent;\r\n    whileDragging?: DraggableEvent;\r\n    onDragEnd?: (coords: GraphSize, ...args: Parameters<DraggableEvent>)=>void;\r\n    onChildren?: boolean | ((e: HTMLElement)=>HTMLElement);\r\n\r\n    //resizeOptions?: Options;\r\n    //resize?: Options;\r\n    resizable?: JQueryUI.ResizableOptions | boolean;\r\n    onResizeStart?: ResizableEvent;\r\n    whileResizing?: ResizableEvent;\r\n    onResizeEnd?: ResizableEvent;\r\n    transformMode?: boolean; // if true uses transform: translate() instead of pos:absolute; left; & top;\r\n\r\n    //rotateOptions?: Options;\r\n    //rotate?: Options;\r\n    rotatable?: GObject | boolean;\r\n    onRotationStart?: RotatableEvent;\r\n    whileRotating?: RotatableEvent;\r\n    onRotationEnd?: RotatableEvent;\r\n}\r\n// private\r\ninterface MeasurableStateProps {\r\n    // propsFromReduxStateOrOtherKindOfStateManagement: boolean; // flux or custom things too, unrelated to this.state of react.\r\n}\r\n\r\n// private\r\ninterface DispatchProps {\r\n    // propsFromReduxActions: typeof funzioneTriggeraAzioneDaImportare;\r\n}\r\n\r\n\r\n// private\r\ntype MeasurableAllProps = MeasurableOwnProps & MeasurableStateProps & DispatchProps;\r\n\r\n////// mapper func\r\n/*\r\nfunction mapStateToProps(state: DState, ownProps: MeasurableOwnProps): MeasurableStateProps {\r\n    const ret: MeasurableStateProps = {} as any;\r\n    /// to fill\r\n    return ret; }\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {} as any;\r\n    /// to fill\r\n    return ret; }\r\n*/\r\n\r\n(MeasurableComponent as any).defaultProps = {\r\n    autosizex: true,\r\n    autosizey: true,\r\n    style: undefined,\r\n    children: [],\r\n} as MeasurableOwnProps;\r\n\r\n\r\nexport function Measurable(props: MeasurableAllProps, children?: any): ReactElement {\r\n    return <MeasurableComponent {...{...props}}>{props.children||children}</MeasurableComponent>;\r\n}\r\n// shortcuts for Draggable Resizable Rotatable with whileDragging onDragStart props simplified to start, while, end\r\nexport function Draggable(props: GObject<MeasurableAllProps>, children?: any): ReactElement {\r\n    return <MeasurableComponent\r\n        {...{...props}}\r\n        draggable={props.options || props.draggable || true}\r\n        onDragStart={props.start || props.begin || props.onDragStart}\r\n        onDragEnd={props.end || props.stop || props.onDragEnd}\r\n        whileDragging={props.drag || props.while || props.ing || props.whileDragging}\r\n    >{props.children||children}</MeasurableComponent>;\r\n}\r\nexport function Resizable(props: GObject<MeasurableAllProps>, children?: any): ReactElement {\r\n    return <MeasurableComponent\r\n        {...{...props}}\r\n        resizable={props.options || props.resizable || true}\r\n        onResizeStart={props.start || props.begin || props.onResizeStart}\r\n        onResizeEnd={props.end || props.stop || props.onResizeEnd}\r\n        whileResizing={props.resize || props.while || props.ing || props.whileResizing}\r\n    >{props.children||children}</MeasurableComponent>;\r\n}\r\nexport function Rotatable(props: GObject<MeasurableAllProps>, children?: any): ReactElement {\r\n    return <MeasurableComponent\r\n        {...{...props}}\r\n        rotatable={props.options || props.rotatable || true}\r\n        onRotationStart={props.start || props.begin || props.onRotateStart|| props.onRotationStart}\r\n        onRotationEnd={props.end || props.stop || props.onRotateEnd|| props.onRotationEnd}\r\n        whileRotating={props.rotate || props.while || props.ing || props.whileRotate || props.whileRotating}\r\n    >{props.children||children}</MeasurableComponent>;\r\n}\r\n\r\n\r\nexport function Scrollable(props: MeasurableAllProps, children?: any): ReactElement {\r\n    // @ts-ignore\r\n    return <ScrollableComponent {...{...props}}>{props.children||children}</ScrollableComponent>;\r\n}/*\r\nexport function InfiniteScroll(props: MeasurableAllProps, children: ReactChild[] = []): ReactElement {\r\n    return <InfiniteScrollComponent {...{...props, children}}>{children}</InfiniteScrollComponent>;\r\n}*/\r\n\r\n/*connect<MeasurableStateProps, DispatchProps, MeasurableOwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(MeasurableComponent);*/\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\Community.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\Profile.tsx",["914","915"],"import {Try} from '../joiner';\r\nimport {Dashboard} from './components';\r\n\r\nimport {Cards, Card} from './components/cards/Cards';\r\nimport { Catalog } from './components/catalog/Catalog';\r\n\r\nfunction ProfilePage(): JSX.Element {\r\n    // NB: this works only in production if you put subfolders with past builds in the new build root.\r\n    return(<Try>\r\n        <Dashboard active={'Profile'} version={{n: 0, date:'fake-date'}}>\r\n            <>                \r\n\r\n            <Cards>\r\n                <Cards.Item\r\n                    title={'Getting started'} \r\n                    subtitle={'Create your first notation.'}\r\n                    icon={'gettingstarted'} \r\n                    style={'rainbow'}   \r\n                />\r\n                {true && <Cards.Item icon={'question'} style={'clear'} title={'Ehy!'} subtitle={'What do you want to do today?'}/>}\r\n            </Cards>\r\n\r\n            <ul>\r\n                <li><a href={window.location.origin + '/jjodel'}>2.0</a></li>\r\n                <li><a href={window.location.origin + '/jjodel/2.1/'}>2.1</a></li>\r\n                <li><a href={window.location.origin + '/jjodel/2.2/'}>2.2 (to come)</a></li>\r\n            </ul>\r\n            </>\r\n            \r\n        </Dashboard>\r\n    </Try>);\r\n}\r\n\r\nexport {ProfilePage};\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\Settings.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\Notes.tsx",["916","917","918","919","920","921","922","923","924","925","926"],"import React, {ChangeEvent, MouseEventHandler, Component, Dispatch, ReactElement, useState, useRef } from 'react';\r\nimport {connect} from 'react-redux';\r\nimport {DProject, DState, LProject, Try, U} from '../joiner';\r\nimport {FakeStateProps} from '../joiner/types';\r\nimport {Dashboard, Project} from './components';\r\nimport Storage from \"../data/storage\";\r\n\r\nimport {Menu, Item, Divisor} from './components/menu/Menu';\r\n\r\nimport colors from '../static/img/colors.png';\r\nimport {CatalogInfoCard} from \"./components/catalog/Catalog\";\r\n\r\n\r\n\r\ntype CardsType = {\r\n    children: any;\r\n};\r\n\r\n\r\nconst Cards = (props: CardsType): any => {\r\n    return (\r\n        <React.Fragment>\r\n            <div className='row mb-5 commandbar'>\r\n                {props.children}\r\n            </div>\r\n        </React.Fragment>\r\n    );\r\n}\r\n\r\ntype CardType = {\r\n    icon: \"add\" | \"import\" | \"clone\" | \"question\";\r\n    style?: \"blue\" | \"red\" | \"dark\" | \"clear\" | \"rainbow\" | \"default\";\r\n    title: string;\r\n    subtitle: string;\r\n    action?: MouseEventHandler;\r\n    children?: JSX.Element[];\r\n};\r\n\r\nconst Card = (props: CardType) => {\r\n\r\n    const icons = {\r\n        add: \"bi-plus-circle\",\r\n        import: \"bi-box-arrow-in-up\",\r\n        question: \"bi-question-square\",\r\n        clone: \"bi-clipboard2-check\"\r\n    };\r\n\r\n    return (<>\r\n        <div className={`card ${props.style ? props.style : 'default' }`}>\r\n            <div className={'col icon'}>\r\n                {props.action ?\r\n                    <i onClick={props.action} className={`bi ${icons[props.icon]}`}></i> :\r\n                    <i className={`bi ${icons[props.icon]} disabled`}></i>\r\n                }\r\n            </div>\r\n            <div className={'col body'}>\r\n                <h5>{props.title}</h5>\r\n                {props.subtitle}\r\n            </div>\r\n        </div>\r\n        </>\r\n    );\r\n}\r\n\r\nCards.Item = Card;\r\n\r\ntype ChildrenType = {\r\n    projects?: any;\r\n    children?: JSX.Element[];\r\n};\r\n\r\n\r\n/* main component */\r\n\r\nconst Catalog = (props: ChildrenType) => {\r\n\r\n    const [filters, setFilters] = useState([false,false,false]);\r\n    const [mode, setMode] = useState<string>(\"cards\");\r\n\r\n    const Header = (props: ChildrenType) => {\r\n        return (\r\n            <div className='row catalog-header'>\r\n                {props.children}\r\n            </div>\r\n        );\r\n    }\r\n\r\n    const CatalogFilters = () => {\r\n\r\n        function toggleFilters(el: 0|1|2) {\r\n            switch(el) {\r\n                case 0:\r\n                    setFilters([!filters[0], filters[1], filters[2]]);\r\n                    break;\r\n                case 1:\r\n                    setFilters([filters[0], !filters[1], filters[2]]);\r\n                    break;\r\n                case 2:\r\n                    setFilters([filters[0], filters[1], !filters[2]]);\r\n                    break;\r\n            }\r\n        };\r\n\r\n        return (\r\n            <div className={'col left'}>\r\n                {filters[0] ? <button onClick={(e) => toggleFilters(0)} className='active'>public</button> : <button onClick={(e) => toggleFilters(0)}>public</button>}\r\n                {filters[1] ? <button onClick={(e) => toggleFilters(1)} className='active'>private</button> : <button onClick={(e) => toggleFilters(1)}>private</button>}\r\n                {filters[2] ? <button onClick={(e) => toggleFilters(2)} className='active'>collaborative</button> : <button onClick={(e) => toggleFilters(2)} >collaborative</button>}\r\n            </div>\r\n        );\r\n    }\r\n\r\n    const CatalogMode = () => { // unused component?\r\n        return (<>\r\n            <div className={'col left'}>\r\n                <div className=\"float-end\">sorted by\r\n                    <div className={'view-icons'}>\r\n                        <i onClick={(e) => setMode('cards')} className={`bi bi-grid ${mode === \"cards\" && 'selected'}`}></i>\r\n                        <i onClick={(e) => setMode('list')} className={`bi bi-list ${mode === \"list\" && 'selected'}`}></i>\r\n                    </div>\r\n                    <div style={{float: 'right'}}>\r\n                    <Menu position={'left'}>\r\n                        <Item action={(e)=> {alert('')}}>Alphabetical</Item>\r\n                        <Item>Date created</Item>\r\n                        <Item>Last modified</Item>\r\n                    </Menu>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </>);\r\n    }\r\n\r\n    const CatalogSide = (props: ChildrenType) => {\r\n        return (\r\n            <div className={'catalog'}>\r\n                {props.children}\r\n            </div>\r\n        );\r\n    }\r\n\r\n\r\n    type CatalogType = {\r\n        projects: LProject[];\r\n    }\r\n\r\n    const CatalogReport = (props: CatalogType) =>{\r\n\r\n        let items_public: LProject[] = [];\r\n        let items_private: LProject[] = [];\r\n        let items_collaborative: LProject[] = [];\r\n\r\n\r\n        if (filters[0]) {\r\n            items_public = props.projects.filter(p => p.type === \"public\");\r\n        }\r\n        if (filters[1]) {\r\n            items_private = props.projects.filter(p => p.type === \"private\");\r\n        }\r\n        if (filters[2]) {\r\n            items_collaborative = props.projects.filter(p => p.type === \"collaborative\");\r\n        }\r\n\r\n        //var items  = items_public.concat(items_private,items_collaborative);\r\n\r\n        var items = props.projects.filter(p =>\r\n            (filters[0] && p.type ===\"public\" || filters[1] && p.type ===\"private\" || filters[2] && p.type ===\"collaborative\" || !filters[0] && !filters[1] && !filters[2]));\r\n\r\n        return (\r\n\r\n            mode == \"cards\" ?\r\n\r\n            <div style={{display: (items.length > 0) ? 'flex' : 'flex'}} className={'flex-wrap'} >\r\n\r\n                {items.length === 0 && <div>Sorry, there are no results matching your search criteria. Please try again with different filters.</div>}\r\n\r\n                {\r\n                    props.projects.map(p => <>\r\n                        {filters[0] && p.type === \"public\" && <Project key={p.id} data={p} mode={mode} />}\r\n                        {filters[1] && p.type === \"private\" && <Project key={p.id} data={p} mode={mode} />}\r\n                        {filters[2] && p.type === \"collaborative\" && <Project key={p.id} data={p} mode={mode} />}\r\n                        {!filters[0] && !filters[1] && !filters[2] && <Project key={p.id} data={p} mode={mode} />}\r\n                    </>)\r\n                }\r\n\r\n            </div>\r\n\r\n            :\r\n            <div className={'row project-list'}>\r\n                <div className='row header'>\r\n                    <div className={'col-6'}>Name</div><div className={'col-3'}>Last modified</div><div className={'col-3'}>Created</div>\r\n                </div>\r\n                {\r\n                    props.projects.map(p => <>\r\n                        {filters[0] && p.type === \"public\" && <Project key={p.id} data={p} mode={mode} />}\r\n                        {filters[1] && p.type === \"private\" && <Project key={p.id} data={p} mode={mode} />}\r\n                        {filters[2] && p.type === \"collaborative\" && <Project key={p.id} data={p} mode={mode} />}\r\n                        {!filters[0] && !filters[1] && !filters[2] && <Project key={p.id} data={p} mode={mode} />}\r\n                    </>)\r\n                }\r\n            </div>\r\n\r\n        );\r\n    };\r\n\r\n    return (\r\n        <div>\r\n            <Header>\r\n                <CatalogFilters/>\r\n                <CatalogMode/>\r\n            </Header>\r\n            <CatalogSide>\r\n                <CatalogInfoCard projects={props.projects}/>\r\n                <CatalogReport projects={props.projects}/>\r\n            </CatalogSide>\r\n        </div>\r\n    );\r\n}\r\n\r\nfunction AllProjectsComponent(props: AllProps): JSX.Element {\r\n    const {projects} = props;\r\n\r\n    const reader = new FileReader();\r\n    reader.onload = async e => {\r\n        /* Import Project File */\r\n        const content = String(e.target?.result);\r\n        if(!content) return;\r\n        try {\r\n            const project = JSON.parse(content) as DProject;\r\n            const projects = Storage.read<DProject[]>('projects') || [];\r\n            const filtered = projects.filter(p => p.id !== project.id);\r\n            filtered.push(project);\r\n            Storage.write('projects', filtered);\r\n            U.resetState();\r\n        } catch (e) {alert('Invalid File.')}\r\n    }\r\n\r\n    const importProject = async(e: ChangeEvent<HTMLInputElement>) => {\r\n        const files = e.target.files || [];\r\n        if(!files.length) return;\r\n        const file = files[0];\r\n        reader.readAsText(file);\r\n    }\r\n\r\n\r\n\r\n\r\n    return(<Try>\r\n        <Dashboard active={'Notes'} version={props.version}>\r\n\r\n            <React.Fragment>\r\n\r\n                <Cards>\r\n                    <Cards.Item\r\n                        title={'Clone a template'}\r\n                        subtitle={'Clone a template in your workspace.'}\r\n                        icon={'clone'}\r\n                        style={'rainbow'}\r\n                    />\r\n                    {true && <Cards.Item icon={'question'} style={'clear'} title={'Ehy!'} subtitle={'What do you want to do today?'}/>}\r\n                </Cards>\r\n\r\n                <Catalog projects={projects} />\r\n            </React.Fragment>\r\n\r\n        </Dashboard>\r\n    </Try>);\r\n}\r\n\r\ninterface OwnProps {}\r\ninterface StateProps {\r\n    projects: LProject[];\r\n    version: DState[\"version\"];\r\n}\r\ninterface DispatchProps {}\r\n\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as FakeStateProps;\r\n    ret.projects = LProject.fromArr(state.projects);\r\n    ret.version = state.version;\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\nconst AllProjectsConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(AllProjectsComponent);\r\n\r\nconst NotesPage = (props: OwnProps, children: (string | Component)[] = []): ReactElement => {\r\n    return <AllProjectsConnected {...{...props, children}} />;\r\n}\r\n\r\nexport {NotesPage};\r\n\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\Recent.tsx",["927","928"],"import React, {ChangeEvent, MouseEventHandler, Component, Dispatch, ReactElement, useState, useRef } from 'react';\r\nimport {connect} from 'react-redux';\r\nimport {DProject, DState, LProject, Try, U} from '../joiner';\r\nimport {FakeStateProps} from '../joiner/types';\r\nimport {Dashboard, Project} from './components';\r\nimport Storage from \"../data/storage\";\r\n\r\nimport {Menu, Item, Divisor} from './components/menu/Menu';\r\nimport { Cards, Card } from './components/cards/Cards';\r\nimport { Catalog } from './components/catalog/Catalog';\r\n\r\nimport colors from '../static/img/colors.png';\r\n\r\n\r\nfunction AllProjectsComponent(props: AllProps): JSX.Element {\r\n    const {projects} = props;\r\n\r\n    const reader = new FileReader();\r\n    reader.onload = async e => {\r\n        /* Import Project File */\r\n        const content = String(e.target?.result);\r\n        if(!content) return;\r\n        try {\r\n            const project = JSON.parse(content) as DProject;\r\n            const projects = Storage.read<DProject[]>('projects') || [];\r\n            const filtered = projects.filter(p => p.id !== project.id);\r\n            filtered.push(project);\r\n            Storage.write('projects', filtered);\r\n            U.resetState();\r\n        } catch (e) {alert('Invalid File.')}\r\n    }\r\n    \r\n    const importProject = async(e: ChangeEvent<HTMLInputElement>) => {\r\n        const files = e.target.files || [];\r\n        if(!files.length) return;\r\n        const file = files[0];\r\n        reader.readAsText(file);\r\n    }\r\n\r\n\r\n\r\n\r\n    return(<Try>\r\n        <Dashboard active={'Recent'} version={props.version}>\r\n            \r\n            <React.Fragment>                \r\n\r\n                <Cards>\r\n                    <Cards.Item\r\n                        title={'Need help?'} \r\n                        subtitle={'Don\\' ask Alexa, click here instead.'}\r\n                        icon={'alexa'} \r\n                        style={'red-orange'}   \r\n                    />\r\n                    {false && <Cards.Item icon={'question'} style={'clear'} title={'Ehy!'} subtitle={'What do you want to do today?'}/>}\r\n                </Cards>\r\n\r\n                <Catalog projects={projects} />\r\n            </React.Fragment>\r\n            \r\n        </Dashboard>\r\n    </Try>);\r\n}\r\n\r\ninterface OwnProps {}\r\ninterface StateProps {\r\n    projects: LProject[];\r\n    version: DState[\"version\"];\r\n}\r\ninterface DispatchProps {}\r\n\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as FakeStateProps;\r\n    ret.projects = LProject.fromArr(state.projects);\r\n    ret.version = state.version;\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\nconst AllProjectsConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(AllProjectsComponent);\r\n\r\nconst RecentPage = (props: OwnProps, children: (string | Component)[] = []): ReactElement => {\r\n    return <AllProjectsConnected {...{...props, children}} />;\r\n}\r\n\r\nexport {RecentPage};\r\n\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\Error.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\Templates.tsx",["929","930","931","932","933","934","935","936","937","938","939"],"import React, {ChangeEvent, MouseEventHandler, Component, Dispatch, ReactElement, useState, useRef } from 'react';\r\nimport {connect} from 'react-redux';\r\nimport {DProject, DState, LProject, Try, U} from '../joiner';\r\nimport {FakeStateProps} from '../joiner/types';\r\nimport {Dashboard, Project} from './components';\r\nimport Storage from \"../data/storage\";\r\n\r\nimport {Menu, Item, Divisor} from './components/menu/Menu';\r\n\r\nimport colors from '../static/img/colors.png';\r\nimport {CatalogInfoCard} from \"./components/catalog/Catalog\";\r\n\r\n\r\n\r\ntype CardsType = {\r\n    children: any;\r\n};\r\n\r\nconst Cards = (props: CardsType): any => {\r\n    return (\r\n        <React.Fragment>\r\n            <div className='row mb-5 commandbar'>\r\n                {props.children}\r\n            </div>\r\n        </React.Fragment>\r\n    );\r\n}\r\n\r\ntype CardType = {\r\n    icon: \"add\" | \"import\" | \"clone\" | \"question\";\r\n    style?: \"blue\" | \"red\" | \"dark\" | \"clear\" | \"rainbow\" | \"default\";\r\n    title: string;\r\n    subtitle: string;\r\n    action?: MouseEventHandler;\r\n    children?: JSX.Element[];\r\n};\r\n\r\nconst Card = (props: CardType) => {\r\n\r\n    const icons = {\r\n        add: \"bi-plus-circle\",\r\n        import: \"bi-box-arrow-in-up\",\r\n        question: \"bi-question-square\",\r\n        clone: \"bi-clipboard2-check\"\r\n    };\r\n\r\n    return (<>\r\n        <div className={`card ${props.style ? props.style : 'default' }`}>\r\n            <div className={'col icon'}>\r\n                {props.action ?\r\n                    <i onClick={props.action} className={`bi ${icons[props.icon]}`}></i> :\r\n                    <i className={`bi ${icons[props.icon]} disabled`}></i>\r\n                }\r\n            </div>\r\n            <div className={'col body'}>\r\n                <h5>{props.title}</h5>\r\n                {props.subtitle}\r\n            </div>\r\n        </div>\r\n        </>\r\n    );\r\n}\r\n\r\nCards.Item = Card;\r\n\r\ntype ChildrenType = {\r\n    projects?: any;\r\n    children?: JSX.Element[];\r\n};\r\n\r\n\r\n/* main component */\r\n\r\nconst Catalog = (props: ChildrenType) => {\r\n\r\n    const [filters, setFilters] = useState([false,false,false]);\r\n    const [mode, setMode] = useState<string>(\"cards\");\r\n\r\n    const Header = (props: ChildrenType) => {\r\n        return (\r\n            <div className='row catalog-header'>\r\n                {props.children}\r\n            </div>\r\n        );\r\n    }\r\n\r\n    const CatalogFilters = () => {\r\n\r\n        function toggleFilters(el: 0|1|2) {\r\n            switch(el) {\r\n                case 0:\r\n                    setFilters([!filters[0], filters[1], filters[2]]);\r\n                    break;\r\n                case 1:\r\n                    setFilters([filters[0], !filters[1], filters[2]]);\r\n                    break;\r\n                case 2:\r\n                    setFilters([filters[0], filters[1], !filters[2]]);\r\n                    break;\r\n            }\r\n        };\r\n\r\n        return (\r\n            <div className={'col left'}>\r\n                {filters[0] ? <button onClick={(e) => toggleFilters(0)} className='active'>public</button> : <button onClick={(e) => toggleFilters(0)}>public</button>}\r\n                {filters[1] ? <button onClick={(e) => toggleFilters(1)} className='active'>private</button> : <button onClick={(e) => toggleFilters(1)}>private</button>}\r\n                {filters[2] ? <button onClick={(e) => toggleFilters(2)} className='active'>collaborative</button> : <button onClick={(e) => toggleFilters(2)} >collaborative</button>}\r\n            </div>\r\n        );\r\n    }\r\n\r\n    const CatalogMode = () => { // unused component?\r\n        return (<>\r\n            <div className={'col left'}>\r\n                <div className=\"float-end\">sorted by\r\n                    <div className={'view-icons'}>\r\n                        <i onClick={(e) => setMode('cards')} className={`bi bi-grid ${mode === \"cards\" && 'selected'}`}></i>\r\n                        <i onClick={(e) => setMode('list')} className={`bi bi-list ${mode === \"list\" && 'selected'}`}></i>\r\n                    </div>\r\n                    <div style={{float: 'right'}}>\r\n                    <Menu position={'left'}>\r\n                        <Item action={(e)=> {alert('')}}>Alphabetical</Item>\r\n                        <Item>Date created</Item>\r\n                        <Item>Last modified</Item>\r\n                    </Menu>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </>);\r\n    }\r\n\r\n    const CatalogSide = (props: ChildrenType) => {\r\n        return (\r\n            <div className={'catalog'}>\r\n                {props.children}\r\n            </div>\r\n        );\r\n    }\r\n\r\n\r\n    type CatalogType = {\r\n        projects: LProject[];\r\n    }\r\n\r\n    const CatalogReport = (props: CatalogType) =>{\r\n\r\n        let items_public: LProject[] = [];\r\n        let items_private: LProject[] = [];\r\n        let items_collaborative: LProject[] = [];\r\n\r\n\r\n        if (filters[0]) {\r\n            items_public = props.projects.filter(p => p.type === \"public\");\r\n        }\r\n        if (filters[1]) {\r\n            items_private = props.projects.filter(p => p.type === \"private\");\r\n        }\r\n        if (filters[2]) {\r\n            items_collaborative = props.projects.filter(p => p.type === \"collaborative\");\r\n        }\r\n\r\n        //var items  = items_public.concat(items_private,items_collaborative);\r\n\r\n        var items = props.projects.filter(p =>\r\n            (filters[0] && p.type ===\"public\" || filters[1] && p.type ===\"private\" || filters[2] && p.type ===\"collaborative\" || !filters[0] && !filters[1] && !filters[2]));\r\n\r\n        return (\r\n\r\n            mode == \"cards\" ?\r\n\r\n            <div style={{display: (items.length > 0) ? 'flex' : 'flex'}} className={'flex-wrap'} >\r\n\r\n                {items.length === 0 && <div>Sorry, there are no results matching your search criteria. Please try again with different filters.</div>}\r\n\r\n                {\r\n                    props.projects.map(p => <>\r\n                        {filters[0] && p.type === \"public\" && <Project key={p.id} data={p} mode={mode} />}\r\n                        {filters[1] && p.type === \"private\" && <Project key={p.id} data={p} mode={mode} />}\r\n                        {filters[2] && p.type === \"collaborative\" && <Project key={p.id} data={p} mode={mode} />}\r\n                        {!filters[0] && !filters[1] && !filters[2] && <Project key={p.id} data={p} mode={mode} />}\r\n                    </>)\r\n                }\r\n\r\n            </div>\r\n\r\n            :\r\n            <div className={'row project-list'}>\r\n                <div className='row header'>\r\n                    <div className={'col-6'}>Name</div><div className={'col-3'}>Last modified</div><div className={'col-3'}>Created</div>\r\n                </div>\r\n                {\r\n                    props.projects.map(p => <>\r\n                        {filters[0] && p.type === \"public\" && <Project key={p.id} data={p} mode={mode} />}\r\n                        {filters[1] && p.type === \"private\" && <Project key={p.id} data={p} mode={mode} />}\r\n                        {filters[2] && p.type === \"collaborative\" && <Project key={p.id} data={p} mode={mode} />}\r\n                        {!filters[0] && !filters[1] && !filters[2] && <Project key={p.id} data={p} mode={mode} />}\r\n                    </>)\r\n                }\r\n            </div>\r\n\r\n        );\r\n    };\r\n\r\n    return (\r\n        <div>\r\n            <Header>\r\n                <CatalogFilters/>\r\n                <CatalogMode/>\r\n            </Header>\r\n            <CatalogSide>\r\n                <CatalogInfoCard projects={props.projects}/>\r\n                <CatalogReport projects={props.projects}/>\r\n            </CatalogSide>\r\n        </div>\r\n    );\r\n}\r\n\r\nfunction AllProjectsComponent(props: AllProps): JSX.Element {\r\n    const {projects} = props;\r\n\r\n    const reader = new FileReader();\r\n    reader.onload = async e => {\r\n        /* Import Project File */\r\n        const content = String(e.target?.result);\r\n        if(!content) return;\r\n        try {\r\n            const project = JSON.parse(content) as DProject;\r\n            const projects = Storage.read<DProject[]>('projects') || [];\r\n            const filtered = projects.filter(p => p.id !== project.id);\r\n            filtered.push(project);\r\n            Storage.write('projects', filtered);\r\n            U.resetState();\r\n        } catch (e) {alert('Invalid File.')}\r\n    }\r\n\r\n    const importProject = async(e: ChangeEvent<HTMLInputElement>) => {\r\n        const files = e.target.files || [];\r\n        if(!files.length) return;\r\n        const file = files[0];\r\n        reader.readAsText(file);\r\n    }\r\n\r\n\r\n\r\n\r\n    return(<Try>\r\n        <Dashboard active={'Templates'} version={props.version}>\r\n\r\n            <React.Fragment>\r\n\r\n                <Cards>\r\n                    <Cards.Item\r\n                        title={'Clone a template'}\r\n                        subtitle={'Clone a template in your workspace.'}\r\n                        icon={'clone'}\r\n                        style={'rainbow'}\r\n                    />\r\n                    {true && <Cards.Item icon={'question'} style={'clear'} title={'Ehy!'} subtitle={'What do you want to do today?'}/>}\r\n                    \r\n                </Cards>\r\n\r\n                <Catalog projects={projects} />\r\n            </React.Fragment>\r\n\r\n        </Dashboard>\r\n    </Try>);\r\n}\r\n\r\ninterface OwnProps {}\r\ninterface StateProps {\r\n    projects: LProject[];\r\n    version: DState[\"version\"];\r\n}\r\ninterface DispatchProps {}\r\n\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as FakeStateProps;\r\n    ret.projects = LProject.fromArr(state.projects);\r\n    ret.version = state.version;\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\nconst AllProjectsConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(AllProjectsComponent);\r\n\r\nconst TemplatePage = (props: OwnProps, children: (string | Component)[] = []): ReactElement => {\r\n    return <AllProjectsConnected {...{...props, children}} />;\r\n}\r\n\r\nexport {TemplatePage};\r\n\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\News.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\UsersInfo.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\ProjectsInfo.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\graph\\vertex\\Vertex.tsx",["940","941"],"import React, {Dispatch, ReactElement, ReactNode} from 'react';\r\nimport {connect} from 'react-redux';\r\nimport {\r\n    Debug,\r\n    DEdgePoint,\r\n    DGraph,\r\n    DGraphElement,\r\n    DGraphVertex,\r\n    DState, DUser,\r\n    DVertex, DViewElement,\r\n    DVoidVertex,\r\n    EMeasurableEvents,\r\n    GObject,\r\n    GraphElementComponent,\r\n    GraphElementDispatchProps,\r\n    GraphElementOwnProps,\r\n    GraphElementReduxStateProps,\r\n    GraphElementStatee,\r\n    GraphPoint,\r\n    GraphSize,\r\n    LClass, LGraph, LGraphElement,\r\n    LModelElement, LNamedElement,\r\n    Log,\r\n    LPointerTargetable,\r\n    LUser, LViewElement,\r\n    LViewPoint,\r\n    LVoidVertex, Pointer,\r\n    RuntimeAccessibleClass,\r\n    SetRootFieldAction,\r\n    Size,\r\n    TRANSACTION,\r\n    U,\r\n} from '../../joiner';\r\nimport $ from 'jquery';\r\nimport 'jqueryui';\r\nimport 'jqueryui/jquery-ui.css';\r\nimport { lightModeAllowedElements } from '../graphElement/graphElement';\r\nimport ContextMenu from \"../../components/contextMenu/ContextMenu\";\r\nimport {VertexOwnProps, VertexStateProps} from '../graphElement/sharedTypes/sharedTypes';\r\n\r\nconst superclassGraphElementComponent: typeof GraphElementComponent = RuntimeAccessibleClass.classes.GraphElementComponent as any as typeof GraphElementComponent;\r\nclass ThisStatee extends GraphElementStatee { forceupdate?: number }\r\n\r\nconst dragHelper = document.createElement('div');\r\ndragHelper.style.backgroundColor = 'transparent';\r\ndragHelper.style.outline = '1px dashed black'; // '4px dashed #333';\r\ndragHelper.style.zIndex = '9999';\r\n\r\n\r\nexport class VertexComponent<AllProps extends AllPropss = AllPropss, ThisState extends ThisStatee = ThisStatee>\r\n    extends superclassGraphElementComponent<AllProps, ThisState> {\r\n    public static cname: string = 'VertexComponent';\r\n    static defaultProps: Partial<VertexOwnProps> = VertexOwnProps.new();\r\n    draggableOptions: GObject | undefined;\r\n    resizableOptions: GObject | undefined;\r\n    rotableOptions: GObject | undefined;\r\n\r\n    constructor(props: AllProps, context: any) {\r\n        super(props, context);\r\n        this.getSize = this.getSize.bind(this);\r\n        this.setSize = this.setSize.bind(this);\r\n        // this.state={forceupdate:1};\r\n        /*// remove this?\r\n        setTimeout(()=>{\r\n            this.getSize = this.getSize.bind(this);\r\n            this.setSize = this.setSize.bind(this);\r\n            // this.get_size = console.error as any;\r\n            // this.r = (<RootVertex props={this.props} render={super.render()} super={this} />);\r\n            this.forceUpdate();\r\n            this.setState({forceupdate:2});\r\n        },1)*/\r\n    }\r\n/*\r\n    onViewChangeOld(): void {\r\n        super.onViewChangeOld();\r\n        this.draggableOptions = undefined;\r\n        this.resizableOptions = undefined;\r\n        this.rotableOptions = undefined;\r\n    }*/\r\n\r\n    onHtmlNodeChange(){\r\n        this.draggableOptions = undefined;\r\n        this.resizableOptions = undefined;\r\n        this.rotableOptions = undefined;\r\n        this.oldHtml = this.html.current;\r\n    }\r\n\r\n    setVertexProperties(){\r\n        if (!this.props.node || !this.html.current) return;\r\n        switch (this.nodeType){\r\n            case 'GraphVertex':\r\n            case 'Vertex':\r\n            case 'VoidVertex':\r\n            case 'EdgePoint': break;\r\n            default: return;\r\n        }\r\n\r\n        let html = this.html.current;\r\n        const $measurable: GObject<'JQuery + ui plugin'> = $(html); // todo: install typings\r\n\r\n        let view: LViewElement = this.props.view;\r\n        let isDraggable: boolean = view.draggable;\r\n        let isResizable: boolean = view.resizable;\r\n        let allviews: Pointer<DViewElement>[] = [view, ...this.props.views].map(v=>v.id);\r\n        // $element = $(html).find('.measurable').addBack();\r\n        try {\r\n        if (!isDraggable) {\r\n            if ($measurable.data(\"uiDraggable\")) $measurable.draggable('disable');\r\n        }\r\n        else if (this.draggableOptions) {\r\n            if ($measurable.data(\"uiDraggable\")) $measurable.draggable('enable');\r\n            // NB: this check is to see if draggable has been setup. i think if 2 refreshes happens to fast it can\r\n            // happen that this.draggableOptions i set, but jqui didn't set up the draggable infos and throws warnings.\r\n        }\r\n        else {\r\n            // first setup only\r\n            this.draggableOptions = {\r\n                cursor: 'grabbing',\r\n                cancel: '.no-drag,[contenteditable=\"true\"],input,textarea,button,select,option',\r\n                // cancel: '.no-drag,input,textarea,button,select,option',\r\n                containment: 'parent',\r\n                opacity: 0.0,\r\n                disabled: !(isDraggable), // this does not work, i think because once set the first time the whole declaration is not re-applied. would need to undo draggable\r\n                distance: 5,\r\n                helper: () => { // or 'clone'\r\n                    // dragHelper.style.display='block';\r\n                    let size = this.getSize();\r\n                    // let actualSize = Size.of(html);\r\n                    // if (size.w !== actualSize.w || size.h !== actualSize.h) this.setSize({w:actualSize.w, h:actualSize.h});\r\n                    dragHelper.style.width = size.w + 'px';\r\n                    dragHelper.style.height = size.h + 'px';\r\n                    dragHelper.style.opacity = '1'; // this.props.view.constraints.length ? '1' : '0.5';\r\n                    if (this.props.view.lazySizeUpdate) dragHelper.classList.add('lazySizeUpdate');\r\n                    else dragHelper.classList.remove('lazySizeUpdate');\r\n                    return dragHelper;\r\n                },\r\n                // disabled: !(view.draggable),\r\n                start: (event: GObject, obj: GObject) => {\r\n                    TRANSACTION('Vertex dragStart ' + this.props.node.name, ()=> {\r\n                        for (let vid of allviews) this.doMeasurableEvent(EMeasurableEvents.onDragStart, vid);\r\n                    })\r\n                },\r\n                drag: (event: GObject, obj: GObject) => {\r\n                    TRANSACTION('Vertex dragging ' + this.props.node.name, ()=>{\r\n                        // console.log('Vertex.setsize', obj);\r\n                        if (!this.props.view.lazySizeUpdate) this.setSize({x:obj.position.left, y:obj.position.top});\r\n                        for (let vid of allviews) this.doMeasurableEvent(EMeasurableEvents.whileDragging, vid);\r\n                    })\r\n                },\r\n                stop: (event: GObject, obj: GObject) => {\r\n                    TRANSACTION('Vertex dragEnd ' + this.props.node.name, ()=>{\r\n                        this.setSize({x:obj.position.left, y:obj.position.top});\r\n                        for (let vid of allviews) this.doMeasurableEvent(EMeasurableEvents.onDragEnd, vid);\r\n                    })\r\n                }\r\n            };\r\n            $measurable.draggable(this.draggableOptions);\r\n        }\r\n        } catch(e) {\r\n            this.draggableOptions = undefined;\r\n            Log.ee(\"failed to setup / update draggable uptions\", e, this, this.props.node, this.props.data);\r\n            return;\r\n            // might throw error if element is not visible or in the dom or similar, but i won't care in that case.\r\n            // but i reset draggableOptions so it can retry later if element enters the DOM instead of thinking it is already finished setup\r\n        }\r\n\r\n        try{\r\n        if (!isResizable) {\r\n            if ($measurable.data(\"uiResizable\")) $measurable.resizable('disable');\r\n        }\r\n        else if (this.resizableOptions) {\r\n            if ($measurable.data(\"uiResizable\")) $measurable.resizable('enable');\r\n        }\r\n        if (!this.resizableOptions) {\r\n            this.resizableOptions = {\r\n                helper: 'selected-by-me',\r\n                start: (event: GObject, obj: GObject) => {\r\n                    TRANSACTION('onResizeStart events ' + this.props.node.name, ()=>{\r\n                        if (!this.props.node.isResized) this.props.node.isResized = true; // set only on manual resize, so here and not on setSize()\r\n                        for (let vid of allviews) this.doMeasurableEvent(EMeasurableEvents.onResizeStart, vid);\r\n                    })\r\n                },\r\n                resize: (event: GObject, obj: GObject) => {\r\n                    TRANSACTION('resizing events ' + this.props.node.name, ()=>{\r\n                        if (!this.props.view.lazySizeUpdate) this.setSize({w:obj.position.width, h:obj.position.height});\r\n                        for (let vid of allviews) this.doMeasurableEvent(EMeasurableEvents.whileResizing, vid);\r\n                    })\r\n                },\r\n                stop: (event: GObject, obj: GObject) => {\r\n                    if (!this.state.classes.includes('resized')) this.setState({classes:[...this.state.classes, 'resized']});\r\n                    // if (!withSetSize) { node.width = obj.size.width; node.height = obj.size.height; } else {\r\n                    let absolutemode = true; // this one is less tested and safe, but should work even if html container is sized 0. best if made to work\r\n                    let newSize: Partial<GraphSize>;\r\n                    if (absolutemode) {\r\n                        let nativeevt: MouseEvent = event.originalEvent.originalEvent;\r\n                        let htmlSize = Size.of(event.target, false);\r\n                        newSize = this.props.node.graph.translateHtmlSize(htmlSize);\r\n                        /*n\r\n                        this is some pixels off, i think because inner coords are post the border of the container element,\r\n                         and the innermost graph size have coords before his borders, so the translation is off by the amount\r\n                          of border width of the innermost graph (and package default view does have a border)\r\n                           so in graph coord translate function should add: outersize.add( x: innergraph.html.getFinalComputedCSS('border-width-left'), y: ...border-width-top\r\n\r\n                    let cursorSize = new GraphSize(0, 0, nativeevt.clientX, nativeevt.clientY);//\r\n                    newSize = htmlSize.duplicate() as any; // .subtract( {w:cursorSize.x, h:cursorSize.y}, true);\r\n                    let handleClasses: string[] = [...event.originalEvent.target.classList];\r\n                    let handleKeyLength = 14; // equal to 'ui-resizable-'.length + 1;\r\n                    let handleClassName = handleClasses.find( // i check both length and indexOf, because i must match 'ui-resizable-se' but not 'ui-resizable-handle'\r\n                        (e) => (e.length === handleKeyLength || e.length === handleKeyLength + 1) && e.indexOf('ui-resizable-')===0);\r\n\r\n                        let handleType = handleClassName ? handleClassName.substring(13) : '';\r\n                        switch (handleType) {\r\n                            default: case '': case 'se':\r\n                                delete newSize.x;\r\n                                delete newSize.y;\r\n                                newSize.w = cursorSize.w - htmlSize.x;\r\n                                newSize.h = cursorSize.h - htmlSize.y;\r\n                                break;\r\n                            case 'n': case 's':\r\n                                delete newSize.x;\r\n                                delete newSize.y;\r\n                                delete newSize.w;\r\n                                newSize.h = cursorSize.h - htmlSize.y;\r\n                                break;\r\n                            case 'e': case 'W':\r\n                                delete newSize.x;\r\n                                delete newSize.y;\r\n                                newSize.w = cursorSize.w - htmlSize.x;\r\n                                delete newSize.h;\r\n                                break;\r\n                            case 'nw':\r\n                                let br = htmlSize.br();\r\n                                newSize.x = cursorSize.x;\r\n                                newSize.y = cursorSize.y;\r\n                                newSize.w = br.x - cursorSize.w;\r\n                                newSize.h = br.y - cursorSize.h;\r\n                                break;\r\n                            case 'ne':\r\n                                delete newSize.x;\r\n                                newSize.y = cursorSize.y;\r\n                                delete newSize.w;\r\n                                delete newSize.h;\r\n                            case '?':\r\n                                delete newSize.x;\r\n                                delete newSize.y;\r\n                                delete newSize.w;\r\n                                delete newSize.h;\r\n                                break;\r\n                        }*/\r\n                        // n, e, s, w, ne, se, sw, nw\r\n                        console.log('resizing', {newSize, htmlSize, event, nativeevt, sizeof_with_transforms: Size.of(event.target, true)});\r\n                        // NB: size.x and size.y are going crazy if the element have an edge, no idea why, i just deleted x & y before setSize()\r\n                    }\r\n                    else newSize = {w:obj.size.width, h:obj.size.height};\r\n                    // evt coordinates: clientX, layerX, offsetX, pageX, screenX\r\n                    TRANSACTION('onResizeEnd events ' + this.props.node.name, ()=>{/*\r\n                        delete newSize.x;\r\n                        delete newSize.y;*/\r\n                        this.setSize(newSize);\r\n                        // console.log('resize setsize:', obj, {w:obj.size.width, h:obj.size.height});\r\n                        for (let vid of allviews) this.doMeasurableEvent(EMeasurableEvents.onResizeEnd, vid);\r\n                    })\r\n\r\n                }\r\n            }\r\n            $measurable.resizable(this.resizableOptions);\r\n        }\r\n        } catch(e){\r\n            // check draggable catch comment\r\n            this.resizableOptions = undefined;\r\n            Log.ee(\"failed to setup / update resizable uptions\", e, this, this.props.node, this.props.data);\r\n            return;\r\n        }\r\n\r\n        try{\r\n            // edit dynamic draggable options post-setup\r\n            if (this.draggableOptions) {\r\n                // none so far?\r\n            }\r\n            // edit dynamic resizable options post-setup\r\n            if (this.resizableOptions) {\r\n                let lazySizeUpdate = view.lazySizeUpdate;\r\n                let containment = lazySizeUpdate ? false : 'parent';\r\n                let helper = lazySizeUpdate ? 'resizable-helper-bad' : 'original';\r\n                // helper does not accept a func or htmlElem, but only a classname...\r\n                // and makes his own empty proxy element to resize in his place. inchoherent.\r\n                if (this.resizableOptions?.containment !== containment){\r\n                    this.resizableOptions.containment = containment;\r\n                    $measurable.draggable( 'option', 'containment', containment);\r\n                }\r\n                if (this.resizableOptions?.helper !== helper){\r\n                    this.resizableOptions.helper = helper;\r\n                    $measurable.resizable( 'option', 'helper', helper);\r\n                }\r\n            }\r\n        } catch(e) {\r\n            // check draggable catch comment\r\n            this.draggableOptions = undefined;\r\n            this.resizableOptions = undefined;\r\n            this.rotableOptions = undefined;\r\n            Log.ee(\"failed to update measurable uptions\", e, this, this.props.node, this.props.data);\r\n            return;\r\n        }\r\n    }\r\n\r\n\r\n\r\n    getSize(): Readonly<GraphSize> {\r\n        return this.props.node.getSize(false, !this.props.node.isResized && this.props.view.adaptWidth);\r\n        /*console.log('get_size('+(this.props?.data as any).name+')', {\r\n            view:this.props.view.getSize(this.props.dataid || this.props.nodeid as string),\r\n            node:this.props.node?.size,\r\n            default: this.props.view.defaultVSize});*/\r\n        let ret = this.props.view.getSize(this.props.data?.id || this.props.nodeid as string)\r\n            || this.props.node?.size\r\n            || this.props.view.defaultVSize;\r\n        if (this.props.node.isResized) return ret;\r\n        let actualSize: Partial<Size>&{w:number, h:number} = this.html.current ? Size.of(this.html.current as Element) : {w:0, h:0};\r\n        if (this.props.view.adaptWidth && ret.w !== actualSize.w) {\r\n            this.setSize({w:actualSize.w});\r\n            ret.w = actualSize.w;\r\n        }\r\n        if (this.props.view.adaptHeight && ret.h !== actualSize.h) {\r\n            this.setSize({h:actualSize.h});\r\n            ret.h = actualSize.h;\r\n        }\r\n        return ret;\r\n    }\r\n    // setSize(x_or_size_or_point: number, y?: number, w?:number, h?:number): void;\r\n    setSize(x_or_size_or_point: Partial<GraphPoint>): void;\r\n    setSize(x_or_size_or_point: Partial<GraphSize>): void;\r\n    // setSize(x_or_size_or_point: number | GraphSize | GraphPoint, y?: number, w?:number, h?:number): void;\r\n    setSize(size0: Partial<GraphSize> | Partial<GraphPoint>): void {\r\n        let size: {x?:number, y?: number, w?:number, h?:number} = size0;\r\n        if (size.w !== undefined && size.w < 0) size.w = 0;\r\n        if (size.h !== undefined && size.h < 0) size.h = 0;\r\n\r\n        console.log('L.setsize', size, size0);\r\n        return this.props.node.size = size as any;\r\n        // console.log('setSize('+(this.props?.data as any).name+') thisss', this);\r\n        if (this.props.view.storeSize) {\r\n            let id = (this.props.data?.id || this.props.nodeid) as string;\r\n            this.props.view.updateSize(id, size);\r\n            return;\r\n        }\r\n        let olds = this.props.node.size;\r\n        size.x = size.x === undefined ? olds?.x : size.x;\r\n        size.y = size.y === undefined ? olds?.y : size.y;\r\n        size.w = size.w === undefined ? olds?.w : size.w;\r\n        size.h = size.h === undefined ? olds?.h : size.h;\r\n        this.props.node.size = size as GraphSize;\r\n    }\r\n\r\n    oldHtml?: Element | null = null;\r\n    nodeType!: string;\r\n    render(): ReactNode {\r\n        if (Debug.lightMode && (!this.props.data || !(lightModeAllowedElements.includes(this.props.data.className)))){\r\n            return this.props.data ? <div>{\" \" + ((this.props.data as any).name)}:{this.props.data.className}</div> : undefined;\r\n        }\r\n        if (!this.props.node) return 'Loading Node...';\r\n\r\n        if (this.html.current !== this.oldHtml){ this.onHtmlNodeChange(); }\r\n\r\n        const cssOverride: string[] = [];\r\n        // const selected = this.props.selected;\r\n        // if (selected && selected.id === this.props.nodeid) cssOverride.push('selected-by-me');\r\n\r\n        // if(!windoww.cpts) windoww.cpts = {};\r\n        // windoww.cpts[this.props.nodeid]=this;\r\n        // console.log('updated');\r\n        //return this.r || <div>loading...</div>;\r\n\r\n        // set classes\r\n        this.nodeType = 'NODE_TYPE_ERROR';\r\n        if ( this.props.isEdgePoint) this.nodeType = 'EdgePoint'; else\r\n        if ( this.props.isGraph &&  this.props.isVertex) this.nodeType = 'GraphVertex'; else\r\n        if ( this.props.isGraph && !this.props.isVertex) this.nodeType = 'Graph'; else\r\n        if (!this.props.isGraph &&  this.props.isVertex && (this.props.isVoid || !this.props.data)) this.nodeType = 'VoidVertex'; else\r\n        if (!this.props.isGraph &&  this.props.isVertex) this.nodeType = 'Vertex'; else\r\n        if (!this.props.isGraph && !this.props.isVertex) this.nodeType = 'Field';\r\n\r\n        // const named: LNamedElement = this.props.data as LNamedElement; // LNamedElement.fromPointer(this.props.dataid);\r\n        const classesOverride = [this.nodeType, ...cssOverride]; // , (named?.name === 'default') ? 'default' : ''];\r\n        const styleOverride: React.CSSProperties = {};\r\n        // set classes end\r\n        const size: Readonly<GraphSize> = this.getSize();\r\n\r\n        let isVertex: boolean= false, isEdge: boolean= false, isGraph: boolean = false;\r\n        switch (this.nodeType) {\r\n            case 'Graph': isGraph = true; break;\r\n            case 'GraphVertex': isGraph = isVertex = true; break;\r\n            case 'Vertex':\r\n            case 'VoidVertex':\r\n            case 'EdgePoint':\r\n                isVertex = true;\r\n                break;\r\n            default: break;\r\n        }\r\n\r\n        if (isGraph){\r\n            let offset = (this.props.node as any as LGraph).offset;\r\n            let zoom = (this.props.node as any as LGraph).zoom;\r\n            // @ts-ignore\r\n            styleOverride['--offset-x'] = offset.x + 'px';\r\n            // @ts-ignore\r\n            styleOverride['--offset-y'] = offset.y + 'px';\r\n            // @ts-ignore\r\n            styleOverride['--zoom-x'] = zoom.x;\r\n            // @ts-ignore\r\n            styleOverride['--zoom-y'] = zoom.y;\r\n        }\r\n        if (isVertex){\r\n            // @ts-ignore\r\n            styleOverride['--top'] = size.y + 'px';\r\n            // @ts-ignore\r\n            styleOverride['--left'] = size.x + 'px';\r\n            let isResized = this.props.node.isResized;\r\n            if (isResized || !this.props.view.adaptWidth) styleOverride.width = size.w+'px';\r\n            else styleOverride.width = undefined;\r\n            if (isResized || !this.props.view.adaptHeight) styleOverride.height = size.h+'px';\r\n            else styleOverride.height = undefined; // todo: the goal is to reset jqui inline style, but not override user-defined inline style\r\n        }\r\n\r\n\r\n        return super.render(this.nodeType, styleOverride, classesOverride);\r\n        // return <RootVertex props={this.props} render={super.render()} super={this} key={this.props.nodeid+'.'+this.state?.forceupdate} />;\r\n    }\r\n\r\n    select(forUser?: Pointer<DUser>): void{\r\n        super.select(forUser);\r\n    }\r\n    componentDidMount(){\r\n        this.setVertexProperties();\r\n    }\r\n    componentDidUpdate(prevProps: Readonly<AllProps>, prevState: Readonly<ThisState>, snapshot?: any) {\r\n        this.setVertexProperties();\r\n    }\r\n}\r\n\r\n\r\nclass DispatchProps extends GraphElementDispatchProps {\r\n}\r\n\r\nexport type AllPropss = VertexOwnProps & VertexStateProps & DispatchProps;\r\n\r\nfunction mapStateToProps(state: DState, ownProps: VertexOwnProps): VertexStateProps {\r\n    let DGraphElementClass: typeof DGraphElement;\r\n    if (ownProps.isEdgePoint) DGraphElementClass = DEdgePoint; else\r\n    if (ownProps.isVertex && ownProps.isGraph) DGraphElementClass = DGraphVertex; else\r\n    if (ownProps.isVertex && !ownProps.isGraph) DGraphElementClass = DVertex; else\r\n    if (!ownProps.isVertex && ownProps.isGraph) DGraphElementClass = DGraph;\r\n    else DGraphElementClass = DGraphElement; // DField;\r\n\r\n    if (DGraphElementClass === DVertex && ownProps.isVoid) DGraphElementClass = DVoidVertex;\r\n    const superret: VertexStateProps = GraphElementComponent.mapStateToProps(state, ownProps, DGraphElementClass, VertexStateProps.new()) as VertexStateProps;\r\n    // superret.lastSelected = state._lastSelected?.modelElement;\r\n    // superret.lastSelected = state._lastSelected ? LPointerTargetable.from(state._lastSelected.modelElement) : null;\r\n\r\n    // change current to correct user ID when authentication is implemented.\r\n    // const selected = state.selected[DUser.current];\r\n    // uperret.selected = (selected) ? LGraphElement.fromPointer(selected) : null;\r\n    /*  Uncomment this when we have user authentication.\r\n    superret.selected = {};\r\n    for(let user of Object.keys(selected)) {\r\n        const pointer = selected[user];\r\n        if (pointer) superret.selected[user] = LModelElement.fromPointer(pointer);\r\n        else superret.selected[user] = null;\r\n    }\r\n    */\r\n\r\n    superret.isEdgePending = {\r\n        user: LPointerTargetable.from(state.isEdgePending.user),\r\n        source: LPointerTargetable.from(state.isEdgePending.source)\r\n    };\r\n    // superret.viewpoint = LViewPoint.fromPointer(state.viewpoint);\r\n    /*const ret: VertexStateProps = VertexStateProps.new();\r\n    U.objectMergeInPlace(superret, ret);*/\r\n    U.removeEmptyObjectKeys(superret);\r\n    return superret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const superret: GraphElementDispatchProps = GraphElementComponent.mapDispatchToProps(dispatch);\r\n    const ret: GraphElementDispatchProps = new GraphElementDispatchProps();\r\n    U.objectMergeInPlace(superret, ret);\r\n    U.removeEmptyObjectKeys(superret);\r\n    return superret;\r\n}\r\nexport const VertexConnected = connect<VertexStateProps, DispatchProps, VertexOwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(VertexComponent as any);\r\n\r\nexport const Vertex = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => { //  children: (string | React.Component)[]\r\n    return <VertexConnected {...{...props, children}}\r\n        isGraph={false} isGraphVertex={false} isVertex={true} isEdgePoint={false} isField={false} isEdge={false} isVoid={false}/>;\r\n}\r\nexport const VoidVertex = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => {\r\n    return <VertexConnected {...{...props, children}}\r\n                            isGraph={false} isGraphVertex={false} isVertex={true} isEdgePoint={false} isField={false} isEdge={false} isVoid={true}/>;\r\n}\r\nexport const EdgePoint = function EdgePoint (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement {\r\n    return <VertexConnected {...{...props, children}}\r\n                            isGraph={false} isGraphVertex={false} isVertex={true} isEdgePoint={true} isField={false} isEdge={false} isVoid={false}/>;\r\n}\r\n// todo: name them all or verify the name is still usable.\r\n\r\nexport const Graph = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => {\r\n    return <VertexConnected {...{...props, children}}\r\n                            isGraph={true} isGraphVertex={false} isVertex={false} isEdgePoint={false} isField={false} isEdge={false} isVoid={false} />;\r\n}\r\n\r\nexport const GraphVertex = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => {\r\n    return <VertexConnected {...{...props, children}}\r\n                            isGraph={true} isGraphVertex={true} isVertex={true} isEdgePoint={false} isField={false} isEdge={false} isVoid={false}/>;\r\n}\r\n\r\nexport const Field = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => {\r\n    return <VertexConnected {...{...props, children}}\r\n                            isGraph={false} isGraphVertex={false} isVertex={false} isEdgePoint={false} isField={true} isEdge={false} isVoid={false} />;\r\n}\r\n(window as any).componentdebug = {Graph, GraphVertex, Field, Vertex, VoidVertex, EdgePoint, VertexConnected, VertexComponent};\r\n\r\n\r\nGraph.cname = 'Graph';\r\nGraphVertex.cname = 'GraphVertex';\r\nField.cname = 'Field';\r\nVertex.cname = 'Vertex';\r\nVoidVertex.cname = 'VoidVertex';\r\nEdgePoint.cname = 'EdgePoint';\r\n\r\n// GraphConnected.cname = 'GraphConnected';\r\n// GraphVertexConnected.cname = 'GraphVertexConnected';\r\n// FieldConnected.cname = 'FieldConnected';\r\nVertexConnected.cname = 'VertexConnected';\r\n// VoidVertexConnected.cname = 'VoidVertexConnected';\r\n// EdgePointConnected.cname = 'EdgePointConnected';\r\n\r\n// GraphComponent.cname = 'GraphComponent';\r\n// GraphVertexComponent.cname = 'GraphVertexComponent';\r\n// FieldComponent.cname = 'FieldComponent';\r\nVertexComponent.cname = 'VertexComponent';\r\n// VoidVertexComponent.cname = 'VoidVertexComponent';\r\n// EdgePointComponent.cname = 'EdgePointComponent';\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\graph\\damedges\\damedge.tsx",["942","943","944"],"import React, {Dispatch, ReactElement, ReactNode} from \"react\";\r\nimport {connect} from \"react-redux\";\r\nimport {\r\n    DEdge,\r\n    DGraph,\r\n    DGraphElement,\r\n    DGraphVertex, Dictionary,\r\n    DVoidVertex, EdgeBendingMode, GObject,\r\n    GraphElementComponent,\r\n    GraphElementDispatchProps,\r\n    GraphElementOwnProps,\r\n    GraphElementReduxStateProps,\r\n    GraphElementStatee, GraphPoint,\r\n    GraphSize,\r\n    DState,\r\n    LClass, LEdge, LGraphElement,\r\n    LModelElement,\r\n    LPointerTargetable,\r\n    LUser,\r\n    LVoidVertex, Overlap,\r\n    RuntimeAccessibleClass,\r\n    U,\r\n    EdgeOwnProps, EdgeStateProps,\r\n    LViewPoint, DModelElement, SetFieldAction, LVertex\r\n} from \"../../joiner\";\r\n\r\nlet groupingsize: Dictionary<EdgeBendingMode, number> = {} as any;\r\ngroupingsize[EdgeBendingMode.Line] = 1;\r\ngroupingsize[EdgeBendingMode.Bezier_quadratic] = 2;\r\ngroupingsize[EdgeBendingMode.Bezier_cubic] = 3;\r\n// groupingsize[EdgeBendingMode.Bezier_quadratic_mirrored] = 1;\r\n// groupingsize[EdgeBendingMode.Bezier_cubic_mirrored] = 2;\r\ngroupingsize[EdgeBendingMode.Elliptical_arc] = 2; // (1_coord), (rotation), (sweep    arc), (1_coord)\r\n\r\nconst superclassGraphElementComponent: typeof GraphElementComponent = RuntimeAccessibleClass.classes.GraphElementComponent as any as typeof GraphElementComponent;\r\nconst superclassGraphElementComponentuntyped: any = RuntimeAccessibleClass.classes.GraphElementComponent as any;\r\nclass ThisStatee extends GraphElementStatee {}\r\n\r\nexport class EdgeComponent<AllProps extends AllPropss = AllPropss, ThisState extends ThisStatee = ThisStatee>\r\n    extends superclassGraphElementComponent<AllProps, ThisState> {\r\n    public static cname: string = \"EdgeComponent\";\r\n    static defaultProps: Partial<EdgeOwnProps> = EdgeOwnProps.new();\r\n\r\n    constructor(props: AllProps, context: any) {\r\n        super(props, context);\r\n    }\r\n/*\r\n    path(): string {\r\n        let coords = this.pathCoords();\r\n        let svgletter: EdgeBendingMode = (this.props.view.bendingMode || \"L\");\r\n        let strings: string[] = coords.map(gp => gp.x+\" \" + gp.y);\r\n        return \"M\"+strings.join(\" \" + svgletter); }\r\n\r\n    pathCoords(): GraphPoint[] {\r\n        const ret = this.props;\r\n        let svgletter: EdgeBendingMode = (ret).view.bendingMode;\r\n        if (!ret.node) return []; // \"node missing\"\r\n        let coords: GraphPoint[] = (ret.node.midnodes as { x:number, y:number }[] as GraphPoint[]) || [];\r\n        let grouping = groupingsize[svgletter];\r\n        console.log(\"edgeee\", {coords, svgletter, groupingsize, midnodes:ret.node.midnodes, mnraw: ret.node.midnodes.map(mn=>mn.__raw), ret});\r\n        let scoord: GraphPoint = ret.node.startPoint || new GraphPoint(10, 10);\r\n        let ecoord: GraphPoint = ret.node.endPoint || new GraphPoint(100, 100);\r\n        return [scoord, ...coords, ecoord]; }\r\n\r\n    pathSegments(): GraphPoint[][]{\r\n        return U.pairArrayElements(this.pathCoords(), true); }\r\n*/\r\n    render(): ReactNode {\r\n        if (this.props.__skipRender) return null;\r\n        if (!this.props.node) return \"loading\";\r\n        // set classes\r\n        let nodeType = \"Edge\";\r\n        let classesoverride = [nodeType];\r\n        // set classes end\r\n        let styleoverride: React.CSSProperties = {}\r\n        return super.render(nodeType, styleoverride, classesoverride);\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\nclass DispatchProps extends GraphElementDispatchProps {\r\n}\r\n\r\ntype AllPropss = Overlap<Overlap<EdgeOwnProps, EdgeStateProps>, DispatchProps>;\r\n\r\nfunction mapStateToProps(state: DState, ownProps: EdgeOwnProps): EdgeStateProps {\r\n    let ret: EdgeStateProps = EdgeStateProps.new();\r\n    if (!ownProps.data && !ownProps.start || !ownProps.end) return {__skipRender: true} as any;\r\n    if (!ownProps.data) {\r\n        let lstart = LPointerTargetable.from(ownProps.start);\r\n        if (RuntimeAccessibleClass.extends(lstart.className, DModelElement.cname)) ret.data = lstart as any;\r\n    }\r\n    ret = GraphElementComponent.mapStateToProps(state, ownProps, DEdge, ret) as EdgeStateProps;\r\n    // superret.lastSelected = state._lastSelected ? LPointerTargetable.from(state._lastSelected.modelElement) : null;\r\n    ret.isEdgePending = {\r\n        user: LPointerTargetable.from(state.isEdgePending.user),\r\n        source: LPointerTargetable.from(state.isEdgePending.source)\r\n    };\r\n    let l: GObject;\r\n\r\n    if (ownProps.start){ l = LPointerTargetable.from(ownProps.start); if (l) ret.start = l as LVertex; }\r\n    if (ownProps.end){ l = LPointerTargetable.from(ownProps.end); if (l) ret.end = l as LVertex; }\r\n\r\n    U.removeEmptyObjectKeys(ret);\r\n    if (!ret.start || !ret.end) return {__skipRender: true} as any;\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const superret: GraphElementDispatchProps = GraphElementComponent.mapDispatchToProps(dispatch);\r\n    const ret: GraphElementDispatchProps = new GraphElementDispatchProps();\r\n    U.objectMergeInPlace(superret, ret);\r\n    U.removeEmptyObjectKeys(superret);\r\n    return superret;\r\n}\r\n\r\n\r\nexport const EdgeConnected = connect<EdgeStateProps, DispatchProps, EdgeOwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(EdgeComponent as any);\r\n\r\nexport const Edge = (props: EdgeOwnProps, children: (string | React.Component)[] = []): ReactElement => {\r\n    return <EdgeConnected {...{...props, children}}\r\n                          isGraph={false} isGraphVertex={false} isVertex={false} isEdgePoint={false} isField={false} isEdge={true} isVoid={false} />;\r\n}\r\n\r\nEdgeComponent.cname = \"EdgeComponent\";\r\nEdgeConnected.cname = \"EdgeConnected\";\r\nEdge.cname = \"Edge\";\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\graph\\vertex\\Shapes.tsx",["945"],"import type { VertexOwnProps } from \"../graphElement/sharedTypes/sharedTypes\";\r\nimport React, {ReactElement, ReactNode} from \"react\";\r\nimport {GObject, Point, U} from \"../../joiner\";\r\nimport { Geom } from \"../../common/Geom\";\r\nimport {VertexConnected} from \"./Vertex\";\r\nimport {radian} from \"../../joiner/types\";\r\n\r\n\r\nfunction polygonSideLength(sides: number, radius: number = 1){\r\n    let rad = Math.PI/sides; // actual angle is twice, ut to do calculations i need half of it, to make it first a triangle slice out of a polygon, and then 2 right angle slices. this is the angle of 1 of the 2 right angle slices\r\n    return 2*(radius * Math.sin(rad)); }\r\n\r\nfunction makePolygon(sides: number, radius: number = 0.5, startingPoint?:Point, startingRad?: radian): Point[]{\r\n    let lastPt: Point = startingPoint || new Point(radius, 0);\r\n    let pts: Point[] = [lastPt];\r\n    let sideLength = polygonSideLength(sides, radius);\r\n    let rad0 = Math.PI/sides;\r\n    let currentRad: radian = startingRad !== undefined ? startingRad : rad0;\r\n    let sidesloop = sides;\r\n    while (sidesloop-- > 0) {\r\n        let nextPt = lastPt.move(currentRad, sideLength);\r\n        pts.push(nextPt);\r\n        lastPt = nextPt;\r\n        currentRad += rad0*2;\r\n    }\r\n    return pts;\r\n}\r\n\r\nfunction makeStar(sides: number, radius: number = 0.5, starRadius: number=0.25, niceBugVersion: boolean = true): Point[]{\r\n    console.log(\"make star\", {sides, starRadius});\r\n    let startRad;\r\n    let nextPtRad;\r\n    if (niceBugVersion && sides % 2 == 0) {\r\n        // nb: not fully correct, the correct \"bug\" version on even would be having an inner polygon identical to outer poly (not rotated)\r\n        // with points[0] = topmost point of the ex-circle for both odd polys. and then matching outer[i] with inner[i-1] points to make a line\r\n        startRad = Geom.degToRad(180/sides+90);\r\n        //nextPtRad = -startRad*2;\r\n        nextPtRad = -startRad*2*(sides-1);\r\n    } else {\r\n        startRad = -Geom.degToRad(-180/sides+90);\r\n        nextPtRad = (startRad - Geom.degToRad(90))*2;\r\n    }\r\n    let startPt: Point = new Point(0.5, 0.5).move(startRad, starRadius);\r\n    //startPt.y = 2*0.5 - startPt.y;\r\n    let poly = makePolygon(sides, radius);\r\n    let innerPoly = makePolygon(sides, starRadius, startPt, nextPtRad);\r\n    //innerPoly = [innerPoly[0], innerPoly[1]]\r\n    let ret: Point[] = []; // both go clockwise, but inner starts on opposide side\r\n    //return innerPoly;\r\n    for (let i = 0; i <= sides; i++) ret.push(poly[i], innerPoly[i]);\r\n    return ret.filter(r => !!r);\r\n}\r\n\r\nfunction makeAsterisk(sides: number, radius: number = 0.5, starRadius: number=0.25): Point[]{\r\n    console.log(\"make asterisk, todo\", {sides, starRadius});\r\n    return [];\r\n}\r\nfunction makeClipPath(pts:Point[]): string {\r\n    return 'polygon(' + pts.map(pt=> (pt.x*100 + '% ' + pt.y*100 + '%')).join(', ') + ')';\r\n}\r\n/*\r\nfunction makeSvg(pts: Point[]): string{\r\n    let val = 'M' + (pts.map(pt=> ('L' + pt.x*100 + ' ' + pt.y*100 + ' ')).join(', ')).substring(1) + '';\r\n    let html = document.querySelector('#p');\r\n    html.setAttribute('d', val);\r\n    html.style.display='block';\r\n    html = document.querySelector('#c'+0);\r\n    html.setAttribute(\"cx\", pts[0].x*100);\r\n    html.setAttribute(\"cy\", pts[0].y*100);\r\n\r\n    for (let i = 1; i < 20; i++) {\r\n        let v =  pts[i] ? \"M\" + pts[i-1].x*100 + ' ' + pts[i-1].y*100 + \" L\" + pts[i].x*100 + ' ' + pts[i].y*100 : \"\";\r\n        html = document.querySelector('#p'+i);\r\n        html.setAttribute('d', v);\r\n        html.style.display='block';\r\n        html.style.display='block';\r\n        html = document.querySelector('#c'+i);\r\n        if (!html) console.error(\"failed selector\", '#c'+i, {i, v, pts});\r\n        html.setAttribute(\"cx\", pts[i] ? pts[i].x*100 : -500);\r\n        html.setAttribute(\"cy\", pts[i] ? pts[i].y*100 : -500);\r\n    }\r\n    console.log(html);\r\n    return val;\r\n}*/\r\n\r\n\r\n\r\n\r\n\r\n// geom shortcuts\r\nfunction addStyle(props0: VertexOwnProps, children:any, childStyle: React.CSSProperties, style: React.CSSProperties = {}){\r\n    let props: GObject = {...props0, children, isGraph:false, isGraphVertex: false, isVertex:true, isEdgePoint: false, isField: false, isEdge: false, isVoid:true};\r\n    // props.style = !props0.style ? {} : {...props0.style};\r\n    props.childStyle = props.childStyle ? {...props.childStyle} : {};\r\n    props.style = props.style ? {...props.style} : {};\r\n    U.objectMergeInPlace(props.childStyle, childStyle, {\r\n        // custom fixed stuff\r\n    });\r\n    U.objectMergeInPlace(props.style, style, {\r\n        // custom fixed stuff\r\n        filter: 'drop-shadow(0px var(--border-width) 0px var(--border-color)) drop-shadow(var(--border-width) 0px 0px var(--border-color))' +\r\n            ' drop-shadow(calc( -1 * var(--border-width)) 0px 0px var(--border-color)) drop-shadow(0px calc( -1 * var(--border-width)) 0px var(--border-color))',\r\n    });\r\n    props.datastyle = JSON.stringify(props.style);\r\n    props.dataChildStyle = JSON.stringify(props.childStyle);\r\n    return props;}\r\n\r\nexport const Ellipse = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => {\r\n    return <VertexConnected {...addStyle(props, children, {borderRadius:'100%', // ellipse(50% 25% at 50% 50%)\r\n    })} />;}\r\nEllipse.cname = 'Ellipse';\r\n\r\nexport const Rectangle = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => { // default\r\n    return <VertexConnected {...addStyle(props, children, {})} />;}\r\nRectangle.cname = 'Rectangle (alias for default <Vertex />)';\r\n\r\nexport const Polygon = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => {\r\n    props = {...props};\r\n    if (!props.sides) props.sides = 6;\r\n    // if (!props.radius) props.radius = 0.5;\r\n    return <VertexConnected {...addStyle(props, children, {clipPath: makeClipPath(makePolygon(props.sides, 0.5))})} />;\r\n}\r\nPolygon.cname = 'N-Polygon';\r\n\r\nexport const Star = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => { // pointed lines, N endings (include 6-stars and more)\r\n    return props.decorated === false ? SimpleStar(props, children) : DecoratedStar(props, children);\r\n}\r\nStar.cname = 'N-Star';\r\nexport const DecoratedStar = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => {\r\n    props = {...props};\r\n    if (!props.sides) props.sides = 4;\r\n    // if (!props.radius) props.radius = 0.5;\r\n    if (!props.innerRadius) props.innerRadius = 0.25;\r\n    return <VertexConnected {...addStyle(props, children, {clipPath: makeClipPath(makeStar(props.sides, 0.5, props.innerRadius, true))})} />;\r\n}\r\nDecoratedStar.cname = 'N-DecoratedStar';\r\nexport const SimpleStar = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => {\r\n    props = {...props};\r\n    if (!props.sides) props.sides = 6;\r\n    // if (!props.radius) props.radius = 0.5;\r\n    if (!props.innerRadius) props.innerRadius = 0.25;\r\n    return <VertexConnected {...addStyle(props, children, {clipPath: makeClipPath(makeStar(props.sides, 0.5, props.innerRadius, false))})} />;\r\n}\r\nSimpleStar.cname = 'N-SimpleStar';\r\n\r\nexport const Cross = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => { // cut lines, N endings (includes asterisk)\r\n    return <div>N-Crosses (Asterisk-like) shapes yet to do</div>;\r\n}\r\nCross.cname = 'N-Cross';\r\n\r\nexport const Trapezoid = (props0: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => { // cut lines, N endings (includes asterisk)\r\n    let props: VertexOwnProps & {ratio: number} = props0 as any;\r\n    if (!props0.ratio) props = {...props, ratio: 0.2 };\r\n    return <VertexConnected {...addStyle(props, children, {clipPath: 'polygon(' + props.ratio * 100 + '% 0%, ' + (1-props.ratio) * 100 + '% 0%, 100% 100%, 0% 100%)'})} />;}\r\nTrapezoid.cname = 'Trapezoid';\r\n\r\n\r\n//////////////// aliases (circle -> ellipse) ...\r\n\r\nexport const Circle = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => { // ellipse ellipse(50% 50% at 50% 50%)\r\n    return Ellipse(props, children); }\r\nCircle.cname = 'Ellipse/Circle';\r\n\r\n/*\r\nstep 1) put favoriteNode props on all GraphElememnt components except the most basic one like here,\r\nin a way that mirrirong components will have the mirror name instead of the implementation name (which is always GraphVertex)\r\n favoriteNode={props.favoriteNode || Square.cname}\r\nstep 2) when parsing jsx to build nodes, edges, check if props like edge.start or node.favoriteNode are different from the same prop in DVertex/DEdge/DView\r\nin that case, update such value\r\n*/\r\nexport const Square = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => { // rectangle\r\n    return <VertexConnected {...{...props, children}} isGraph={false} isVertex={true} isVoid={true} />; }\r\nSquare.cname = 'Rectangle/Square';\r\n/*\r\nexport const Rhombus = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => { // rectangle\r\n    return <VertexConnected {...{...props, children}} isGraph={false} isVertex={true} isVoid={true} rotate={props.rotate || 45} />; }\r\nRhombus.cname = 'Rectangle/Diamond';\r\n\r\nexport const Diamond = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => { return Rhombus(props, children); }\r\nDiamond.cname = 'Rectangle/Diamond';*/\r\n\r\n// polygon\r\nexport const Triangle = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => {\r\n    return <VertexConnected {...addStyle(props, children, {clipPath: 'polygon(50% 0%, 0% 100%, 100% 100%)'})} />;}\r\nTriangle.cname = 'Polygon/Triangle';\r\n\r\nexport const Pentagon = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => {\r\n    return <VertexConnected {...addStyle(props, children, {clipPath: 'polygon(50% 0%, 100% 38%, 82% 100%, 18% 100%, 0% 38%)'})} />;}\r\nPentagon.cname = 'Polygon/Pentagon';\r\n\r\nexport const Hexagon = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => {\r\n    return <VertexConnected {...addStyle(props, children, {clipPath: 'polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%)'})} />;}\r\nHexagon.cname = 'Polygon/Hexagon';\r\n\r\nexport const Heptagon = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => {\r\n    return <VertexConnected {...addStyle(props, children, {clipPath: 'polygon(50% 0%, 90% 20%, 100% 60%, 75% 100%, 25% 100%, 0% 60%, 10% 20%)'})} />;}\r\nHeptagon.cname = 'Polygon/Heptagon';\r\nexport const Septagon = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => {\r\n    return <VertexConnected {...addStyle(props, children, {clipPath: 'polygon(50% 0%, 90% 20%, 100% 60%, 75% 100%, 25% 100%, 0% 60%, 10% 20%)'})} />;}\r\nSeptagon.cname = 'Polygon/Heptagon';\r\n\r\nexport const Octagon = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => {\r\n    return <VertexConnected {...addStyle(props, children, {clipPath: 'polygon(30% 0%, 70% 0%, 100% 30%, 100% 70%, 70% 100%, 30% 100%, 0% 70%, 0% 30%)'})} />;}\r\nOctagon.cname = 'Polygon/Octagon';\r\n\r\nexport const Nonagon = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => {\r\n    return <VertexConnected {...addStyle(props, children, {clipPath: 'polygon(50% 0%, 83% 12%, 100% 43%, 94% 78%, 68% 100%, 32% 100%, 6% 78%, 0% 43%, 17% 12%)'})} />;}\r\nNonagon.cname = 'Polygon/Nonagon';\r\n\r\nexport const Enneagon = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => {\r\n    return <VertexConnected {...addStyle(props, children, {clipPath: 'polygon(50% 0%, 83% 12%, 100% 43%, 94% 78%, 68% 100%, 32% 100%, 6% 78%, 0% 43%, 17% 12%)'})} />;}\r\nEnneagon.cname = 'Polygon/Nonagon';\r\n\r\nexport const Decagon = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => {\r\n    return <VertexConnected {...addStyle(props, children, {clipPath: 'polygon(50% 0%, 80% 10%, 100% 35%, 100% 70%, 80% 90%, 50% 100%, 20% 90%, 0% 70%, 0% 35%, 20% 10%)'})} />;}\r\nDecagon.cname = 'Polygon/Decagon';\r\n\r\nexport const Asterisk = (props: VertexOwnProps, children: ReactNode | undefined = []): ReactElement => { // cut lines, N endings (includes asterisk)\r\n    return Star(props, children); }\r\nAsterisk.cname = 'Cross/Asterisk';\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\graph\\defaultNode\\DefaultNode.tsx",["946"],"import React, {ReactElement, ReactNode} from \"react\";\r\nimport {connect} from \"react-redux\";\r\nimport {\r\n    DClassifier,\r\n    DEnumerator,\r\n    Dictionary,\r\n    DModel,\r\n    DModelElement,\r\n    DPackage,\r\n    DV,\r\n    GObject,\r\n    GraphElementComponent,\r\n    GraphElementDispatchProps,\r\n    GraphElementOwnProps,\r\n    GraphElementReduxStateProps,\r\n    GraphElementStatee,\r\n    DState,\r\n    LModelElement,\r\n    Log,\r\n    LViewElement,\r\n    RuntimeAccessibleClass,\r\n    SetRootFieldAction,\r\n    windoww,\r\n    Field,\r\n    Graph,\r\n    GraphVertex,\r\n    Vertex,\r\n    VoidVertex,\r\n    RuntimeAccessible,\r\n    Polygon,\r\n    Circle,\r\n    Cross,\r\n    Decagon,\r\n    Asterisk,\r\n    Ellipse,\r\n    Enneagon,\r\n    Hexagon,\r\n    Nonagon,\r\n    Octagon,\r\n    Heptagon,\r\n    Pentagon,\r\n    Rectangle,\r\n    Septagon,\r\n    Square,\r\n    Star,\r\n    SimpleStar,\r\n    DecoratedStar,\r\n    Trapezoid,\r\n    Triangle,\r\n    Selectors,\r\n    LPointerTargetable,\r\n    Pointer,\r\n    DGraphElement,\r\n    DPointerTargetable, LGraphElement, transientProperties\r\n} from \"../../joiner\";\r\nimport { GraphElements } from \"../../joiner/components\";\r\n// import {Field, Graph, GraphVertex} from \"../vertex/Vertex\";\r\n\r\nconst superclass: typeof GraphElementComponent = RuntimeAccessibleClass.classes.GraphElementComponent as any as typeof GraphElementComponent;\r\n\r\n// private\r\nclass DefaultNodeStatee extends GraphElementStatee { }\r\n\r\n// from ownstateprops function getVertexID(props: AllPropss): Pointer<DVoidVertex, 0, 1, LVoidVertex> { return props.vertex?.id; }\r\n\r\n// Giordano: add ignore for webpack\r\n@RuntimeAccessible('DefaultNodeComponent')\r\n//@ts-ignore\r\nexport class DefaultNodeComponent<AllProps extends AllPropss = AllPropss, NodeState = DefaultNodeStatee> extends superclass<AllProps, NodeState>{\r\n    static defaultProps: Partial<DefaultNodeOwnProps> = {}; // cannot decide anything on this level, delegated to lower levels.\r\n\r\n    static mapStateToProps(state: DState, ownProps: GraphElementOwnProps): GraphElementReduxStateProps {\r\n        let ret: GraphElementReduxStateProps = {} as GraphElementReduxStateProps; // NB: cannot use a constructor, must be pojo\r\n        // GraphElementComponent.mapLModelStuff(state, ownProps, ret); // not necessary either?\r\n        // GraphElementComponent.mapLGraphElementStuff(state, ownProps, ret, dGraphDataClass); not necessary, it's demanded to sub-components\r\n/*        ret.data = LPointerTargetable.wrap(ownProps.data);\r\n        ret.node = undefined as any; // because DefaultNode is all about determining the correct node to create, so there is no node yet.\r\n        ret.nodeid = ownProps.nodeid as Pointer<DGraphElement>; // but nodeid exists, passed from the parent along graphid and parentview\r\n*/\r\n        // try{\r\n        ret.data = LPointerTargetable.wrap(ownProps.data);\r\n        ret.dataid = ownProps.data ? (typeof ownProps.data === \"string\" ? ownProps.data : ownProps.data.id) : undefined;\r\n        // if node does not exist yet it's fine, don't create it. let Vertex or Graph or Edge make it with appropriate constructor according fo first matching view on model.\r\n        // problem: what kind of node to make / initial view assign on shapeless objects? they have both data and node undefined at first render.\r\n        ret.node = LPointerTargetable.wrap(ownProps.nodeid) as LGraphElement;\r\n        if (ret.dataid) {\r\n            // set up transient model-> node map\r\n            if (!transientProperties.modelElement[ret.dataid]) transientProperties.modelElement[ret.dataid] = {nodes: {}} as any;\r\n            transientProperties.modelElement[ret.dataid].nodes[ownProps.nodeid as string] = ret.node;\r\n            transientProperties.modelElement[ret.dataid].node = ret.node;\r\n        }\r\n\r\n        GraphElementComponent.mapViewStuff(state, ret, ownProps);\r\n\r\n            // GraphElementComponent.mapViewStuff(state, ret, ownProps);\r\n            // (ret as any).skiparenderforloading = false;\r\n        //} catch(e) {\r\n            //(ret as any).skiparenderforloading = true; // model id is updated, but he's still trying to load old model which got replaced and is not in state.\r\n            /* crashes on loading because old model and new model have different timestamps? looks by id of old model with same number and diffferent timestamp*/\r\n            // Log.eDev(!ret.data, \"can't find model data:\", {state, ret, ownpropsdata:ownProps.data, ownProps});\r\n            // Log.eDevv(\"cannot map state to props:\", {e, state, ret, ownpropsdata:ownProps.data, ownProps});\r\n        //}\r\n        return ret; }\r\n\r\n    constructor(props: AllProps, context: any) { super(props, context); }\r\n\r\n    shouldComponentUpdate(nextProps: Readonly<AllProps>, nextState: Readonly<NodeState>, nextContext: any): boolean {\r\n        // i want to avoid double check on this and Vertex or graph.\r\n        // actually should not use this and avoid double mapstatetoprops execution too\r\n        return true;\r\n    }\r\n\r\n    render(): ReactNode {\r\n        if ((this.props as any).skiparenderforloading) {\r\n            windoww.bugged = this;\r\n            console.log(\"realoading render: \", {thiss:this, data:this.props.data});\r\n            SetRootFieldAction.new(\"rerenderforloading\", new Date().getTime()); return <div>loading...</div>;}\r\n        const view: LViewElement = this.props.view;\r\n        const modelElement: LModelElement | undefined = this.props.data;\r\n        if (!view) { Log.exx(\"cannot find view in DefaultNode\", {props: this.props, thiss:this}); }\r\n        // if (!view) { SetRootFieldAction.new(\"uselessrefresh_afterload\", new Date().getTime()); return <div>Loading...</div>; }\r\n\r\n        let componentMap: Dictionary<string, (props: GObject, children?: (string | React.Component)[]) => ReactElement> = windoww.components;\r\n        let dmodelMap: Dictionary<string, typeof DModelElement> = RuntimeAccessibleClass.classes as any;\r\n\r\n        let serializableProps = {...this.props};\r\n        // let serializableProps = {...this.props, data: this.props.data?.id, view: this.props.view?.id, views: this.props.views?.map( v => v.id )};\r\n\r\n        // console.log('dnode render', {props: {...this.props}, serializableProps});\r\n        let componentfunction: typeof Graph = null as any;\r\n        let forceNodeType = view.forceNodeType;\r\n        if (forceNodeType && forceNodeType !== \"Any\") {\r\n            componentfunction = GraphElements[forceNodeType] as any;\r\n            Log.exDev(!componentfunction, 'unrecognized View.forceNodeType:' + view.forceNodeType, {view, modelElement, nt: forceNodeType, GraphElements, });\r\n            // console.log(\"force node type\", {requested:view.forceNodeType, G:  windoww.GraphComponent.name, GE: windoww.GraphElementComponent.name, GV: windoww.GraphVertexComponent.name, V: windoww.VertexComponent.name, F:windoww.FieldComponent.name})\r\n            return componentfunction(serializableProps, this.props.children); }\r\n\r\n        if (modelElement?.className) switch(modelElement.className) {\r\n            case \"DModel\": componentfunction = Graph; break;\r\n            case \"DPackage\": componentfunction = GraphVertex; break;\r\n            case \"DClassifier\":\r\n            case \"DEnumerator\":\r\n            case \"DObject\":\r\n            case \"DClass\": componentfunction = Vertex; break;\r\n            case \"DAnnotation\":\r\n            case \"DAttribute\":\r\n            case \"DOperation\":\r\n            case \"DParameter\":\r\n            case \"DReference\":\r\n            case \"DEnumLiteral\":\r\n            case \"DValue\":\r\n            case \"DModelElement\": componentfunction = Field; break;\r\n            default:\r\n                Log.exDevv('invalid model class, add a case in the switch', {modelElement, view, dmodelMap, componentMap});\r\n                // const dmodel: typeof DModelElement = dmodelMap[modelElement.className];\r\n                // Log.exDev(!dmodel || !dmodel.defaultComponent, 'invalid model class:', {dmodel, modelElement, view, dmodelMap, componentMap});\r\n                // return dmodel.defaultComponent(serializableProps, this.props.children);\r\n        } else componentfunction = VoidVertex; // model-less, VoidVertex\r\n\r\n        if (componentfunction) return componentfunction(serializableProps, this.props.children);\r\n        // errore: questoon passa gli id correttamente al sottoelemento vertex o field\r\n        return DV.errorView(\"DefaultNode is missing both view and model, please state node type explicitly: Graph, GraphVertex, Vertex or Field\",\r\n            '', 'DefaultNode', modelElement?.__raw, this.props.node?.__raw, view);\r\n    }\r\n\r\n}\r\n\r\n// private\r\nclass DefaultNodeOwnProps extends GraphElementOwnProps {}\r\nclass DefaultNodeReduxStateProps  extends GraphElementReduxStateProps {}\r\nclass DefaultNodeDispatchProps extends GraphElementDispatchProps {}\r\ntype AllPropss = DefaultNodeOwnProps & DefaultNodeReduxStateProps & DefaultNodeDispatchProps;\r\n\r\n\r\nconst DefaultNodeConnected = connect<DefaultNodeReduxStateProps, DefaultNodeDispatchProps, DefaultNodeOwnProps, DState>(\r\n    DefaultNodeComponent.mapStateToProps,\r\n    DefaultNodeComponent.mapDispatchToProps\r\n)(DefaultNodeComponent as any);\r\n// export const Vertex = VertexConnected;\r\n\r\n\r\nexport const DefaultNode = (props: DefaultNodeOwnProps, children: (string | React.Component)[] = []): ReactElement => {\r\n    return <DefaultNodeConnected {...{...props, children}} />; }\r\n\r\n\r\nDefaultNodeComponent.cname = \"DefaultNodeComponent\";\r\nDefaultNodeConnected.cname = \"DefaultNodeConnected\";\r\nDefaultNode.cname = \"DefaultNode\";\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\graph\\graph\\graphContainer.tsx",["947"],"import React, {Dispatch, PureComponent, ReactElement, ReactNode} from \"react\";\r\nimport {connect} from \"react-redux\";\r\n// import './graph.scss';\r\nimport {DGraph, DModel, DPointerTargetable, DState, LGraph, LModel, LPointerTargetable} from \"../../joiner\";\r\n\r\n\r\n// private\r\ninterface ThisState { }\r\n\r\nexport class GraphsContainerComponent extends PureComponent<AllProps, ThisState>{\r\n    public static cname: string = \"GraphsContainerComponent\";\r\n    constructor(props: AllProps, context: any) {\r\n        super(props, context);\r\n    }\r\n\r\n    // todo: per ogni vista crea un set di opzioni {enableAutocorrect: \"boolean(true)\", displayEdges: \"boolean(true)\", maximumGraphWidth: \"number(2000)\"} specificate dall\\'utente che deve specificare sia il tipo (Come se osse una funzione) che il valore predefinito\r\n    // il grafo deve leggere l'oggetto di opzioni e creare un menù che consente di cambiarle (una checkbox al posto dell'enableAutocorrect (bool), uno spinner per maximumGraphWidth (number...)\r\n\r\n    render(): ReactNode {\r\n        // const editinput = \"<input onChange={(e) => this.data.name = e.target.value } value={this.data.name} />\";\r\n        // const editinput = \"\";\r\n        // todo: rendi opzionale obj = this.data.id se non è specificato.\r\n        // const editinput = \"<Input obj={this.data.id} field={'name'} getter={val => val.toUpperCase()} setter={(val) => val.toLowerCase()} />\";\r\n        // \"<Input obj={this.data} field={'name'} getter={val => val.toUpperCase()} setter={(val) => val.toLowerCase()} />\";\r\n        return (<>\r\n            {\r\n                this.props.graphs.map( (m: LGraph) => (\r\n                    <>\r\n                        {/*<svg style={{backgroundColor: 'red'}}>\r\n                        <Overlap style={{width: '100px'}}>\r\n                            success, now i can test resize handler overlayed to content and dragndrop dnd\r\n                            <foreignObject className={\"rectangle\"} />\r\n                            <foreignObject className={\"ellipse\"} />\r\n                            <foreignObject className={\"point\"} />\r\n                        </Overlap>\r\n                        </svg><svg style={{backgroundColor: 'red'}}>\r\n                            <Overlap>\r\n                                <foreignObject className={\"rectangle\"} style={{width: '100px'}}/>\r\n                                <foreignObject className={\"ellipse\"} style={{width: '300px'}}/>\r\n                                <foreignObject className={\"point\"} />\r\n                            </Overlap>\r\n                        </svg>* /}\r\n                        <GraphElement data={m} />*/}\r\n                        {/*\r\n                            Giordano comment this problem with model's children\r\n                            <Graph graphid={m.id} data={m.model} view={undefined}>\r\n                                <Vertex data={m.model}/>\r\n                            </Graph>\r\n\r\n                        */}\r\n                        {this.props.children/*<QA />*/}\r\n                    </>)\r\n                )\r\n            }\r\n        </>); }\r\n}\r\n\r\n// private\r\ninterface OwnProps {\r\n    // propsRequestedFromHtmlAsAttributes: string;\r\n}\r\n// private\r\ninterface StateProps {\r\n    models: LModel[];\r\n    graphs: LGraph[];\r\n    // propsFromReduxStateOrOtherKindOfStateManagement: boolean; // flux or custom things too, unrelated to this.state of react.\r\n}\r\n\r\n// private\r\ninterface DispatchProps {\r\n    // propsFromReduxActions: typeof funzioneTriggeraAzioneDaImportare;\r\n}\r\n\r\n\r\n// private\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n////// mapper func\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as any;\r\n    console.log('mapStateToProps', {ret, state, ownProps, models: state.models})\r\n    ret.models = state.models.length ? LPointerTargetable.fromArr(state.models, state) as LModel[] : [];\r\n    ret.graphs = state.graphs.length ? LGraph.fromArr(state.graphs, state) as LGraph[] : [];\r\n    /// to fill\r\n    return ret; }\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {} as any;\r\n    /// to fill\r\n    return ret; }\r\n\r\n\r\nconst GraphsContainerConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(GraphsContainerComponent);\r\n\r\nexport const GraphsContainer = (props: OwnProps, children: (string | React.Component)[] = []): ReactElement => {\r\n    return <GraphsContainerConnected {...{...props, children}} />; }\r\n\r\n\r\nGraphsContainer.cname = \"GraphsContainer\";\r\nGraphsContainerConnected.cname = \"GraphsContainerConnected\";\r\nGraphsContainerComponent.cname = \"GraphsContainerComponent\";\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\logger\\DataOutput.tsx",["948"],"import React, {PureComponent, ReactNode} from \"react\";\r\nimport ReactJson from 'react-json-view' // npm i react-json-view\r\nimport './logger.scss'\r\nimport {GObject} from \"../../joiner\";\r\n\r\n// private\r\ninterface ThisState { }\r\n\r\nexport class DataOutputComponent extends PureComponent<AllProps, ThisState>{\r\n    static cname: string = \"DataOutputComponent\";\r\n\r\n    render(): ReactNode {\r\n        {/* themes:\r\n                                        export interface ThemeObject {\r\n                                            base00: string;\r\n                                            base01: string;\r\n                                            base02: string;\r\n                                            base03: string;\r\n                                            base04: string;\r\n                                            base05: string;\r\n                                            base06: string;\r\n                                            base07: string;\r\n                                            base08: string;\r\n                                            base09: string;\r\n                                            base0A: string;\r\n                                            base0B: string;\r\n                                            base0C: string;\r\n                                            base0D: string;\r\n                                            base0E: string;\r\n                                            base0F: string;\r\n                                        }\r\n\r\n                                            export type ThemeKeys =\r\n                                              | 'apathy'\r\n                                              | 'apathy:inverted'\r\n                                              | 'ashes'\r\n                                              | 'bespin'\r\n                                              | 'brewer'\r\n                                              | 'bright:inverted'\r\n                                              | 'bright'\r\n                                              | 'chalk'\r\n                                              | 'codeschool'\r\n                                              | 'colors'\r\n                                              | 'eighties'\r\n                                              | 'embers'\r\n                                              | 'flat'\r\n                                              | 'google'\r\n                                              | 'grayscale'\r\n                                              | 'grayscale:inverted'\r\n                                              | 'greenscreen'\r\n                                              | 'harmonic'\r\n                                              | 'hopscotch'\r\n                                              | 'isotope'\r\n                                              | 'marrakesh'\r\n                                              | 'mocha'\r\n                                              | 'monokai'\r\n                                              | 'ocean'\r\n                                              | 'paraiso'\r\n                                              | 'pop'\r\n                                              | 'railscasts'\r\n                                              | 'rjv-default'\r\n                                              | 'shapeshifter'\r\n                                              | 'shapeshifter:inverted'\r\n                                              | 'solarized'\r\n                                              | 'summerfruit'\r\n                                              | 'summerfruit:inverted'\r\n                                              | 'threezerotwofour'\r\n                                              | 'tomorrow'\r\n                                              | 'tube'\r\n                                              | 'twilight'; */}\r\n        return <ReactJson src={this.props.data}\r\n                          collapsed={1}\r\n                          collapseStringsAfterLength={20}\r\n                          displayDataTypes={true}\r\n                          displayObjectSize={true}\r\n                          enableClipboard={true}\r\n                          groupArraysAfterLength={100}\r\n                          indentWidth={4}\r\n                          iconStyle={\"triangle\"}\r\n                          name={this.props.rootName}\r\n                          quotesOnKeys={true} shouldCollapse={ false /*((field: CollapsedFieldProps) => { return Object.keys(field.src).length > 3;*/ }\r\n                          sortKeys={false}\r\n                          theme={\"rjv-default\"}\r\n        >{this.props.children}</ReactJson>;\r\n    };\r\n\r\n}\r\n\r\n// private\r\ninterface OwnProps {\r\n    data: GObject;\r\n    rootName?: string;\r\n}\r\n// private\r\ntype AllProps = OwnProps;\r\n/*\r\nif (!windoww.mycomponents) windoww.mycomponents = {};\r\nwindoww.mycomponents.DataOutput = DataOutputComponent;\r\nwindoww.mycomponents.DataOutputComponent = DataOutputComponent;*/\r\n////// mapper func\r\n\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\logger\\loggerComponent.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\api\\persistance\\index.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\SizeInput.tsx",["949"],"import React, {Dispatch, PureComponent, ReactNode} from \"react\";\r\nimport { connect } from \"react-redux\";\r\nimport toast from \"react-hot-toast\";\r\nimport type {GObject, Pointer, Info} from \"../../joiner\";\r\nimport {\r\n    DPointerTargetable,\r\n    DState,\r\n    GenericInput,\r\n    Log,\r\n    LPointerTargetable,\r\n    Input,\r\n    ISize,\r\n    SetFieldAction\r\n} from \"../../joiner\";\r\nexport let useless=1;\r\n\r\n// private\r\ninterface ThisState {\r\n}\r\n\r\nclass SizeInputComponent extends PureComponent<AllProps, ThisState>{\r\n    static cname: string;\r\n\r\n    constructor(props: AllProps, context: any) {\r\n        super(props, context);\r\n    }\r\n\r\n    render(): ReactNode {\r\n        let l: LPointerTargetable = this.props.data;\r\n        let ll: GObject = l;\r\n        let field: keyof LPointerTargetable = this.props.field as any;\r\n        let otherProps: GObject = {...this.props};\r\n        delete otherProps.xgetter;\r\n        delete otherProps.xsetter;\r\n        delete otherProps.ygetter;\r\n        delete otherProps.ysetter;\r\n        delete otherProps.wgetter;\r\n        delete otherProps.wsetter;\r\n        delete otherProps.hgetter;\r\n        delete otherProps.hsetter;\r\n        delete otherProps.data;\r\n        delete otherProps.field;\r\n        delete otherProps.label;\r\n        delete otherProps.tooltip;\r\n        delete otherProps.key;\r\n\r\n        let tooltip: JSX.Element;\r\n        if (this.props.tooltip === true) { tooltip = (ll[\"__info_of__\" + field])?.txt || ''; }\r\n        else { tooltip = (this.props.tooltip || '') as any; }\r\n\r\n        const notify = () => toast((t: GObject) => (\r\n            <div onClick={() => toast.dismiss(t.id)}>\r\n                <label className={'ms-1'}>{tooltip}</label>\r\n            </div>\r\n        ));\r\n\r\n\r\n        let size: Partial<ISize> = (l[field] || {}) as GObject;\r\n        console.log('sizeinput debug', {l, field, size})\r\n\r\n        const inputStyle = {justifyContent: \"right\", width: \"auto\", marginRight:\"5px\"};\r\n        let labelStyle = {height: '100%', display: 'inline-block', marginRight:\"5px\"}\r\n        return (<>\r\n            <label className={this.props.rootClassName} style={{fontFamily:'Inter Tight', ...(this.props.rootStyle||{})}}>\r\n                {(this.props.label) && <label className={'my-auto'} style={{fontFamily:'-webkit-body'}} onClick={() => { if (tooltip) notify() }}>\r\n                    {this.props.label}\r\n                </label>}\r\n                <label className={\"d-flex my-auto ms-auto\"} style={{flexWrap: \"wrap\"}}>\r\n                    {\"x\" in size && <Input {...otherProps} className={\"\"} data={l} label={<span style={labelStyle}>x</span>} field={field} type={\"number\"}\r\n                        getter={(ll)=>(l[field] as any as ISize).x+''}\r\n                        setter={(val)=>{\r\n                            // SetFieldAction.new(l.id, field as string, {x: +val}, '+=', false)\r\n                            (l[field] as any as Partial<ISize>) = {x: +val}; // {y:? x: +val, w:?, h:?}}\r\n                    }}\r\n                        inputStyle={inputStyle}\r\n                    />}\r\n                    {\"y\" in size && <Input {...otherProps} className={\"\"} data={l} label={<span style={labelStyle}>y</span>} field={field} type={\"number\"}\r\n                       getter={(ll)=>(l[field] as any as ISize).y+''}\r\n                       setter={(val)=>{(l[field] as any as Partial<ISize>) = {y: +val}}}\r\n                       inputStyle={inputStyle}\r\n                    />}\r\n                    {\"w\" in size && <Input {...otherProps} className={\"\"} data={l} label={<span style={labelStyle}>w</span>} field={field} type={\"number\"}\r\n                        getter={(ll)=>(l[field] as any as ISize).w+''}\r\n                        setter={(val)=>{(l[field] as any as Partial<ISize>) = {w: +val}}}\r\n                        inputStyle={inputStyle}\r\n                    />}\r\n                    {\"h\" in size && <Input {...otherProps} className={\"\"} data={l} label={<span style={labelStyle}>h</span>} field={field} type={\"number\"}\r\n                       getter={(ll)=>(l[field] as any as ISize).h+''}\r\n                       setter={(val)=>{(l[field] as any as Partial<ISize>) = {h: +val}}}\r\n                       inputStyle={inputStyle}\r\n                    />}\r\n                </label>\r\n            </label>\r\n        </>); }\r\n}\r\n\r\n// private\r\ninterface OwnProps {\r\n    data: LPointerTargetable;\r\n    field: string;\r\n    xgetter?: (data: LPointerTargetable) => string;\r\n    xsetter?: (value: string|boolean) => void;\r\n    ygetter?: (data: LPointerTargetable) => string;\r\n    ysetter?: (value: string|boolean) => void;\r\n    wgetter?: (data: LPointerTargetable) => string;\r\n    wsetter?: (value: string|boolean) => void;\r\n    hgetter?: (data: LPointerTargetable) => string;\r\n    hsetter?: (value: string|boolean) => void;\r\n    label?: ReactNode;\r\n    tooltip?: ReactNode | true; // if true picks it up from __info_of__\r\n    readonly?: boolean;\r\n    key?: React.Key | null;\r\n    className?: string;\r\n    rootClassName?: string;\r\n    inputClassName?: string;\r\n    rootStyle?: GObject;// this goes to root\r\n    style?: GObject; // this goes at the root of <Input> or <Select> element(s)\r\n    inputStyle?: GObject; // this goes to the actual native <input> or <select> element(s)\r\n}\r\n\r\n// private\r\ninterface StateProps {\r\n    // propsFromReduxStateOrOtherKindOfStateManagement: boolean; // flux or custom things too, unrelated to this.state of react.\r\n}\r\n\r\n// private\r\ninterface DispatchProps {\r\n    // propsFromReduxActions: typeof funzioneTriggeraAzioneDaImportare;\r\n}\r\n\r\n\r\n// private\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n////// mapper func\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as any;\r\n    /// to fill\r\n    return ret; }\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {} as any;\r\n    /// to fill\r\n    return ret; }\r\n\r\n\r\nexport const SizeInput = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(SizeInputComponent);\r\n\r\n\r\nSizeInputComponent.cname = \"SizeInputComponent\";\r\nSizeInput.cname = \"SizeInput\";\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\cards\\Cards.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\menu\\Menu.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\catalog\\Catalog.tsx",["950","951","952","953","954","955","956","957","958","959","960"],"import React, {useState} from \"react\";\r\nimport { LProject } from \"../../../joiner\";\r\nimport { Menu, Item } from \"../menu/Menu\";\r\nimport { Project } from \"../Project\";\r\n\r\nimport colors from '../../../static/img/colors.png';\r\nimport { icon } from \"../icons/Icons\";\r\nimport \"./catalog.scss\"\r\nimport _ from \"lodash\";\r\n\r\nexport const CatalogInfoCard = (props: any) => {\r\n    return (\r\n        <div className={'details'}>\r\n            {props.projects ?\r\n                <>\r\n                    <h5>Your projects</h5>\r\n                    <p>You developed <strong>{props.projects.length}</strong> projects{false && ' with an overall number of 12 artifacts'}.</p>\r\n                    <img src={colors} width={220} />\r\n                </>\r\n                :\r\n                <>\r\n                    <h5>No projects so far. Are you new to Jjodel? why not exploring the Getting Started section?</h5>\r\n                    <img src={colors} width={220} />\r\n                </>\r\n            }\r\n        </div>\r\n    );\r\n}\r\ntype ChildrenType = {\r\n    projects?: any;\r\n    children?: any;\r\n};\r\n\r\nconst Catalog = (props: ChildrenType) => {\r\n\r\n    const [filters, setFilters] = useState([true,true,true]);\r\n    const [mode, setMode] = useState<string>(\"cards\");\r\n\r\n    const [sortingMode, setSortingMode] = useState<string>(\"alphabetical\");\r\n\r\n    const Header = (props: ChildrenType) => {\r\n        return (\r\n            <div className='row catalog-header' style={{maxWidth: '1250px'}}>\r\n                {props.children}\r\n            </div>\r\n        );\r\n    }\r\n\r\n    const CatalogFilters = () => {\r\n\r\n        function toggleFilters(el: 0|1|2) {\r\n            switch(el) {\r\n                case 0:\r\n                    setFilters([!filters[0], filters[1], filters[2]]);\r\n                    break;\r\n                case 1:\r\n                    setFilters([filters[0], !filters[1], filters[2]]);\r\n                    break;\r\n                case 2:\r\n                    setFilters([filters[0], filters[1], !filters[2]]);\r\n                    break;\r\n            }\r\n        };\r\n\r\n        return (\r\n            <div className={'left'}>\r\n                {filters[0] ? <button onClick={(e) => toggleFilters(0)} className='active'>public</button> : <button onClick={(e) => toggleFilters(0)}>public</button>}\r\n                {filters[1] ? <button onClick={(e) => toggleFilters(1)} className='active'>private</button> : <button onClick={(e) => toggleFilters(1)}>private</button>}\r\n                {filters[2] ? <button onClick={(e) => toggleFilters(2)} className='active'>collaborative</button> : <button onClick={(e) => toggleFilters(2)} >collaborative</button>}\r\n            </div>\r\n        );\r\n    }\r\n\r\n    const CatalogMode = () => {\r\n        return (<>\r\n            <div className={'right'}>\r\n                <span>sorted by <span style={{paddingLeft: '6px'}}>{icon[sortingMode]} </span></span>\r\n                <Menu position={'left'}>\r\n                    <Item icon={icon['alphabetical']} action={(e)=> {setSortingMode('alphabetical')}}>Alphabetical {sortingMode === 'alphabetical' && <i style={{float: 'right'}} className=\"bi bi-check-lg\"></i>}</Item>\r\n                    <Item icon={icon['created']} action={(e)=> {setSortingMode('created')}}>Date created {sortingMode === 'created' && <i style={{float: 'right'}} className=\"bi bi-check-lg\"></i>}</Item>\r\n                    <Item icon={icon['modified']} action={(e)=> {setSortingMode('modified')}}>Last modified {sortingMode === 'modified' && <i style={{float: 'right'}} className=\"bi bi-check-lg\"></i>}</Item>\r\n                </Menu>\r\n                <div className={'view-icons'}>\r\n                    <i onClick={(e) => setMode('cards')} className={`bi bi-grid ${mode === \"cards\" && 'selected'}`}></i>\r\n                    <i onClick={(e) => setMode('list')} className={`bi bi-list ${mode === \"list\" && 'selected'}`}></i>\r\n                </div>\r\n            </div>\r\n        </>);\r\n    }\r\n\r\n    const CatalogSide = (props: ChildrenType) => {\r\n        return (\r\n            <div className={'catalog'}>\r\n                {props.children}\r\n            </div>\r\n        );\r\n    }\r\n\r\n\r\n\r\n    type CatalogType = {\r\n        projects: LProject[];\r\n    }\r\n\r\n    const CatalogReport = (props: CatalogType) => {\r\n\r\n\r\n        var items = props.projects\r\n            .filter(p =>\r\n                (filters[0] && p.type ===\"public\" || filters[1] && p.type ===\"private\" || filters[2] && p.type ===\"collaborative\" || !filters[0] && !filters[1] && !filters[2]));\r\n        \r\n        var sorted = items;\r\n        var iteratees: ((obj: LProject) => any) | string = 'created';\r\n\r\n        switch(sortingMode) {\r\n            case \"alphabetical\":\r\n                sorted = _.sortBy(items, 'name');\r\n                break;\r\n            case \"created\":\r\n                iteratees = (obj: LProject) => -new Date(obj.creation).getTime();\r\n                sorted = _.sortBy(items, iteratees);\r\n                break;\r\n            case \"modified\":\r\n                iteratees = (obj: LProject) => -new Date(obj.lastModified).getTime();\r\n                sorted = _.sortBy(items, iteratees);\r\n                break;\r\n        }\r\n\r\n        return (\r\n\r\n            mode == \"cards\" ?\r\n\r\n                /* cards mode */\r\n\r\n                <div className={'card-holder'}>\r\n\r\n                    {items.length === 0 && <div className={\"fallback-message\"}><span>\r\n                        Sorry, there are no results matching your search criteria. Please try again with different filters.\r\n                    </span></div>}\r\n\r\n                    {\r\n                        sorted.map((p,i) => <Project key={i} data={p} mode={mode} />)\r\n                    }\r\n\r\n                </div>\r\n\r\n            :\r\n                /* list mode */\r\n\r\n                <div className={'row project-list'}>\r\n                    <div className='row header'>\r\n                        <div className={'col-4'}>Name</div>\r\n                        <div className={'col-1'}>Type</div>\r\n                        <div className={'col-3'}>Created</div>\r\n                        <div className={'col-2'}>Last modified</div>\r\n                        <div className={'col-2'}>Operation</div>\r\n                    </div>\r\n                    {\r\n                        sorted.map(p => <>\r\n                            {filters[0] && p.type === \"public\" && <Project key={p.id} data={p} mode={mode} />}\r\n                            {filters[1] && p.type === \"private\" && <Project key={p.id} data={p} mode={mode} />}\r\n                            {filters[2] && p.type === \"collaborative\" && <Project key={p.id} data={p} mode={mode} />}\r\n                            {!filters[0] && !filters[1] && !filters[2] && <Project key={p.id} data={p} mode={mode} />}\r\n                        </>)\r\n                    }\r\n                </div>\r\n\r\n        );\r\n    };\r\n\r\n    return (\r\n        <>\r\n            <Header>\r\n                <CatalogFilters />\r\n                <CatalogMode />\r\n            </Header>\r\n            <CatalogSide>\r\n                <CatalogInfoCard projects={props.projects}/>\r\n                <CatalogReport projects={props.projects}/>\r\n            </CatalogSide>\r\n        </>\r\n    );\r\n}\r\n\r\nexport {Catalog}\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\abstract\\DockManager.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\about\\About.tsx",["961","962"],"import { useState } from \"react\";\r\nimport logo from '../../../static/img/logo-on.png';\r\nimport manatee from '../../../static/img/manatee.png';\r\nimport React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\n\r\nlet windoww = window as any;\r\n\r\ntype Props = {\r\n    type?: 'inline'|'menu';\r\n    ver: string;\r\n    name: string;\r\n    value?: boolean;\r\n};\r\n\r\nconst message: string = \"Manatees are large, fully aquatic, mostly herbivorous marine mammals sometimes known as sea cows.The main causes of death for manatees are human-related issues. As usual, we are the most dangerous animal on earth.\";\r\n\r\n\r\nclass AboutModal {\r\n  \r\n    static open() {\r\n        if (!document) return;\r\n\r\n        const aboutElement = document.createElement('div');\r\n        ReactDOM.render(React.createElement(About, { ver: '1.0', name: 'Jjodel', type: 'menu', value: true }), aboutElement);\r\n        document.body.append(aboutElement);\r\n    }\r\n}\r\n\r\nconst About = (props: Props) => {\r\n\r\n    const [open, setOpen] = useState<boolean>(props.value ? props.value : false);\r\n\r\n    const {type, ver, name} = props;\r\n\r\n    const AboutRaw = (props: Props) => {\r\n        return(\r\n            <>\r\n                <div className='modal-container'></div>\r\n                <div className='modal'>\r\n                    <div><img src={logo} /></div>\r\n                    <div>v{props.ver} {props.name}</div>\r\n                    <div>\r\n                        {message}\r\n                    </div>\r\n                    <div><img src={manatee} /></div>\r\n                    \r\n                    <button className={'close'} onClick={() => setOpen(!open)}>close</button>\r\n                </div>\r\n            </>\r\n        );\r\n    }\r\n\r\n    return (\r\n        <>\r\n            {props.type !== 'menu' && <span className={'about'} onClick={(e) => setOpen(!open)}>Jjodel v{props.ver} <i className=\"bi bi-globe-americas\"></i> {props.name}</span>}\r\n            {open  && <AboutRaw ver={ver} name={name} />}\r\n        </>\r\n\r\n    );\r\n};\r\n\r\n\r\nexport {About, AboutModal};\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\topbar\\undoredocomponent.tsx",["963","964","965"],"import React, {Dispatch, PureComponent, ReactNode} from 'react';\r\nimport {\r\n    Dictionary, DUser,\r\n    GObject, DState,\r\n    Log, U, RedoAction,\r\n    statehistory,\r\n    UndoAction, store, DPointerTargetable, Pointer, LProject, UserHistory,\r\n} from '../../joiner';\r\nimport {connect} from \"react-redux\";\r\nimport \"./undoredo.scss\"\r\nimport {icon} from \"../../pages/components/icons/Icons\";\r\n\r\ninterface SaveManagerProps {}\r\n\r\nclass UndoRedoState{\r\n    hover: boolean = false;\r\n    jsx: any | null;\r\n    constructor(jsx: any) {  this.jsx = jsx; }\r\n}\r\n\r\n// private\r\ninterface ThisState {\r\n    undo: UndoRedoState;\r\n    redo: UndoRedoState;\r\n    user: Pointer<DUser>|'all';\r\n}\r\n\r\n// private\r\ninterface OwnProps {\r\n    // propsRequestedFromHtmlAsAttributes: string;\r\n    project: LProject;\r\n}\r\n// private\r\ninterface StateProps {\r\n    // propsFromReduxStateOrOtherKindOfStateManagement: boolean; // flux or custom things too, unrelated to this.state of react.\r\n    maxlistsize: number;\r\n    maxDetailSize: number;\r\n    //undo: GObject<\"delta\">[],\r\n    // redo: GObject<\"delta\">[],\r\n    debug: boolean\r\n}\r\n\r\n// private\r\ninterface DispatchProps {\r\n    // propsFromReduxActions: typeof funzioneTriggeraAzioneDaImportare;\r\n}\r\n\r\ntype R = {\r\n    str: string,\r\n    fullstr: string,\r\n    path:string[],\r\n    fullpath:string[],\r\n    fullpath_str?:string, // fullpath.join('.') only saved temporarly in render phase\r\n    val: string,\r\n    fullvalue: string,\r\n    pathlength?: number\r\n};\r\n\r\n// private\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\nexport class SaveManagerComponent extends PureComponent<AllProps, ThisState>{\r\n    public static cname: string = \"SaveManagerComponent\";\r\n    private undoredolistoutdated: boolean;\r\n    do_undo = (index: number) => {\r\n        UndoAction.new(index+1, this.state.user, false).commit();\r\n        this.undoenter(); // updates list\r\n    }\r\n    do_redo = (index: number) => {\r\n        console.log(\"redo(\" + index + \")\");\r\n        RedoAction.new(index+1, this.state.user, false).commit();\r\n        this.redoenter();\r\n    }\r\n    printablePointer(pathsegment: string, state: DState){\r\n        let obj = DPointerTargetable.from(pathsegment, state) as GObject;\r\n        if (!obj) return pathsegment;\r\n        if (obj.name) return \"$\"+obj.name;\r\n        if (obj.className) return \"#\"+obj.className;\r\n        return pathsegment;\r\n    }\r\n\r\n    // redo list is updated only when the user mouse-enters it. for efficiency.\r\n    undoredoenter2 = (key: \"undo\"|\"redo\" = \"undo\") => {\r\n        let history = this.get_history(this.state.user);\r\n        let undoarr = history.undoable;\r\n        let redoarr = history.redoable;\r\n        // console.log(\"statemanager undo update\", {thiss:this, undoarr, redoarr, user: this.state.user, props: this.props, state:this.state});\r\n        if (!this.undoredolistoutdated) return;\r\n        let s: DState = store.getState();\r\n        let arr = [...(key === 'undo' ? undoarr : redoarr)].reverse().slice(0, this.props.maxlistsize);\r\n        let out: {best: R, obj: GObject}&R[] = [] as any;\r\n        let strings = arr.map( delta => U.ObjectToAssignementStrings(delta, 10, 6, 20, \"…\", out, true));\r\n        //todo: make it just for current index, then get the next val from index+1 or current state, using R.path and replacing just the value. on mouseover switch it val of the delta vs next val\r\n            let list = arr.map((delta, index) => {})\r\n\r\n    }\r\n\r\n    improveText(e: R, s: DState) {\r\n        if (e.fullstr.includes(\"Pointer\")) {\r\n            let editedfullpath = e.fullpath.map( (pathsegment) => {\r\n                //  console.log(\"undoredo replace attempt\", {pathsegment, idlookup:s.idlookup, dobj:s.idlookup[pathsegment], replacement: this.printablePointer(pathsegment, s)});\r\n                return this.printablePointer(pathsegment, s); });\r\n            e.str = editedfullpath.join(\".\") + \" = \" + e.val;\r\n            console.log(\"undoredo replace attempt\", {editedfullpath, beststr:e.str, best: e});\r\n        }\r\n        if (e.path[0] === \"idlookup\") e.str = \"\" + e.str.substring(\"idlookup.\".length);\r\n        if (e.fullvalue.includes(\"Pointer\")) {\r\n            e.val = this.printablePointer(e.fullvalue.substring(1, e.fullvalue.length-1), s); // 1, -1 because string values have quotes \"\"\r\n            e.str = e.str.substring(0, e.str.lastIndexOf(\"=\")) + \"= \" + e.val;\r\n        }\r\n    }\r\n    undoredoenter = (key: \"undo\"|\"redo\" = \"undo??\" as any) => {\r\n        let debug = this.props.debug;\r\n        let history = this.get_history(this.state.user);\r\n        let undoarr = history.undoable;\r\n        let redoarr = history.redoable;\r\n        // console.log(\"statemanager undo update\", {thiss:this, undoarr, redoarr, user: this.state.user, props: this.props, state:this.state});\r\n        if (!this.undoredolistoutdated) return;\r\n        let s: DState = store.getState();\r\n        // let arr = [...(this.props as GObject)[key]].reverse().slice(0, this.props.maxlistsize);\r\n        let fullarr = [...(key === 'undo' ? undoarr : redoarr)].reverse()\r\n        let arr = fullarr.slice(0, this.props.maxlistsize);\r\n\r\n        function getLatestDelta(i: number, searchPath: string[], direction: -1 | 1 = 1): GObject {\r\n            outer: for (; i < fullarr.length+1 && i >= -1; i+=direction) {\r\n                let rootdelta = fullarr[i] || s;\r\n                let currDelta = rootdelta;\r\n                for (let pathSeg of searchPath){\r\n                    if (!(pathSeg in currDelta)) continue outer;\r\n                    else currDelta = currDelta[pathSeg];\r\n                }\r\n                return rootdelta;\r\n            }\r\n            return s;\r\n        }\r\n        let list = arr.map((delta, index) => {\r\n            let out: {best: R, obj: GObject}&R[] = [] as GObject as any;\r\n            let out_otherdelta: {best: R, obj: GObject}&R[] = [] as any;\r\n            let titleindex = index + (key === 'undo' ? -1 : 0);\r\n            let titleDelta = arr[titleindex]\r\n            let otherDelta = arr[index + 1]; //[index + (key === 'undo' ? -1 : +1)]\r\n            // let actiodesc = key ==='undo' ? arr[index + 1] : ) || s;\r\n\r\n            let excludedPaths: Dictionary<string, boolean> = {'action.title': true, 'action.description': true};\r\n            let filterrow = (e:R)=> {\r\n                //console.log('filterrow', {debug, e});\r\n                return debug || !excludedPaths[key] && !e.fullpath.includes(\"clonedCounter\")\r\n                    && !e.fullpath.includes(\"timestamp\")\r\n                    && !e.fullpath.includes(\"timestampdiff\")\r\n                    && !e.fullpath.includes(\"pointedBy\")\r\n                    && !e.fullpath.includes(\"pointedBy\")\r\n                    && !e.fullpath.includes('__jjObjDiffIsArr');\r\n            }\r\n            U.ObjectToAssignementStrings(delta, 10, 6, 20, \"…\", out, true, filterrow);\r\n            if (otherDelta) U.ObjectToAssignementStrings(otherDelta, 10, 6, 20, \"…\", out_otherdelta, true, filterrow);\r\n            // if (!index) console.log('debug undoredo', {out, delta, arr});\r\n            // if out.best is undef, then get most recent titles until you find a delta with a title or the current(state)\r\n            let latestTitleDelta = getLatestDelta(titleindex, ['action_title'], (key === 'undo' ? -1 : +1));\r\n            let debugTitle = (titleDelta||s).action_title;\r\n            // console.log('getLatestDelta', {delta, latestTitleDelta, best:out.best?.str, titleDelta, dt:(titleDelta||s).action_title, titleindex, out})\r\n            if (!out.best?.str) {\r\n                console.error('generated wrong delta??', {out, best:out?.best});\r\n                return <><div>errored</div></>;\r\n            }\r\n            if (latestTitleDelta.action_title) out.best.str = latestTitleDelta.action_title;\r\n            if (latestTitleDelta.action_description) out.best.fullstr = latestTitleDelta.action_description;\r\n            else out.best.fullstr = out.length + ' subchanges';\r\n            if (latestTitleDelta.action_title !== debugTitle) out.best.str = '* ' + out.best.str;\r\n            if ((otherDelta)?.action_title) out_otherdelta.best.str = (otherDelta||s).action_title;\r\n            if ((otherDelta)?.action_description) out_otherdelta.best.fullstr = (otherDelta||s).action_description;\r\n            out.best.str = U.cropStr(out.best.str, 1, 0, 13, 12);\r\n            out.best.fullstr = U.cropStr(out.best.fullstr, 1, 0, 250, 250);\r\n            //out_otherdelta.best.str = U.cropStr(out_otherdelta.best.str, 1, 0, 13, 12);\r\n            //out_otherdelta.best.fullstr = U.cropStr(out_otherdelta.best.fullstr, 1, 0, 250, 250);\r\n            //this.improveText(out.best, s);\r\n            let other = out.slice(0, this.props.maxDetailSize); //.map(e=>this.improveText(e));\r\n            let other2 = out_otherdelta.slice(0, this.props.maxDetailSize); //.map(e=>this.improveText(e));\r\n\r\n            let newstyle: boolean = true as any;\r\n\r\n            let entry = (): JSX.Element => {\r\n                return (\r\n                    <li onClick={() => ((this as GObject)[\"do_\" + key](index))} className=\"hoverable\" key={index} tabIndex={0}>\r\n                        <label className=\"highlight undefined\">\r\n                            <span><i className=\"bi bi-app hidden\"/> i</span>\r\n                        </label>\r\n                    </li>)\r\n            }\r\n            // if (newstyle) return entry();\r\n\r\n\r\n            for (let e of other2){ e.fullpath_str = e.fullpath.join(\".\")}\r\n            for (let e of other){ e.fullpath_str = e.fullpath.join(\".\")}\r\n            return <li onClick={() => ((this as GObject)[\"do_\" + key](index))} className=\"\" key={index}\r\n                       tabIndex={0}\r\n                       style={{/*overflow: \"visible\", height: \"24px\"*/}}>\r\n                <label className=\"highlight undefined hoverable\">\r\n                    <div className={\"my-auto preview\"}>{out.best.str}</div>\r\n                    <div className={\"my-auto content inline\"}>{out.best.fullstr}</div>\r\n                    <div className={\"content right detail-list\"}>\r\n                        <ul className=\"context-menu right\">{\r\n                            other.map((row, ii) => {\r\n                                let row2 = other2.filter(e=>e.fullpath_str === row.fullpath_str)[0];//other2[ii];\r\n                                return <li className={'detail-entry hoverable'} onClick={(e=> {\r\n                                    e.stopPropagation()\r\n                                })}>\r\n                                    <label className={`highlight disabled hoverable`}>\r\n                                    <span\r\n                                        className='preview inline'>{row.fullpath_str + \" = \" + row.fullvalue}</span>\r\n                                        <span className='content inline'>{row2 && (row2.fullpath_str + \" = \" + row2.fullvalue)}</span>\r\n                                    </label>\r\n                                </li>\r\n                            })}\r\n                            {out.length !== other.length ? <div className={'detail-entry'}>...</div> : null}\r\n                        </ul>\r\n                    </div>\r\n                </label>\r\n            </li>\r\n        });\r\n        let jsx =\r\n            <>{list}</>;\r\n        let obj: GObject = {};\r\n        obj[key] = {...(this.state as GObject)[key], hover: true, jsx};\r\n        // {undo: {...this.state.undo, hover: true, jsx}}\r\n        this.undoredolistoutdated = false;\r\n        this.setState(obj as ThisState);\r\n    }\r\n\r\n    undoenter = ()=>{ return this.undoredoenter(\"undo\"); }\r\n    redoenter = ()=>{ return this.undoredoenter(\"redo\"); }\r\n    undoleave = ()=>{ this.setState({undo: {...this.state.undo, hover: false}}); }\r\n    redoleave = ()=>{ this.setState({redo: {...this.state.redo, hover: false}}); }\r\n\r\n    constructor(props: AllProps, context: any) {\r\n        super(props, context);\r\n        let undo = new UndoRedoState(<div>undo list example</div>);\r\n        let redo = new UndoRedoState(<div>redo list example</div>);\r\n        this.state = {undo, redo, user: DUser.current};\r\n        this.undoredolistoutdated = true;\r\n        // this.setState({undo, redo});\r\n    }\r\n    get_history(user: Pointer<DUser> | 'all'): {redoable: GObject[], undoable: GObject[]}{\r\n        // let ret = {redoable: [] as GObject[], undoable: [] as GObject[]};\r\n        return statehistory[user];\r\n    }\r\n    erase_history(user: Pointer<DUser> | 'all', project: LProject){\r\n        if (user === 'all'){/*\r\n            for (let user of project.collaborators){\r\n                this.erase_history(user.id, project);\r\n            }\r\n            this.erase_history(DUser.current, project);*/\r\n            for (let user in statehistory){\r\n                statehistory[user].undoable = [];\r\n                statehistory[user].redoable = [];\r\n            }\r\n        } else {\r\n            statehistory[user].undoable = [];\r\n            statehistory[user].redoable = [];\r\n        }\r\n    }\r\n    render(): ReactNode {\r\n        let user = this.state.user;\r\n        this.undoredolistoutdated = true; // if render is called it means redux state props he's watching (redux-state) changed, so the preview list in component-state is outdated.\r\n        // console.log(\"undoredomanager\", {thiss:this, undo:this.props.undo, props: this.props, state:this.state});\r\n        let history: UserHistory = this.get_history(user);\r\n        let undo: GObject<\"delta\">[] = history?.undoable || [];\r\n        let redo: GObject<\"delta\">[] = history?.redoable || [];\r\n\r\n        let contextmenustyle =(undoStr: 'Undo'|'Redo', undoarr: GObject<\"delta\">[]): JSX.Element => {\r\n            let undostr = undoStr.toLowerCase() as 'undo'|'redo';\r\n            let isUndo = undoarr === undo;\r\n            return (\r\n            <li className={\"undoredo hoverable \" +(!undoarr.length?'disabled':'')} tabIndex={0}\r\n                onMouseEnter={isUndo?this.undoenter:this.redoenter}\r\n                onMouseLeave={isUndo?this.undoleave:this.redoleave}>\r\n\r\n                <label className=\"highlight undefined\" onClick={(e) => {\r\n                    isUndo ? this.do_undo(0) : this.do_redo(0)\r\n                }}>\r\n                    <span>{icon[undoStr.toLowerCase()]} <span>{undoStr + ' ' + ((undoarr).length || '')}</span></span>\r\n                    {<div className=\"keystrokes\">\r\n                        <i className=\"text-icon ctrl\" title=\"Control\" data-val=\"ctrl\" data-content=\"Control\"/>\r\n                        <span>{isUndo ? 'Z' : 'Y'}</span>\r\n                    </div>}\r\n                    {undoarr.length ? <i className=\"bi bi-chevron-right icon-expand-submenu\"/> : null}\r\n                </label>\r\n                <div className=\"content right\">\r\n                    {undoarr.length ? <ul className=\"context-menu right\">{this.state[undoStr.toLowerCase() as 'undo'|'redo'].jsx}</ul> : null}\r\n                </div>\r\n            </li>)\r\n        }\r\n\r\n        let testnew: boolean = true as any;\r\n        if (testnew) return <>\r\n            {contextmenustyle('Undo', undo)}\r\n            {contextmenustyle('Redo', redo)}\r\n        </>\r\n\r\n        return (<>\r\n            <div className='undoredo' key={'undo'}>\r\n                <span className={\"hoverable\"} style={{position: \"relative\", background: \"white\"}}\r\n                      onMouseEnter={this.undoenter} onMouseLeave={this.undoleave}>\r\n                    <button className={'item border round ms-1'} onClick={(e) => {\r\n                        this.do_undo(0)\r\n                    }}>Undo ({undo.length})</button>\r\n                    {undo.length ?\r\n                        <ul style={{background: \"inherit\", width: \"max-content\", zIndex:10000}} className={\"content\"}>\r\n                            {this.state.undo.jsx}\r\n                        </ul>\r\n                        : null}\r\n                </span>\r\n                <span className={\"hoverable\"} style={{position: \"relative\", background: \"white\"}} onMouseEnter={this.redoenter} onMouseLeave={this.redoleave}>\r\n                    <button className={'item border round ms-1'} onClick={(e)=> { this.do_redo(0) }}>Redo ({redo.length})</button>\r\n                    { redo.length ? <ul style={{background: \"inherit\", width: \"max-content\", zIndex:10000}} className={\"content\"}>{this.state.redo.jsx}</ul> : null}\r\n                </span>\r\n                <button onClick={()=>{this.erase_history(user, this.props.project)}}>x</button>\r\n            </div>\r\n        </>);\r\n    }\r\n}\r\n\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as any;\r\n    //ret.undo = statehistory[DUser.current].undoable;\r\n    //ret.redo = statehistory[DUser.current].redoable;\r\n    ret.maxlistsize = 20;\r\n    ret.maxDetailSize = 30;\r\n    ret.debug = state.debug;\r\n    return ret; }\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {} as any;\r\n    /// to fill\r\n    return ret; }\r\n\r\nexport const SaveManagerConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(SaveManagerComponent);\r\n\r\nexport default SaveManagerConnected;\r\nexport const Undoredocomponent = SaveManagerConnected;","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\api\\persistance\\admin.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\abstract\\tabs\\TabDataMaker.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\languages\\index.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\api\\persistance\\projects.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\api\\persistance\\users.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\api\\persistance\\auth.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\topbar\\SaveManager.ts",["966"],"import {\r\n    Dictionary,\r\n    DUser,\r\n    EcoreParser,\r\n    GObject,\r\n    DState,\r\n    Json,\r\n    LModel,\r\n    LoadAction,\r\n    Log,\r\n    U,\r\n    LPointerTargetable,\r\n    prjson2xml,\r\n    prxml2json,\r\n    store,\r\n    RuntimeAccessible,\r\n    DModelElement,\r\n    SetRootFieldAction,\r\n    Selectors,\r\n    Debug,\r\n    DViewElement,\r\n    transientProperties,\r\n    LUser\r\n} from '../../joiner';\r\nimport {ProjectsApi} from \"../../api/persistance\";\r\nimport {VersionFixer} from \"../../redux/VersionFixer\";\r\n\r\n@RuntimeAccessible('SaveManager')\r\nexport class SaveManager {\r\n    private static tmpsave: DState;\r\n\r\n    static save(): void {\r\n        let project = LUser.fromPointer(DUser.current)?.project;\r\n        if (project) ProjectsApi.save(project);\r\n        U.isProjectModified = false;\r\n        /*SaveManager.tmpsave = store.getState();\r\n        localStorage.setItem(\"tmpsave\", JSON.stringify(SaveManager.tmpsave));\r\n        console.clear();\r\n        console.log(JSON.stringify(SaveManager.tmpsave))*/\r\n    }\r\n\r\n    static load(state0?: string | GObject<DState>): void {\r\n        if (!state0 && SaveManager.tmpsave) { LoadAction.new(SaveManager.tmpsave); return; }\r\n        state0 = state0 || localStorage.getItem('tmpsave') || 'null'; // priorities: 1) argument from file 2) state variable cached 3) localstorage 4) null prevent crash\r\n        let save: GObject<DState> = SaveManager.tmpsave = typeof state0 === 'string' ? JSON.parse(state0) : state0;\r\n        for (let vid of [...save.viewelements, ...save.viewpoints]) {\r\n            for (let key of DViewElement.RecompileKeys) {\r\n                if(!transientProperties.view[vid]) transientProperties.view[vid] = {name: (save.idlookup[vid] as any)?.name || 'Unnamed'} as any;\r\n                key = 'VIEWS_RECOMPILE_' + key;\r\n                if (!save[key]) save[key] = [];\r\n                save[key].push(vid);\r\n            }\r\n        }\r\n        VersionFixer.update(save);\r\n        LoadAction.new(save);\r\n    }\r\n\r\n    public static exportEcore_click(toXML: boolean = false, toFile: boolean = true): void { // e: React.MouseEvent,\r\n        let lmodel: null|LModel = Selectors.getActiveModel();\r\n        if (!lmodel) return;\r\n        let json = SaveManager.exportEcore(lmodel);\r\n        let str = JSON.stringify(json, null, \"\\t\");\r\n        if (toXML) {\r\n            str = prjson2xml.json2xml(json, '\\t');\r\n            str = U.formatXml(str);\r\n        }\r\n\r\n        if (!toFile) {\r\n            // (document.querySelector(\"#export-tmp\") as any).innerText = str;\r\n            localStorage.setItem(\"import\", str);\r\n            return;\r\n        }\r\n        let ism2 = (lmodel as LModel).isMetamodel;\r\n        let name = (lmodel.name || (ism2 ? 'M2' : 'M1') + '_unnamed')  + (toXML ? \".xml\" : '.json') + \".\"+ (ism2 ? \"ecore\" : lmodel.instanceof?.name || \"shapeless\");\r\n        console.log(\"download file:\", {name, ism2, toXML, lmodel, instanceof:lmodel.instanceof});\r\n        U.download(name, str);\r\n    }\r\n\r\n    public static importEcore_click(fromXML: boolean = false, fromfile: boolean = true): void {\r\n        try { this.importEcore_click0(fromXML, fromfile); } catch (e: any) {\r\n            let str = e?.message?.substring?.(0, 1000) || 'some error';\r\n            console.trace(str, e);\r\n            // throw new Error(str);\r\n        }\r\n    }\r\n    public static importEcore_click0(fromXML: boolean = false, fromfile: boolean = true): void {\r\n        const extensions: string[] = [(fromXML ? \"*.xml.*\" : \"*.json.*\")]; // [\".ecore\"]; // Selectors.getActiveModel().isM1() ? '.' + Selectors.getActiveModel().metamodel.fullname() : '.ecore';\r\n        let filestring: string, jsonstring: string, jsonobj: GObject = undefined as any;\r\n        console.log(\"importEcore: prefromfile\");\r\n        if (!fromfile) {\r\n            filestring = localStorage.getItem(\"import\") || 'null';\r\n            if (fromXML) {\r\n                const xmlDoc = new DOMParser().parseFromString(filestring,\"text/xml\");\r\n                jsonobj = prxml2json.xml2jsonobj(xmlDoc, ' ');\r\n            }\r\n            //if (filestring.includes(\"\\n\")) throw new Error(filestring.substring(0, 1000));\r\n            SaveManager.importEcore(jsonobj || filestring, true, undefined, true); // todo: trova il modo di determinare se è m1 o m2 senza filename\r\n            return; }\r\n\r\n        console.log(\"importEcore: pre file read\", {fromXML, fromfile});\r\n        let filename;\r\n        U.fileRead((e: Event, files?: FileList | null, fileContents?: string[]) => {\r\n            Log.ex(!fileContents || !files || fileContents.length !== files.length, 'Failed to get file contents:', files, fileContents);\r\n            Log.ex(!!fileContents && fileContents.length > 1, 'Should not be possible to input multiple files yet.');\r\n            if (!fileContents) return;\r\n            if (fileContents.length == 0) return;\r\n            // @ts-ignore\r\n            filename = e.target.files?.[0].name;\r\n            console.log(\"file read\", {e, fileContents, files, filename});\r\n            filestring = fileContents[0];\r\n\r\n            // if file is over 500kb, lightmode on\r\n            if (filestring.length >= 500*1024 && !Debug.lightMode) {\r\n                Debug.setLightMode(true);\r\n                // $(document).one(\"click\", (e) => { Debug.setLightMode(false); });\r\n            }\r\n\r\n            console.log('importEcore filestring input: ', filestring);\r\n            if (fromXML) {\r\n                let windoww = window as any;\r\n                windoww.file = filestring;\r\n                windoww.todoc = (str: any) => new DOMParser().parseFromString(str,\"text/xml\");\r\n                windoww.doctojson = (doc: any) => prxml2json.xml2jsonobj(doc, ' ');\r\n                // problemi doctojson or xmi parser: \\n replacemet causa crash per stringa in posizione invalida. \\\" anche per attributi inline che iniiano con \\\\\"\r\n                // filestring = U.multiReplaceAll(filestring, [\"\\t\", \"\\r\", \"\\n\", '&amp;', '&#38;', '&quot;', '&', '\\'', '\"'], [\"\\\\t\", \"\\\\r\", \"\\\\n\", '\\\\&', \"\\\\'\", '\\\\\"', '\\\\&', \"\\\\'\", '\\\\\"']);//,  \"\\\\t\"), \"\\r\", \"\\\\r\"), \"\\n\", \"\\\\n\");\r\n\r\n                const xmlDoc = new DOMParser().parseFromString(filestring,\"text/xml\");\r\n                console.log('importEcore xml:', xmlDoc);\r\n                let jsonstring0 = '';\r\n                jsonobj = prxml2json.xml2jsonobj(xmlDoc, ' ');//doto: non devo wrappare con \\\" i nomi di chiavi o valori ma solo i contenuti\r\n                /*jsonstring = jsonstring0;\r\n                //jsonstring = U.multiReplaceAll(jsonstring0, [\"\\t\", \"\\r\", \"\\n\", '&amp;', '&#38;', '&quot;', '&', '\\'', '\"'], [\"\\\\t\", \"\\\\r\", \"\\\\n\", '\\\\&', \"\\\\'\", '\\\\\"', '\\\\&', \"\\\\'\", '\\\\\"']);//,  \"\\\\t\"), \"\\r\", \"\\\\r\"), \"\\n\", \"\\\\n\");\r\n                *///jsonstring = jsonstring.replaceAll(/(\\{|\\,)\\\\n\\s*/gm, \"\")\r\n                /*if (jsonstring.includes(\"\\n\")) throw new Error(jsonstring0.substring(0, 1000)+\"\\n\\n\\n\\n\" + jsonstring.substring(0, 1000));\r\n                */\r\n                // jsonstring = JSON.stringify(jsonobj);\r\n                if (jsonobj.parsererror) { Log.ee(\"failed to parse XML->JSON\", {parseError:jsonobj.parseerror, jsonobj});  return; }\r\n                console.log('importEcore jsonstr input: ', jsonobj);\r\n            }\r\n            else jsonstring = filestring;\r\n            let isMetamodel = filename.indexOf(\".ecore\") === filename.length - \".ecore\".length;\r\n            console.log(\"ismetamodel\", {filename, isMetamodel});\r\n            let end = SaveManager.importEcore(jsonobj || jsonstring || 'null', isMetamodel, filename, true);\r\n        }, extensions, true);\r\n    }\r\n\r\n    public static exportEcore(model: LModel): Json {\r\n        let loopobj = {};\r\n        try { return model.generateEcoreJson(loopobj); }\r\n        catch(e) { Log.exx(\"possible loop in model:\\t\\n\" + (e as Error).message, {loopobj, e}); }\r\n        return {\"error\": true, loopobj};\r\n    }\r\n    public static importEcore(jsonstr: GObject | string | null, isMetamodel: boolean, filename: string | undefined, persist: boolean = true): DModelElement[] {\r\n        return EcoreParser.parse(jsonstr, isMetamodel, filename, persist);\r\n    }\r\n\r\n    static exportLayout_click(toFile: boolean) {\r\n        let lmodel: LModel = (LPointerTargetable.wrap(store.getState().models[0]) as LModel);\r\n        // lmodel.node?.allSubNodes\r\n\r\n    }\r\n    static importLayout_click(fromFile: boolean) {\r\n\r\n    }\r\n}\r\n\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\abstract\\Dock.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\hooks\\useQuery.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\popups\\index.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\commandbar\\CommandBar.tsx",["967","968"],"import React, {MouseEventHandler, ClassAttributes, useState, useRef, useEffect, ReactElement, ReactNode} from \"react\";\r\nimport './commandbar.scss';\r\nimport { inherits } from \"util\";\r\nimport { Tooltip } from \"../forEndUser/Tooltip\";\r\nimport { U } from \"../../joiner\";\r\n\r\ntype BtnProps = {\r\n    disabled?: boolean;\r\n    active?: boolean;\r\n    icon: \"up\"\r\n        | \"down\"\r\n        | \"back\"\r\n        | \"fwd\"\r\n        | \"add\"\r\n        | \"add2\"\r\n        | \"delete\"\r\n        | \"delete2\"\r\n        | \"open\"\r\n        | \"edit\"\r\n        | \"favorite\"\r\n        | \"shrink\"\r\n        | \"expand\"\r\n        | \"space\"\r\n        | \"minispace\"\r\n        | \"sep\"\r\n        | \"check\"\r\n        | \"copy\"\r\n        | \"close\"\r\n        | \"info\"\r\n        | \"show\"\r\n        | \"open-down\"\r\n        | \"close-up\"\r\n        | \"settings\"\r\n        | \"download\";\r\n\r\n    tip?: string | ReactNode;\r\n    label?: string;\r\n    theme?: \"dark\" | \"light\",\r\n    action?: MouseEventHandler,\r\n    size?: \"x-small\" | \"small\" | \"medium\" | \"large\",\r\n    style?: React.CSSProperties,\r\n    mode?: 'normal' | 'negative'\r\n    className?: string;\r\n    needConfirm?:boolean;\r\n}\r\n\r\n\r\nexport const Btn = (props: BtnProps) => {\r\n\r\n    const [askingConfirm, setConfirm] = useState(false);\r\n    const mode = (props.mode ? props.mode : 'normal');\r\n    let needConfirm = props.needConfirm || props.icon === 'delete' && !props.disabled;\r\n    let i_classes = (props.className||'') + ` bi tab-btn commandbar-btn ${askingConfirm ? 'bi-question-square-fill question': props.icon} ${props.theme ? props.theme : 'light'} ${props.size||''} ${mode} ${props.disabled ? 'disabled ' : ''}`\r\n    let action = (e: React.MouseEvent<any,any>) => {\r\n        console.log('commandbar action', {disabled: props.disabled, action:props.action, askingConfirm, needConfirm});\r\n        if (props.disabled || !props.action) return;\r\n        if (!askingConfirm && needConfirm) {\r\n            setConfirm(true);\r\n            U.clickedOutside(e, ()=> {\r\n                console.log('clicked outside remove confirm');\r\n                setConfirm(false)\r\n            });\r\n            return;\r\n        }\r\n        props.action(e);\r\n        e.stopPropagation();\r\n    }\r\n    let icon: ReactNode = null;\r\n\r\n    switch (props.icon){\r\n        case 'delete2':\r\n            icon = <div className={`delete2 ${props.theme ? props.theme : 'light'}`}>Delete</div>; break;\r\n\r\n        case 'delete':\r\n            icon = <Tooltip tooltip={askingConfirm ? 'Are you sure?' : props.tip} inline={true} position={'top'} offsetY={10} >\r\n                <i onClick={action} style={props.style} className={i_classes} />\r\n            </Tooltip>; break;\r\n\r\n        default:\r\n            icon = <Tooltip tooltip={props.tip} inline={true} position={'top'} offsetY={10}>\r\n                <i className={i_classes} onClick={action} style={props.style}/>\r\n            </Tooltip>; break;\r\n    }\r\n\r\n    if (props.icon === \"space\" || props.icon === \"minispace\") return <span style={{display: 'block', width: `${props.icon === 'space' ? '24px' : '4px'}`}} />;\r\n    return <div className={'btn-component '+(props.active ? 'active' : '')}>{icon}</div>;\r\n}\r\n\r\n\r\n\r\nexport const Sep = (style?: any) => {\r\n\r\n    return (<>\r\n            {style ?\r\n                <div>\r\n                    <div className={'tab-btn sep'}></div>\r\n                </div>\r\n            :\r\n                <div>\r\n                    <div className={'tab-btn sep'} style={style}></div>\r\n                </div>\r\n            }\r\n\r\n    </>);\r\n}\r\n\r\n\r\ntype CommandProps = {\r\n    children: any,\r\n    style?: React.CSSProperties,\r\n    className?: string,\r\n    noBorder?: boolean;\r\n}\r\n\r\nexport const CommandBar = (props: CommandProps) => {\r\n\r\n    let style = props.style;\r\n\r\n    let noBorder = (props.noBorder ? props.noBorder: false);\r\n\r\n    return(<>\r\n        {props.style ?\r\n            <div className={`command-bar ${props.className && props.className} ${noBorder && 'no-border'}`} style={props.style}>\r\n                {props.children}\r\n            </div>\r\n            :\r\n            <div className={`command-bar ${props.className && props.className} ${noBorder && 'no-border'}`} >\r\n                {props.children}\r\n            </div>\r\n        }\r\n\r\n    </>);\r\n};\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\icons\\Icons.tsx",["969","970"],"import './icons.scss';\r\n\r\nimport jj from '../../../static/img/jj-k.png';\r\nimport { Tooltip } from '../../../components/forEndUser/Tooltip';\r\nimport { Logo, MetamodelIcon, ModelIcon } from '../../../components/logo';\r\n\r\nimport { LuPackage2 } from \"react-icons/lu\";\r\nimport { CgToolbarTop as Toolbar } from \"react-icons/cg\";\r\n\r\nexport let icon: { [name: string]: any} = {\r\n    'new': <i className=\"bi bi-plus-circle-dotted menuitem\"></i>,\r\n    close: <i className=\"bi bi-x-lg menuitem\"></i>,\r\n    edit: <i className=\"bi bi-pencil-square menuitem\"></i>,\r\n    duplicate: <i className=\"bi bi-files menuitem\"></i>,\r\n    copy: <i className=\"bi bi-files menuitem\"></i>,\r\n    undo: <i className=\"bi bi-arrow-counterclockwise menuitem\"></i>,\r\n    redo: <i className=\"bi bi-arrow-clockwise menuitem\"></i>,\r\n    save: <i className=\"bi bi-floppy menuitem\"></i>,\r\n    select: <i className=\"bi bi-check menuitem\"></i>,\r\n    deselect: <i className=\"bi bi-check2 menuitem\"></i>,\r\n    add: <i className=\"bi bi-plus-circle-dotted menuitem\"></i>,\r\n    validation: <i className=\"bi bi-check2-circle menuitem\"></i>,\r\n    validate: <i className=\"bi bi-clipboard-check menuitem\"></i>,\r\n    faq: <i className=\"bi bi-chat-left-dots menuitem\"></i>,\r\n    'user-guide': <i className=\"bi bi-journal-text menuitem\"></i>,\r\n    glossary: <i className=\"bi bi-book menuitem\"></i>,\r\n\r\n    'import': <i className=\"bi bi-cloud-upload menuitem\"></i>,\r\n    'export': <i className=\"bi bi-arrow-bar-right menuitem\"></i>,\r\n    download: <i className=\"bi bi-cloud-download menuitem\"></i>,\r\n\r\n    favorite: <i className=\"bi bi-star menuitem\"></i>,\r\n    favoriteFill: <i className=\"bi bi-star-fill menuitem\"></i>,\r\n    share: <i className=\"bi bi-share menuitem\"></i>,\r\n    delete: <i className=\"bi bi-trash3 menuitem\"></i>,\r\n    'delete-confirm': <i className=\"bi bi-question-square-fill menuitem confirm\"></i>,\r\n    refresh: <i className=\"bi bi-arrow-clockwise menuitem\"></i>,\r\n    up: <i className=\"bi bi-arrow-up menuitem\"></i>,\r\n    down: <i className=\"bi bi-arrow-down menuitem\"></i>,\r\n    lock: <i className=\"bi bi-lock menuitem\" style={{marginRight: '10px'}}></i>,\r\n    unlock: <i className=\"bi bi-unlock menuitem\" style={{marginRight: '10px'}}></i>,\r\n    view: <i className=\"bi bi-window-plus menuitem\"></i>,\r\n    grid: <i className=\"bi bi-grid-3x3-gap menuitem\"></i>,\r\n    maximize: <i className=\"bi bi-arrows-fullscreen menuitem\"></i>,\r\n    fullscreen: <i className=\"bi bi-arrows-fullscreen menuitem\"></i>,\r\n    'fullscreen-exit': <i className=\"bi bi-fullscreen-exit\"></i>,\r\n    'zoom-in': <i className=\"bi bi-zoom-in menuitem\"></i>,\r\n    'zoom-out': <i className=\"bi bi-zoom-out menuitem\"></i>,\r\n    help: <i className=\"bi bi-question-square menuitem\"></i>,\r\n    'whats-, Metamodel': <i className=\"bi bi-bell menuitem\"></i>,\r\n    home: <i className=\"bi bi-house menuitem\"></i>,\r\n    'getting-started': <i className=\"bi bi-airplane menuitem\"></i>,\r\n    manual: <i className=\"bi bi-journals menuitem\"></i>,\r\n    legal: <i className=\"bi bi-mortarboard menuitem\"></i>,\r\n    about: <Logo style={{width: 15}} className={'menuitem'}/>,\r\n    'jjodel-dark': <img src={jj} width={15} className={'menuitem'}/>,\r\n    'jjodel-clear': <img\r\n        style={{border: '1px solid var(--color)', borderRadius: '2px', marginTop: '2px', marginRight: '-2px'}} src={jj}\r\n        width={16} className={'menuitem'}/>,\r\n\r\n    jjodel: <Logo style={{fontSize: '1.5em'}} className={'menuitem'}/>,\r\n    metamodel: <MetamodelIcon className={'menuitem'} style={{fontSize: '1.5em'}}/>,\r\n    model: <ModelIcon className={'menuitem'} style={{fontSize: '1.5em'}}/>,\r\n    project: <LuPackage2 style={{fontSize: '1.5em'}} className='menuitem'/>,\r\n\r\n    logout: <i className=\"bi bi-box-arrow-right menuitem\"></i>,\r\n    dashboard2: <i className=\"bi bi-grid menuitem\"></i>,\r\n    dashboard: <i className=\"bi bi-columns-gap menuitem\"></i>,\r\n    profile: <i className=\"bi bi-person-square menuitem\"></i>,\r\n    settings: <i className=\"bi bi-sliders menuitem\"></i>,\r\n    recent: <i className=\"bi bi-clock-history menuitem\"></i>,\r\n    folder: <i className=\"bi bi-folder menuitem\"></i>,\r\n    template: <i className=\"bi bi-code-square menuitem\"></i>,\r\n    template2: <i className=\"bi bi-lightbulb menuitem\"></i>,\r\n    extend: <i className=\"bi bi-caret-up menuitem\" style={{paddingBottom: '2px'}}></i>,\r\n    ai: <i className=\"bi bi-stars\"></i>,\r\n    metrics: <i className=\"bi bi-graph-up\" style={{marginRight: '10px'}}></i>,\r\n    analytics: <i className=\"bi bi-graph-up menuitem\"></i>,\r\n    submenu: <i className=\"bi bi-chevron-right menuitem float-end\"></i>,\r\n    contract: <i className=\"bi bi-arrows-angle-contract\"></i>,\r\n    expand: <i className=\"bi bi-arrows-angle-expand\"></i>,\r\n    alphabetical: <i className=\"bi bi-sort-alpha-down\"></i>,\r\n    created: <i className=\"bi bi-calendar2-plus\"></i>,\r\n    modified: <i className=\"bi bi-clock\"></i>,\r\n    lastModified: <i className=\"bi bi-clock\"></i>,\r\n    link: <i style={{scale: '1.2'}}\r\n             className=\"bi bi-link-45deg menuitem\"></i>,\r\n    learn: <i className=\"bi bi-infinity menuitem\"></i>,\r\n    video: <i className=\"bi bi-youtube menuitem\"></i>,\r\n    roadmap: <i className=\"bi bi-calendar3 menuitem\"></i>,\r\n    support: <i className=\"bi bi-life-preserver menuitem\"></i>,\r\n    'report-bug': <i className=\"bi bi-bug menuitem\"></i>,\r\n    'feature-request': <i className=\"bi bi-hand-index menuitem\"></i>,\r\n    contact: <i className=\"bi bi-card-text menuitem\"></i>,\r\n    'toggle-grid': <i className=\"bi bi-grid-1x2 menuitem\"></i>,\r\n    'toggle-snap': <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"22\" height=\"22\" fill=\"currentColor\"\r\n                        className=\"bi bi-layout-sidebar\" viewBox=\"0 0 16 16\">\r\n        <path\r\n            d=\"M6 1H1v14h5z m9 0h-5v5h5zm0 9v5M0 1a1 1 0 0 1 1-1h5a1 1 0 0 1 1 1v14a1 1 0 0 1-1 1H1a1 1 0 0 1-1-1zm9 0a1 1 0 0 1 1-1h5a1 1 0 0 1 1 1v5a1 1 0 0 1-1 1h-5a1 1 0 0 1-1-1zm1 8a1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h5a1 1 0 0 0 1-1v-5a1 1 0 0 0-1-1z\"/>\r\n    </svg>,\r\n    'reset-layout': <i className=\"bi bi-columns menuitem\"></i>,\r\n    sidebar: <i className=\"bi bi-layout-sidebar menuitem\"></i>,\r\n    toolbar2: <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"22\" height=\"22\" fill=\"currentColor\"\r\n                   className=\"bi bi-layout-sidebar\" viewBox=\"0 0 16 16\">\r\n        <path\r\n            d=\"M0 3a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2z m2 -1 a1 1 0 0 0 -1 1v2h14v-2a1 1 0 0 0 -1 -1zm -1 4l 0 7a1 1 0 0 0 1 1h12a1 1 0 0 0 1 -1v-7z\"/>\r\n    </svg>\r\n}\r\n\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\collaborative\\CollaborativeAttacher.tsx",["971"],"import Collaborative from './Collaborative';\r\nimport type {CompositeAction, GObject, LProject, Pointer} from '../../joiner';\r\nimport {Action, SetRootFieldAction} from '../../joiner';\r\nimport {useEffect, useState} from \"react\";\r\n\r\ninterface Props {project: LProject}\r\nfunction CollaborativeAttacher(props: Props) {\r\n    const project = props.project;\r\n    const [actions, setActions] = useState<Pointer[]>([]);\r\n\r\n    useEffect(() => {\r\n        SetRootFieldAction.new('collaborativeSession', true);\r\n        Collaborative.client.io.opts.query = {'project': project.id};\r\n        Collaborative.client.connect();\r\n        /*\r\n        return () => {\r\n            Collaborative.client.off('pullAction');\r\n            Collaborative.client.disconnect();\r\n            SetRootFieldAction.new('collaborativeSession', false);\r\n        }\r\n        */\r\n        Collaborative.client.on('pullAction', (action: GObject<Action & CompositeAction>) => {\r\n            const receivedAction = Action.fromJson(action);\r\n            console.log('Received Action from server.', action);\r\n            receivedAction.hasFired = 0;\r\n            if(!actions.includes(receivedAction.id)) {\r\n                console.log('Received actions', actions)\r\n                setActions([...actions, action.id]);\r\n                receivedAction.fire();\r\n            }\r\n        });\r\n    }, []);\r\n\r\n    return(<></>);\r\n}\r\n\r\nexport default CollaborativeAttacher;\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\LatestUpdates.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\Edit\\Edit.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\data\\api.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\abstract\\tabs\\MetamodelTab.tsx",["972","973"],"import React, {Dispatch, ReactElement} from \"react\";\r\nimport {connect} from \"react-redux\";\r\nimport {DModel, Pointer, Try, U} from \"../../../joiner\";\r\nimport {\r\n    DState,\r\n    CreateElementAction,\r\n    DGraph,\r\n    LGraph,\r\n    LModel,\r\n    Edge,\r\n    DUser,\r\n    DClass,\r\n    SetRootFieldAction\r\n} from \"../../../joiner\";\r\nimport {DefaultNode} from \"../../../joiner/components\";\r\nimport ToolBar from \"../../toolbar/ToolBar\";\r\nimport ContextMenu from \"../../contextMenu/ContextMenu\";\r\nimport { MetricsPanel } from \"../../metrics/Metrics\";\r\n\r\n\r\nfunction MetamodelTabComponent(props: AllProps) {\r\n    const model = props.model;\r\n    const graph = props.graph;\r\n    const isEdgePending = props.isEdgePending;\r\n\r\n    if (!model) return(<>closed tab</>);\r\n    if (!graph) {\r\n        DGraph.new(0, model.id);\r\n        return(<div style={{width: \"100%\", height: \"100%\", display: \"flex\"}}>\r\n            <span style={{margin: \"auto\"}}>Building the Graph...</span>\r\n        </div>);\r\n    }\r\n\r\n    return(<div className={'w-100 h-100'}>\r\n        <MetricsPanel data={model}/>\r\n        <ContextMenu />\r\n        {/*<PendingEdge />*/}\r\n        {/* Temporary Edge Pending Manager */}\r\n        {isEdgePending.source && <div style={{position: 'absolute', top: 15, right: 15, zIndex: 999}}\r\n             className={'w-fit bg-white rounded border p-2'}>\r\n            <label className={'d-block text-center'}>Pending Edge...</label>\r\n            <label tabIndex={-1} onClick={e => SetRootFieldAction.new('isEdgePending', {user: '', source: ''})}\r\n               className={'cursor-pointer text-decoration-none d-block text-danger text-center'}>close</label>\r\n        </div>}\r\n\r\n        <div className={'d-flex h-100'}>\r\n            <ToolBar model={model.id} isMetamodel={model.isMetamodel} />\r\n            <Try>\r\n                <div className={\"GraphContainer h-100 w-100\"} style={{position:\"relative\"}}\r\n                     onClick={ e => {\r\n                         if(!U.isProjectModified) U.isProjectModified = U.userHasInteracted = true\r\n                     }}>\r\n                    {graph && <DefaultNode data={model} nodeid={graph.id} graphid={graph.id}/> || <div>Error: missing DGraph prop</div> }\r\n                </div>\r\n            </Try>\r\n        </div>\r\n    </div>);\r\n\r\n}\r\ninterface OwnProps { modelid: Pointer<DModel, 1, 1, LModel> }\r\ninterface StateProps {\r\n    model: LModel,\r\n    graph: LGraph,\r\n    isEdgePending: {user: Pointer<DUser>, source: Pointer<DClass>}\r\n}\r\ninterface DispatchProps { }\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as any;\r\n    ret.model = LModel.fromPointer(ownProps.modelid);\r\n    const graphs: DGraph[] = DGraph.fromPointer(state.graphs);\r\n    const pointers = graphs.filter((graph) => { return graph.model === ret.model?.id });\r\n    if (pointers.length > 0) ret.graph = LGraph.fromPointer(pointers[0].id);\r\n    ret.isEdgePending = state.isEdgePending\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\n\r\nexport const MetamodelTabConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(MetamodelTabComponent);\r\n\r\nexport const MetamodelTab = (props: OwnProps, children: (string | React.Component)[] = []): ReactElement => {\r\n    return <MetamodelTabConnected {...{...props, children}} />;\r\n}\r\nexport default MetamodelTab;\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\abstract\\tabs\\ModelTab.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\languages\\Ocl.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\languages\\Jsx.tsx",["974"],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\languages\\Js.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\PermissionModelTab.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\popups\\Model.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\pages\\components\\popups\\Metamodel.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\abstract\\tabs\\ModelsSummaryTab.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\Broker.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\NodeEditor.tsx",["975","976","977","978"],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\dock\\MyRcDock.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\metrics\\Metrics.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\contextMenu\\ContextMenu.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\toolbar\\ToolBar.tsx",["979","980","981"],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\languages\\Javascript.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\index.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\Empty.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\dock\\MyDock.tsx",["982","983","984","985","986","987"],"import JqxDockingLayout, {IDockingLayoutProps} from \"jqwidgets-scripts/jqwidgets-react-tsx/jqxdockinglayout\";\r\nimport React, {PureComponent, ReactElement, ReactNode} from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\n/*import \"./jqx.base.css\"\r\nimport \"./jqx.darkblue.css\"*/\r\nimport \"./jqx.custom-styling.scss\"\r\nimport \"./smartdock.custom-styling.scss\"\r\nimport 'jqwidgets-scripts/jqwidgets/styles/jqx.base.css';\r\nimport 'jqwidgets-scripts/jqwidgets/styles/jqx.material-purple.css';\r\nimport $ from \"jquery\";\r\nimport {Dictionary, DocString, GObject, Log} from \"../../joiner\";\r\nimport { DockingLayout } from 'smart-webcomponents-react/dockinglayout';\r\n\r\nimport {DockLayout, LayoutData} from 'rc-dock';\r\nimport { Slider } from 'smart-webcomponents-react/slider';\r\nimport { MultilineTextBox } from 'smart-webcomponents-react/multilinetextbox';\r\nclass PortalOwnProps{\r\n    children!: ReactNode;\r\n    container!: string | Element;\r\n}\r\n\r\nexport class MyPortal extends React.Component<PortalOwnProps> {\r\n    container: Element | null = null;\r\n    maxRetries: number = 10;\r\n    retries: number = 0;\r\n\r\n    constructor(props: PortalOwnProps) {\r\n        super(props);\r\n    }\r\n\r\n    render() {\r\n        if (!this.container) {\r\n            if (!this.props.container) return <div>Error: Portal container is {this.props.container}</div>;\r\n            if (typeof this.props.container === 'object') this.container = this.props.container; else\r\n            if (typeof this.props.container === 'string') this.container = document.querySelector(this.props.container);\r\n        }\r\n        if (!this.container) {\r\n            if (this.retries++ < this.maxRetries) this.forceUpdate();\r\n            console.log('MyPortal retry getting container', {thiss: this, props: this.props});\r\n            return this.props.children;\r\n        }\r\n        this.retries = 0;\r\n        return ReactDOM.createPortal(this.props.children, this.container);\r\n    }\r\n}\r\nconst defaultLayout = [{\r\n    type: 'LayoutGroup',\r\n    orientation: 'horizontal',\r\n    items: [{\r\n        type: 'LayoutGroup',\r\n        items: [{\r\n            type: 'LayoutPanel',\r\n            id: 'tabPanel',\r\n            label: 'Input',\r\n            items: [{\r\n                id: 'tab1',\r\n                label: 'first TextBox Tab',\r\n                content: '<div class=\"tab-root\" idata-d=\"do not use those content at all. the whole content is lost when you save state\"><div>firstcontainer content</div></div>'\r\n            },\r\n                {\r\n                    id: 'tabslider',\r\n                    label: 'Slider Tab',\r\n                    content: '<div style=\"padding:10px;\" id=\"secondContainer\"></div>'\r\n                }\r\n            ]\r\n        },\r\n            {\r\n                type: 'LayoutPanel',\r\n                label: 'Output',\r\n                items: [{\r\n                    id: 'outputTab',\r\n                    label: 'Output',\r\n                    headerPosition: 'none',\r\n                    content: 'Write more text here ...'\r\n                }]\r\n            }\r\n        ],\r\n        orientation: 'vertical'\r\n    },\r\n        {\r\n            id: 'item0',\r\n            label: 'Tabs 0',\r\n            items: [{\r\n                id: 'tab A',\r\n                label: 'Tab A',\r\n                selected: true,\r\n                content: 'What is Lorem Ipsum?\\n' +\r\n                    'Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry\\'s standard dummy text ever since the 1500s, when an unknown printer took a galley of' + 'type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in ' + 'the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.\\n' +\r\n                    'Why do we use it?\\n' +\r\n                    'It is a long established fact that a reader will be distracted by the readable content of a page when looking at its layout. The point of using Lorem Ipsum is that it has a more-or-less normal ' + 'distribution of letters, as opposed to using \\'Content here, content here\\', making it look like readable English. Many desktop publishing packages and web page editors now use Lorem Ipsum as their' + 'default model text, and a search for \\'lorem ipsum\\' will uncover many web sites still in their infancy. Various versions have evolved over the years, sometimes by accident, sometimes on ' + 'purpose (injected humour and the like).'\r\n            }]\r\n        }\r\n    ]\r\n}];\r\n\r\nexport class SmartDock extends React.Component {\r\n    public layout: GObject;\r\n    constructor(props: any) {\r\n        super(props);\r\n        let layoutstr = localStorage.getItem('smartDockingLayoutdocking-smart-1');\r\n        let layout: GObject | null = layoutstr ? JSON.parse(layoutstr) : null;\r\n        if (!layout) {\r\n            layout = defaultLayout;\r\n        }\r\n        this.layout = layout;\r\n    }\r\n\r\n    private html: HTMLElement | null = null;\r\n    private dock: DockingLayout | null = null;\r\n    // componentDidMount() { this.afterUpdate(); }\r\n    dockReady() { this.afterUpdate(); }\r\n    componentDidUpdate(prevProps: Readonly<{}>, prevState: Readonly<{}>, snapshot?: any) { this.afterUpdate(); }\r\n\r\n    saveHtmlMap: Dictionary<DocString<'id'>, NodeListOf<ChildNode>> = {}\r\n    beforeUpdate(){\r\n        if (!this.html) return;\r\n        let $tabs = $(this.html).find('smart-tab-item.smart-element.smart-tab-item');\r\n        let tab: HTMLElement;\r\n        for (tab of $tabs){\r\n            if (!tab.id) { Log.eDevv('tabs must have id\\'s', {tab}); }\r\n            this.saveHtmlMap[tab.id] = tab.childNodes;\r\n        }\r\n    }\r\n    afterUpdate(){\r\n        if ((this.dock as any).items.length === 0) {\r\n            this.layout = defaultLayout;\r\n            this.forceUpdate();\r\n            // dock failed to load from localStorage, i'm forcing rerender.\r\n        }\r\n        (window as any).debugAfterUpdate = () => {\r\n            this.forceUpdate();\r\n        }\r\n        if (window) return; // weirdly it works also without this?\r\n        // ReactDOM.render(<MultilineTextBox />, document.querySelector(\"#firstContainer\"));\r\n        //ReactDOM.render(<Slider />, document.querySelector(\"#secondContainer\"));\r\n        if (!this.html) return;\r\n        // let $html = $(this.html);\r\n        let id: string;\r\n        for (id in this.saveHtmlMap){\r\n            let elem = document.getElementById(id);\r\n            if (!elem) { continue; }\r\n            for (let c of this.saveHtmlMap[id]) {\r\n                elem.append(c);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    render() {\r\n        const random = Math.random();\r\n        let layout: GObject = this.layout;\r\n        let r = (random * 255).toFixed(0);\r\n        this.beforeUpdate();\r\n        return (\r\n            <div onMouseEnter={() => this.forceUpdate()} ref={e => this.html = e}>\r\n                <h1>{r}</h1>\r\n                <DockingLayout id={'docking-smart-1'} autoSaveState={true} autoLoadState={true}\r\n                               ref={(e)=> {\r\n                                   this.dock = e;\r\n                                   if (!this.dock) return;\r\n                                   // this.dock.loadState(layout);\r\n                               }}\r\n                               style={{backgroundColor: `rgb(${r}, ${r}, ${r})`}}\r\n                    onReady={() => this.dockReady()} layout={layout} draggable={true}>\r\n                </DockingLayout>\r\n                <MyPortal container={'#tab1'}>\r\n                    <div id={'tab1content'}>tab1 content!</div>\r\n                </MyPortal>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\n/*\r\nhow to do custom pinned tabs:\r\n\r\nto show preview after is pinned:\r\nkeep a fake tab in a sidebar outside rc-dock. keep the rc-dock tab hidden in floating mode but anchored to the side of the pin.\r\nwhen hover on a sidebar title, set display: block on the hovering tab.\r\n\r\nto unpin: set display: block on the hovering tab and remove the sidebar fake tab\r\nto pin: set tab on float mode, position it near the pin fake sidebar, make a fake sidebar entry, then hide the float tab\r\n\r\nbonus: add pin buttons at the 4 edges near the current position of the 4\r\n .jqx-docking-layout-overlay-square.jqx-docking-layout-overlay-square-edge\r\n\r\n*/\r\nexport class JQDock extends React.PureComponent<{}, IDockingLayoutProps> {\r\n    constructor(props: {}) {\r\n        super(props);\r\n        const layout: IDockingLayoutProps['layout'] = [\r\n            {\r\n                items: [{\r\n                    alignment: 'left',\r\n                    items: [{\r\n                        contentContainer: 'ToolboxPanel',\r\n                        title: 'toolbox', //<b color={\"red\"}>Toolbox red</b>,\r\n                        type: 'layoutPanel'\r\n                    }, {\r\n                        contentContainer: 'HelpPanel',\r\n                        title: 'Help',\r\n                        type: 'layoutPanel'\r\n                    }],\r\n                    type: 'autoHideGroup',\r\n                    unpinnedWidth: 200,\r\n                    width: 80\r\n                },\r\n                    {\r\n                        items: [{\r\n                            height: 400,\r\n                            items: [{\r\n                                contentContainer: 'Document1Panel',\r\n                                title: 'Document 1',\r\n                                type: 'documentPanel',\r\n                            },\r\n                                {\r\n                                    contentContainer: 'Document2Panel',\r\n                                    title: 'Document 2',\r\n                                    type: 'documentPanel'\r\n                                }],\r\n                            minHeight: 200,\r\n                            type: 'documentGroup'\r\n                        },\r\n                            {\r\n                                height: 200,\r\n                                items: [{\r\n                                    contentContainer: 'ErrorListPanel',\r\n                                    title: 'Error List',\r\n                                    type: 'layoutPanel'\r\n                                }],\r\n                                pinnedHeight: 30,\r\n                                type: 'tabbedGroup'\r\n                            }],\r\n                        orientation: 'vertical',\r\n                        type: 'layoutGroup',\r\n                        width: 500\r\n                    },\r\n                    {\r\n                        items: [\r\n                            {\r\n                                contentContainer: 'SolutionExplorerPanel',\r\n                                initContent: () => {\r\n                                    // initialize a jqxTree inside the Solution Explorer Panel\r\n                                    const source = [{\r\n                                        expanded: true,\r\n                                        icon: './../images/earth.png',\r\n                                        items: [\r\n                                            {\r\n                                                expanded: true,\r\n                                                icon: './../images/folder.png',\r\n                                                items: [{\r\n                                                    icon: './../images/nav1.png',\r\n                                                    label: 'jqx.base.css'\r\n                                                },\r\n                                                    {\r\n                                                        icon: './../images/nav1.png',\r\n                                                        label: 'jqx.energyblue.css'\r\n                                                    }, {\r\n                                                        icon: './../images/nav1.png',\r\n                                                        label: 'jqx.orange.css'\r\n                                                    }],\r\n                                                label: 'css'\r\n                                            },\r\n                                            {\r\n                                                icon: './../images/folder.png',\r\n                                                items: [{\r\n                                                    icon: './../images/nav1.png',\r\n                                                    label: 'jqxcore.js'\r\n                                                },\r\n                                                    {\r\n                                                        icon: './../images/nav1.png',\r\n                                                        label: 'jqxdata.js'\r\n                                                    }, {\r\n                                                        icon: './../images/nav1.png',\r\n                                                        label: 'jqxgrid.js'\r\n                                                    }],\r\n                                                label: 'scripts',\r\n                                            },\r\n                                            {\r\n                                                icon: './../images/nav1.png',\r\n                                                label: 'index.htm'\r\n                                            }],\r\n                                        label: 'Project',\r\n                                    }];\r\n                                    ReactDOM.render(<div>tree?</div>, document.querySelector('#treeContainer'));\r\n                                },\r\n                                title: 'Solution Explorer',\r\n                                type: 'layoutPanel'\r\n                            },\r\n                            {\r\n                                contentContainer: 'PropertiesPanel',\r\n                                title: 'Properties',\r\n                                type: 'layoutPanel'\r\n                            }],\r\n                        minWidth: 200,\r\n                        type: 'tabbedGroup',\r\n                        width: 220\r\n                    }],\r\n                orientation: 'horizontal',\r\n                type: 'layoutGroup'\r\n            },\r\n            {\r\n                height: 300,\r\n                items: [{\r\n                    contentContainer: 'OutputPanel',\r\n                    selected: true,\r\n                    title: 'Output',\r\n                    type: 'layoutPanel'\r\n                }],\r\n                position: {\r\n                    x: 350,\r\n                    y: 250\r\n                },\r\n                type: 'floatGroup',\r\n                width: 500\r\n            }\r\n        ];\r\n        this.state = {\r\n            layout\r\n        }\r\n    }\r\n    public html: Element | null = null;\r\n    callbackReference(e: HTMLElement | null) {\r\n        this.html = e;\r\n        if (!e) return;\r\n        $(e).on('float', function (event: JQuery.Event & GObject) {\r\n            var floatedItem = event.args.item;\r\n            const $allfloats = $('.jqx-docking-layout-group-floating');\r\n            console.log(\"something is afloat\", {event, args:event.args, floatedItem, e, $allfloats});\r\n            // @ts-ignore\r\n            e.prepend(...($allfloats as any));\r\n\r\n        });\r\n    }\r\n    public render() {\r\n        return (\r\n            <div id={\"dock-roottt\"}  ref={(e)=> this.callbackReference(e)}>\r\n            <JqxDockingLayout width={500} height={300} layout={this.state.layout}>\r\n                {/* The panel content divs can have a flat structure */}\r\n                {/* autoHideGroup */}\r\n                <div data-container={'ToolboxPanel'}>\r\n                    List of tools\r\n                </div>\r\n                <div data-container={'HelpPanel'}>\r\n                    Help topics\r\n                </div>\r\n                {/* documentGroup */}\r\n                <div data-container={'Document1Panel'}>\r\n                    Document 1 content\r\n                </div>\r\n                <div data-container={'Document2Panel'}>\r\n                    Document 2 content\r\n                </div>\r\n                {/* bottom tabbedGroup */}\r\n                <div data-container={'ErrorListPanel'}>\r\n                    List of errors\r\n                </div>\r\n                {/* right tabbedGroup */}\r\n                <div data-container={'SolutionExplorerPanel'}>\r\n                    <div id=\"treeContainer\" style={{ border: 'none', width: '99%', height: '100%' }} />\r\n                </div>\r\n                <div data-container={'PropertiesPanel'}>\r\n                    List of properties\r\n                </div>\r\n                {/* floatGroup */}\r\n                <div data-container={'OutputPanel'}>\r\n                    <div style={{ fontFamily: 'Inter Tight' }}>\r\n                        <p>\r\n                            Themes installation complete.\r\n                        </p>\r\n                        <p>\r\n                            List of installed stylesheet files. Include at least one stylesheet Theme file and\r\n                            the images folder:\r\n                        </p>\r\n                        <ul>\r\n                            <li>\r\n                                styles/jqx.base.css: Stylesheet for the base Theme. The jqx.base.css file should\r\n                                be always included in your project.\r\n                            </li>\r\n                            <li>styles/jqx.arctic.css: Stylesheet for the Arctic Theme</li>\r\n                            <li>styles/jqx.web.css: Stylesheet for the Web Theme</li>\r\n                            <li>styles/jqx.bootstrap.css: Stylesheet for the Bootstrap Theme</li>\r\n                            <li>styles/jqx.classic.css: Stylesheet for the Classic Theme</li>\r\n                            <li>styles/jqx.darkblue.css: Stylesheet for the DarkBlue Theme</li>\r\n                            <li>styles/jqx.energyblue.css: Stylesheet for the EnergyBlue Theme</li>\r\n                            <li>styles/jqx.shinyblack.css: Stylesheet for the ShinyBlack Theme</li>\r\n                            <li>styles/jqx.office.css: Stylesheet for the Office Theme</li>\r\n                            <li>styles/jqx.metro.css: Stylesheet for the Metro Theme</li>\r\n                            <li>styles/jqx.metrodark.css: Stylesheet for the Metro Dark Theme</li>\r\n                            <li>styles/jqx.orange.css: Stylesheet for the Orange Theme</li>\r\n                            <li>styles/jqx.summer.css: Stylesheet for the Summer Theme</li>\r\n                            <li>styles/jqx.black.css: Stylesheet for the Black Theme</li>\r\n                            <li>styles/jqx.fresh.css: Stylesheet for the Fresh Theme</li>\r\n                            <li>styles/jqx.highcontrast.css: Stylesheet for the HighContrast Theme</li>\r\n                            <li>styles/jqx.blackberry.css: Stylesheet for the Blackberry Theme</li>\r\n                            <li>styles/jqx.android.css: Stylesheet for the Android Theme</li>\r\n                            <li>styles/jqx.mobile.css: Stylesheet for the Mobile Theme</li>\r\n                            <li>styles/jqx.windowsphone.css: Stylesheet for the Windows Phone Theme</li>\r\n                            <li>styles/jqx.ui-darkness.css: Stylesheet for the UI Darkness Theme</li>\r\n                            <li>styles/jqx.ui-lightness.css: Stylesheet for the UI Lightness Theme</li>\r\n                            <li>styles/jqx.ui-le-frog.css: Stylesheet for the UI Le Frog Theme</li>\r\n                            <li>styles/jqx.ui-overcast.css: Stylesheet for the UI Overcast Theme</li>\r\n                            <li>styles/jqx.ui-redmond.css: Stylesheet for the UI Redmond Theme</li>\r\n                            <li>styles/jqx.ui-smoothness.css: Stylesheet for the UI Smoothness Theme</li>\r\n                            <li>styles/jqx.ui-start.css: Stylesheet for the UI Start Theme</li>\r\n                            <li>styles/jqx.ui-sunny.css: Stylesheet for the UI Sunny Theme</li>\r\n                            <li>styles/images: contains images referenced in the stylesheet files</li>\r\n                        </ul>\r\n                    </div>\r\n                </div>\r\n            </JqxDockingLayout>\r\n            </div>\r\n        );\r\n    }\r\n}\r\nexport const MyDock = JQDock;\r\n// export class MyDock extends JQDock{}\r\n\r\n\r\n/*\r\n// @ts-ignore\r\nexport function MyDock(...a:any) {\r\n// @ts-ignore\r\n    return <igc-dockmanager id=\"dockManager\" onClick={()=>new IgcDockManager()}>\r\n        <div slot=\"content1\" className=\"dockManagerContent\">Content 1</div>\r\n        <div slot=\"content2\" className=\"dockManagerContent\">Content 2</div>\r\n        <div slot=\"content3\" className=\"dockManagerContent\">Content 3</div>\r\n        <div slot=\"content4\" className=\"dockManagerContent\">Content 4</div>\r\n        <div slot=\"content5\" className=\"dockManagerContent\">Content 5</div>\r\n        <div slot=\"content6\" className=\"dockManagerContent\">Content 6</div>\r\n        <div slot=\"content7\" className=\"dockManagerContent\">Content 7</div>\r\n        <div slot=\"content8\" className=\"dockManagerContent\">Content 8</div>\r\n        <div slot=\"content9\" className=\"dockManagerContent\">Content 9</div>\r\n        <div slot=\"content10\" className=\"dockManagerContent\">Content 10</div>\r\n        <div slot=\"content11\" className=\"dockManagerContent\">Content 11</div>\r\n        <div slot=\"content12\" className=\"dockManagerContent\">Content 12</div>\r\n        {/* @ts-ignore * /}\r\n    </igc-dockmanager>\r\n\r\n\r\n//    return <IgcDockManager {...a}></IgcDockManager>;\r\n}\r\n*/\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\ModellingIcon.tsx",["988"],"import React from 'react';\r\nimport EPackage from '../../static/icon/modelling/package.png';\r\nimport EClass from '../../static/icon/modelling/class.png';\r\nimport EAttribute from '../../static/icon/modelling/attribute.png';\r\nimport EReference from '../../static/icon/modelling/reference.png';\r\nimport EOperation from '../../static/icon/modelling/operation.png';\r\nimport EEnumerator from '../../static/icon/modelling/enumerator.png';\r\nimport ELiteral from '../../static/icon/modelling/literal.png';\r\nimport Utility from '../../static/img/utility.png';\r\n\r\ninterface Props {name?: string, className?: string, src?:string}\r\n\r\n/* function ModellingIcon(props: Props) {\r\n    const name = props.name;\r\n    const className = props.className ? props.className : '';\r\n    const pprops = {width:20, height:20, className:`my-auto ${className||''} ` + (name || '')}\r\n    if (props.src) return <img {...pprops} src={props.src} />;\r\n    switch (name) {\r\n        case 'package': return(<img {...pprops} src={EPackage} />);\r\n        case 'object':\r\n        case 'class':\r\n            return(<img {...pprops} src={EClass} />);\r\n        case 'reference': return(<img {...pprops} src={EReference} />);\r\n        case 'operation': return(<img {...pprops} src={EOperation} />);\r\n        case 'enumerator': return(<img {...pprops} src={EEnumerator} />);\r\n        case 'literal': return(<img {...pprops} src={ELiteral} />);\r\n        case 'value':\r\n        case 'attribute':\r\n            return(<img {...pprops} src={EAttribute} />);\r\n        default:\r\n            return(<img {...pprops} src={Utility} />);\r\n\r\n    }\r\n}*/\r\n\r\ntype IconProps = {\r\n    letter: string\r\n}\r\nfunction Icon(props: IconProps) {\r\n\r\n    return (\r\n        <label className={'element-icon'}>{props.letter}</label>\r\n    );\r\n\r\n};\r\n\r\nfunction ModellingIcon(props: Props) {\r\n    const name = props.name;\r\n    const className = props.className ? props.className : '';\r\n    const pprops = {width:20, height:20, className:`my-auto ${className||''} ` + (name || '')}\r\n    if (props.src) return <img {...pprops} src={props.src} />;\r\n    switch (name) {\r\n        case 'package': return(<Icon letter={'P'} />);\r\n        case 'object':\r\n        case 'class':\r\n            return(<Icon letter={'C'} />);\r\n        case 'reference': return(<Icon letter={'R'} />)\r\n        case 'operation': return(<Icon letter={'O'} />)\r\n        case 'enumerator': return(<Icon letter={'E'} />)\r\n        case 'literal': return(<Icon letter={'L'} />)\r\n        case 'value':\r\n        case 'attribute':\r\n            return(<Icon letter={'A'} />)\r\n        default:\r\n            return(<Icon letter={'U'} />)\r\n    }\r\n}\r\n\r\nexport default ModellingIcon;\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\model\\logicWrapper\\index.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\Collaborative.tsx",["989"],"import {Dispatch, ReactElement, useEffect, useState} from 'react';\r\nimport {connect} from 'react-redux';\r\nimport type {DState, LProject} from '../../joiner';\r\nimport {DUser, GObject, LUser, U} from '../../joiner';\r\nimport {FakeStateProps} from '../../joiner/types';\r\nimport {UsersApi} from \"../../api/persistance\";\r\nimport {Btn, CommandBar} from '../commandbar/CommandBar';\r\nimport {useEffectOnce} from \"usehooks-ts\";\r\n\r\nfunction CollaborativeComponent(props: AllProps) {\r\n    const {project, users} = props;\r\n    const [emails, setEmails] = useState<string[]>([]);\r\n    const [filteredEmails, setFilteredEmails] = useState<string[]>([]);\r\n    const [email, setEmail] = useState<string>('');\r\n\r\n    useEffectOnce(() => {\r\n        (async function() {\r\n            setEmails(await UsersApi.getAllEmails());\r\n        })();\r\n    });\r\n\r\n    useEffect(() => {\r\n        if(!email) setFilteredEmails([]);\r\n        else setFilteredEmails(emails.filter(e => e.startsWith(email)));\r\n    }, [email])\r\n\r\n    const addCollaborator = async(e: string) => {\r\n        const user = await UsersApi.getUserByEmail(e);\r\n        if(!user) {\r\n            U.alert('e', 'Cannot retrieve user data.', 'Something went wrong ...');\r\n            return;\r\n        }\r\n        if(!users.map(u => u.id).includes(user.id))\r\n            DUser.new(user.name, user.surname, user.nickname, user.affiliation, user.country, user.newsletter, user.email, '', user.id);\r\n        if(project.collaborators.map(c => c.id).includes(user.id)) return;\r\n        project.collaborators = [...project.collaborators, user];\r\n    }\r\n\r\n    return(<section className={'page-root collaborative-tab'}>\r\n        <h1 className={'view'}>Collaborative Modeling</h1>\r\n        <div className={'p-1 w-100  d-flex'} style={{borderRadius: 'var(--radius)'}}>\r\n            <h5><i className=\"bi bi-person-video3\"></i> Editor</h5>\r\n            <label className={'ms-auto'}>{project.author.nickname}</label>\r\n        </div>\r\n        {project.collaborators.length > 0 && <div className={'mt-2 p-1 w-100 border'} style={{borderRadius: 'var(--radius'}}>\r\n            <h5><i className=\"bi bi-person-video3\"></i> Collaborators</h5>\r\n            <div className={'ms-auto'}>\r\n                {project.collaborators.map((c, index) => {\r\n                    return(<label className={'ms-1'} key={index}>{c.surname}</label>);\r\n                })}\r\n            </div>\r\n        </div>}\r\n        <input placeholder={'contributor email'} className={'input w-25 float-end'} defaultValue={email} onChange={e => setEmail(e.target.value)} />\r\n        <div>\r\n            {filteredEmails.map(e => <div key={e}>\r\n                <CommandBar className={'float-end'} style={{marginLeft: '5px'}}>\r\n                    {e}\r\n                    <Btn icon={'add'} action={() => addCollaborator(e)} tip={'Invite contributor'} />\r\n                </CommandBar>\r\n            </div>)}\r\n        </div>\r\n        <div className={'alert'}>\r\n            <i className=\"bi bi-exclamation-circle\"></i>\r\n            Important: After sending the invitation, save the project!\r\n        </div>\r\n    </section>);\r\n}\r\ninterface OwnProps {}\r\ninterface StateProps {project: LProject, users: LUser[]}\r\ninterface DispatchProps {}\r\ntype AllProps = OwnProps & StateProps & DispatchProps;\r\n\r\n\r\nfunction mapStateToProps(state: DState, ownProps: OwnProps): StateProps {\r\n    const ret: StateProps = {} as FakeStateProps;\r\n    const user = LUser.fromPointer(DUser.current);\r\n    ret.project = user.project as LProject;\r\n    ret.users = LUser.fromPointer(state.users);\r\n    return ret;\r\n}\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {};\r\n    return ret;\r\n}\r\n\r\nexport const CollaborativeConnected = connect<StateProps, DispatchProps, OwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(CollaborativeComponent);\r\n\r\nexport const Collaborative = (props: OwnProps, children: (string | React.Component)[] = []): ReactElement => {\r\n    return <CollaborativeConnected {...{...props, children}} />;\r\n}\r\n","C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\NestedView.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\MetaData.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\Info.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\Logger.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\Settings.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\Console.tsx",["990","991","992","993","994","995"],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\Skeleton.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\api\\memorec\\index.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\ViewData.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\Tree.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\data\\ComponentsTab.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\data\\PermissionViewpointTab.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\data\\PermissionViewTab.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\data\\PaletteData.tsx",["996"],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\data\\GenericNodeData.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\data\\CustomData.tsx",["997"],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\data\\TemplateData.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\data\\InfoData.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\tooltip\\MyTooltip.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\Color.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\data\\EdgePointData.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\data\\EdgeData.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\data\\FieldData.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\data\\GraphData.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\forEndUser\\FunctionComponent.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\views\\data\\NodeData.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\widgets\\Widgets.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\alert\\Dialog.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\logo.tsx",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\common\\libraries\\projectModified.ts",[],"C:\\0Programmi\\Dev\\projects\\frontend\\jjodel\\frontend\\src\\components\\editors\\MTM.tsx",[],{"ruleId":"998","replacedBy":"999"},{"ruleId":"1000","replacedBy":"1001"},{"ruleId":"1002","severity":1,"message":"1003","line":14,"column":8,"nodeType":"1004","endLine":14,"endColumn":18,"suggestions":"1005"},{"ruleId":"1006","severity":1,"message":"1007","line":19,"column":29,"nodeType":"1008","messageId":"1009","endLine":19,"endColumn":31},{"ruleId":"1010","severity":1,"message":"1011","line":26,"column":22,"nodeType":"1012","messageId":"1013","endLine":26,"endColumn":23},{"ruleId":"1006","severity":1,"message":"1007","line":27,"column":22,"nodeType":"1008","messageId":"1009","endLine":27,"endColumn":24},{"ruleId":"1006","severity":1,"message":"1007","line":29,"column":27,"nodeType":"1008","messageId":"1009","endLine":29,"endColumn":29},{"ruleId":"1006","severity":1,"message":"1014","line":31,"column":37,"nodeType":"1008","messageId":"1009","endLine":31,"endColumn":39},{"ruleId":"1006","severity":1,"message":"1007","line":34,"column":45,"nodeType":"1008","messageId":"1009","endLine":34,"endColumn":47},{"ruleId":"998","replacedBy":"999"},{"ruleId":"1000","replacedBy":"1001"},{"ruleId":"1006","severity":1,"message":"1007","line":11,"column":23,"nodeType":"1008","messageId":"1009","endLine":11,"endColumn":25},{"ruleId":"1006","severity":1,"message":"1007","line":18,"column":30,"nodeType":"1008","messageId":"1009","endLine":18,"endColumn":32},{"ruleId":"1006","severity":1,"message":"1007","line":19,"column":35,"nodeType":"1008","messageId":"1009","endLine":19,"endColumn":37},{"ruleId":"1006","severity":1,"message":"1007","line":20,"column":35,"nodeType":"1008","messageId":"1009","endLine":20,"endColumn":37},{"ruleId":"1010","severity":1,"message":"1015","line":25,"column":28,"nodeType":"1012","messageId":"1013","endLine":25,"endColumn":29},{"ruleId":"1006","severity":1,"message":"1007","line":26,"column":37,"nodeType":"1008","messageId":"1009","endLine":26,"endColumn":39},{"ruleId":"1006","severity":1,"message":"1007","line":28,"column":42,"nodeType":"1008","messageId":"1009","endLine":28,"endColumn":44},{"ruleId":"1010","severity":1,"message":"1015","line":57,"column":28,"nodeType":"1012","messageId":"1013","endLine":57,"endColumn":29},{"ruleId":"1006","severity":1,"message":"1007","line":63,"column":28,"nodeType":"1008","messageId":"1009","endLine":63,"endColumn":30},{"ruleId":"1006","severity":1,"message":"1007","line":97,"column":28,"nodeType":"1008","messageId":"1009","endLine":97,"endColumn":30},{"ruleId":"1006","severity":1,"message":"1007","line":110,"column":33,"nodeType":"1008","messageId":"1009","endLine":110,"endColumn":35},{"ruleId":"1006","severity":1,"message":"1007","line":112,"column":33,"nodeType":"1008","messageId":"1009","endLine":112,"endColumn":35},{"ruleId":"1016","severity":1,"message":"1017","line":123,"column":22,"nodeType":"1018","messageId":"1019","endLine":123,"endColumn":23,"suggestions":"1020"},{"ruleId":"1006","severity":1,"message":"1007","line":130,"column":25,"nodeType":"1008","messageId":"1009","endLine":130,"endColumn":27},{"ruleId":"1006","severity":1,"message":"1007","line":139,"column":30,"nodeType":"1008","messageId":"1009","endLine":139,"endColumn":32},{"ruleId":"1006","severity":1,"message":"1007","line":150,"column":21,"nodeType":"1008","messageId":"1009","endLine":150,"endColumn":23},{"ruleId":"1021","severity":1,"message":"1022","line":188,"column":9,"nodeType":"1023","messageId":"1009","endLine":188,"endColumn":62},{"ruleId":"1024","severity":1,"message":"1025","line":190,"column":9,"nodeType":"1026","messageId":"1009","endLine":190,"endColumn":13},{"ruleId":"1027","severity":1,"message":"1028","line":575,"column":20,"nodeType":"1029","messageId":"1030","endLine":575,"endColumn":22},{"ruleId":"1027","severity":1,"message":"1028","line":575,"column":44,"nodeType":"1029","messageId":"1030","endLine":575,"endColumn":46},{"ruleId":"1016","severity":1,"message":"1031","line":1588,"column":74,"nodeType":"1018","messageId":"1019","endLine":1588,"endColumn":75,"suggestions":"1032"},{"ruleId":"1016","severity":1,"message":"1031","line":1588,"column":97,"nodeType":"1018","messageId":"1019","endLine":1588,"endColumn":98,"suggestions":"1033"},{"ruleId":"1034","severity":1,"message":"1035","line":1701,"column":104,"nodeType":"1036","messageId":"1037","endLine":1701,"endColumn":106},{"ruleId":"1027","severity":1,"message":"1028","line":1844,"column":28,"nodeType":"1029","messageId":"1030","endLine":1844,"endColumn":30},{"ruleId":"1027","severity":1,"message":"1028","line":1844,"column":38,"nodeType":"1029","messageId":"1030","endLine":1844,"endColumn":40},{"ruleId":"1027","severity":1,"message":"1028","line":1855,"column":89,"nodeType":"1029","messageId":"1030","endLine":1855,"endColumn":91},{"ruleId":"1027","severity":1,"message":"1028","line":1855,"column":97,"nodeType":"1029","messageId":"1030","endLine":1855,"endColumn":99},{"ruleId":"1027","severity":1,"message":"1028","line":1856,"column":50,"nodeType":"1029","messageId":"1030","endLine":1856,"endColumn":52},{"ruleId":"1027","severity":1,"message":"1028","line":1856,"column":63,"nodeType":"1029","messageId":"1030","endLine":1856,"endColumn":65},{"ruleId":"1027","severity":1,"message":"1038","line":2361,"column":24,"nodeType":"1029","messageId":"1030","endLine":2361,"endColumn":26},{"ruleId":"1027","severity":1,"message":"1038","line":2361,"column":57,"nodeType":"1029","messageId":"1030","endLine":2361,"endColumn":59},{"ruleId":"1027","severity":1,"message":"1038","line":2568,"column":16,"nodeType":"1029","messageId":"1030","endLine":2568,"endColumn":18},{"ruleId":"1027","severity":1,"message":"1038","line":2568,"column":27,"nodeType":"1029","messageId":"1030","endLine":2568,"endColumn":29},{"ruleId":"1039","severity":1,"message":"1040","line":429,"column":13,"nodeType":"1041","messageId":"1042","endLine":429,"endColumn":61},{"ruleId":"1027","severity":1,"message":"1028","line":217,"column":44,"nodeType":"1029","messageId":"1030","endLine":217,"endColumn":46},{"ruleId":"1027","severity":1,"message":"1028","line":217,"column":53,"nodeType":"1029","messageId":"1030","endLine":217,"endColumn":55},{"ruleId":"1043","severity":1,"message":"1044","line":680,"column":79,"nodeType":"1045","messageId":"1046","endLine":680,"endColumn":135},{"ruleId":"1016","severity":1,"message":"1047","line":710,"column":109,"nodeType":"1018","messageId":"1019","endLine":710,"endColumn":110,"suggestions":"1048"},{"ruleId":"1043","severity":1,"message":"1044","line":726,"column":29,"nodeType":"1045","messageId":"1046","endLine":726,"endColumn":93},{"ruleId":"1043","severity":1,"message":"1044","line":735,"column":29,"nodeType":"1045","messageId":"1046","endLine":735,"endColumn":72},{"ruleId":"1043","severity":1,"message":"1044","line":776,"column":38,"nodeType":"1045","messageId":"1046","endLine":776,"endColumn":66},{"ruleId":"1043","severity":1,"message":"1044","line":815,"column":30,"nodeType":"1045","messageId":"1046","endLine":815,"endColumn":58},{"ruleId":"1043","severity":1,"message":"1044","line":837,"column":57,"nodeType":"1045","messageId":"1046","endLine":837,"endColumn":85},{"ruleId":"1043","severity":1,"message":"1044","line":878,"column":63,"nodeType":"1045","messageId":"1046","endLine":878,"endColumn":90},{"ruleId":"1039","severity":1,"message":"1040","line":1011,"column":21,"nodeType":"1049","messageId":"1042","endLine":1029,"endColumn":124},{"ruleId":"1050","severity":1,"message":"1051","line":216,"column":17,"nodeType":"1052","messageId":"1009","endLine":218,"endColumn":28},{"ruleId":"1039","severity":1,"message":"1040","line":209,"column":9,"nodeType":"1053","messageId":"1042","endLine":209,"endColumn":34},{"ruleId":"1027","severity":1,"message":"1038","line":286,"column":22,"nodeType":"1029","messageId":"1030","endLine":286,"endColumn":24},{"ruleId":"1027","severity":1,"message":"1038","line":286,"column":41,"nodeType":"1029","messageId":"1030","endLine":286,"endColumn":43},{"ruleId":"1027","severity":1,"message":"1038","line":287,"column":22,"nodeType":"1029","messageId":"1030","endLine":287,"endColumn":24},{"ruleId":"1027","severity":1,"message":"1038","line":287,"column":41,"nodeType":"1029","messageId":"1030","endLine":287,"endColumn":43},{"ruleId":"1027","severity":1,"message":"1038","line":288,"column":22,"nodeType":"1029","messageId":"1030","endLine":288,"endColumn":24},{"ruleId":"1027","severity":1,"message":"1038","line":288,"column":41,"nodeType":"1029","messageId":"1030","endLine":288,"endColumn":43},{"ruleId":"1027","severity":1,"message":"1038","line":289,"column":22,"nodeType":"1029","messageId":"1030","endLine":289,"endColumn":24},{"ruleId":"1027","severity":1,"message":"1038","line":289,"column":41,"nodeType":"1029","messageId":"1030","endLine":289,"endColumn":43},{"ruleId":"1027","severity":1,"message":"1038","line":290,"column":26,"nodeType":"1029","messageId":"1030","endLine":290,"endColumn":28},{"ruleId":"1027","severity":1,"message":"1038","line":290,"column":50,"nodeType":"1029","messageId":"1030","endLine":290,"endColumn":52},{"ruleId":"1027","severity":1,"message":"1038","line":291,"column":27,"nodeType":"1029","messageId":"1030","endLine":291,"endColumn":29},{"ruleId":"1027","severity":1,"message":"1038","line":291,"column":52,"nodeType":"1029","messageId":"1030","endLine":291,"endColumn":54},{"ruleId":"1039","severity":1,"message":"1040","line":623,"column":13,"nodeType":"1054","messageId":"1042","endLine":630,"endColumn":42},{"ruleId":"1039","severity":1,"message":"1040","line":812,"column":9,"nodeType":"1053","messageId":"1042","endLine":812,"endColumn":19},{"ruleId":"1006","severity":1,"message":"1007","line":928,"column":57,"nodeType":"1008","messageId":"1009","endLine":928,"endColumn":59},{"ruleId":"1027","severity":1,"message":"1038","line":982,"column":25,"nodeType":"1029","messageId":"1030","endLine":982,"endColumn":27},{"ruleId":"1027","severity":1,"message":"1038","line":982,"column":35,"nodeType":"1029","messageId":"1030","endLine":982,"endColumn":37},{"ruleId":"1027","severity":1,"message":"1028","line":982,"column":35,"nodeType":"1029","messageId":"1030","endLine":982,"endColumn":37},{"ruleId":"1027","severity":1,"message":"1028","line":982,"column":45,"nodeType":"1029","messageId":"1030","endLine":982,"endColumn":47},{"ruleId":"1027","severity":1,"message":"1028","line":1036,"column":24,"nodeType":"1029","messageId":"1030","endLine":1036,"endColumn":26},{"ruleId":"1027","severity":1,"message":"1028","line":1036,"column":43,"nodeType":"1029","messageId":"1030","endLine":1036,"endColumn":45},{"ruleId":"1027","severity":1,"message":"1028","line":1037,"column":28,"nodeType":"1029","messageId":"1030","endLine":1037,"endColumn":30},{"ruleId":"1027","severity":1,"message":"1028","line":1037,"column":47,"nodeType":"1029","messageId":"1030","endLine":1037,"endColumn":49},{"ruleId":"1039","severity":1,"message":"1040","line":502,"column":9,"nodeType":"1054","messageId":"1042","endLine":514,"endColumn":58},{"ruleId":"1039","severity":1,"message":"1040","line":520,"column":9,"nodeType":"1053","messageId":"1042","endLine":520,"endColumn":28},{"ruleId":"1039","severity":1,"message":"1040","line":585,"column":9,"nodeType":"1049","messageId":"1042","endLine":611,"endColumn":26},{"ruleId":"1055","severity":1,"message":"1056","line":857,"column":30,"nodeType":"1012","messageId":"1057","endLine":857,"endColumn":44},{"ruleId":"1024","severity":1,"message":"1025","line":349,"column":20,"nodeType":"1026","messageId":"1009","endLine":349,"endColumn":24},{"ruleId":"1027","severity":1,"message":"1028","line":507,"column":59,"nodeType":"1029","messageId":"1030","endLine":507,"endColumn":61},{"ruleId":"1027","severity":1,"message":"1028","line":507,"column":82,"nodeType":"1029","messageId":"1030","endLine":507,"endColumn":84},{"ruleId":"1039","severity":1,"message":"1040","line":600,"column":9,"nodeType":"1053","messageId":"1042","endLine":600,"endColumn":23},{"ruleId":"1039","severity":1,"message":"1040","line":638,"column":9,"nodeType":"1053","messageId":"1042","endLine":638,"endColumn":20},{"ruleId":"1027","severity":1,"message":"1028","line":732,"column":33,"nodeType":"1029","messageId":"1030","endLine":732,"endColumn":35},{"ruleId":"1027","severity":1,"message":"1028","line":732,"column":54,"nodeType":"1029","messageId":"1030","endLine":732,"endColumn":56},{"ruleId":"1016","severity":1,"message":"1058","line":745,"column":27,"nodeType":"1018","messageId":"1019","endLine":745,"endColumn":28,"suggestions":"1059"},{"ruleId":"1016","severity":1,"message":"1060","line":745,"column":29,"nodeType":"1018","messageId":"1019","endLine":745,"endColumn":30,"suggestions":"1061"},{"ruleId":"1024","severity":1,"message":"1025","line":816,"column":13,"nodeType":"1026","messageId":"1009","endLine":816,"endColumn":17},{"ruleId":"1043","severity":1,"message":"1044","line":818,"column":26,"nodeType":"1045","messageId":"1046","endLine":818,"endColumn":97},{"ruleId":"1024","severity":1,"message":"1025","line":921,"column":20,"nodeType":"1026","messageId":"1009","endLine":921,"endColumn":24},{"ruleId":"1043","severity":1,"message":"1044","line":948,"column":19,"nodeType":"1045","messageId":"1046","endLine":948,"endColumn":151},{"ruleId":"1024","severity":1,"message":"1025","line":954,"column":20,"nodeType":"1026","messageId":"1009","endLine":954,"endColumn":24},{"ruleId":"1043","severity":1,"message":"1044","line":963,"column":17,"nodeType":"1045","messageId":"1046","endLine":963,"endColumn":61},{"ruleId":"1024","severity":1,"message":"1025","line":969,"column":36,"nodeType":"1026","messageId":"1009","endLine":969,"endColumn":40},{"ruleId":"1027","severity":1,"message":"1028","line":1014,"column":29,"nodeType":"1029","messageId":"1030","endLine":1014,"endColumn":31},{"ruleId":"1027","severity":1,"message":"1028","line":1014,"column":38,"nodeType":"1029","messageId":"1030","endLine":1014,"endColumn":40},{"ruleId":"1027","severity":1,"message":"1038","line":1285,"column":24,"nodeType":"1029","messageId":"1030","endLine":1285,"endColumn":26},{"ruleId":"1027","severity":1,"message":"1038","line":1285,"column":38,"nodeType":"1029","messageId":"1030","endLine":1285,"endColumn":40},{"ruleId":"1027","severity":1,"message":"1038","line":1863,"column":44,"nodeType":"1029","messageId":"1030","endLine":1863,"endColumn":46},{"ruleId":"1027","severity":1,"message":"1038","line":1863,"column":64,"nodeType":"1029","messageId":"1030","endLine":1863,"endColumn":66},{"ruleId":"1039","severity":1,"message":"1040","line":1940,"column":9,"nodeType":"1053","messageId":"1042","endLine":1940,"endColumn":26},{"ruleId":"1006","severity":1,"message":"1014","line":2115,"column":53,"nodeType":"1008","messageId":"1009","endLine":2115,"endColumn":55},{"ruleId":"1006","severity":1,"message":"1014","line":2120,"column":63,"nodeType":"1008","messageId":"1009","endLine":2120,"endColumn":65},{"ruleId":"1006","severity":1,"message":"1014","line":2125,"column":58,"nodeType":"1008","messageId":"1009","endLine":2125,"endColumn":60},{"ruleId":"1006","severity":1,"message":"1014","line":2130,"column":52,"nodeType":"1008","messageId":"1009","endLine":2130,"endColumn":54},{"ruleId":"1006","severity":1,"message":"1014","line":2135,"column":54,"nodeType":"1008","messageId":"1009","endLine":2135,"endColumn":56},{"ruleId":"1006","severity":1,"message":"1014","line":2138,"column":55,"nodeType":"1008","messageId":"1009","endLine":2138,"endColumn":57},{"ruleId":"1006","severity":1,"message":"1014","line":2143,"column":53,"nodeType":"1008","messageId":"1009","endLine":2143,"endColumn":55},{"ruleId":"1006","severity":1,"message":"1014","line":2148,"column":52,"nodeType":"1008","messageId":"1009","endLine":2148,"endColumn":54},{"ruleId":"1006","severity":1,"message":"1014","line":2153,"column":53,"nodeType":"1008","messageId":"1009","endLine":2153,"endColumn":55},{"ruleId":"1006","severity":1,"message":"1014","line":2158,"column":55,"nodeType":"1008","messageId":"1009","endLine":2158,"endColumn":57},{"ruleId":"1006","severity":1,"message":"1014","line":2163,"column":55,"nodeType":"1008","messageId":"1009","endLine":2163,"endColumn":57},{"ruleId":"1006","severity":1,"message":"1014","line":2166,"column":55,"nodeType":"1008","messageId":"1009","endLine":2166,"endColumn":57},{"ruleId":"1006","severity":1,"message":"1014","line":2171,"column":56,"nodeType":"1008","messageId":"1009","endLine":2171,"endColumn":58},{"ruleId":"1006","severity":1,"message":"1014","line":2176,"column":43,"nodeType":"1008","messageId":"1009","endLine":2176,"endColumn":45},{"ruleId":"1006","severity":1,"message":"1007","line":2184,"column":39,"nodeType":"1008","messageId":"1009","endLine":2184,"endColumn":41},{"ruleId":"1006","severity":1,"message":"1014","line":2189,"column":41,"nodeType":"1008","messageId":"1009","endLine":2189,"endColumn":43},{"ruleId":"1006","severity":1,"message":"1014","line":2190,"column":41,"nodeType":"1008","messageId":"1009","endLine":2190,"endColumn":43},{"ruleId":"1006","severity":1,"message":"1014","line":2191,"column":41,"nodeType":"1008","messageId":"1009","endLine":2191,"endColumn":43},{"ruleId":"1016","severity":1,"message":"1047","line":2265,"column":98,"nodeType":"1018","messageId":"1019","endLine":2265,"endColumn":99,"suggestions":"1062"},{"ruleId":"1016","severity":1,"message":"1063","line":2265,"column":100,"nodeType":"1018","messageId":"1019","endLine":2265,"endColumn":101,"suggestions":"1064"},{"ruleId":"1065","severity":1,"message":"1066","line":2441,"column":38,"nodeType":"1036","messageId":"1067","endLine":2450,"endColumn":18},{"ruleId":"1055","severity":1,"message":"1068","line":2595,"column":12,"nodeType":"1012","messageId":"1057","endLine":2595,"endColumn":24},{"ruleId":"1055","severity":1,"message":"1069","line":2600,"column":81,"nodeType":"1012","messageId":"1057","endLine":2600,"endColumn":96},{"ruleId":"1070","severity":1,"message":"1071","line":380,"column":34,"nodeType":"1008","messageId":"1072","endLine":380,"endColumn":35},{"ruleId":"1073","severity":1,"message":"1074","line":380,"column":36,"nodeType":"1018","messageId":"1075","endLine":380,"endColumn":55},{"ruleId":"1070","severity":1,"message":"1071","line":380,"column":56,"nodeType":"1008","messageId":"1072","endLine":380,"endColumn":57},{"ruleId":"1039","severity":1,"message":"1040","line":662,"column":17,"nodeType":"1076","messageId":"1042","endLine":662,"endColumn":23},{"ruleId":"1039","severity":1,"message":"1040","line":668,"column":17,"nodeType":"1076","messageId":"1042","endLine":668,"endColumn":23},{"ruleId":"1077","severity":1,"message":"1078","line":126,"column":13,"nodeType":"1052","messageId":"1079","endLine":126,"endColumn":64},{"ruleId":"1077","severity":1,"message":"1078","line":129,"column":13,"nodeType":"1052","messageId":"1079","endLine":129,"endColumn":26},{"ruleId":"1077","severity":1,"message":"1078","line":133,"column":13,"nodeType":"1052","messageId":"1079","endLine":133,"endColumn":38},{"ruleId":"1016","severity":1,"message":"1080","line":228,"column":83,"nodeType":"1018","messageId":"1019","endLine":228,"endColumn":84,"suggestions":"1081"},{"ruleId":"1082","severity":1,"message":"1083","line":330,"column":53,"nodeType":"1023","messageId":"1084","endLine":330,"endColumn":93},{"ruleId":"1082","severity":1,"message":"1083","line":336,"column":52,"nodeType":"1023","messageId":"1084","endLine":336,"endColumn":91},{"ruleId":"1039","severity":1,"message":"1040","line":235,"column":17,"nodeType":"1053","messageId":"1042","endLine":235,"endColumn":30},{"ruleId":"1039","severity":1,"message":"1040","line":332,"column":9,"nodeType":"1053","messageId":"1042","endLine":332,"endColumn":19},{"ruleId":"1006","severity":1,"message":"1014","line":1087,"column":35,"nodeType":"1008","messageId":"1009","endLine":1087,"endColumn":37},{"ruleId":"1085","severity":1,"message":"1086","line":1169,"column":13,"nodeType":"1008","messageId":"1087","endLine":1169,"endColumn":48},{"ruleId":"1024","severity":1,"message":"1025","line":1744,"column":34,"nodeType":"1026","messageId":"1009","endLine":1744,"endColumn":38},{"ruleId":"1088","severity":1,"message":"1089","line":2450,"column":32,"nodeType":"1090","messageId":"1091","endLine":2450,"endColumn":39,"fix":"1092"},{"ruleId":"1093","severity":1,"message":"1094","line":4617,"column":69,"nodeType":"1012","messageId":"1009","endLine":4617,"endColumn":74,"fix":"1095"},{"ruleId":"1093","severity":1,"message":"1094","line":4620,"column":53,"nodeType":"1012","messageId":"1009","endLine":4620,"endColumn":58,"fix":"1096"},{"ruleId":"1093","severity":1,"message":"1094","line":4623,"column":75,"nodeType":"1012","messageId":"1009","endLine":4623,"endColumn":80,"fix":"1097"},{"ruleId":"1093","severity":1,"message":"1094","line":4625,"column":61,"nodeType":"1012","messageId":"1009","endLine":4625,"endColumn":66,"fix":"1098"},{"ruleId":"1027","severity":1,"message":"1028","line":4955,"column":46,"nodeType":"1029","messageId":"1030","endLine":4955,"endColumn":48},{"ruleId":"1027","severity":1,"message":"1028","line":4955,"column":62,"nodeType":"1029","messageId":"1030","endLine":4955,"endColumn":64},{"ruleId":"1099","severity":1,"message":"1100","line":5068,"column":5,"nodeType":"1101","messageId":"1102","endLine":5070,"endColumn":6},{"ruleId":"1034","severity":1,"message":"1035","line":5182,"column":92,"nodeType":"1036","messageId":"1037","endLine":5182,"endColumn":94},{"ruleId":"1043","severity":1,"message":"1044","line":6040,"column":39,"nodeType":"1045","messageId":"1046","endLine":6040,"endColumn":117},{"ruleId":"1043","severity":1,"message":"1044","line":6413,"column":40,"nodeType":"1045","messageId":"1046","endLine":6413,"endColumn":121},{"ruleId":"1039","severity":1,"message":"1040","line":6459,"column":9,"nodeType":"1054","messageId":"1042","endLine":6495,"endColumn":21},{"ruleId":"1027","severity":1,"message":"1028","line":6467,"column":27,"nodeType":"1029","messageId":"1030","endLine":6467,"endColumn":29},{"ruleId":"1027","severity":1,"message":"1028","line":6467,"column":36,"nodeType":"1029","messageId":"1030","endLine":6467,"endColumn":38},{"ruleId":"1027","severity":1,"message":"1028","line":6537,"column":41,"nodeType":"1029","messageId":"1030","endLine":6537,"endColumn":43},{"ruleId":"1027","severity":1,"message":"1028","line":6537,"column":56,"nodeType":"1029","messageId":"1030","endLine":6537,"endColumn":58},{"ruleId":"1027","severity":1,"message":"1038","line":204,"column":62,"nodeType":"1029","messageId":"1030","endLine":204,"endColumn":64},{"ruleId":"1027","severity":1,"message":"1038","line":204,"column":89,"nodeType":"1029","messageId":"1030","endLine":204,"endColumn":91},{"ruleId":"1027","severity":1,"message":"1038","line":818,"column":22,"nodeType":"1029","messageId":"1030","endLine":818,"endColumn":24},{"ruleId":"1027","severity":1,"message":"1038","line":818,"column":42,"nodeType":"1029","messageId":"1030","endLine":818,"endColumn":44},{"ruleId":"1006","severity":1,"message":"1007","line":924,"column":88,"nodeType":"1008","messageId":"1009","endLine":924,"endColumn":90},{"ruleId":"1065","severity":1,"message":"1103","line":1367,"column":54,"nodeType":"1036","messageId":"1067","endLine":1367,"endColumn":105},{"ruleId":"1006","severity":1,"message":"1014","line":1368,"column":27,"nodeType":"1008","messageId":"1009","endLine":1368,"endColumn":29},{"ruleId":"1006","severity":1,"message":"1014","line":1369,"column":30,"nodeType":"1008","messageId":"1009","endLine":1369,"endColumn":32},{"ruleId":"1027","severity":1,"message":"1028","line":1376,"column":58,"nodeType":"1029","messageId":"1030","endLine":1376,"endColumn":60},{"ruleId":"1027","severity":1,"message":"1028","line":1377,"column":36,"nodeType":"1029","messageId":"1030","endLine":1377,"endColumn":38},{"ruleId":"1077","severity":1,"message":"1078","line":1755,"column":13,"nodeType":"1052","messageId":"1079","endLine":1755,"endColumn":44},{"ruleId":"1099","severity":1,"message":"1100","line":168,"column":5,"nodeType":"1101","messageId":"1102","endLine":172,"endColumn":6},{"ruleId":"1006","severity":1,"message":"1014","line":110,"column":98,"nodeType":"1008","messageId":"1009","endLine":110,"endColumn":100},{"ruleId":"1006","severity":1,"message":"1014","line":129,"column":74,"nodeType":"1008","messageId":"1009","endLine":129,"endColumn":76},{"ruleId":"1006","severity":1,"message":"1007","line":74,"column":42,"nodeType":"1008","messageId":"1009","endLine":74,"endColumn":44},{"ruleId":"1039","severity":1,"message":"1040","line":32,"column":5,"nodeType":"1053","messageId":"1042","endLine":32,"endColumn":15},{"ruleId":"1039","severity":1,"message":"1040","line":44,"column":95,"nodeType":"1076","messageId":"1042","endLine":44,"endColumn":101},{"ruleId":"1039","severity":1,"message":"1040","line":46,"column":5,"nodeType":"1053","messageId":"1042","endLine":46,"endColumn":16},{"ruleId":"1104","severity":1,"message":"1105","line":50,"column":9,"nodeType":"1106","messageId":"1107","endLine":50,"endColumn":25},{"ruleId":"1039","severity":1,"message":"1040","line":73,"column":13,"nodeType":"1076","messageId":"1042","endLine":73,"endColumn":19},{"ruleId":"1039","severity":1,"message":"1040","line":98,"column":13,"nodeType":"1076","messageId":"1042","endLine":98,"endColumn":19},{"ruleId":"1039","severity":1,"message":"1040","line":101,"column":13,"nodeType":"1076","messageId":"1042","endLine":101,"endColumn":19},{"ruleId":"1108","severity":1,"message":"1109","line":66,"column":25,"nodeType":"1110","messageId":"1111","endLine":66,"endColumn":40},{"ruleId":"1108","severity":1,"message":"1109","line":73,"column":25,"nodeType":"1110","messageId":"1111","endLine":73,"endColumn":41},{"ruleId":"1108","severity":1,"message":"1109","line":80,"column":25,"nodeType":"1110","messageId":"1111","endLine":80,"endColumn":39},{"ruleId":"1108","severity":1,"message":"1109","line":83,"column":113,"nodeType":"1110","messageId":"1111","endLine":83,"endColumn":133},{"ruleId":"1112","severity":1,"message":"1113","line":524,"column":41,"nodeType":"1114","endLine":524,"endColumn":57},{"ruleId":"1002","severity":1,"message":"1115","line":53,"column":8,"nodeType":"1004","endLine":53,"endColumn":12,"suggestions":"1116"},{"ruleId":"1108","severity":1,"message":"1109","line":87,"column":29,"nodeType":"1110","messageId":"1111","endLine":87,"endColumn":42},{"ruleId":"1108","severity":1,"message":"1109","line":98,"column":33,"nodeType":"1110","messageId":"1111","endLine":98,"endColumn":46},{"ruleId":"1108","severity":1,"message":"1109","line":107,"column":33,"nodeType":"1110","messageId":"1111","endLine":107,"endColumn":46},{"ruleId":"1108","severity":1,"message":"1109","line":114,"column":51,"nodeType":"1110","messageId":"1111","endLine":114,"endColumn":66},{"ruleId":"1108","severity":1,"message":"1109","line":147,"column":17,"nodeType":"1110","messageId":"1111","endLine":147,"endColumn":34},{"ruleId":"1108","severity":1,"message":"1109","line":149,"column":52,"nodeType":"1110","messageId":"1111","endLine":149,"endColumn":67},{"ruleId":"1112","severity":1,"message":"1113","line":307,"column":17,"nodeType":"1114","endLine":307,"endColumn":80},{"ruleId":"1039","severity":1,"message":"1040","line":57,"column":5,"nodeType":"1053","messageId":"1042","endLine":62,"endColumn":7},{"ruleId":"1006","severity":1,"message":"1007","line":123,"column":45,"nodeType":"1008","messageId":"1009","endLine":123,"endColumn":47},{"ruleId":"1006","severity":1,"message":"1007","line":123,"column":80,"nodeType":"1008","messageId":"1009","endLine":123,"endColumn":82},{"ruleId":"1006","severity":1,"message":"1007","line":177,"column":53,"nodeType":"1008","messageId":"1009","endLine":177,"endColumn":55},{"ruleId":"1112","severity":1,"message":"1113","line":75,"column":25,"nodeType":"1114","endLine":75,"endColumn":75},{"ruleId":"1099","severity":1,"message":"1100","line":31,"column":5,"nodeType":"1101","messageId":"1102","endLine":33,"endColumn":6},{"ruleId":"1016","severity":1,"message":"1047","line":189,"column":87,"nodeType":"1018","messageId":"1019","endLine":189,"endColumn":88,"suggestions":"1117"},{"ruleId":"1118","severity":1,"message":"1119","line":139,"column":85,"nodeType":"1114","messageId":"1120","endLine":139,"endColumn":120,"fix":"1121"},{"ruleId":"1104","severity":1,"message":"1105","line":174,"column":13,"nodeType":"1106","messageId":"1107","endLine":174,"endColumn":31},{"ruleId":"1104","severity":1,"message":"1105","line":239,"column":13,"nodeType":"1106","messageId":"1107","endLine":239,"endColumn":31},{"ruleId":"1065","severity":1,"message":"1122","line":192,"column":26,"nodeType":"1036","messageId":"1067","endLine":201,"endColumn":14},{"ruleId":"1108","severity":1,"message":"1109","line":18,"column":21,"nodeType":"1110","messageId":"1111","endLine":18,"endColumn":38},{"ruleId":"1108","severity":1,"message":"1109","line":20,"column":56,"nodeType":"1110","messageId":"1111","endLine":20,"endColumn":71},{"ruleId":"1027","severity":1,"message":"1038","line":166,"column":25,"nodeType":"1029","messageId":"1030","endLine":166,"endColumn":27},{"ruleId":"1027","severity":1,"message":"1038","line":166,"column":47,"nodeType":"1029","messageId":"1030","endLine":166,"endColumn":49},{"ruleId":"1027","severity":1,"message":"1028","line":166,"column":47,"nodeType":"1029","messageId":"1030","endLine":166,"endColumn":49},{"ruleId":"1027","severity":1,"message":"1028","line":166,"column":61,"nodeType":"1029","messageId":"1030","endLine":166,"endColumn":63},{"ruleId":"1027","severity":1,"message":"1028","line":166,"column":84,"nodeType":"1029","messageId":"1030","endLine":166,"endColumn":86},{"ruleId":"1027","severity":1,"message":"1028","line":166,"column":98,"nodeType":"1029","messageId":"1030","endLine":166,"endColumn":100},{"ruleId":"1027","severity":1,"message":"1028","line":166,"column":127,"nodeType":"1029","messageId":"1030","endLine":166,"endColumn":129},{"ruleId":"1027","severity":1,"message":"1028","line":166,"column":157,"nodeType":"1029","messageId":"1030","endLine":166,"endColumn":159},{"ruleId":"1006","severity":1,"message":"1007","line":170,"column":18,"nodeType":"1008","messageId":"1009","endLine":170,"endColumn":20},{"ruleId":"1108","severity":1,"message":"1109","line":257,"column":25,"nodeType":"1110","messageId":"1111","endLine":257,"endColumn":42},{"ruleId":"1108","severity":1,"message":"1109","line":259,"column":60,"nodeType":"1110","messageId":"1111","endLine":259,"endColumn":75},{"ruleId":"1108","severity":1,"message":"1109","line":53,"column":25,"nodeType":"1110","messageId":"1111","endLine":53,"endColumn":45},{"ruleId":"1108","severity":1,"message":"1109","line":55,"column":61,"nodeType":"1110","messageId":"1111","endLine":55,"endColumn":76},{"ruleId":"1027","severity":1,"message":"1038","line":165,"column":25,"nodeType":"1029","messageId":"1030","endLine":165,"endColumn":27},{"ruleId":"1027","severity":1,"message":"1038","line":165,"column":47,"nodeType":"1029","messageId":"1030","endLine":165,"endColumn":49},{"ruleId":"1027","severity":1,"message":"1028","line":165,"column":47,"nodeType":"1029","messageId":"1030","endLine":165,"endColumn":49},{"ruleId":"1027","severity":1,"message":"1028","line":165,"column":61,"nodeType":"1029","messageId":"1030","endLine":165,"endColumn":63},{"ruleId":"1027","severity":1,"message":"1028","line":165,"column":84,"nodeType":"1029","messageId":"1030","endLine":165,"endColumn":86},{"ruleId":"1027","severity":1,"message":"1028","line":165,"column":98,"nodeType":"1029","messageId":"1030","endLine":165,"endColumn":100},{"ruleId":"1027","severity":1,"message":"1028","line":165,"column":127,"nodeType":"1029","messageId":"1030","endLine":165,"endColumn":129},{"ruleId":"1027","severity":1,"message":"1028","line":165,"column":157,"nodeType":"1029","messageId":"1030","endLine":165,"endColumn":159},{"ruleId":"1006","severity":1,"message":"1007","line":169,"column":18,"nodeType":"1008","messageId":"1009","endLine":169,"endColumn":20},{"ruleId":"1108","severity":1,"message":"1109","line":256,"column":25,"nodeType":"1110","messageId":"1111","endLine":256,"endColumn":42},{"ruleId":"1108","severity":1,"message":"1109","line":258,"column":60,"nodeType":"1110","messageId":"1111","endLine":258,"endColumn":75},{"ruleId":"1039","severity":1,"message":"1040","line":314,"column":9,"nodeType":"1054","messageId":"1042","endLine":327,"endColumn":20},{"ruleId":"1039","severity":1,"message":"1040","line":341,"column":9,"nodeType":"1049","messageId":"1042","endLine":351,"endColumn":50},{"ruleId":"1099","severity":1,"message":"1100","line":44,"column":5,"nodeType":"1101","messageId":"1102","endLine":46,"endColumn":6},{"ruleId":"1027","severity":1,"message":"1038","line":90,"column":24,"nodeType":"1029","messageId":"1030","endLine":90,"endColumn":26},{"ruleId":"1027","severity":1,"message":"1038","line":90,"column":43,"nodeType":"1029","messageId":"1030","endLine":90,"endColumn":45},{"ruleId":"1006","severity":1,"message":"1007","line":33,"column":37,"nodeType":"1008","messageId":"1009","endLine":33,"endColumn":39},{"ruleId":"1099","severity":1,"message":"1100","line":105,"column":5,"nodeType":"1101","messageId":"1102","endLine":105,"endColumn":74},{"ruleId":"1099","severity":1,"message":"1100","line":12,"column":5,"nodeType":"1101","messageId":"1102","endLine":14,"endColumn":6},{"ruleId":"1104","severity":1,"message":"1105","line":13,"column":9,"nodeType":"1106","messageId":"1107","endLine":70,"endColumn":64},{"ruleId":"1099","severity":1,"message":"1100","line":24,"column":5,"nodeType":"1101","messageId":"1102","endLine":26,"endColumn":6},{"ruleId":"1112","severity":1,"message":"1113","line":18,"column":21,"nodeType":"1114","endLine":18,"endColumn":53},{"ruleId":"1112","severity":1,"message":"1113","line":23,"column":21,"nodeType":"1114","endLine":23,"endColumn":53},{"ruleId":"1027","severity":1,"message":"1038","line":110,"column":29,"nodeType":"1029","messageId":"1030","endLine":110,"endColumn":31},{"ruleId":"1027","severity":1,"message":"1038","line":110,"column":51,"nodeType":"1029","messageId":"1030","endLine":110,"endColumn":53},{"ruleId":"1027","severity":1,"message":"1028","line":110,"column":51,"nodeType":"1029","messageId":"1030","endLine":110,"endColumn":53},{"ruleId":"1027","severity":1,"message":"1028","line":110,"column":65,"nodeType":"1029","messageId":"1030","endLine":110,"endColumn":67},{"ruleId":"1027","severity":1,"message":"1028","line":110,"column":88,"nodeType":"1029","messageId":"1030","endLine":110,"endColumn":90},{"ruleId":"1027","severity":1,"message":"1028","line":110,"column":102,"nodeType":"1029","messageId":"1030","endLine":110,"endColumn":104},{"ruleId":"1027","severity":1,"message":"1028","line":110,"column":131,"nodeType":"1029","messageId":"1030","endLine":110,"endColumn":133},{"ruleId":"1027","severity":1,"message":"1028","line":110,"column":161,"nodeType":"1029","messageId":"1030","endLine":110,"endColumn":163},{"ruleId":"1006","severity":1,"message":"1007","line":131,"column":18,"nodeType":"1008","messageId":"1009","endLine":131,"endColumn":20},{"ruleId":"1112","severity":1,"message":"1113","line":41,"column":26,"nodeType":"1114","endLine":41,"endColumn":44},{"ruleId":"1112","severity":1,"message":"1113","line":46,"column":26,"nodeType":"1114","endLine":46,"endColumn":47},{"ruleId":"1034","severity":1,"message":"1123","line":93,"column":47,"nodeType":"1036","messageId":"1124","endLine":93,"endColumn":49},{"ruleId":"1027","severity":1,"message":"1028","line":146,"column":30,"nodeType":"1029","messageId":"1030","endLine":146,"endColumn":32},{"ruleId":"1027","severity":1,"message":"1028","line":151,"column":21,"nodeType":"1029","messageId":"1030","endLine":151,"endColumn":23},{"ruleId":"1006","severity":1,"message":"1007","line":106,"column":37,"nodeType":"1008","messageId":"1009","endLine":106,"endColumn":39},{"ruleId":"1027","severity":1,"message":"1028","line":52,"column":41,"nodeType":"1029","messageId":"1030","endLine":52,"endColumn":43},{"ruleId":"1027","severity":1,"message":"1028","line":52,"column":68,"nodeType":"1029","messageId":"1030","endLine":52,"endColumn":70},{"ruleId":"1112","severity":1,"message":"1113","line":56,"column":20,"nodeType":"1114","endLine":56,"endColumn":69},{"ruleId":"1112","severity":1,"message":"1113","line":57,"column":21,"nodeType":"1114","endLine":59,"endColumn":44},{"ruleId":"1002","severity":1,"message":"1125","line":32,"column":8,"nodeType":"1004","endLine":32,"endColumn":10,"suggestions":"1126"},{"ruleId":"1027","severity":1,"message":"1038","line":53,"column":28,"nodeType":"1029","messageId":"1030","endLine":53,"endColumn":30},{"ruleId":"1027","severity":1,"message":"1038","line":53,"column":96,"nodeType":"1029","messageId":"1030","endLine":53,"endColumn":98},{"ruleId":"1016","severity":1,"message":"1127","line":94,"column":37,"nodeType":"1018","messageId":"1019","endLine":94,"endColumn":38,"suggestions":"1128"},{"ruleId":"1027","severity":1,"message":"1038","line":66,"column":27,"nodeType":"1029","messageId":"1030","endLine":66,"endColumn":29},{"ruleId":"1027","severity":1,"message":"1038","line":66,"column":43,"nodeType":"1029","messageId":"1030","endLine":66,"endColumn":45},{"ruleId":"1027","severity":1,"message":"1038","line":67,"column":28,"nodeType":"1029","messageId":"1030","endLine":67,"endColumn":30},{"ruleId":"1027","severity":1,"message":"1038","line":67,"column":45,"nodeType":"1029","messageId":"1030","endLine":67,"endColumn":47},{"ruleId":"1006","severity":1,"message":"1007","line":102,"column":26,"nodeType":"1008","messageId":"1009","endLine":102,"endColumn":28},{"ruleId":"1065","severity":1,"message":"1129","line":107,"column":124,"nodeType":"1036","messageId":"1067","endLine":107,"endColumn":181},{"ruleId":"1002","severity":1,"message":"1130","line":213,"column":8,"nodeType":"1004","endLine":213,"endColumn":25,"suggestions":"1131"},{"ruleId":"1099","severity":1,"message":"1100","line":27,"column":5,"nodeType":"1101","messageId":"1102","endLine":29,"endColumn":6},{"ruleId":"1070","severity":1,"message":"1071","line":88,"column":218,"nodeType":"1008","messageId":"1072","endLine":88,"endColumn":219},{"ruleId":"1070","severity":1,"message":"1071","line":88,"column":418,"nodeType":"1008","messageId":"1072","endLine":88,"endColumn":419},{"ruleId":"1070","severity":1,"message":"1071","line":90,"column":217,"nodeType":"1008","messageId":"1072","endLine":90,"endColumn":218},{"ruleId":"1070","severity":1,"message":"1071","line":90,"column":419,"nodeType":"1008","messageId":"1072","endLine":90,"endColumn":420},{"ruleId":"1070","severity":1,"message":"1071","line":90,"column":611,"nodeType":"1008","messageId":"1072","endLine":90,"endColumn":612},{"ruleId":"1112","severity":1,"message":"1113","line":51,"column":27,"nodeType":"1114","endLine":51,"endColumn":62},{"ruleId":"1002","severity":1,"message":"1132","line":25,"column":8,"nodeType":"1004","endLine":25,"endColumn":15,"suggestions":"1133"},{"ruleId":"1027","severity":1,"message":"1038","line":183,"column":20,"nodeType":"1029","messageId":"1030","endLine":183,"endColumn":22},{"ruleId":"1027","severity":1,"message":"1038","line":183,"column":30,"nodeType":"1029","messageId":"1030","endLine":183,"endColumn":32},{"ruleId":"1070","severity":1,"message":"1071","line":323,"column":51,"nodeType":"1008","messageId":"1072","endLine":323,"endColumn":52},{"ruleId":"1070","severity":1,"message":"1071","line":326,"column":44,"nodeType":"1008","messageId":"1072","endLine":326,"endColumn":45},{"ruleId":"1070","severity":1,"message":"1071","line":329,"column":47,"nodeType":"1008","messageId":"1072","endLine":329,"endColumn":48},{"ruleId":"1039","severity":1,"message":"1040","line":354,"column":13,"nodeType":"1041","messageId":"1042","endLine":355,"endColumn":28},{"ruleId":"1016","severity":1,"message":"1134","line":247,"column":47,"nodeType":"1018","messageId":"1019","endLine":247,"endColumn":48,"suggestions":"1135"},{"ruleId":"1034","severity":1,"message":"1123","line":45,"column":23,"nodeType":"1053","messageId":"1136","endLine":45,"endColumn":30},"no-native-reassign",["1137"],"no-negated-in-lhs",["1138"],"react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'renders'. Either include it or remove the dependency array.","ArrayExpression",["1139"],"eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","no-redeclare","'m' is already defined.","Identifier","redeclared","Expected '!==' and instead saw '!='.","'n' is already defined.","no-useless-escape","Unnecessary escape character: \\\".","Literal","unnecessaryEscape",["1140","1141"],"no-extend-native","Array prototype is read only, properties should not be added.","AssignmentExpression","no-eval","eval can be harmful.","CallExpression","no-mixed-operators","Unexpected mix of '||' and '&&'. Use parentheses to clarify the intended order of operations.","LogicalExpression","unexpectedMixedOperator","Unnecessary escape character: \\'.",["1142","1143"],["1144","1145"],"array-callback-return","Array.prototype.map() expects a value to be returned at the end of arrow function.","ArrowFunctionExpression","expectedAtEnd","Unexpected mix of '&&' and '||'. Use parentheses to clarify the intended order of operations.","no-unreachable","Unreachable code.","ExpressionStatement","unreachableCode","no-new-func","The Function constructor is eval.","NewExpression","noFunctionConstructor","Unnecessary escape character: \\..",["1146","1147"],"IfStatement","no-duplicate-case","Duplicate case label.","SwitchCase","ReturnStatement","VariableDeclaration","@typescript-eslint/no-use-before-define","'AccessModifier' was used before it was defined.","noUseBeforeDefine","Unnecessary escape character: \\/.",["1148","1149"],"Unnecessary escape character: \\,.",["1150","1151"],["1152","1153"],"Unnecessary escape character: \\_.",["1154","1155"],"no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'fileLetti', 'fileLetti'.","unsafeRefs","'AttribETypes' was used before it was defined.","'DefaultEClasses' was used before it was defined.","no-useless-concat","Unexpected string concatenation of literals.","unexpectedConcat","no-template-curly-in-string","Unexpected template string expression.","unexpectedTemplateExpression","BreakStatement","no-fallthrough","Expected a 'break' statement before 'case'.","case","Unnecessary escape character: \\].",["1156","1157"],"no-cond-assign","Expected a conditional expression and instead saw an assignment.","missing","no-self-compare","Comparing to itself is potentially pointless.","comparingToSelf","no-whitespace-before-property","Unexpected whitespace before property data.","MemberExpression","unexpectedWhitespace",{"range":"1158","text":"1159"},"no-extra-label","This label 'inner' is unnecessary.",{"range":"1160","text":"1161"},{"range":"1162","text":"1161"},{"range":"1163","text":"1161"},{"range":"1164","text":"1161"},"@typescript-eslint/no-useless-constructor","Useless constructor.","MethodDefinition","noUselessConstructor","Function declared in a loop contains unsafe references to variable(s) 's0', 's00'.","no-lone-blocks","Nested block is redundant.","BlockStatement","redundantNestedBlock","react/style-prop-object","Style prop value must be an object","JSXAttribute","stylePropNotObject","jsx-a11y/alt-text","img elements must have an alt prop, either with meaningful text, or an empty string for decorative images.","JSXOpeningElement","React Hook useEffect has a missing dependency: 'user'. Either include it or remove the dependency array.",["1165"],["1166","1167"],"react/jsx-no-target-blank","Using target=\"_blank\" without rel=\"noreferrer\" (which implies rel=\"noopener\") is a security risk in older browsers: see https://mathiasbynens.github.io/rel-noopener/#recommendations","noTargetBlankWithoutNoreferrer",{"range":"1168","text":"1169"},"Function declared in a loop contains unsafe references to variable(s) 'key', 'key', 'key', 'key', 'key', 'key', 'key', 'key', 'key'.","Array.prototype.map() expects a return value from arrow function.","expectedInside","React Hook useEffect has missing dependencies: 'actions' and 'project.id'. Either include them or remove the dependency array. You can also do a functional update 'setActions(a => ...)' if you only need 'actions' in the 'setActions' call.",["1170"],"Unnecessary escape character: \\:.",["1171","1172"],"Function declared in a loop contains unsafe references to variable(s) 'data'.","React Hook useEffect has an unnecessary dependency: 'htmlref.current'. Either exclude it or remove the dependency array. Mutable values like 'htmlref.current' aren't valid dependencies because mutating them doesn't re-render the component.",["1173"],"React Hook useEffect has a missing dependency: 'emails'. Either include it or remove the dependency array. You can also replace multiple useState variables with useReducer if 'setFilteredEmails' needs the current value of 'emails'.",["1174"],"Unnecessary escape character: \\-.",["1175","1176"],"expectedReturnValue","no-global-assign","no-unsafe-negation",{"desc":"1177","fix":"1178"},{"messageId":"1179","fix":"1180","desc":"1181"},{"messageId":"1182","fix":"1183","desc":"1184"},{"messageId":"1179","fix":"1185","desc":"1181"},{"messageId":"1182","fix":"1186","desc":"1184"},{"messageId":"1179","fix":"1187","desc":"1181"},{"messageId":"1182","fix":"1188","desc":"1184"},{"messageId":"1179","fix":"1189","desc":"1181"},{"messageId":"1182","fix":"1190","desc":"1184"},{"messageId":"1179","fix":"1191","desc":"1181"},{"messageId":"1182","fix":"1192","desc":"1184"},{"messageId":"1179","fix":"1193","desc":"1181"},{"messageId":"1182","fix":"1194","desc":"1184"},{"messageId":"1179","fix":"1195","desc":"1181"},{"messageId":"1182","fix":"1196","desc":"1184"},{"messageId":"1179","fix":"1197","desc":"1181"},{"messageId":"1182","fix":"1198","desc":"1184"},{"messageId":"1179","fix":"1199","desc":"1181"},{"messageId":"1182","fix":"1200","desc":"1184"},[118498,118500],".",[236047,236053],"",[236226,236232],[236496,236502],[236618,236624],{"desc":"1201","fix":"1202"},{"messageId":"1179","fix":"1203","desc":"1181"},{"messageId":"1182","fix":"1204","desc":"1184"},[6141,6141]," rel=\"noreferrer\"",{"desc":"1205","fix":"1206"},{"messageId":"1179","fix":"1207","desc":"1181"},{"messageId":"1182","fix":"1208","desc":"1184"},{"desc":"1209","fix":"1210"},{"desc":"1211","fix":"1212"},{"messageId":"1179","fix":"1213","desc":"1181"},{"messageId":"1182","fix":"1214","desc":"1184"},"Update the dependencies array to be: [pathname, renders]",{"range":"1215","text":"1216"},"removeEscape",{"range":"1217","text":"1161"},"Remove the `\\`. This maintains the current functionality.","escapeBackslash",{"range":"1218","text":"1219"},"Replace the `\\` with `\\\\` to include the actual backslash character.",{"range":"1220","text":"1161"},{"range":"1221","text":"1219"},{"range":"1222","text":"1161"},{"range":"1223","text":"1219"},{"range":"1224","text":"1161"},{"range":"1225","text":"1219"},{"range":"1226","text":"1161"},{"range":"1227","text":"1219"},{"range":"1228","text":"1161"},{"range":"1229","text":"1219"},{"range":"1230","text":"1161"},{"range":"1231","text":"1219"},{"range":"1232","text":"1161"},{"range":"1233","text":"1219"},{"range":"1234","text":"1161"},{"range":"1235","text":"1219"},"Update the dependencies array to be: [id, user]",{"range":"1236","text":"1237"},{"range":"1238","text":"1161"},{"range":"1239","text":"1219"},"Update the dependencies array to be: [actions, project.id]",{"range":"1240","text":"1241"},{"range":"1242","text":"1161"},{"range":"1243","text":"1219"},"Update the dependencies array to be: []",{"range":"1244","text":"1245"},"Update the dependencies array to be: [email, emails]",{"range":"1246","text":"1247"},{"range":"1248","text":"1161"},{"range":"1249","text":"1219"},[450,460],"[pathname, renders]",[5160,5161],[5160,5160],"\\",[93305,93306],[93305,93305],[93328,93329],[93328,93328],[37972,37973],[37972,37972],[34538,34539],[34538,34538],[34540,34541],[34540,34540],[117122,117123],[117122,117122],[117124,117125],[117124,117124],[14743,14744],[14743,14743],[1788,1792],"[id, user]",[9384,9385],[9384,9384],[1347,1349],"[actions, project.id]",[4229,4230],[4229,4229],[9298,9315],"[]",[979,986],"[email, emails]",[10858,10859],[10858,10858]]