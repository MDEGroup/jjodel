{"ast":null,"code":"import{Log}from\"../joiner\";/* problema: se creo una key per ordinare l'albero e trovare \"of\" in O(log n), allora perdo l'ordinamento arbitrario di sottoalberi = sottoclassi a prescindere dai nomi.\r\n   potrei fare un dizionario di alberi, 1 albero per ogni dclass e lclass, con sottoelementi\r\n    */ // not binary, not rb tree, not balanced, just a tree\n// it is N-ary\n// ma probabilmente non dovrei usare affatto un albero, ma fare un dizionario per ogni classe con cosa estende direttamente\n// e uno con cosa estende direttamente e indirettamente popolato automaticamente in n*logn una volta e fine\n// navigando superclass\n// B.superclass = [a1, a2] --- > a1.pushdirectsubclass(b), a2 same.  poi se a1 estende c, c.pushindirectsubclass(b)... e si risale da b finchè ci sono superclassi (logn) volte, fatto per tutte le n classi\n// each node have a \"node<T>\" value and a subtree with all subelements.\n// iterable with for...of with width iterator (not depth)\nexport class SimpleTree{// can be undef, if root was an array instead of a single element.\n// the nodes containing the rooots will be the childrens instead, as if they are N trees\n// with a fake node joining them in a single one\n// up: SimpleTree<T>; maybe do this too\ngetiIsSubElementMatrix(namekey){let ret={};// matrix name x name telling if A extends B\nfor(let o of this){// O(N^2), but optimal for this task, as the matrix size is O(N^2) as well\nlet name=o.node[namekey];if(!name)Log.ee(\"missing key property  in tree node: \",{tree:this,node:o.node,namekey});ret[name]={};// if (o === this) continue;\nfor(let subo of o){let subname=subo.node[namekey];if(!subname){console.log(\"skipped\");continue;}ret[name][subname]=true;}}return ret;}add(e,childKey,loopdetector){if(loopdetector){if(loopdetector.get(e)){Log.eDev(e.cname.indexOf(\"GraphVertex\")!==1,\"A constructor is extending 2 different classes, or there is a loop in Tree constructor parameter.\",\"GraphVertex should be the only class doing that currently\",{e,cname:e.cname,childKey,loopdetector});return;}loopdetector.set(e,true);}let subtree=new SimpleTree(e,childKey,loopdetector);this.subelements.push(subtree);return subtree;}getSubtree(e){for(let t of this){if(t.node==e)return t;}return undefined;}// childkey: adds subobjects found in \"roots\" parameters as nodes<T> in the tree\n// comparison: tells if a node comes first or after another, example: (a, b) => a.name.toUpperCase() < b.name.toUpperCase()\nconstructor(roots,childKey,loopdetector){this.subelements=void 0;this.node=void 0;this[Symbol.iterator]=function*(){// [Symbol.iterator]: Generator<number, string, boolean> = function*() {\n// [Symbol.iterator]: Generator<number, string, boolean>= () => {\n// [Symbol.iterator] () {\nyield this;let fifo=this.subelements;while(fifo.length){let nextLevel=[];for(let subtree of fifo){yield subtree;nextLevel.push(...subtree.subelements);}//@ts-ignore\n// console.log(\"fifo -> next level\", fifo.map(f=>f?.node?.cname), nextLevel.map(f=>f?.node?.cname));\nfifo=nextLevel;}};// if arr, add N roots as subelements, and delegate actual subelements of the root to subtree constructors\nif(!loopdetector)loopdetector=new WeakMap();/*(this as any)[Symbol.iterator] = function *(){\r\n            yield this;\r\n            let fifo = this.subelements;\r\n            while (fifo.length) {\r\n                let nextLevel = [];\r\n                for (let subtree of fifo) {\r\n                    yield subtree;\r\n                    nextLevel.push(subtree);\r\n                }\r\n                fifo = nextLevel;\r\n            }\r\n        }*/ //@ts-ignore\nthis.debug=roots.cname;this.subelements=[];if(Array.isArray(roots)){this.node=undefined;for(let e of roots){if(!e)continue;this.add(e,childKey,loopdetector);}}// if not arr, add immediate subelements of root\nelse{this.node=roots;if(!childKey)return;let child=this.node[childKey];if(Array.isArray(child)){for(let c of child)this.add(c,childKey,loopdetector);}else this.add(child,childKey,loopdetector);}}}","map":{"version":3,"names":["Log","SimpleTree","getiIsSubElementMatrix","namekey","ret","o","name","node","ee","tree","subo","subname","console","log","add","e","childKey","loopdetector","get","eDev","cname","indexOf","set","subtree","subelements","push","getSubtree","t","undefined","constructor","roots","Symbol","iterator","fifo","length","nextLevel","WeakMap","debug","Array","isArray","child","c"],"sources":["C:/0Programmi/Dev/projects/frontend/jjodel/frontend/src/common/SimpleTree.ts"],"sourcesContent":["import {Dictionary, GObject, Log, U} from \"../joiner\";\r\n\r\n\r\n/* problema: se creo una key per ordinare l'albero e trovare \"of\" in O(log n), allora perdo l'ordinamento arbitrario di sottoalberi = sottoclassi a prescindere dai nomi.\r\n   potrei fare un dizionario di alberi, 1 albero per ogni dclass e lclass, con sottoelementi\r\n    */\r\n\r\n// not binary, not rb tree, not balanced, just a tree\r\n// it is N-ary\r\n// ma probabilmente non dovrei usare affatto un albero, ma fare un dizionario per ogni classe con cosa estende direttamente\r\n// e uno con cosa estende direttamente e indirettamente popolato automaticamente in n*logn una volta e fine\r\n// navigando superclass\r\n\r\n// B.superclass = [a1, a2] --- > a1.pushdirectsubclass(b), a2 same.  poi se a1 estende c, c.pushindirectsubclass(b)... e si risale da b finchè ci sono superclassi (logn) volte, fatto per tutte le n classi\r\n// each node have a \"node<T>\" value and a subtree with all subelements.\r\n// iterable with for...of with width iterator (not depth)\r\nexport class SimpleTree<T extends GObject> {\r\n    subelements: SimpleTree<T>[];\r\n    node: T; // can be undef, if root was an array instead of a single element.\r\n    // the nodes containing the rooots will be the childrens instead, as if they are N trees\r\n    // with a fake node joining them in a single one\r\n    // up: SimpleTree<T>; maybe do this too\r\n\r\n    [Symbol.iterator] = function*(this:SimpleTree<T>) {\r\n    // [Symbol.iterator]: Generator<number, string, boolean> = function*() {\r\n    // [Symbol.iterator]: Generator<number, string, boolean>= () => {\r\n    // [Symbol.iterator] () {\r\n        yield this;\r\n        let fifo = this.subelements;\r\n        while (fifo.length) {\r\n            let nextLevel = [];\r\n            for (let subtree of fifo) {\r\n                yield subtree;\r\n                nextLevel.push(...subtree.subelements);\r\n            }\r\n            //@ts-ignore\r\n            // console.log(\"fifo -> next level\", fifo.map(f=>f?.node?.cname), nextLevel.map(f=>f?.node?.cname));\r\n            fifo = nextLevel;\r\n        }\r\n    }\r\n\r\n    getiIsSubElementMatrix(namekey: keyof T): Dictionary<string, Dictionary<string, boolean>>{\r\n        let ret: Dictionary<string, Dictionary<string, boolean>> = {}// matrix name x name telling if A extends B\r\n        for (let o of this) { // O(N^2), but optimal for this task, as the matrix size is O(N^2) as well\r\n            let name = o.node[namekey];\r\n            if (!name) Log.ee(\"missing key property  in tree node: \", {tree: this, node:o.node, namekey});\r\n            ret[name] = {};\r\n            // if (o === this) continue;\r\n            for (let subo of o) {\r\n                let subname = subo.node[namekey];\r\n                if (!subname) { console.log(\"skipped\"); continue; }\r\n                ret[name as string][subname as string] = true;\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    public add(e: T, childKey?: keyof T, loopdetector?: WeakMap<T, boolean>): SimpleTree<T> | undefined{\r\n        if (loopdetector) {\r\n            if (loopdetector.get(e)) {\r\n                Log.eDev(e.cname.indexOf(\"GraphVertex\") !== 1,\r\n                    \"A constructor is extending 2 different classes, or there is a loop in Tree constructor parameter.\",\r\n                    \"GraphVertex should be the only class doing that currently\",\r\n                    {e, cname:e.cname, childKey, loopdetector});\r\n                return;\r\n            }\r\n            loopdetector.set(e, true);\r\n        }\r\n        let subtree =  new SimpleTree<T>(e, childKey, loopdetector);\r\n        this.subelements.push(subtree);\r\n        return subtree; }\r\n\r\n    getSubtree(e: T): SimpleTree<T> | undefined {\r\n        for (let t of this) { if (t.node == e) return t; }\r\n        return undefined; }\r\n\r\n    // childkey: adds subobjects found in \"roots\" parameters as nodes<T> in the tree\r\n    // comparison: tells if a node comes first or after another, example: (a, b) => a.name.toUpperCase() < b.name.toUpperCase()\r\n    constructor(roots: GObject | GObject[], childKey?: keyof T, loopdetector?: WeakMap<T, boolean>) {\r\n        // if arr, add N roots as subelements, and delegate actual subelements of the root to subtree constructors\r\n        if (!loopdetector) loopdetector = new WeakMap();\r\n        /*(this as any)[Symbol.iterator] = function *(){\r\n            yield this;\r\n            let fifo = this.subelements;\r\n            while (fifo.length) {\r\n                let nextLevel = [];\r\n                for (let subtree of fifo) {\r\n                    yield subtree;\r\n                    nextLevel.push(subtree);\r\n                }\r\n                fifo = nextLevel;\r\n            }\r\n        }*/\r\n\r\n        //@ts-ignore\r\n        this.debug = roots.cname;\r\n        this.subelements = [];\r\n        if (Array.isArray(roots)) {\r\n            this.node = undefined as any;\r\n            for (let e of roots) {\r\n                if (!e) continue;\r\n                this.add(e as T, childKey, loopdetector);\r\n            }\r\n        }\r\n        // if not arr, add immediate subelements of root\r\n        else {\r\n            this.node = roots as T;\r\n            if (!childKey) return;\r\n            let child: T | T[] = this.node[childKey];\r\n            if (Array.isArray(child)) {\r\n                for (let c of child) this.add(c, childKey, loopdetector);\r\n            }\r\n            else this.add(child, childKey, loopdetector);\r\n        }\r\n    }\r\n\r\n\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}