{"ast":null,"code":"var _dec,_class,_class2,_dec2,_class3,_class4;import React,{Component}from\"react\";import{DGraphElement,Log,RuntimeAccessible,Size,U}from\"../../joiner\";import $ from\"jquery\";/// <reference path=\"../../common/libraries/jqui-types.ts\" />\nimport\"./Measurable.scss\";// private\nimport{jsx as _jsx}from\"react/jsx-runtime\";export let MeasurableComponent=(_dec=RuntimeAccessible('MeasurableComponent'),_dec(_class=(_class2=class MeasurableComponent extends Component{constructor(){super(...arguments);this.html=null;this.$html=void 0;this.dragOptionsChanged=true;this.resizeOptionsChanged=true;this.rotateOptionsChanged=true;this.defaultOptions={draggable:{cancel:'.no-drag,[contenteditable=\"true\"],input,textarea,button,select,option',cursor:'grabbing',// containment: 'parent',\ndistance:5// helper: 'clone', // 'original' or 'csselector'? or func=>html\n// disabled: !(view.draggable),}\n},resizable:{},rotatable:{}};this.oldPos={left:undefined,top:undefined};}componentDidMount(){this.afterUpdate();}componentDidUpdate(prevProps,prevState,snapshot){this.afterUpdate();}afterUpdate(){if(!this.html)return;this.$html=$(this.html);if(this.dragOptionsChanged){this.afterUpdateSingle(\"draggable\");}if(this.resizeOptionsChanged){this.afterUpdateSingle(\"resizable\");}if(this.rotateOptionsChanged){this.afterUpdateSingle(\"rotatable\");}}/*\r\n        afterUpdateSingle(type: \"draggable\" | \"resizable\" | \"rotatable\"): void{\r\n            if (this.props.draggable) this.afterUpdateDraggable\r\n        }/*\r\n        afterUpdateDraggable_old(): void{\r\n            nope, erase this and just make the previous _old genericversion with inner dynamic functions called 9 times like event('drag', 'while'); event('drag', 'end'); event('resize', 'while');...\r\n            make and extract new functions from code so that it dinamically build the jqui options object\r\n            if (!this.$html) return;\r\n            let $measurable = this.$html;\r\n            let jqui_options = this.props.draggable;\r\n            let jqui_start = jqui_options === 'object' ? jqui_options.start : undefined;\r\n            let jqui_end = jqui_options === 'object' ? jqui_options.stop : undefined;\r\n            let jqui_ing = jqui_options === 'object' ? jqui_options.drag : undefined;\r\n            let props_start = this.props.onDragStart;\r\n            let props_end = this.props.onDragEnd;\r\n            let props_ing = this.props.whileDragging;\r\n            let type = 'draggable';\r\n\r\n\r\n            //let positionMap = new WeakMap<HTMLElement, {left: number; top: number}>();\r\n            let childmode_drag = (e: HTMLElement, evt?: any, evtkind?: EventLetter, ui?:any): void => {\r\n                let oc = this.props.onChildren;\r\n                if (!oc) {\r\n                    Log.ee('not oc', {evt, oc, e, p: this.props}); return;\r\n                }\r\n                let child: HTMLElement;\r\n                if (typeof oc === 'function') child = oc(e);\r\n                else child = e.children[0] as HTMLElement;\r\n                if (!child) {\r\n                    Log.ee('child not found', {child, evt, oc, e}); return;\r\n                }\r\n                let oldpos = this.oldPos; // positionMap.get(e);\r\n                console.log('measurable default event child ' + evtkind, {ui, e, oc, oldpos});\r\n                //if (evtkind === 'e') { positionMap.set(e, ui.position); }\r\n\r\n                /*if (evtkind === 's') {\r\n                    ui.originalPosition.left = 300;\r\n                    ui.offset.left = 300;\r\n                    ui.position.left = 300;\r\n                    console.log('measurable sstart ', {type, e, oc, ui, el: e.style.left, cl: child.style.left});\r\n                }* /\r\n\r\n                let key: any;\r\n                for (key of childmodekeys) {\r\n                    let fixpos = () => {\r\n                        if (oldpos && (oldpos as any)[key] !== undefined) {\r\n                            if (key ==='left') console.log('measurable fixpos ' + evtkind, (oldpos as any)[key] + ui.position[key] + 'px', (oldpos as any)[key]);\r\n                            let newpos = (oldpos as any)[key] + ui.position[key];\r\n                            child.style[key] = (newpos) + 'px';\r\n                            if (evtkind === 'e') this.oldPos[key] = newpos;\r\n                        }\r\n                        else child.style[key] = e.style[key];\r\n                    }\r\n                    fixpos();\r\n                    if (evtkind === 'e')  setTimeout(fixpos, 1000);\r\n                    if (evtkind === 's' && !e.classList.contains('draggable-child-mode')) e.classList.add('draggable-child-mode');\r\n                    // delete e.style[key]\r\n                }\r\n            }\r\n\r\n            let translateeevents: Dictionary<string, Dictionary<string, DraggableEvent>> = {\r\n                'draggable': {\r\n                    's': (e, ui)=>{ this.absoluteToTransform(e.target as HTMLElement, e, 's'); },\r\n                    'ing': (e, ui)=>{ this.absoluteToTransform(e.target as HTMLElement, e, 'ing'); },\r\n                    'e': (e, ui)=>{ this.absoluteToTransform(e.target as HTMLElement, e, 'e'); }},\r\n            };\r\n            let defaulteevent = (evtkind: EventLetter): MeasurableUIEvent | null =>{\r\n                if (!this.props.transformMode && !this.props.onChildren) return null;\r\n                return (e: any, ui: any) => {\r\n                    //console.log('measurable default event', {type, evtkind, translateeevents, e, t: e.target});\r\n                    if (this.props.transformMode === true) translateeevents[type][evtkind](e, ui);\r\n                    childmode_drag(e.target, e, evtkind, ui);\r\n                }\r\n            };\r\n\r\n            if (props[optionkey] === false || !props[optionkey]) {\r\n                console.log(\"measurable off \" + type, {$measurable, type, datamap, optionkey, props});\r\n                if ($measurable.data(datamap[type])) ($measurable as GObject)[type]('disable');\r\n                return;\r\n            }\r\n            if (props[optionkey] === true) {\r\n                options = {};\r\n            } else options = {...props[optionkey]};\r\n\r\n            if (props_start && typeof props_start !== \"function\") { return Log.ee(\"<Measurable /> onDragStart props must be a function\"); }\r\n            if (props_end && typeof props_end !== \"function\") { return Log.ee(\"<Measurable /> onDragEnd props must be a function\"); }\r\n            if (props_ing && typeof props_ing !== \"function\") { return Log.ee(\"<Measurable /> whileDragging props must be a function\"); }\r\n            if (!jqui_start && !props_start && ! default_start) delete options.start,\r\n                else options.start = (evt, ui) => { default_start?.(evt, ui); jqui_start?.(evt, ui); props_start?.(thiss.getCoords(evt, ui), evt, ui); }\r\n\r\n            let propsOptions = {...options};\r\n            let defaultOptions = this.defaultOptions[type];\r\n            U.objectMergeInPlace(options, defaultOptions);\r\n            //console.log(\"measurable\", {type, $measurable, options, propsOptions, defaultOptions});\r\n            ($measurable as GObject)[type](options);\r\n        }*/absoluteToTransform(e,evt,evtkind){let x=e.style.left;let y=e.style.top;/*\r\n            e.style.left = '0px';\r\n            e.style.top = '0px';*/ //e.style.position = 'unset';\ne.style.transform=\"translate(\".concat(x,\", \").concat(y,\")\");}childmode(e,evt,evtkind,ui){let oc=this.props.onChildren;if(!oc){Log.ee('not oc',{evt,oc,e,p:this.props});return;}let child;console.log('cchild',{e,evt,evtkind,ui});if(typeof oc==='function')child=oc(e);else child=e.children[0];if(!child){Log.ee('child not found',{child,evt,oc,e});return;}console.log('measurable default event child '+evtkind,{ui,e,oc,oldpos:this.oldPos});//if (evtkind === 'e') { positionMap.set(e, ui.position); }\n/*if (evtkind === 's') {\r\n            ui.originalPosition.left = 300;\r\n            ui.offset.left = 300;\r\n            ui.position.left = 300;\r\n            console.log('measurable sstart ', {type, e, oc, ui, el: e.style.left, cl: child.style.left});\r\n        }*/let key;for(key of MeasurableComponent.childmodekeys){let fixpos=()=>{let oldpos=this.oldPos;// positionMap.get(e); {x:-1000, y:-3000};//\nif(oldpos&&oldpos[key]!==undefined){let newpos=oldpos[key]+ui.position[key];if(key==='left')console.log('measurable fixpos '+newpos+'px',oldpos[key],{oldpos,uipos:ui.position,newpos});child.style[key]=newpos+'px';if(evtkind==='e')this.oldPos[key]=newpos;}else child.style[key]=e.style[key];};if(evtkind==='e')setTimeout(fixpos,1000);if(evtkind==='s'){let graph=this.props.isPanning;if(this.oldPos.left===undefined&&graph){console.log('measurable fixposss ',{oldpos:{...this.oldPos}});this.oldPos.left=ui.position.left=graph.offset.x;this.oldPos.top=ui.position.top=graph.offset.y;}if(!e.classList.contains('draggable-child-mode'))e.classList.add('draggable-child-mode');}fixpos();// delete e.style[key]\n}}getDefaultEvent(type,evtkind){if(!this.props.transformMode&&!(this.props.onChildren&&type==='draggable'))return null;switch(type){case'draggable':if(!this.props.transformMode&&!this.props.onChildren)return null;break;case'resizable':break;case'rotatable':break;}let translateeevents={'draggable':{'s':(e,ui)=>{this.absoluteToTransform(e.target,e,'s');},'ing':(e,ui)=>{this.absoluteToTransform(e.target,e,'ing');},'e':(e,ui)=>{this.absoluteToTransform(e.target,e,'e');}}/*'resizable': {\r\n                's': (e, ui)=>{ },\r\n                'ing': (e, ui)=>{ },\r\n                'e': (e, ui)=>{ }},\r\n            'rotatable': {\r\n                's': (e, ui)=>{ },\r\n                'ing': (e, ui)=>{ },\r\n                'e': (e, ui)=>{ }},*/};return(e,ui)=>{var _translateeevents$typ,_translateeevents$typ2;console.log('measurable default event',{type,evtkind,translateeevents,e,t:e.target});if(this.props.transformMode===true)(_translateeevents$typ=translateeevents[type])===null||_translateeevents$typ===void 0?void 0:(_translateeevents$typ2=_translateeevents$typ[evtkind])===null||_translateeevents$typ2===void 0?void 0:_translateeevents$typ2.call(_translateeevents$typ,e,ui);this.childmode(e.target,e,evtkind,ui);};}makeEvent(options,type,evtkey){let eventmap={'s':{'draggable':'onDragStart','rotatable':'onRotateStart','resizable':'onResizeStart'},'ing':{'draggable':'whileDragging','rotatable':'whileRotating','resizable':'whileResizing'},'e':{'draggable':'onDragEnd','rotatable':'onRotateEnd','resizable':'onResizeEnd'}};let jqui_ing;switch(type){default:jqui_ing=Log.eDevv(\"unexpected measurable event: \"+type);return;case\"draggable\":jqui_ing='drag';break;case\"resizable\":jqui_ing='resize';break;case\"rotatable\":jqui_ing='rotate';break;}//let jodelevent = {'s': eventmap.s[type], 'ing': eventmap.ing[type], 'e': eventmap.e[type]};\nlet jquievent={'s':'start','ing':jqui_ing,'e':'stop'};let jqkey=jquievent[evtkey]||'';let props=this.props;let propsevent=props[eventmap[evtkey][type]];if(propsevent&&typeof propsevent!==\"function\"){Log.ee(\"<Measurable /> \"+eventmap[evtkey][type]+\" props must be a function\");return;}// call ondragend... jodel events\nlet jquievt=options[jqkey];// let jodelevt = propsevent; // (...params: any) => propsevent(...params); // was made to preserve \"this\"?\nlet defaultevt=this.getDefaultEvent(type,evtkey);let allevents=[defaultevt,jquievt,propsevent].filter(e=>!!e);if(allevents.length)options[jqkey]=(evt,ui)=>{for(let e of allevents){propsevent=props[eventmap[evtkey][type]];// if i don't redeclare it here, closure makes a mess taking always the last jodelevt for all iterations.\nif(e===propsevent){e(this.getCoords(evt,ui,this.props.isPanning),evt,ui);}else e(evt,ui);}};}afterUpdateSingle(type){// was forced to move from general loop-style implementation to individual redundant stuff because of closure messes.\nif(!this.$html)return;let $measurable=this.$html;let options;const props=this.props;const datamap={draggable:\"uiDraggable\",resizable:\"uiResizable\",rotatable:\"uiRotatable\"};const optionmap={draggable:\"draggable\",resizable:\"resizable\",rotatable:\"rotatable\"};const optionkey=optionmap[type];if(props[optionkey]===false||!props[optionkey]){// console.log(\"measurable off \" + type, {$measurable, type, datamap, optionkey, props});\nif($measurable.data(datamap[type]))$measurable[type]('disable');return;}if(props[optionkey]===true){options={};}else options={...props[optionkey]};// todo: changing options at runtime works, but changing children does not update\nlet jqui_ing;switch(type){default:jqui_ing=Log.eDevv(\"unexpected measurable event: \"+type);return;case\"draggable\":jqui_ing='drag';break;case\"resizable\":jqui_ing='resize';break;case\"rotatable\":jqui_ing='rotate';break;}let jquievent={'s':'start','ing':jqui_ing,'e':'stop'};let evtkey;for(evtkey in jquievent){this.makeEvent(options,type,evtkey);}let defaultOptions=this.defaultOptions[type];U.objectMergeInPlace(options,defaultOptions);$measurable[type](options);}shouldComponentUpdate(nextProps,nextState,nextContext){//console.log(\"measurable shouldup\", {nc:nextProps.children, tc:this.props.children, eq: nextProps.children == this.props.children});\n// todo: would need to check if pros.children has changed, but that requires a deep search of subcomponents props and state.\n// currently with just return true it works and rerenders every time the parent component rerenders. not when other elements are interacted.\n// it works also with <Input> as direct child and it updates.\nif(window)return true;const oldProps=this.props||{};this.dragOptionsChanged=false;this.resizeOptionsChanged=false;this.rotateOptionsChanged=false;let ret=false;const nestederr=\"Options cannot contain functions or nested objects\";if(!U.isShallowEqualWithProxies(oldProps.draggable,nextProps.draggable)){const opt=oldProps.draggable;if(opt&&typeof opt===\"object\")for(let k in opt){switch(typeof opt[k]){case\"function\":case\"object\":Log.ee(\"drag\"+nestederr,k);}}this.dragOptionsChanged=true;ret=true;}if(!U.isShallowEqualWithProxies(oldProps.resizable,nextProps.resizable)){const opt=oldProps.resizable;if(opt&&typeof opt===\"object\")for(let k in opt){switch(typeof opt[k]){case\"function\":case\"object\":Log.ee(\"resize\"+nestederr,k);}}this.resizeOptionsChanged=true;ret=true;}if(!U.isShallowEqualWithProxies(oldProps.rotatable,nextProps.rotatable)){const opt=oldProps.rotatable;if(opt&&typeof opt===\"object\")for(let k in opt){switch(typeof opt[k]){case\"function\":case\"object\":Log.ee(\"rotate\"+nestederr,k);}}this.rotateOptionsChanged=true;return true;}if(ret)return true;// i don't need to set more this.variable stuff and i already determined something changed.\nif(Object.keys(oldProps).length!==Object.keys(nextProps).length)return true;let k;for(k in oldProps){switch(k){//case \"axis\": if (ok)\ncase\"draggable\":case\"resizable\":case\"rotatable\":continue;case\"children\":continue;}if(!(k in nextProps))return false;let ok=oldProps[k];let nk=nextProps[k];if(ok===nk)continue;let tk=typeof ok;if(tk!==typeof nk)return false;switch(tk){case\"object\":Log.ee(\"unexpected object in <Measurable/> props\",{k,nk,ok});return true;case\"function\":if(ok.toString()!==nk.toString())return true;break;default:return false;// already checked they are !==\n}}return false;}updateDefaultOptions(){/*let addClasses = this.props.children ? 'on-children' as any : undefined;\r\n                                          jqui.classes does not owrk? and addclass is only for draggable?\r\n        if (this.defaultOptions.draggable.addClasses !== addClasses) {\r\n            this.defaultOptions.resizable.classes = addClasses;\r\n            // this.defaultOptions.rotatable.classes = addClasses;\r\n        }*/}render(){let child=this.props.children;this.updateDefaultOptions();if(!child)return child||null;// sometimes react passes {} as props.children?\nif(!Object.keys(child).length)return Log.ee(\"Measurable can have only 1 subelement and it cannot be an array or a <>React.fragment</>\",child,this.props);if(Array.isArray(child)){if(child.length!==1){Log.ee(\"Measurable can have only 1 subelement and it cannot be an array or a <>React.fragment</>\",child,this.props);return child;}else child=child[0];}if(child.type.toString()===React.Fragment.toString()){Log.ee(\"Measurable can have only 1 subelement and it cannot be an array or a <>React.fragment</>\",child,this.props);return child;}let oldProps=child.props;let newProps={ref:html=>{if(html&&!U.isHtmlNode(html)){Log.ee('ref tring to set non-html element',html);return;}this.html=html;}};U.objectMergeInPlace(newProps,oldProps);let clonedChild=/*#__PURE__*/React.cloneElement(child,newProps);return clonedChild;}getCoords(evt,ui,isPanning){let size=Size.of(evt.target);let graph=DGraphElement.graphLFromHtml(evt.target);let gsize=graph===null||graph===void 0?void 0:graph.translateHtmlSize(size);if(isPanning){let position=this.props.onChildren?this.oldPos:ui.position;gsize.x=position.left;gsize.y=position.top;}return gsize;}},_class2.cname=\"MeasurableComponent\",_class2.childmodekeys=['left','top','transform','position'],_class2))||_class);export let ScrollableComponent=(_dec2=RuntimeAccessible('ScrollableComponent'),_dec2(_class3=(_class4=class ScrollableComponent extends Component{render(){let graph=this.props.graph;let create=e=>{/*\r\n            let target: HTMLElement = e.target.children[0] as HTMLElement;\r\n            target.style.left = graph.offset.x+'px';\r\n            target.style.top = graph.offset.y+'px';*/ // $(target).data({uiDraggable:{offset:{left: graph.offset.x, top: graph.offset.y}}});\n};return/*#__PURE__*/_jsx(\"div\",{className:\"scrollable\",children:/*#__PURE__*/_jsx(Measurable,{draggable:{create},isPanning:graph,onDragEnd:graph?function(coords){if(!graph)return;// just for ts-lint\nfor(var _len=arguments.length,args=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){args[_key-1]=arguments[_key];}console.log(\"drag odee\",{coords,graph,args});let offset=graph.offset;if(!offset.equals(coords))graph.offset=coords;}:undefined,onChildren:true,children:/*#__PURE__*/_jsx(\"div\",{className:\"panning-handle\",children:/*#__PURE__*/_jsx(\"div\",{className:\"panning-content\",children:this.props.children})})})});}},_class4.cname=\"ScrollableComponent\",_class4))||_class3);// private\n// private\n// private\n// private\n////// mapper func\n/*\r\nfunction mapStateToProps(state: DState, ownProps: MeasurableOwnProps): MeasurableStateProps {\r\n    const ret: MeasurableStateProps = {} as any;\r\n    /// to fill\r\n    return ret; }\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {} as any;\r\n    /// to fill\r\n    return ret; }\r\n*/MeasurableComponent.defaultProps={autosizex:true,autosizey:true,style:undefined,children:[]};export function Measurable(props,children){return/*#__PURE__*/_jsx(MeasurableComponent,{...props,children:props.children||children});}// shortcuts for Draggable Resizable Rotatable with whileDragging onDragStart props simplified to start, while, end\nexport function Draggable(props,children){return/*#__PURE__*/_jsx(MeasurableComponent,{...props,draggable:props.options||props.draggable||true,onDragStart:props.start||props.begin||props.onDragStart,onDragEnd:props.end||props.stop||props.onDragEnd,whileDragging:props.drag||props.while||props.ing||props.whileDragging,children:props.children||children});}export function Resizable(props,children){return/*#__PURE__*/_jsx(MeasurableComponent,{...props,resizable:props.options||props.resizable||true,onResizeStart:props.start||props.begin||props.onResizeStart,onResizeEnd:props.end||props.stop||props.onResizeEnd,whileResizing:props.resize||props.while||props.ing||props.whileResizing,children:props.children||children});}export function Rotatable(props,children){return/*#__PURE__*/_jsx(MeasurableComponent,{...props,rotatable:props.options||props.rotatable||true,onRotationStart:props.start||props.begin||props.onRotateStart||props.onRotationStart,onRotationEnd:props.end||props.stop||props.onRotateEnd||props.onRotationEnd,whileRotating:props.rotate||props.while||props.ing||props.whileRotate||props.whileRotating,children:props.children||children});}export function Scrollable(props,children){// @ts-ignore\nreturn/*#__PURE__*/_jsx(ScrollableComponent,{...props,children:props.children||children});}/*\r\nexport function InfiniteScroll(props: MeasurableAllProps, children: ReactChild[] = []): ReactElement {\r\n    return <InfiniteScrollComponent {...{...props, children}}>{children}</InfiniteScrollComponent>;\r\n}*/ /*connect<MeasurableStateProps, DispatchProps, MeasurableOwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(MeasurableComponent);*/","map":{"version":3,"names":["React","Component","DGraphElement","Log","RuntimeAccessible","Size","U","$","jsx","_jsx","MeasurableComponent","_dec","_class","_class2","constructor","arguments","html","$html","dragOptionsChanged","resizeOptionsChanged","rotateOptionsChanged","defaultOptions","draggable","cancel","cursor","distance","resizable","rotatable","oldPos","left","undefined","top","componentDidMount","afterUpdate","componentDidUpdate","prevProps","prevState","snapshot","afterUpdateSingle","absoluteToTransform","e","evt","evtkind","x","style","y","transform","concat","childmode","ui","oc","props","onChildren","ee","p","child","console","log","children","oldpos","key","childmodekeys","fixpos","newpos","position","uipos","setTimeout","graph","isPanning","offset","classList","contains","add","getDefaultEvent","type","transformMode","translateeevents","s","target","ing","_translateeevents$typ","_translateeevents$typ2","t","call","makeEvent","options","evtkey","eventmap","jqui_ing","eDevv","jquievent","jqkey","propsevent","jquievt","defaultevt","allevents","filter","length","getCoords","$measurable","datamap","optionmap","optionkey","data","objectMergeInPlace","shouldComponentUpdate","nextProps","nextState","nextContext","window","oldProps","ret","nestederr","isShallowEqualWithProxies","opt","k","Object","keys","ok","nk","tk","toString","updateDefaultOptions","render","Array","isArray","Fragment","newProps","ref","isHtmlNode","clonedChild","cloneElement","size","of","graphLFromHtml","gsize","translateHtmlSize","cname","ScrollableComponent","_dec2","_class3","_class4","create","className","Measurable","onDragEnd","coords","_len","args","_key","equals","defaultProps","autosizex","autosizey","Draggable","onDragStart","start","begin","end","stop","whileDragging","drag","while","Resizable","onResizeStart","onResizeEnd","whileResizing","resize","Rotatable","onRotationStart","onRotateStart","onRotationEnd","onRotateEnd","whileRotating","rotate","whileRotate","Scrollable"],"sources":["C:/0Programmi/Dev/projects/frontend/jjodel/src/components/forEndUser/Measurable.tsx"],"sourcesContent":["import React, {Component, CSSProperties, PureComponent, ReactChild, ReactElement, ReactNode} from \"react\";\r\nimport {DGraphElement, Dictionary, GObject, GraphSize, LGraph, Log, RuntimeAccessible, Size, TRANSACTION, U} from \"../../joiner\";\r\nimport $ from \"jquery\";\r\n/// <reference path=\"../../common/libraries/jqui-types.ts\" />\r\nimport {JQueryUI} from \"../../common/libraries/jqui-types\"\r\nimport \"./Measurable.scss\";\r\n\r\ntype ResizableEvent = JQueryUI.ResizableEvent;\r\ntype DraggableEvent = JQueryUI.DraggableEvent;\r\ntype RotatableEvent = JQueryUI.RotatableEvent;\r\ntype DraggableOptions = JQueryUI.DraggableOptions;\r\ntype ResizableOptions = JQueryUI.ResizableOptions;\r\ntype RotatabeOptions = JQueryUI.RotatableOptions;\r\n// private\r\ninterface MeasurableState {\r\n}\r\ninterface ScrollState {\r\n}\r\n\r\ntype EventLetter = 's'|'ing'|'e';\r\ntype MeasurableUIEvent = ResizableEvent | DraggableEvent | RotatableEvent;\r\n\r\n@RuntimeAccessible('MeasurableComponent')\r\nexport class MeasurableComponent extends Component<MeasurableAllProps, MeasurableState>{\r\n    static cname: string = \"MeasurableComponent\";\r\n    static childmodekeys: (keyof CSSStyleDeclaration)[] = ['left', 'top', 'transform', 'position'];\r\n\r\n\r\n    private html: Element | null = null;\r\n    private $html!:  JQuery<Element>;\r\n    dragOptionsChanged: boolean = true;\r\n    resizeOptionsChanged: boolean = true;\r\n    rotateOptionsChanged: boolean = true;\r\n    defaultOptions: {\"draggable\": JQueryUI.DraggableOptions, resizable: JQueryUI.ResizableOptions, rotatable: GObject} = {\r\n        draggable: {\r\n            cancel: '.no-drag,[contenteditable=\"true\"],input,textarea,button,select,option',\r\n            cursor: 'grabbing',\r\n            // containment: 'parent',\r\n            distance: 5,\r\n            // helper: 'clone', // 'original' or 'csselector'? or func=>html\r\n            // disabled: !(view.draggable),}\r\n        },\r\n        resizable: {},\r\n        rotatable: {},\r\n    }\r\n    oldPos: Dictionary<string, number> = {left: undefined, top: undefined} as any;\r\n\r\n    componentDidMount() {\r\n        this.afterUpdate();\r\n    }\r\n    componentDidUpdate(prevProps: Readonly<MeasurableAllProps>, prevState: Readonly<MeasurableState>, snapshot?: any) {\r\n        this.afterUpdate();\r\n    }\r\n\r\n    afterUpdate(): void{\r\n        if (!this.html) return;\r\n        this.$html = $(this.html);\r\n        if (this.dragOptionsChanged) { this.afterUpdateSingle(\"draggable\"); }\r\n        if (this.resizeOptionsChanged) { this.afterUpdateSingle(\"resizable\"); }\r\n        if (this.rotateOptionsChanged) { this.afterUpdateSingle(\"rotatable\"); }\r\n    }\r\n    /*\r\n        afterUpdateSingle(type: \"draggable\" | \"resizable\" | \"rotatable\"): void{\r\n            if (this.props.draggable) this.afterUpdateDraggable\r\n        }/*\r\n        afterUpdateDraggable_old(): void{\r\n            nope, erase this and just make the previous _old genericversion with inner dynamic functions called 9 times like event('drag', 'while'); event('drag', 'end'); event('resize', 'while');...\r\n            make and extract new functions from code so that it dinamically build the jqui options object\r\n            if (!this.$html) return;\r\n            let $measurable = this.$html;\r\n            let jqui_options = this.props.draggable;\r\n            let jqui_start = jqui_options === 'object' ? jqui_options.start : undefined;\r\n            let jqui_end = jqui_options === 'object' ? jqui_options.stop : undefined;\r\n            let jqui_ing = jqui_options === 'object' ? jqui_options.drag : undefined;\r\n            let props_start = this.props.onDragStart;\r\n            let props_end = this.props.onDragEnd;\r\n            let props_ing = this.props.whileDragging;\r\n            let type = 'draggable';\r\n\r\n\r\n            //let positionMap = new WeakMap<HTMLElement, {left: number; top: number}>();\r\n            let childmode_drag = (e: HTMLElement, evt?: any, evtkind?: EventLetter, ui?:any): void => {\r\n                let oc = this.props.onChildren;\r\n                if (!oc) {\r\n                    Log.ee('not oc', {evt, oc, e, p: this.props}); return;\r\n                }\r\n                let child: HTMLElement;\r\n                if (typeof oc === 'function') child = oc(e);\r\n                else child = e.children[0] as HTMLElement;\r\n                if (!child) {\r\n                    Log.ee('child not found', {child, evt, oc, e}); return;\r\n                }\r\n                let oldpos = this.oldPos; // positionMap.get(e);\r\n                console.log('measurable default event child ' + evtkind, {ui, e, oc, oldpos});\r\n                //if (evtkind === 'e') { positionMap.set(e, ui.position); }\r\n\r\n                /*if (evtkind === 's') {\r\n                    ui.originalPosition.left = 300;\r\n                    ui.offset.left = 300;\r\n                    ui.position.left = 300;\r\n                    console.log('measurable sstart ', {type, e, oc, ui, el: e.style.left, cl: child.style.left});\r\n                }* /\r\n\r\n                let key: any;\r\n                for (key of childmodekeys) {\r\n                    let fixpos = () => {\r\n                        if (oldpos && (oldpos as any)[key] !== undefined) {\r\n                            if (key ==='left') console.log('measurable fixpos ' + evtkind, (oldpos as any)[key] + ui.position[key] + 'px', (oldpos as any)[key]);\r\n                            let newpos = (oldpos as any)[key] + ui.position[key];\r\n                            child.style[key] = (newpos) + 'px';\r\n                            if (evtkind === 'e') this.oldPos[key] = newpos;\r\n                        }\r\n                        else child.style[key] = e.style[key];\r\n                    }\r\n                    fixpos();\r\n                    if (evtkind === 'e')  setTimeout(fixpos, 1000);\r\n                    if (evtkind === 's' && !e.classList.contains('draggable-child-mode')) e.classList.add('draggable-child-mode');\r\n                    // delete e.style[key]\r\n                }\r\n            }\r\n\r\n            let translateeevents: Dictionary<string, Dictionary<string, DraggableEvent>> = {\r\n                'draggable': {\r\n                    's': (e, ui)=>{ this.absoluteToTransform(e.target as HTMLElement, e, 's'); },\r\n                    'ing': (e, ui)=>{ this.absoluteToTransform(e.target as HTMLElement, e, 'ing'); },\r\n                    'e': (e, ui)=>{ this.absoluteToTransform(e.target as HTMLElement, e, 'e'); }},\r\n            };\r\n            let defaulteevent = (evtkind: EventLetter): MeasurableUIEvent | null =>{\r\n                if (!this.props.transformMode && !this.props.onChildren) return null;\r\n                return (e: any, ui: any) => {\r\n                    //console.log('measurable default event', {type, evtkind, translateeevents, e, t: e.target});\r\n                    if (this.props.transformMode === true) translateeevents[type][evtkind](e, ui);\r\n                    childmode_drag(e.target, e, evtkind, ui);\r\n                }\r\n            };\r\n\r\n            if (props[optionkey] === false || !props[optionkey]) {\r\n                console.log(\"measurable off \" + type, {$measurable, type, datamap, optionkey, props});\r\n                if ($measurable.data(datamap[type])) ($measurable as GObject)[type]('disable');\r\n                return;\r\n            }\r\n            if (props[optionkey] === true) {\r\n                options = {};\r\n            } else options = {...props[optionkey]};\r\n\r\n            if (props_start && typeof props_start !== \"function\") { return Log.ee(\"<Measurable /> onDragStart props must be a function\"); }\r\n            if (props_end && typeof props_end !== \"function\") { return Log.ee(\"<Measurable /> onDragEnd props must be a function\"); }\r\n            if (props_ing && typeof props_ing !== \"function\") { return Log.ee(\"<Measurable /> whileDragging props must be a function\"); }\r\n            if (!jqui_start && !props_start && ! default_start) delete options.start,\r\n                else options.start = (evt, ui) => { default_start?.(evt, ui); jqui_start?.(evt, ui); props_start?.(thiss.getCoords(evt, ui), evt, ui); }\r\n\r\n            let propsOptions = {...options};\r\n            let defaultOptions = this.defaultOptions[type];\r\n            U.objectMergeInPlace(options, defaultOptions);\r\n            //console.log(\"measurable\", {type, $measurable, options, propsOptions, defaultOptions});\r\n            ($measurable as GObject)[type](options);\r\n        }*/\r\n\r\n    absoluteToTransform(e: HTMLElement, evt?: any, evtkind?: EventLetter): any {\r\n        let x = e.style.left;\r\n        let y = e.style.top;\r\n        /*\r\n            e.style.left = '0px';\r\n            e.style.top = '0px';*/\r\n        //e.style.position = 'unset';\r\n        e.style.transform = `translate(${x}, ${y})`;\r\n    }\r\n    childmode(e: HTMLElement, evt?: any, evtkind?: EventLetter, ui?:any): void{\r\n        let oc = this.props.onChildren;\r\n        if (!oc) {\r\n            Log.ee('not oc', {evt, oc, e, p: this.props}); return;\r\n        }\r\n        let child: HTMLElement;\r\n        console.log('cchild', {e, evt,  evtkind, ui});\r\n        if (typeof oc === 'function') child = oc(e);\r\n        else child = e.children[0] as HTMLElement;\r\n        if (!child) {\r\n            Log.ee('child not found', {child, evt, oc, e}); return;\r\n        }\r\n        console.log('measurable default event child ' + evtkind, {ui, e, oc, oldpos: this.oldPos});\r\n        //if (evtkind === 'e') { positionMap.set(e, ui.position); }\r\n\r\n        /*if (evtkind === 's') {\r\n            ui.originalPosition.left = 300;\r\n            ui.offset.left = 300;\r\n            ui.position.left = 300;\r\n            console.log('measurable sstart ', {type, e, oc, ui, el: e.style.left, cl: child.style.left});\r\n        }*/\r\n\r\n        let key: any;\r\n        for (key of MeasurableComponent.childmodekeys) {\r\n            let fixpos = () => {\r\n                let oldpos = this.oldPos; // positionMap.get(e); {x:-1000, y:-3000};//\r\n                if (oldpos && (oldpos as any)[key] !== undefined) {\r\n                    let newpos = (oldpos as any)[key] + ui.position[key];\r\n                    if (key ==='left') console.log('measurable fixpos ' + newpos + 'px', (oldpos as any)[key], {oldpos, uipos:ui.position, newpos});\r\n                    child.style[key] = (newpos) + 'px';\r\n                    if (evtkind === 'e') this.oldPos[key] = newpos;\r\n                }\r\n                else child.style[key] = e.style[key];\r\n            }\r\n            if (evtkind === 'e') setTimeout(fixpos, 1000);\r\n            if (evtkind === 's') {\r\n                let graph = this.props.isPanning;\r\n                if (this.oldPos.left === undefined && graph) {\r\n                    console.log('measurable fixposss ',{oldpos:{...this.oldPos}});\r\n                    this.oldPos.left = ui.position.left = graph.offset.x;\r\n                    this.oldPos.top = ui.position.top = graph.offset.y;\r\n                }\r\n                if (!e.classList.contains('draggable-child-mode')) e.classList.add('draggable-child-mode');\r\n            }\r\n            fixpos();\r\n            // delete e.style[key]\r\n        }\r\n    }\r\n    getDefaultEvent(type: \"draggable\" | \"resizable\" | \"rotatable\", evtkind: EventLetter): MeasurableUIEvent | null {\r\n        if (!this.props.transformMode && !(this.props.onChildren && type === 'draggable')) return null;\r\n        switch (type) {\r\n            case 'draggable': if (!this.props.transformMode && !this.props.onChildren) return null; break\r\n            case 'resizable': break\r\n            case 'rotatable': break\r\n        }\r\n\r\n        let translateeevents: Dictionary<string, Dictionary<string, DraggableEvent>> = {\r\n            'draggable': {\r\n                's': (e, ui)=>{ this.absoluteToTransform(e.target as HTMLElement, e, 's'); },\r\n                'ing': (e, ui)=>{ this.absoluteToTransform(e.target as HTMLElement, e, 'ing'); },\r\n                'e': (e, ui)=>{ this.absoluteToTransform(e.target as HTMLElement, e, 'e'); }},\r\n            /*'resizable': {\r\n                's': (e, ui)=>{ },\r\n                'ing': (e, ui)=>{ },\r\n                'e': (e, ui)=>{ }},\r\n            'rotatable': {\r\n                's': (e, ui)=>{ },\r\n                'ing': (e, ui)=>{ },\r\n                'e': (e, ui)=>{ }},*/\r\n        };\r\n        return (e: any, ui: any) => {\r\n            console.log('measurable default event', {type, evtkind, translateeevents, e, t: e.target});\r\n            if (this.props.transformMode === true) translateeevents[type]?.[evtkind]?.(e, ui);\r\n            this.childmode(e.target, e, evtkind, ui);\r\n        }\r\n    }\r\n    makeEvent(options: GObject<DraggableOptions>, type: string, evtkey: keyof typeof jquievent) {\r\n        let eventmap = {\r\n            's':    {'draggable': 'onDragStart',    'rotatable': 'onRotateStart',   'resizable': 'onResizeStart'},\r\n            'ing':  {'draggable': 'whileDragging',  'rotatable': 'whileRotating',   'resizable': 'whileResizing'},\r\n            'e':    {'draggable': 'onDragEnd',      'rotatable': 'onRotateEnd',     'resizable': 'onResizeEnd'  },\r\n        }\r\n        let jqui_ing: string;\r\n        switch (type){\r\n            default: jqui_ing = Log.eDevv(\"unexpected measurable event: \" + type); return;\r\n            case \"draggable\": jqui_ing = 'drag'; break;\r\n            case \"resizable\": jqui_ing = 'resize'; break;\r\n            case \"rotatable\": jqui_ing = 'rotate'; break;\r\n        }\r\n        //let jodelevent = {'s': eventmap.s[type], 'ing': eventmap.ing[type], 'e': eventmap.e[type]};\r\n        let jquievent = {'s': 'start', 'ing': jqui_ing, 'e':'stop'};\r\n\r\n        let jqkey = jquievent[evtkey] || '';\r\n        let props: GObject<MeasurableAllProps> = this.props;\r\n        let propsevent = props[eventmap[evtkey][type]];\r\n\r\n        if (propsevent && typeof propsevent !== \"function\") {\r\n            Log.ee(\"<Measurable /> \" + eventmap[evtkey][type] + \" props must be a function\");\r\n            return;\r\n        }\r\n        // call ondragend... jodel events\r\n        let jquievt = options[jqkey];\r\n        // let jodelevt = propsevent; // (...params: any) => propsevent(...params); // was made to preserve \"this\"?\r\n        let defaultevt: null | MeasurableUIEvent = this.getDefaultEvent(type, evtkey);\r\n        let allevents = [defaultevt, jquievt, propsevent].filter((e)=>!!e);\r\n        if (allevents.length) options[jqkey] = ((evt, ui)=>{\r\n            for (let e of allevents) {\r\n                propsevent = props[eventmap[evtkey][type]]; // if i don't redeclare it here, closure makes a mess taking always the last jodelevt for all iterations.\r\n                if (e === propsevent) { e(this.getCoords(evt, ui, this.props.isPanning), evt, ui); }\r\n                else e(evt, ui);\r\n            }\r\n        }) as DraggableEvent;\r\n    }\r\n    afterUpdateSingle(type: \"draggable\" | \"resizable\" | \"rotatable\"): void{\r\n        // was forced to move from general loop-style implementation to individual redundant stuff because of closure messes.\r\n        if (!this.$html) return;\r\n        let $measurable = this.$html;\r\n        let options: GObject;\r\n        const props: GObject = this.props;\r\n        const datamap = {draggable: \"uiDraggable\", resizable: \"uiResizable\", rotatable: \"uiRotatable\"};\r\n        const optionmap = {draggable: \"draggable\", resizable: \"resizable\", rotatable: \"rotatable\"};\r\n        const optionkey = optionmap[type];\r\n        if (props[optionkey] === false || !props[optionkey]) {\r\n            // console.log(\"measurable off \" + type, {$measurable, type, datamap, optionkey, props});\r\n            if ($measurable.data(datamap[type])) ($measurable as GObject)[type]('disable');\r\n            return;\r\n        }\r\n        if (props[optionkey] === true) {\r\n            options = {};\r\n        } else options = {...props[optionkey]};\r\n\r\n        // todo: changing options at runtime works, but changing children does not update\r\n\r\n        let jqui_ing: string;\r\n        switch (type){\r\n            default: jqui_ing = Log.eDevv(\"unexpected measurable event: \" + type); return;\r\n            case \"draggable\": jqui_ing = 'drag'; break;\r\n            case \"resizable\": jqui_ing = 'resize'; break;\r\n            case \"rotatable\": jqui_ing = 'rotate'; break;\r\n        }\r\n        let jquievent = {'s': 'start', 'ing': jqui_ing, 'e':'stop'};\r\n        let evtkey: keyof typeof jquievent;\r\n        for (evtkey in jquievent) { this.makeEvent(options, type, evtkey); }\r\n        let defaultOptions = this.defaultOptions[type];\r\n        U.objectMergeInPlace(options, defaultOptions);\r\n        ($measurable as GObject)[type](options);\r\n    }\r\n    shouldComponentUpdate(nextProps: Readonly<MeasurableAllProps>, nextState: Readonly<MeasurableState>, nextContext: any): boolean {\r\n        //console.log(\"measurable shouldup\", {nc:nextProps.children, tc:this.props.children, eq: nextProps.children == this.props.children});\r\n        // todo: would need to check if pros.children has changed, but that requires a deep search of subcomponents props and state.\r\n        // currently with just return true it works and rerenders every time the parent component rerenders. not when other elements are interacted.\r\n        // it works also with <Input> as direct child and it updates.\r\n        if (window) return true;\r\n        const oldProps = this.props || {};\r\n        this.dragOptionsChanged = false;\r\n        this.resizeOptionsChanged = false;\r\n        this.rotateOptionsChanged = false;\r\n        let ret: boolean = false;\r\n        const nestederr = \"Options cannot contain functions or nested objects\";\r\n        if (!U.isShallowEqualWithProxies(oldProps.draggable, nextProps.draggable)) {\r\n            const opt: GObject = oldProps.draggable as any;\r\n            if (opt && typeof opt === \"object\") for(let k in opt){ switch (typeof opt[k]){ case \"function\": case \"object\": Log.ee(\"drag\" + nestederr, k); } }\r\n            this.dragOptionsChanged = true;\r\n            ret = true;\r\n        }\r\n        if (!U.isShallowEqualWithProxies(oldProps.resizable, nextProps.resizable)) {\r\n            const opt: GObject = oldProps.resizable as any;\r\n            if (opt && typeof opt === \"object\") for(let k in opt){ switch (typeof opt[k]){ case \"function\": case \"object\": Log.ee(\"resize\" + nestederr, k); } }\r\n            this.resizeOptionsChanged = true;\r\n            ret = true;\r\n        }\r\n        if (!U.isShallowEqualWithProxies(oldProps.rotatable, nextProps.rotatable)) {\r\n            const opt: GObject = oldProps.rotatable as any;\r\n            if (opt && typeof opt === \"object\") for(let k in opt){ switch (typeof opt[k]){ case \"function\": case \"object\": Log.ee(\"rotate\" + nestederr, k); } }\r\n            this.rotateOptionsChanged = true;\r\n            return true;\r\n        }\r\n        if (ret) return true; // i don't need to set more this.variable stuff and i already determined something changed.\r\n        if (Object.keys(oldProps).length !== Object.keys(nextProps).length) return true;\r\n        let k: keyof typeof nextProps;\r\n        for (k in oldProps){\r\n            switch(k){\r\n                //case \"axis\": if (ok)\r\n                case \"draggable\": case \"resizable\": case \"rotatable\": continue;\r\n                case \"children\": continue;\r\n            }\r\n            if (!(k in nextProps)) return false;\r\n            let ok = oldProps[k];\r\n            let nk = nextProps[k];\r\n            if (ok === nk) continue;\r\n            let tk = typeof ok;\r\n            if (tk !== typeof nk) return false;\r\n            switch (tk) {\r\n                case \"object\": Log.ee(\"unexpected object in <Measurable/> props\", {k, nk, ok}); return true;\r\n                case \"function\": if (ok!.toString() !== nk!.toString()) return true; break;\r\n                default: return false; // already checked they are !==\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    updateDefaultOptions(){\r\n        /*let addClasses = this.props.children ? 'on-children' as any : undefined;\r\n                                          jqui.classes does not owrk? and addclass is only for draggable?\r\n        if (this.defaultOptions.draggable.addClasses !== addClasses) {\r\n            this.defaultOptions.resizable.classes = addClasses;\r\n            // this.defaultOptions.rotatable.classes = addClasses;\r\n        }*/\r\n    }\r\n    render(): ReactNode {\r\n        let child: ReactElement = this.props.children as any;\r\n\r\n        this.updateDefaultOptions();\r\n        if (!child) return child || null; // sometimes react passes {} as props.children?\r\n        if (!Object.keys(child).length) return Log.ee(\"Measurable can have only 1 subelement and it cannot be an array or a <>React.fragment</>\", child, this.props);\r\n        if (Array.isArray(child)) {\r\n            if (child.length !== 1) {\r\n                Log.ee(\"Measurable can have only 1 subelement and it cannot be an array or a <>React.fragment</>\", child, this.props);\r\n                return child;\r\n            }\r\n            else child = child[0];\r\n        }\r\n        if (child.type.toString() === React.Fragment.toString()) {\r\n            Log.ee(\"Measurable can have only 1 subelement and it cannot be an array or a <>React.fragment</>\", child, this.props);\r\n            return child; }\r\n\r\n        let oldProps = child.props;\r\n        let newProps = {\r\n            ref: (html: Element | null)=>{\r\n                if (html && !U.isHtmlNode(html)) {\r\n                    Log.ee('ref tring to set non-html element', html);\r\n                    return;\r\n                }\r\n                this.html = html;\r\n            }\r\n        };\r\n        U.objectMergeInPlace(newProps, oldProps);\r\n        let clonedChild = React.cloneElement(child, newProps);\r\n        return clonedChild;\r\n    }\r\n\r\n    private getCoords(evt: JQueryEventObject, ui: JQueryUI.DraggableEventUIParams, isPanning?: LGraph): GraphSize {\r\n        let size = Size.of(evt.target);\r\n        let graph: LGraph = DGraphElement.graphLFromHtml(evt.target) as LGraph;\r\n        let gsize: GraphSize = graph?.translateHtmlSize(size);\r\n        if (isPanning) {\r\n            let position = this.props.onChildren ? this.oldPos : ui.position;\r\n            gsize.x = position.left;\r\n            gsize.y = position.top;\r\n        }\r\n        return gsize;\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('ScrollableComponent')\r\nexport class ScrollableComponent extends Component<ScrollOwnProps, ScrollState>{\r\n    static cname: string = \"ScrollableComponent\";\r\n    render(){\r\n        let graph = this.props.graph;\r\n        let create = (e: JQueryEventObject) => {/*\r\n            let target: HTMLElement = e.target.children[0] as HTMLElement;\r\n            target.style.left = graph.offset.x+'px';\r\n            target.style.top = graph.offset.y+'px';*/\r\n            // $(target).data({uiDraggable:{offset:{left: graph.offset.x, top: graph.offset.y}}});\r\n        }\r\n        return (\r\n            <div className={\"scrollable\"}>\r\n                <Measurable draggable={{create}}\r\n                            isPanning={graph}\r\n                            onDragEnd={graph ? (coords, ...args: any)=>{\r\n                                if (!graph) return; // just for ts-lint\r\n                                console.log(\"drag odee\", {coords, graph, args});\r\n                                let offset = graph.offset;\r\n                                if (!offset.equals(coords)) graph.offset = coords as any;\r\n                            } : undefined}\r\n                            onChildren={true}>\r\n                    <div className=\"panning-handle\">\r\n                        <div className=\"panning-content\">{ this.props.children }</div>\r\n                    </div>\r\n                </Measurable>\r\n            </div>);\r\n    }\r\n}\r\n\r\n// private\r\ninterface ScrollOwnProps {\r\n    children: ReactChild[] | ReactChild;\r\n    graph: LGraph;\r\n}\r\ninterface MeasurableOwnProps {\r\n    isPanning?: LGraph;\r\n    children: ReactChild[] | ReactChild;\r\n    //dragOptions?: Options;\r\n    //drag?: Options;\r\n    draggable?: JQueryUI.DraggableOptions | boolean;\r\n    onDragStart?: DraggableEvent;\r\n    whileDragging?: DraggableEvent;\r\n    onDragEnd?: (coords: GraphSize, ...args: Parameters<DraggableEvent>)=>void;\r\n    onChildren?: boolean | ((e: HTMLElement)=>HTMLElement);\r\n\r\n    //resizeOptions?: Options;\r\n    //resize?: Options;\r\n    resizable?: JQueryUI.ResizableOptions | boolean;\r\n    onResizeStart?: ResizableEvent;\r\n    whileResizing?: ResizableEvent;\r\n    onResizeEnd?: ResizableEvent;\r\n    transformMode?: boolean; // if true uses transform: translate() instead of pos:absolute; left; & top;\r\n\r\n    //rotateOptions?: Options;\r\n    //rotate?: Options;\r\n    rotatable?: GObject | boolean;\r\n    onRotationStart?: RotatableEvent;\r\n    whileRotating?: RotatableEvent;\r\n    onRotationEnd?: RotatableEvent;\r\n}\r\n// private\r\ninterface MeasurableStateProps {\r\n    // propsFromReduxStateOrOtherKindOfStateManagement: boolean; // flux or custom things too, unrelated to this.state of react.\r\n}\r\n\r\n// private\r\ninterface DispatchProps {\r\n    // propsFromReduxActions: typeof funzioneTriggeraAzioneDaImportare;\r\n}\r\n\r\n\r\n// private\r\ntype MeasurableAllProps = MeasurableOwnProps & MeasurableStateProps & DispatchProps;\r\n\r\n////// mapper func\r\n/*\r\nfunction mapStateToProps(state: DState, ownProps: MeasurableOwnProps): MeasurableStateProps {\r\n    const ret: MeasurableStateProps = {} as any;\r\n    /// to fill\r\n    return ret; }\r\n\r\nfunction mapDispatchToProps(dispatch: Dispatch<any>): DispatchProps {\r\n    const ret: DispatchProps = {} as any;\r\n    /// to fill\r\n    return ret; }\r\n*/\r\n\r\n(MeasurableComponent as any).defaultProps = {\r\n    autosizex: true,\r\n    autosizey: true,\r\n    style: undefined,\r\n    children: [],\r\n} as MeasurableOwnProps;\r\n\r\n\r\nexport function Measurable(props: MeasurableAllProps, children?: any): ReactElement {\r\n    return <MeasurableComponent {...{...props}}>{props.children||children}</MeasurableComponent>;\r\n}\r\n// shortcuts for Draggable Resizable Rotatable with whileDragging onDragStart props simplified to start, while, end\r\nexport function Draggable(props: GObject<MeasurableAllProps>, children?: any): ReactElement {\r\n    return <MeasurableComponent\r\n        {...{...props}}\r\n        draggable={props.options || props.draggable || true}\r\n        onDragStart={props.start || props.begin || props.onDragStart}\r\n        onDragEnd={props.end || props.stop || props.onDragEnd}\r\n        whileDragging={props.drag || props.while || props.ing || props.whileDragging}\r\n    >{props.children||children}</MeasurableComponent>;\r\n}\r\nexport function Resizable(props: GObject<MeasurableAllProps>, children?: any): ReactElement {\r\n    return <MeasurableComponent\r\n        {...{...props}}\r\n        resizable={props.options || props.resizable || true}\r\n        onResizeStart={props.start || props.begin || props.onResizeStart}\r\n        onResizeEnd={props.end || props.stop || props.onResizeEnd}\r\n        whileResizing={props.resize || props.while || props.ing || props.whileResizing}\r\n    >{props.children||children}</MeasurableComponent>;\r\n}\r\nexport function Rotatable(props: GObject<MeasurableAllProps>, children?: any): ReactElement {\r\n    return <MeasurableComponent\r\n        {...{...props}}\r\n        rotatable={props.options || props.rotatable || true}\r\n        onRotationStart={props.start || props.begin || props.onRotateStart|| props.onRotationStart}\r\n        onRotationEnd={props.end || props.stop || props.onRotateEnd|| props.onRotationEnd}\r\n        whileRotating={props.rotate || props.while || props.ing || props.whileRotate || props.whileRotating}\r\n    >{props.children||children}</MeasurableComponent>;\r\n}\r\n\r\n\r\nexport function Scrollable(props: MeasurableAllProps, children?: any): ReactElement {\r\n    // @ts-ignore\r\n    return <ScrollableComponent {...{...props}}>{props.children||children}</ScrollableComponent>;\r\n}/*\r\nexport function InfiniteScroll(props: MeasurableAllProps, children: ReactChild[] = []): ReactElement {\r\n    return <InfiniteScrollComponent {...{...props, children}}>{children}</InfiniteScrollComponent>;\r\n}*/\r\n\r\n/*connect<MeasurableStateProps, DispatchProps, MeasurableOwnProps, DState>(\r\n    mapStateToProps,\r\n    mapDispatchToProps\r\n)(MeasurableComponent);*/\r\n"],"mappings":"8CAAA,MAAO,CAAAA,KAAK,EAAGC,SAAS,KAA0E,OAAO,CACzG,OAAQC,aAAa,CAA0CC,GAAG,CAAEC,iBAAiB,CAAEC,IAAI,CAAeC,CAAC,KAAO,cAAc,CAChI,MAAO,CAAAC,CAAC,KAAM,QAAQ,CACtB;AAEA,MAAO,mBAAmB,CAQ1B;AAAA,OAAAC,GAAA,IAAAC,IAAA,yBASA,UACa,CAAAC,mBAAmB,EAAAC,IAAA,CAD/BP,iBAAiB,CAAC,qBAAqB,CAAC,CAAAO,IAAA,CAAAC,MAAA,EAAAC,OAAA,CAAzC,KACa,CAAAH,mBAAmB,QAAS,CAAAT,SAA8C,CAAAa,YAAA,WAAAC,SAAA,OAK3EC,IAAI,CAAmB,IAAI,MAC3BC,KAAK,aACbC,kBAAkB,CAAY,IAAI,MAClCC,oBAAoB,CAAY,IAAI,MACpCC,oBAAoB,CAAY,IAAI,MACpCC,cAAc,CAAuG,CACjHC,SAAS,CAAE,CACPC,MAAM,CAAE,uEAAuE,CAC/EC,MAAM,CAAE,UAAU,CAClB;AACAC,QAAQ,CAAE,CACV;AACA;AACJ,CAAC,CACDC,SAAS,CAAE,CAAC,CAAC,CACbC,SAAS,CAAE,CAAC,CAChB,CAAC,MACDC,MAAM,CAA+B,CAACC,IAAI,CAAEC,SAAS,CAAEC,GAAG,CAAED,SAAS,CAAC,EAEtEE,iBAAiBA,CAAA,CAAG,CAChB,IAAI,CAACC,WAAW,CAAC,CAAC,CACtB,CACAC,kBAAkBA,CAACC,SAAuC,CAAEC,SAAoC,CAAEC,QAAc,CAAE,CAC9G,IAAI,CAACJ,WAAW,CAAC,CAAC,CACtB,CAEAA,WAAWA,CAAA,CAAQ,CACf,GAAI,CAAC,IAAI,CAACjB,IAAI,CAAE,OAChB,IAAI,CAACC,KAAK,CAAGV,CAAC,CAAC,IAAI,CAACS,IAAI,CAAC,CACzB,GAAI,IAAI,CAACE,kBAAkB,CAAE,CAAE,IAAI,CAACoB,iBAAiB,CAAC,WAAW,CAAC,CAAE,CACpE,GAAI,IAAI,CAACnB,oBAAoB,CAAE,CAAE,IAAI,CAACmB,iBAAiB,CAAC,WAAW,CAAC,CAAE,CACtE,GAAI,IAAI,CAAClB,oBAAoB,CAAE,CAAE,IAAI,CAACkB,iBAAiB,CAAC,WAAW,CAAC,CAAE,CAC1E,CACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAEIC,mBAAmBA,CAACC,CAAc,CAAEC,GAAS,CAAEC,OAAqB,CAAO,CACvE,GAAI,CAAAC,CAAC,CAAGH,CAAC,CAACI,KAAK,CAACf,IAAI,CACpB,GAAI,CAAAgB,CAAC,CAAGL,CAAC,CAACI,KAAK,CAACb,GAAG,CACnB;AACR;AACA,kCAFQ,CAGA;AACAS,CAAC,CAACI,KAAK,CAACE,SAAS,cAAAC,MAAA,CAAgBJ,CAAC,OAAAI,MAAA,CAAKF,CAAC,KAAG,CAC/C,CACAG,SAASA,CAACR,CAAc,CAAEC,GAAS,CAAEC,OAAqB,CAAEO,EAAO,CAAO,CACtE,GAAI,CAAAC,EAAE,CAAG,IAAI,CAACC,KAAK,CAACC,UAAU,CAC9B,GAAI,CAACF,EAAE,CAAE,CACL/C,GAAG,CAACkD,EAAE,CAAC,QAAQ,CAAE,CAACZ,GAAG,CAAES,EAAE,CAAEV,CAAC,CAAEc,CAAC,CAAE,IAAI,CAACH,KAAK,CAAC,CAAC,CAAE,OACnD,CACA,GAAI,CAAAI,KAAkB,CACtBC,OAAO,CAACC,GAAG,CAAC,QAAQ,CAAE,CAACjB,CAAC,CAAEC,GAAG,CAAGC,OAAO,CAAEO,EAAE,CAAC,CAAC,CAC7C,GAAI,MAAO,CAAAC,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","ignoreList":[]},"metadata":{},"sourceType":"module"}