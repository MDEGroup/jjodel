{"ast":null,"code":"var _jsxFileName = \"C:\\\\0Programmi\\\\Dev\\\\projects\\\\frontend\\\\jjodel\\\\src\\\\graph\\\\graphElement\\\\graphElement.tsx\",\n  _class,\n  _class2,\n  _this = this;\nimport React, { PureComponent } from \"react\";\nimport { createPortal } from \"react-dom\";\nimport { connect } from \"react-redux\";\nimport './graphElement.scss';\nimport { CreateElementAction, DGraph, DGraphElement, JSXT, Log, LPointerTargetable, MyProxyHandler, RuntimeAccessible, Selectors, SetRootFieldAction, U, UX, windoww, DV } from \"../../joiner\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport function makeEvalContext(props, view) {\n  let evalContext = view.constants ? eval('window.tmp = ' + view.constants) : {};\n  evalContext = {\n    ...windoww.defaultContext,\n    ...evalContext,\n    model: props.data,\n    ...props\n  };\n  windoww.evalContext = evalContext;\n  return evalContext;\n}\nfunction setTemplateString(stateProps, ownProps) {\n  //if (!jsxString) { this.setState({template: this.getDefaultTemplate()}); return; }\n  // sintassi: '||' + anything + (opzionale: '|' + anything)*N_Volte + '||' + jsx oppure direttamente: jsx\n  const view = stateProps.view; //data._transient.currentView;\n  // eslint-disable-next-line no-mixed-operators\n  let allProps = {\n    ...ownProps,\n    ...stateProps\n  };\n  allProps.props = allProps;\n  const evalContext = makeEvalContext(allProps, view);\n  // const evalContextOld = U.evalInContext(this, constants);\n  // this.setState({evalContext});\n  //console.error({jsx:view.jsxString, view});\n\n  // todo: invece di fare un mapping ricorsivo dei figli per inserirgli delle prop, forse posso farlo passando una mia factory che wrappa React.createElement\n  let jsxCodeString;\n  try {\n    jsxCodeString = JSXT.fromString(view.jsxString, {\n      factory: 'React.createElement'\n    });\n  } catch (e) {\n    Log.eDevv('Syntax Error in custom user-defined template. try to remove typescript typings:\\n\\n' + e.toString() + '\\n\\n' + view.jsxString, {\n      evalContext\n    });\n    jsxCodeString = '<div>Syntax error 1</div>';\n  }\n  let jsxparsedfunc;\n  try {\n    jsxparsedfunc = U.evalInContextAndScope('()=>{ return ' + jsxCodeString + '}', evalContext);\n    // U.evalInContext({...this, ...evalContext}, res); // todo: remove eval and add new Function() ?\n  } catch (e) {\n    let errormsg = ''; // 'Syntax Error in custom user-defined template.\\n';\n    let otherargs = {\n      e,\n      jsxCodeString,\n      evalContext,\n      where: \"setTemplateString()\",\n      view\n    };\n    if (e.message.indexOf(\"Unexpected token .\") >= 0 || view.jsxString.indexOf('?.') >= 0 || view.jsxString.indexOf('??') >= 0) {\n      errormsg += 'Reminder: nullish operators \".?\" and \"??\" are not supported.\\n\\n' + e.toString() + '\\n\\n' + view.jsxString;\n    } else if (view.jsxString.indexOf('?.') >= 0) {\n      errormsg += 'Reminder: ?. operator and empty tags <></> are not supported.\\n\\n' + e.toString() + '\\n\\n' + view.jsxString;\n    }\n    jsxparsedfunc = () => DV.errorView(errormsg, otherargs);\n  }\n  stateProps.preRenderFunc = view.preRenderFunc;\n  stateProps.evalContext = evalContext;\n  stateProps.template = jsxparsedfunc;\n  // console.log('GE settemplatestring:', {stateProps});\n}\nexport let GraphElementComponent = RuntimeAccessible(_class = (_class2 = class GraphElementComponent extends PureComponent {\n  static refresh() {\n    for (let key in GraphElementComponent.all) {\n      GraphElementComponent.all[key].forceUpdate();\n    }\n    console.log(GraphElementComponent.all);\n  }\n  static defaultShouldComponentUpdate(instance, nextProps, nextState, nextContext) {\n    return !U.shallowEqual(instance.props, nextProps) || !U.shallowEqual(instance.state, nextState);\n  }\n  static mapViewStuff(state, ret, ownProps) {\n    let dnode = (ownProps === null || ownProps === void 0 ? void 0 : ownProps.nodeid) && state.idlookup[ownProps.nodeid];\n    if (ownProps.view) {\n      ret.views = [];\n      ret.view = LPointerTargetable.wrap(ownProps.view);\n    } else {\n      const viewScores = Selectors.getAppliedViews(ret.data, dnode, ret.graph, ownProps.view || null, ownProps.parentViewId || null);\n      ret.views = viewScores.map(e => MyProxyHandler.wrap(e.element));\n      ret.view = ret.views[0];\n      ret.viewScores = viewScores; // debug only\n    }\n\n    /*        if (ownProps.view) {\r\n                ret.view = DPointerTargetable.wrap(state.idlookup[ownProps.view]);\r\n            } else {\r\n                ret.view = ret.views[0];\r\n            }*/\n  }\n  static mapLModelStuff(state, ownProps, ret) {\n    var _ownProps$data;\n    const meid = typeof ownProps.data === 'string' ? ownProps.data : (_ownProps$data = ownProps.data) === null || _ownProps$data === void 0 ? void 0 : _ownProps$data.id;\n    // Log.exDev(!meid, \"model element id not found in GE.mapstatetoprops\", {meid, ret, ownProps, state});\n    ret.data = MyProxyHandler.wrap(state.idlookup[meid]);\n    // Log.ex(!ret.data, \"can't find model data:\", {meid, state, ownpropsdata:ownProps.data, ownProps});\n  }\n  static mapLGraphElementStuff(state, ownProps, ret) {\n    let dGraphElementDataClass = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DGraphElement;\n    let isDGraph = arguments.length > 4 ? arguments[4] : undefined;\n    const idlookup = state.idlookup;\n    let nodeid = ownProps.nodeid;\n    let graphid = isDGraph ? isDGraph.id : ownProps.graphid;\n    let parentnodeid = ownProps.parentnodeid;\n    let dataid = ownProps.data || null;\n    // Log.exDev(!nodeid || !graphid, 'node id injection failed', {ownProps, data: ret.data, name:(ret.data as any)?.name || (ret.data as any)?.className}); /*\n    /*if (!nodeid) {\r\n        nodeid = 'nodeof_' + stateProps.data.id + (stateProps.view.bindVertexSizeToView ? '^' + stateProps.view.id : '') + '^1';\r\n        stateProps.nodeid = U.increaseEndingNumber(nodeid, false, false, id => !idlookup[id]);\r\n        todo: quando il componente si aggiorna questo viene perso, come posso rendere permanente un settaggio di reduxstate in mapstatetoprops? o devo metterlo nello stato normale?\r\n    }*/\n\n    ret.graph = idlookup[graphid]; // se non c'è un grafo lo creo\n    if (!ret.graph) {\n      Log.exDev(!dataid, 'attempted to make a Graph element without model', {\n        dataid,\n        ownProps,\n        ret,\n        thiss: this\n      });\n      if (dataid) CreateElementAction.new(DGraph.new(dataid, parentnodeid, graphid, graphid));\n    } else {\n      ret.graph = MyProxyHandler.wrap(ret.graph);\n      Log.exDev(ret.graph.__raw.className !== \"DGraph\", 'graph class is wrong', {\n        graph: ret.graph,\n        ownProps\n      });\n    }\n    let dnode = idlookup[nodeid];\n\n    // console.log('dragx GE mapstate addGEStuff', {dGraphElementDataClass, created: new dGraphElementDataClass(false, nodeid, graphid)});\n    if (!dnode) {\n      let dge = dGraphElementDataClass.new(dataid, parentnodeid, graphid, nodeid);\n      let act = CreateElementAction.new(dge, false);\n      // console.log(\"map ge2\", {nodeid: nodeid+'', dge: {...dge}, dgeid: dge.id});\n    } else {\n      ret.node = MyProxyHandler.wrap(dnode);\n    }\n  }\n\n  ////// mapper func\n  static mapStateToProps(state, ownProps) {\n    let dGraphDataClass = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DGraphElement;\n    let startingobj = arguments.length > 3 ? arguments[3] : undefined;\n    // console.log('dragx GE mapstate', {dGraphDataClass});\n    let ret = startingobj || {}; // NB: cannot use a constructor, must be pojo\n    GraphElementComponent.mapLModelStuff(state, ownProps, ret);\n    // console.log(\"map ge\", {ownProps, ret, state});\n    GraphElementComponent.mapLGraphElementStuff(state, ownProps, ret, dGraphDataClass);\n    GraphElementComponent.mapViewStuff(state, ret, ownProps);\n    // ret.view = LViewElement.wrap(state.idlookup[vid]);\n    // view non deve essere più injected ma calcolata, però devo fare inject della view dell'elemento parent. learn ocl to make view target\n    Log.exDev(!ret.view, 'failed to inject view:', {\n      state,\n      ownProps,\n      reduxProps: ret\n    });\n    // console.log(!ret.view, 'failed to inject view:', {state, ownProps, reduxProps: ret});\n    if (ret.view.usageDeclarations) U.objectMergeInPlace(ret, U.evalInContextAndScope(ret.view.usageDeclarations));\n    // console.log('GE mapstatetoprops:', {state, ownProps, reduxProps: ret});\n    // ret.model = state.models.length ? LModelElement.wrap(state.models[0]) as LModel : undefined;\n    setTemplateString(ret, ownProps); // todo: this is heavy, should be moved somewhere where it's executed once unless view changes (pre-render with if?)\n    // @ts-ignore\n    ret.forceupdate = state.forceupdate;\n    return ret;\n  }\n  static mapDispatchToProps(dispatch) {\n    const ret = {};\n    return ret;\n  }\n  // todo: can be improved by import memoize from \"memoize-one\"; it is high-order function that memorize the result if params are the same without re-executing it (must not have side effects)\n  //  i could use memoization to parse the jsx and to execute the user-defined pre-render function\n  constructor(props, context) {\n    super(props, context);\n    this.id = void 0;\n    this._isMounted = void 0;\n    this._isMounted = false;\n    this.id = GraphElementComponent.maxid++;\n    GraphElementComponent.all[this.id] = this;\n    /*\r\n            console.log('GE constructor props:', this.props);\r\n            this.setTemplateString(this.props.view, true);\r\n            /*if (false) this.setTemplateString('{colors:[\"rEd\", \"gReen\", \"blye\"], key2:[0,2,5]}',\r\n                '() => { colors = colors.map(c=>c.toLowerCase())}',\r\n                '<div><b>GraphElement colors:</b>{colors.map( (c, i) => <li key={c} style={{color: c}}>{c}</li>)}</div>', true);*/\n    // this.onMountBindID();\n  }\n  /*\r\n      onMountBindID() {\r\n          /*if (!this.props.view.bindVertexSizeToView) {\r\n              // get position from view itself\r\n              nodeid = 'nodeof_' + this.props.data.id;\r\n              if (!store.getState().idlookup[nodeid]){\r\n                  new CreateElementAction(this.createDataNode(nodeid));\r\n              } // view-indipendent fallback, i do not add view.id to node.id\r\n          } else {* /\r\n          if (this.getId()) return;\r\n          let dnode: DGraphElement = this.createDataNode(this.generateId());\r\n          new CreateElementAction(dnode);\r\n          // let nodeid: Pointer<DGraphElement, 1, 1, LGraphElement> = dnode.id;\r\n          // this.setState({nodeid} );\r\n      }\r\n  \r\n      getId(): string | undefined {\r\n          return this.props.nodeid;\r\n      }\r\n  \r\n      generateId(): Pointer<DGraphElement, 1, 1, LGraphElement> {\r\n          // if (this.state.nodeid) return this.state.nodeid;\r\n          let ret: string = 'nodeof_' + this.props.data.id + (this.props.view.bindVertexSizeToView ? '^' + this.props.view.id : '') + '^1';\r\n          const idlookup = store.getState().idlookup;\r\n          ret = U.increaseEndingNumber(ret, false, false, id => !idlookup[id]);\r\n          return ret;\r\n      }\r\n  \r\n      // to override\r\n  \r\n      createDataNode(id?: string): DGraphElement {\r\n          return new DGraphElement(id || this.generateId(), this);\r\n      }\r\n   */\n\n  // constants: evalutate solo durante il primo render, può essere una funzione con effetti collaterali sul componente,\n  // in tal caso la si esegue e si prende il valore di ritorno.\n  // preRenderFunc: funzione evalutata ed eseguita sempre prima del render, ha senso solo per generare effetti collaterali sulle \"costanti\".\n  // jsxString: funzione evalutata una sola volta durante il primo render ed eseguita ad ogni update dei dati.\n\n  /*getDefaultTemplate(): () => ReactNode{\r\n      // to delete, i will get it from redux props instead of asking them with a func\r\n      return () => null;\r\n  }*/\n\n  /*\r\n  makeEvalContext_to_move(view: ViewElement): GObject {\r\n      let evalContext: GObject = view.constants ? eval('window.tmp = ' + view.constants) : {};\r\n      evalContext = {...GraphElementRaw.defaultContext, ...evalContext, model: this.props.data, ...this.props};\r\n      (window as any).evalContext = evalContext;\r\n      return evalContext;\r\n  }\r\n  /*\r\n  setTemplateStringToDelete_move_in_map_statetoprops(view: ViewElement, fromConstructor: boolean = false): void {\r\n      // to delete, i will get it from redux props instead of asking them with a func\r\n      //if (!jsxString) { this.setState({template: this.getDefaultTemplate()}); return; }\r\n      // sintassi: '||' + anything + (opzionale: '|' + anything)*N_Volte + '||' + jsx oppure direttamente: jsx\r\n      let colors = [\"red\", \"green\", \"blallo\"];\r\n      let daa = \"daa_var\";\r\n      sposta tutto lo stato non-redux in stato redux e memoizza\r\n      learn samuro & zeratul\r\n      // eslint-disable-next-line no-mixed-operators\r\n      windoww.Input2 = Input;\r\n      const evalContext = this.makeEvalContext();\r\n      // const evalContextOld = U.evalInContext(this, constants);\r\n      // this.setState({evalContext});\r\n      //console.error({jsx:view.jsxString, view});\r\n        let jsxCodeString: DocString<ReactNode> = JSXT.fromString(view.jsxString, {factory: 'React.createElement'}) as any;\r\n      const jsxparsedfunc = U.evalInContextAndScope<() => ReactNode>('()=>' + jsxCodeString, evalContext); // U.evalInContext({...this, ...evalContext}, res); // todo: remove eval and add new Function() ?\r\n        let state: GraphElementState = new GraphElementStatee(view.preRenderFunc, evalContext, jsxparsedfunc) as GraphElementState;\r\n      if (!fromConstructor) this.setState(state);\r\n      else (this as any).state = state;\r\n      console.log('parsed:', {state, thisstate: this.state, 'template':jsxparsedfunc, data:this.props.data});\r\n  }\r\n  /*\r\n      setState<K extends keyof MPState>(state: ((prevState: Readonly<MPState>, props: Readonly<AllProps>) => (Pick<MPState, K> | MPState | null)) | Pick<MPState, K> | MPState | null, callback?: () => void): void {\r\n          if (this._isMounted) super.setState(state, callback);\r\n          else this.state = state as MPState;\r\n      }*/\n\n  componentDidMount() {\n    // after first render\n    this._isMounted = true;\n  }\n  componentWillUnmount() {\n    // todo: devo fare in modo che il nodo venga cancellato solo se sto modificando la vista in modo che questo vertice non esista più.\n    //  e non venga cancellato se il componente viene smontato perchè ho solo cambiato vista\n    //  LOW PRIORITY perchè funziona anche senza, pur sprecando memoria che potrebbe essere liberata.\n    // if (view_is_still_active_but_got_modified_and_vertex_is_deleted) new DeleteElementAction(this.getId());\n  }\n  /*\r\n      componentDidUpdate(oldProps: Readonly<AllProps {/*\r\n          const newProps = this.props\r\n          if (oldProps.view !== newProps.view) { this.setTemplateString(newProps.view); }\r\n  }*/\n\n  getTemplate() {\n    /*if (!this.state.template) {\r\n        this.setTemplateString('{c1: 118}', '()=>{this.setState({c1: this.state.c1+1})}',\r\n            '<div><input value=\"{name}\" onInput=\"{setName}\"></input><p>c1:{this.state.c1}</p><Attribute prop1={daa} prop2={1 + 1.5} stringPropdaa=\\\"daa\\\" /><ul>{colors.map( color => <li>color: {color}</li>)}</ul></div>');\r\n    }*/\n    // console.log('getTemplate:', {props: this.props, template: this.props.template, ctx: this.props.evalContext});\n    let ret;\n    if (false && this.props.evalContext.Vertex) {\n      setTimeout(() => SetRootFieldAction.new('forceupdate_', 41), 1); // todo: optimize this to avoid triggering it tons of times when a model is loaded.\n      return /*#__PURE__*/_jsxDEV(\"div\", {\n        children: \"Loading\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 321,\n        columnNumber: 20\n      }, this);\n    }\n    let context = {\n      component: this,\n      __proto__: this.props.evalContext\n    };\n    try {\n      ret = U.execInContextAndScope(this.props.template, [], context);\n    } catch (e) {\n      const view = this.props.view; //data._transient.currentView;\n      let errormsg = ''; // 'Syntax Error in custom user-defined template.\\n';\n      if (e.message.indexOf(\"Unexpected token .\") >= 0 || view.jsxString.indexOf('?.') >= 0 || view.jsxString.indexOf('??') >= 0) {\n        errormsg += 'Reminder: nullish operators \".?\" and \"??\" are not supported.\\n\\n' + e.toString() + '\\n\\n' + view.jsxString;\n      } else if (view.jsxString.indexOf('?.') >= 0) {\n        errormsg += 'Reminder: ?. operator and empty tags <></> are not supported.\\n\\n' + e.toString() + '\\n\\n' + view.jsxString;\n      }\n      ret = DV.errorView(errormsg, {\n        where: \"in getTemplate()\",\n        e\n      });\n    }\n    return ret;\n  }\n  /**\r\n   * package got node id injected\r\n   * package.render() start\r\n   *    ge render message\r\n   *    mapstate of denum before?? crash here?\r\n   *    inject enum props (not happening?)\r\n   *    mapstate of denum again after??\r\n   * package.render() end\r\n   *\r\n   * */\n  render() {\n    var _this$props$node;\n    if (this.props.preRenderFunc) U.evalInContextAndScope(this.props.preRenderFunc, {\n      component: this,\n      __proto__: this.props.evalContext\n    });\n    const rnode = this.getTemplate();\n    let rawRElement = U.ReactNodeAsElement(rnode);\n    // @ts-ignore\n    // console.log('GE render', {rnode, rawRElement, props:this.props, name: this.props.data.name});\n    const me = this.props.data; // this.props.model;\n\n    const addprops = true;\n    let fiximport = !!this.props.node; // todo: check if correct approach\n    if (addprops && me && rawRElement && fiximport) {\n      // console.log(\"pre-injecting\", {thiss:this, data:this.props.data, props:this.props});\n      const onDragTestInject = () => {}; // might inject event handlers like this with cloneelement\n      // add view props to GraphElement childrens (any level down)\n      const subElements = {}; // this.props.getGVidMap(); // todo: per passarla come prop ma mantenerla modificabile\n      try {\n        rawRElement = /*#__PURE__*/React.cloneElement(rawRElement, {\n          key: this.props.key || this.props.view.id + '_' + me.id,\n          onDragTestInject,\n          children: UX.recursiveMap(rawRElement /*.props.children*/, rn => UX.injectProp(this, rn, subElements))\n        });\n      } catch (e) {\n        var _this$props$view;\n        rawRElement = DV.errorView(\"error while injecting props to subnodes\", {\n          e,\n          rawRElement,\n          key: this.props.key,\n          newid: ((_this$props$view = this.props.view) === null || _this$props$view === void 0 ? void 0 : _this$props$view.id) + '_' + (me === null || me === void 0 ? void 0 : me.id)\n        });\n      }\n      /*console.log('tempdebug', {deepStrictEqual, okeys:Object.keys});\r\n      let isEqual = true;\r\n      try {deepStrictEqual(subElements, this.props.node.subElements)} catch(e) { isEqual = false; }\r\n      if (isEqual) {\r\n          this.props.node.subElements = Object.keys(subElements);\r\n      }*/\n    }\n    // const injectprops = {a:3, b:4} as DetailedHTMLProps<HTMLAttributes<HTMLDivElement>, HTMLDivElement>;\n    // rnode = React.cloneElement(rnode as ReactElement, injectprops);\n\n    // console.log(\"nodeee\", {thiss:this, props:this.props, node: this.props.node});\n    if (false && ((_this$props$node = this.props.node) === null || _this$props$node === void 0 ? void 0 : _this$props$node.__raw).father) {\n      let $containedIn = $('#' + this.props.node.father);\n      let $containerDropArea = $containedIn.find(\".VertexContainer\");\n      const droparea = $containerDropArea[0] || $containedIn[0];\n      Log.exDev(!droparea, 'invalid vertex container target', {\n        $containedIn,\n        $containerDropArea\n      });\n      if (droparea) return /*#__PURE__*/createPortal(rawRElement || rnode, droparea);\n    }\n    return rawRElement || rnode;\n  }\n}, _class2.maxid = 0, _class2.all = {}, _class2.graphVertexID_counter = {}, _class2)) || _class;\n\n// private\n// type AllPropss = GraphElementOwnProps & GraphElementDispatchProps & GraphElementReduxStateProps;\n\nconst GraphElementConnected = connect(GraphElementComponent.mapStateToProps, GraphElementComponent.mapDispatchToProps)(GraphElementComponent);\nexport const GraphElement = function (props) {\n  let childrens = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return /*#__PURE__*/_jsxDEV(GraphElementConnected, {\n    ...props,\n    childrens\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 402,\n    columnNumber: 12\n  }, _this);\n};\n_c = GraphElement;\nconsole.info('graphElement loaded');\nvar _c;\n$RefreshReg$(_c, \"GraphElement\");","map":{"version":3,"names":["React","PureComponent","createPortal","connect","CreateElementAction","DGraph","DGraphElement","JSXT","Log","LPointerTargetable","MyProxyHandler","RuntimeAccessible","Selectors","SetRootFieldAction","U","UX","windoww","DV","jsxDEV","_jsxDEV","makeEvalContext","props","view","evalContext","constants","eval","defaultContext","model","data","setTemplateString","stateProps","ownProps","allProps","jsxCodeString","fromString","jsxString","factory","e","eDevv","toString","jsxparsedfunc","evalInContextAndScope","errormsg","otherargs","where","message","indexOf","errorView","preRenderFunc","template","GraphElementComponent","_class","_class2","refresh","key","all","forceUpdate","console","log","defaultShouldComponentUpdate","instance","nextProps","nextState","nextContext","shallowEqual","state","mapViewStuff","ret","dnode","nodeid","idlookup","views","wrap","viewScores","getAppliedViews","graph","parentViewId","map","element","mapLModelStuff","_ownProps$data","meid","id","mapLGraphElementStuff","dGraphElementDataClass","arguments","length","undefined","isDGraph","graphid","parentnodeid","dataid","exDev","thiss","new","__raw","className","dge","act","node","mapStateToProps","dGraphDataClass","startingobj","reduxProps","usageDeclarations","objectMergeInPlace","forceupdate","mapDispatchToProps","dispatch","constructor","context","_isMounted","maxid","componentDidMount","componentWillUnmount","getTemplate","Vertex","setTimeout","children","fileName","_jsxFileName","lineNumber","columnNumber","component","__proto__","execInContextAndScope","render","_this$props$node","rnode","rawRElement","ReactNodeAsElement","me","addprops","fiximport","onDragTestInject","subElements","cloneElement","recursiveMap","rn","injectProp","_this$props$view","newid","father","$containedIn","$","$containerDropArea","find","droparea","graphVertexID_counter","GraphElementConnected","GraphElement","childrens","_this","_c","info","$RefreshReg$"],"sources":["C:/0Programmi/Dev/projects/frontend/jjodel/src/graph/graphElement/graphElement.tsx"],"sourcesContent":["import React, {Dispatch, PureComponent, ReactElement, ReactNode,} from \"react\";\r\nimport {createPortal} from \"react-dom\";\r\nimport {connect} from \"react-redux\";\r\nimport './graphElement.scss';\r\n\r\nimport {\r\n    CreateElementAction,\r\n    DGraph,\r\n    DGraphElement,\r\n    Dictionary,\r\n    DModelElement,\r\n    DocString, DViewElement,\r\n    GObject,\r\n    GraphElementDispatchProps,\r\n    GraphElementOwnProps,\r\n    GraphElementReduxStateProps,\r\n    GraphElementStatee,\r\n    InOutParam,\r\n    IStore,\r\n    JSXT,\r\n    LModelElement,\r\n    Log, LPointerTargetable,\r\n    LViewElement,\r\n    MyProxyHandler, Overlap,\r\n    Pointer,\r\n    RuntimeAccessible,\r\n    Selectors,\r\n    SetRootFieldAction,\r\n    U,\r\n    UX,\r\n    windoww, DV\r\n} from \"../../joiner\";\r\n\r\n\r\nexport function makeEvalContext(props: AllPropss, view: LViewElement): GObject {\r\n    let evalContext: GObject = view.constants ? eval('window.tmp = ' + view.constants) : {};\r\n    evalContext = {...windoww.defaultContext, ...evalContext, model: props.data, ...props};\r\n    windoww.evalContext = evalContext;\r\n    return evalContext;\r\n}\r\n\r\nfunction setTemplateString(stateProps: InOutParam<GraphElementReduxStateProps>, ownProps: Readonly<GraphElementOwnProps>): void {\r\n    //if (!jsxString) { this.setState({template: this.getDefaultTemplate()}); return; }\r\n    // sintassi: '||' + anything + (opzionale: '|' + anything)*N_Volte + '||' + jsx oppure direttamente: jsx\r\n    const view: LViewElement = stateProps.view; //data._transient.currentView;\r\n    // eslint-disable-next-line no-mixed-operators\r\n    let allProps: AllPropss = {...ownProps, ...stateProps} as AllPropss;\r\n    (allProps as GObject).props = allProps;\r\n    const evalContext = makeEvalContext(allProps, view);\r\n    // const evalContextOld = U.evalInContext(this, constants);\r\n    // this.setState({evalContext});\r\n    //console.error({jsx:view.jsxString, view});\r\n\r\n    // todo: invece di fare un mapping ricorsivo dei figli per inserirgli delle prop, forse posso farlo passando una mia factory che wrappa React.createElement\r\n    let jsxCodeString: DocString<ReactNode>;\r\n    try { jsxCodeString = JSXT.fromString(view.jsxString, {factory: 'React.createElement'}); }\r\n    catch (e: any) {\r\n        Log.eDevv('Syntax Error in custom user-defined template. try to remove typescript typings:\\n\\n' +e.toString() + '\\n\\n' + view.jsxString, {evalContext});\r\n        jsxCodeString = '<div>Syntax error 1</div>';\r\n    }\r\n    let jsxparsedfunc: () => React.ReactNode;\r\n    try {\r\n        jsxparsedfunc = U.evalInContextAndScope<() => ReactNode>('()=>{ return ' + jsxCodeString + '}', evalContext);\r\n        // U.evalInContext({...this, ...evalContext}, res); // todo: remove eval and add new Function() ?\r\n    }\r\n    catch (e: any) {\r\n        let errormsg = ''; // 'Syntax Error in custom user-defined template.\\n';\r\n        let otherargs: any = {e, jsxCodeString, evalContext, where:\"setTemplateString()\", view};\r\n        if (e.message.indexOf(\"Unexpected token .\") >= 0 || view.jsxString.indexOf('?.') >= 0 || view.jsxString.indexOf('??') >= 0)\r\n        { errormsg += 'Reminder: nullish operators \".?\" and \"??\" are not supported.\\n\\n' +e.toString() + '\\n\\n' + view.jsxString; }\r\n        else if (view.jsxString.indexOf('?.') >= 0) { errormsg += 'Reminder: ?. operator and empty tags <></> are not supported.\\n\\n' +e.toString() + '\\n\\n' + view.jsxString; }\r\n        jsxparsedfunc = ()=> DV.errorView(errormsg, otherargs);\r\n    }\r\n\r\n    stateProps.preRenderFunc = view.preRenderFunc;\r\n    stateProps.evalContext = evalContext;\r\n    stateProps.template = jsxparsedfunc;\r\n    // console.log('GE settemplatestring:', {stateProps});\r\n}\r\n\r\n@RuntimeAccessible\r\nexport class GraphElementComponent<AllProps extends AllPropss = AllPropss, GraphElementState extends GraphElementStatee = GraphElementStatee>\r\n    extends PureComponent<AllProps, GraphElementState>{\r\n    static maxid: number = 0;\r\n    static all: Dictionary<number, GraphElementComponent> = {};\r\n    id: number;\r\n    public static refresh() {\r\n        for (let key in GraphElementComponent.all) {\r\n            GraphElementComponent.all[key].forceUpdate();\r\n        }\r\n        console.log(GraphElementComponent.all);\r\n    }\r\n\r\n    public static defaultShouldComponentUpdate<AllProps extends GObject, State extends GObject, Context extends any>\r\n    (instance: React.Component, nextProps: Readonly<AllProps>, nextState: Readonly<State>, nextContext: Context) {\r\n        return (\r\n            !U.shallowEqual(instance.props, nextProps) ||\r\n            !U.shallowEqual(instance.state, nextState)\r\n        );\r\n    }\r\n\r\n    static mapViewStuff(state: IStore, ret: GraphElementReduxStateProps, ownProps: GraphElementOwnProps) {\r\n        let dnode: DGraphElement | undefined = ownProps?.nodeid && state.idlookup[ownProps.nodeid] as any;\r\n        if (ownProps.view) {\r\n            ret.views = [];\r\n            ret.view = LPointerTargetable.wrap(ownProps.view) as LViewElement;\r\n        }\r\n        else {\r\n            const viewScores = Selectors.getAppliedViews(ret.data, dnode, ret.graph, ownProps.view || null, ownProps.parentViewId || null);\r\n            ret.views = viewScores.map(e => MyProxyHandler.wrap(e.element));\r\n            ret.view = ret.views[0];\r\n            (ret as any).viewScores = viewScores; // debug only\r\n        }\r\n\r\n        /*        if (ownProps.view) {\r\n                    ret.view = DPointerTargetable.wrap(state.idlookup[ownProps.view]);\r\n                } else {\r\n                    ret.view = ret.views[0];\r\n                }*/\r\n    }\r\n\r\n    static mapLModelStuff(state: IStore, ownProps: GraphElementOwnProps, ret: GraphElementReduxStateProps): void {\r\n        const meid: string = (typeof ownProps.data === 'string' ? ownProps.data as string : (ownProps.data as any as DModelElement)?.id) as string;\r\n        // Log.exDev(!meid, \"model element id not found in GE.mapstatetoprops\", {meid, ret, ownProps, state});\r\n        ret.data = MyProxyHandler.wrap(state.idlookup[meid as any]);\r\n        // Log.ex(!ret.data, \"can't find model data:\", {meid, state, ownpropsdata:ownProps.data, ownProps});\r\n\r\n    }\r\n\r\n    static mapLGraphElementStuff(state: IStore,\r\n                                 ownProps: GraphElementOwnProps,\r\n                                 ret: GraphElementReduxStateProps,\r\n                                 dGraphElementDataClass: typeof DGraphElement = DGraphElement,\r\n                                 isDGraph?: DGraph): void {\r\n        const idlookup = state.idlookup;\r\n        let nodeid: string = ownProps.nodeid as string;\r\n        let graphid: string = isDGraph ? isDGraph.id : ownProps.graphid as string;\r\n        let parentnodeid: string = ownProps.parentnodeid as string;\r\n        let dataid: Pointer<DModelElement, 0, 1, LModelElement> = ownProps.data || null;\r\n        // Log.exDev(!nodeid || !graphid, 'node id injection failed', {ownProps, data: ret.data, name:(ret.data as any)?.name || (ret.data as any)?.className}); /*\r\n        /*if (!nodeid) {\r\n            nodeid = 'nodeof_' + stateProps.data.id + (stateProps.view.bindVertexSizeToView ? '^' + stateProps.view.id : '') + '^1';\r\n            stateProps.nodeid = U.increaseEndingNumber(nodeid, false, false, id => !idlookup[id]);\r\n            todo: quando il componente si aggiorna questo viene perso, come posso rendere permanente un settaggio di reduxstate in mapstatetoprops? o devo metterlo nello stato normale?\r\n        }*/\r\n\r\n        ret.graph = idlookup[graphid] as DGraphElement as any; // se non c'è un grafo lo creo\r\n        if (!ret.graph) {\r\n            Log.exDev(!dataid, 'attempted to make a Graph element without model', {dataid, ownProps, ret, thiss:this});\r\n            if (dataid) CreateElementAction.new(DGraph.new(dataid, parentnodeid, graphid, graphid)); }\r\n        else {\r\n            ret.graph = MyProxyHandler.wrap(ret.graph);\r\n            Log.exDev(ret.graph.__raw.className !== \"DGraph\", 'graph class is wrong', {graph: ret.graph, ownProps});\r\n        }\r\n\r\n\r\n        let dnode: DGraphElement = idlookup[nodeid] as DGraphElement;\r\n\r\n        // console.log('dragx GE mapstate addGEStuff', {dGraphElementDataClass, created: new dGraphElementDataClass(false, nodeid, graphid)});\r\n        if (!dnode) {\r\n            let dge = dGraphElementDataClass.new(dataid, parentnodeid, graphid, nodeid);\r\n            let act = CreateElementAction.new(dge, false);\r\n            // console.log(\"map ge2\", {nodeid: nodeid+'', dge: {...dge}, dgeid: dge.id});\r\n        }\r\n        else { ret.node = MyProxyHandler.wrap(dnode); }\r\n    }\r\n\r\n    ////// mapper func\r\n    static mapStateToProps(state: IStore, ownProps: GraphElementOwnProps, dGraphDataClass: typeof DGraphElement = DGraphElement, startingobj?: GObject): GraphElementReduxStateProps {\r\n        // console.log('dragx GE mapstate', {dGraphDataClass});\r\n        let ret: GraphElementReduxStateProps = (startingobj || {}) as GraphElementReduxStateProps; // NB: cannot use a constructor, must be pojo\r\n        GraphElementComponent.mapLModelStuff(state, ownProps, ret);\r\n        // console.log(\"map ge\", {ownProps, ret, state});\r\n        GraphElementComponent.mapLGraphElementStuff(state, ownProps, ret, dGraphDataClass);\r\n        GraphElementComponent.mapViewStuff(state, ret, ownProps);\r\n        // ret.view = LViewElement.wrap(state.idlookup[vid]);\r\n        // view non deve essere più injected ma calcolata, però devo fare inject della view dell'elemento parent. learn ocl to make view target\r\n        Log.exDev(!ret.view, 'failed to inject view:', {state, ownProps, reduxProps: ret});\r\n        // console.log(!ret.view, 'failed to inject view:', {state, ownProps, reduxProps: ret});\r\n        if (ret.view.usageDeclarations) U.objectMergeInPlace(ret, U.evalInContextAndScope(ret.view.usageDeclarations));\r\n        // console.log('GE mapstatetoprops:', {state, ownProps, reduxProps: ret});\r\n        // ret.model = state.models.length ? LModelElement.wrap(state.models[0]) as LModel : undefined;\r\n        setTemplateString(ret, ownProps); // todo: this is heavy, should be moved somewhere where it's executed once unless view changes (pre-render with if?)\r\n        // @ts-ignore\r\n        ret.forceupdate = state.forceupdate;\r\n        return ret;\r\n    }\r\n\r\n    static mapDispatchToProps(dispatch: Dispatch<any>): GraphElementDispatchProps {\r\n        const ret: GraphElementDispatchProps = {} as any;\r\n        return ret;\r\n    }\r\n\r\n\r\n    _isMounted: boolean;\r\n    // todo: can be improved by import memoize from \"memoize-one\"; it is high-order function that memorize the result if params are the same without re-executing it (must not have side effects)\r\n    //  i could use memoization to parse the jsx and to execute the user-defined pre-render function\r\n    constructor(props: AllProps, context: any) {\r\n        super(props, context);\r\n        this._isMounted = false;\r\n        this.id = GraphElementComponent.maxid++;\r\n        GraphElementComponent.all[this.id] = this;\r\n/*\r\n        console.log('GE constructor props:', this.props);\r\n        this.setTemplateString(this.props.view, true);\r\n        /*if (false) this.setTemplateString('{colors:[\"rEd\", \"gReen\", \"blye\"], key2:[0,2,5]}',\r\n            '() => { colors = colors.map(c=>c.toLowerCase())}',\r\n            '<div><b>GraphElement colors:</b>{colors.map( (c, i) => <li key={c} style={{color: c}}>{c}</li>)}</div>', true);*/\r\n        // this.onMountBindID();\r\n    }\r\n/*\r\n    onMountBindID() {\r\n        /*if (!this.props.view.bindVertexSizeToView) {\r\n            // get position from view itself\r\n            nodeid = 'nodeof_' + this.props.data.id;\r\n            if (!store.getState().idlookup[nodeid]){\r\n                new CreateElementAction(this.createDataNode(nodeid));\r\n            } // view-indipendent fallback, i do not add view.id to node.id\r\n        } else {* /\r\n        if (this.getId()) return;\r\n        let dnode: DGraphElement = this.createDataNode(this.generateId());\r\n        new CreateElementAction(dnode);\r\n        // let nodeid: Pointer<DGraphElement, 1, 1, LGraphElement> = dnode.id;\r\n        // this.setState({nodeid} );\r\n    }\r\n\r\n    getId(): string | undefined {\r\n        return this.props.nodeid;\r\n    }\r\n\r\n    generateId(): Pointer<DGraphElement, 1, 1, LGraphElement> {\r\n        // if (this.state.nodeid) return this.state.nodeid;\r\n        let ret: string = 'nodeof_' + this.props.data.id + (this.props.view.bindVertexSizeToView ? '^' + this.props.view.id : '') + '^1';\r\n        const idlookup = store.getState().idlookup;\r\n        ret = U.increaseEndingNumber(ret, false, false, id => !idlookup[id]);\r\n        return ret;\r\n    }\r\n\r\n    // to override\r\n\r\n    createDataNode(id?: string): DGraphElement {\r\n        return new DGraphElement(id || this.generateId(), this);\r\n    }\r\n */\r\n\r\n    // constants: evalutate solo durante il primo render, può essere una funzione con effetti collaterali sul componente,\r\n    // in tal caso la si esegue e si prende il valore di ritorno.\r\n    // preRenderFunc: funzione evalutata ed eseguita sempre prima del render, ha senso solo per generare effetti collaterali sulle \"costanti\".\r\n    // jsxString: funzione evalutata una sola volta durante il primo render ed eseguita ad ogni update dei dati.\r\n\r\n    /*getDefaultTemplate(): () => ReactNode{\r\n        // to delete, i will get it from redux props instead of asking them with a func\r\n        return () => null;\r\n    }*/\r\n\r\n    static graphVertexID_counter: Dictionary<DocString<'GraphID'>, Dictionary<DocString<'VertexID'>, boolean>> = {}\r\n\r\n    /*\r\n    makeEvalContext_to_move(view: ViewElement): GObject {\r\n        let evalContext: GObject = view.constants ? eval('window.tmp = ' + view.constants) : {};\r\n        evalContext = {...GraphElementRaw.defaultContext, ...evalContext, model: this.props.data, ...this.props};\r\n        (window as any).evalContext = evalContext;\r\n        return evalContext;\r\n    }\r\n    /*\r\n    setTemplateStringToDelete_move_in_map_statetoprops(view: ViewElement, fromConstructor: boolean = false): void {\r\n        // to delete, i will get it from redux props instead of asking them with a func\r\n        //if (!jsxString) { this.setState({template: this.getDefaultTemplate()}); return; }\r\n        // sintassi: '||' + anything + (opzionale: '|' + anything)*N_Volte + '||' + jsx oppure direttamente: jsx\r\n        let colors = [\"red\", \"green\", \"blallo\"];\r\n        let daa = \"daa_var\";\r\n        sposta tutto lo stato non-redux in stato redux e memoizza\r\n        learn samuro & zeratul\r\n        // eslint-disable-next-line no-mixed-operators\r\n        windoww.Input2 = Input;\r\n        const evalContext = this.makeEvalContext();\r\n        // const evalContextOld = U.evalInContext(this, constants);\r\n        // this.setState({evalContext});\r\n        //console.error({jsx:view.jsxString, view});\r\n\r\n        let jsxCodeString: DocString<ReactNode> = JSXT.fromString(view.jsxString, {factory: 'React.createElement'}) as any;\r\n        const jsxparsedfunc = U.evalInContextAndScope<() => ReactNode>('()=>' + jsxCodeString, evalContext); // U.evalInContext({...this, ...evalContext}, res); // todo: remove eval and add new Function() ?\r\n\r\n        let state: GraphElementState = new GraphElementStatee(view.preRenderFunc, evalContext, jsxparsedfunc) as GraphElementState;\r\n        if (!fromConstructor) this.setState(state);\r\n        else (this as any).state = state;\r\n        console.log('parsed:', {state, thisstate: this.state, 'template':jsxparsedfunc, data:this.props.data});\r\n    }\r\n    /*\r\n        setState<K extends keyof MPState>(state: ((prevState: Readonly<MPState>, props: Readonly<AllProps>) => (Pick<MPState, K> | MPState | null)) | Pick<MPState, K> | MPState | null, callback?: () => void): void {\r\n            if (this._isMounted) super.setState(state, callback);\r\n            else this.state = state as MPState;\r\n        }*/\r\n\r\n    componentDidMount(): void {\r\n        // after first render\r\n        this._isMounted = true;\r\n    }\r\n\r\n    componentWillUnmount(): void {\r\n        // todo: devo fare in modo che il nodo venga cancellato solo se sto modificando la vista in modo che questo vertice non esista più.\r\n        //  e non venga cancellato se il componente viene smontato perchè ho solo cambiato vista\r\n        //  LOW PRIORITY perchè funziona anche senza, pur sprecando memoria che potrebbe essere liberata.\r\n        // if (view_is_still_active_but_got_modified_and_vertex_is_deleted) new DeleteElementAction(this.getId());\r\n    }\r\n    /*\r\n        componentDidUpdate(oldProps: Readonly<AllProps {/*\r\n            const newProps = this.props\r\n            if (oldProps.view !== newProps.view) { this.setTemplateString(newProps.view); }\r\n    }*/\r\n\r\n    private getTemplate(): ReactNode {\r\n        /*if (!this.state.template) {\r\n            this.setTemplateString('{c1: 118}', '()=>{this.setState({c1: this.state.c1+1})}',\r\n                '<div><input value=\"{name}\" onInput=\"{setName}\"></input><p>c1:{this.state.c1}</p><Attribute prop1={daa} prop2={1 + 1.5} stringPropdaa=\\\"daa\\\" /><ul>{colors.map( color => <li>color: {color}</li>)}</ul></div>');\r\n        }*/\r\n        // console.log('getTemplate:', {props: this.props, template: this.props.template, ctx: this.props.evalContext});\r\n        let ret;\r\n        if (false && this.props.evalContext.Vertex) {\r\n            setTimeout( () => SetRootFieldAction.new('forceupdate_', 41), 1); // todo: optimize this to avoid triggering it tons of times when a model is loaded.\r\n            return <div>Loading</div>;}\r\n        let context = {component:this, __proto__:this.props.evalContext};\r\n        try {\r\n            ret = U.execInContextAndScope<() => ReactNode>(this.props.template, [], context); }\r\n        catch(e: any) {\r\n            const view: LViewElement = this.props.view; //data._transient.currentView;\r\n            let errormsg = ''; // 'Syntax Error in custom user-defined template.\\n';\r\n            if (e.message.indexOf(\"Unexpected token .\") >= 0 || view.jsxString.indexOf('?.') >= 0 || view.jsxString.indexOf('??') >= 0)\r\n            { errormsg += 'Reminder: nullish operators \".?\" and \"??\" are not supported.\\n\\n' +e.toString() + '\\n\\n' + view.jsxString; }\r\n            else if (view.jsxString.indexOf('?.') >= 0) { errormsg += 'Reminder: ?. operator and empty tags <></> are not supported.\\n\\n' +e.toString() + '\\n\\n' + view.jsxString; }\r\n            ret = DV.errorView(errormsg, {where:\"in getTemplate()\", e});\r\n        }\r\n        return ret;\r\n    }\r\n/**\r\n * package got node id injected\r\n * package.render() start\r\n *    ge render message\r\n *    mapstate of denum before?? crash here?\r\n *    inject enum props (not happening?)\r\n *    mapstate of denum again after??\r\n * package.render() end\r\n *\r\n * */\r\n    public render(): ReactNode {\r\n        if (this.props.preRenderFunc) U.evalInContextAndScope(this.props.preRenderFunc, {component:this, __proto__:this.props.evalContext});\r\n        const rnode: ReactNode = this.getTemplate();\r\n        let rawRElement: ReactElement | null = U.ReactNodeAsElement(rnode);\r\n        // @ts-ignore\r\n        // console.log('GE render', {rnode, rawRElement, props:this.props, name: this.props.data.name});\r\n        const me: LModelElement = this.props.data as LModelElement; // this.props.model;\r\n\r\n        const addprops: boolean = true;\r\n        let fiximport = !!this.props.node; // todo: check if correct approach\r\n        if (addprops && me && rawRElement && fiximport) {\r\n            // console.log(\"pre-injecting\", {thiss:this, data:this.props.data, props:this.props});\r\n            const onDragTestInject = () => {}; // might inject event handlers like this with cloneelement\r\n            // add view props to GraphElement childrens (any level down)\r\n            const subElements: Dictionary<DocString<'nodeid'>, boolean> = {}; // this.props.getGVidMap(); // todo: per passarla come prop ma mantenerla modificabile\r\n            try {\r\n                rawRElement = React.cloneElement(rawRElement, {key: this.props.key || this.props.view.id + '_' + me.id, onDragTestInject, children: UX.recursiveMap(rawRElement/*.props.children*/,\r\n                        (rn: ReactNode) => UX.injectProp(this, rn, subElements))});\r\n            } catch (e) {\r\n                rawRElement = DV.errorView(\"error while injecting props to subnodes\", {e, rawRElement, key:this.props.key, newid: this.props.view?.id+'_'+me?.id});\r\n            }\r\n            /*console.log('tempdebug', {deepStrictEqual, okeys:Object.keys});\r\n            let isEqual = true;\r\n            try {deepStrictEqual(subElements, this.props.node.subElements)} catch(e) { isEqual = false; }\r\n            if (isEqual) {\r\n                this.props.node.subElements = Object.keys(subElements);\r\n            }*/\r\n        }\r\n        // const injectprops = {a:3, b:4} as DetailedHTMLProps<HTMLAttributes<HTMLDivElement>, HTMLDivElement>;\r\n        // rnode = React.cloneElement(rnode as ReactElement, injectprops);\r\n\r\n        // console.log(\"nodeee\", {thiss:this, props:this.props, node: this.props.node});\r\n        if (false && (this.props.node?.__raw as DGraphElement).father) {\r\n            let $containedIn = $('#' + this.props.node.father);\r\n            let $containerDropArea = $containedIn.find(\".VertexContainer\");\r\n            const droparea = $containerDropArea[0] || $containedIn[0];\r\n            Log.exDev(!droparea, 'invalid vertex container target', {$containedIn, $containerDropArea});\r\n            if (droparea) return createPortal(\r\n                rawRElement || rnode,\r\n                droparea\r\n            );\r\n        }\r\n        return rawRElement || rnode;\r\n    }\r\n\r\n}\r\n\r\n// private\r\n// type AllPropss = GraphElementOwnProps & GraphElementDispatchProps & GraphElementReduxStateProps;\r\ntype AllPropss = Overlap<Overlap<GraphElementOwnProps, GraphElementDispatchProps>, GraphElementReduxStateProps>;\r\n\r\nconst GraphElementConnected = connect<GraphElementReduxStateProps, GraphElementDispatchProps, GraphElementOwnProps, IStore>(\r\n    GraphElementComponent.mapStateToProps,\r\n    GraphElementComponent.mapDispatchToProps\r\n)(GraphElementComponent as any);\r\n\r\nexport const GraphElement = (props: GraphElementOwnProps, childrens: (string | React.Component)[] = []): ReactElement => {\r\n    return <GraphElementConnected {...{...props, childrens}} />; }\r\nconsole.info('graphElement loaded');\r\n"],"mappings":"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iBAAiB,CAAC,CAAC;IAC9G;IACA;IACA3E,iBAAiB,CAACsC,GAAG,EAAEpC,QAAQ,CAAC,CAAC,CAAC;IAClC;IACAoC,GAAG,CAACuC,WAAW,GAAGzC,KAAK,CAACyC,WAAW;IACnC,OAAOvC,GAAG;EACd;EAEA,OAAOwC,kBAAkBA,CAACC,QAAuB,EAA6B;IAC1E,MAAMzC,GAA8B,GAAG,CAAC,CAAQ;IAChD,OAAOA,GAAG;EACd;EAIA;EACA;EACA0C,WAAWA,CAACxF,KAAe,EAAEyF,OAAY,EAAE;IACvC,KAAK,CAACzF,KAAK,EAAEyF,OAAO,CAAC;IAAC,KAjH1B5B,EAAE;IAAA,KA6GF6B,UAAU;IAKN,IAAI,CAACA,UAAU,GAAG,KAAK;IACvB,IAAI,CAAC7B,EAAE,GAAGhC,qBAAqB,CAAC8D,KAAK,EAAE;IACvC9D,qBAAqB,CAACK,GAAG,CAAC,IAAI,CAAC2B,EAAE,CAAC,GAAG,IAAI;IACjD;AACA;AACA;AACA;AACA;AACA;IACQ;EACJ;EACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEI;EACA;EACA;EACA;;EAEA;AACJ;AACA;AACA;;EAII;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAII+B,iBAAiBA,CAAA,EAAS;IACtB;IACA,IAAI,CAACF,UAAU,GAAG,IAAI;EAC1B;EAEAG,oBAAoBA,CAAA,EAAS;IACzB;IACA;IACA;IACA;EAAA;EAEJ;AACJ;AACA;AACA;AACA;;EAEYC,WAAWA,CAAA,EAAc;IAC7B;AACR;AACA;AACA;IACQ;IACA,IAAIhD,GAAG;IACP,IAAI,KAAK,IAAI,IAAI,CAAC9C,KAAK,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","ignoreList":[]},"metadata":{},"sourceType":"module"}