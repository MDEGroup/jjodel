{"ast":null,"code":"// export type Class = { new(...args: any[]): any; };\n\n// Json<T> = oggetto con le chiavi di T senza le funzioni (post deserializzazione)\n\n// export type Dictionary<K extends keyof any, T> = { [P in K]: T; };\n\n// _subMaps type *actually just Dict<str, boolean> but if i set it as bool and access a random element of the map it will be typed as boolean | V*/\n\nexport const NotFoundv = null;\nexport let EdgeBendingMode; // x y, rot, arc sweep, x y super messy not only coords but degrees and booleans mixed with path coords\n\n// export type Subtract<T, K> = {  [L in Exclude<keyof T, K>]: T[L] };\n// Or alternatively, and more concisely, as:\n\n// export type Subtract<T, K> = Pick<T, Exclude<keyof T, K>>;\n(function (EdgeBendingMode) {\n  EdgeBendingMode[\"Line\"] = \"L\";\n  EdgeBendingMode[\"Bezier_quadratic\"] = \"Q\";\n  EdgeBendingMode[\"Bezier_cubic\"] = \"C\";\n  EdgeBendingMode[\"Bezier_cubic_mirrored\"] = \"S\";\n  EdgeBendingMode[\"Bezier_quadratic_mirrored\"] = \"T\";\n  EdgeBendingMode[\"Elliptical_arc\"] = \"A\";\n})(EdgeBendingMode || (EdgeBendingMode = {})); // tipo puramente documentazionale, è solo una stringa o array di stringhe\n/*export type Pointer<T extends DPointerTargetable = DPointerTargetable, lowerbound = number, upperbound = number | string, RET = LPointerTargetable> =\r\n    upperbound extends 'N' ? string[] : (\r\n    upperbound extends 0 ? never : (\r\n    lowerbound extends 0 ? (string | undefined | null) : string)); // & {[Symbol.iterator]: () => IterableIterator<string>};\r\n*/\n// export type Proxyfied<T extends object> = T | GObject;// | T;\nexport const windoww = window;\n\n// for some reason typescript complains about circular type references? this is a workaround","map":{"version":3,"names":["NotFoundv","EdgeBendingMode","windoww","window"],"sources":["C:/0Programmi/Dev/projects/frontend/jjodel/src/joiner/types.ts"],"sourcesContent":["// export type Class = { new(...args: any[]): any; };\r\nimport type {NotAString, Pointer} from \"./classes\";\r\nimport type {DAttribute, DPackage} from \"../model/logicWrapper\";\r\n\r\nexport declare type Class<CtorArgs extends any[] = any[], InstanceType = {}, StaticType = {}, IsAbstract = false> = (abstract new (...args: any[]) => InstanceType) & StaticType;\r\nexport declare type CClass<CtorArgs extends any[] = any[], InstanceType = {}, StaticType = {}, IsAbstract = false> = (new (...args: any[]) => InstanceType) & StaticType;\r\ninterface Caller { caller: any; }\r\ninterface Bind { bind: any; }\r\ninterface Apply { apply: any; }\r\ninterface Call { call: any; }\r\nexport type Function =  Caller | Bind | Apply | Call;\r\nexport type Function2 =  (...a: any) => any;\r\nexport type Constructor<InstanceType = any> = (new (...a: any) => InstanceType) & {__proto__?: Constructor<InstanceType> & GObject};\r\nexport type AbstractConstructor<InstanceType = any> = (GObject | (new (...a: any) => InstanceType)) & {__proto__?: Constructor<InstanceType> & GObject};\r\nexport type Temporary = any;\r\nexport type Nullable<T> = T | null\r\nexport type UnixTimestamp = number;\r\ninterface NoCaller { caller?: never; }\r\ninterface NoBind { bind?: never; }\r\ninterface NoApply { apply?: never; }\r\ninterface NoCall { call?: never; }\r\n\r\n\r\nexport type orArr<T> = T | T[];\r\nexport type unArr<T extends any[] | any> = T extends any[] ? T[0] : T;\r\n\r\ntype primitiveType = string | number | boolean | symbol | null | undefined;\r\nexport type PrimitiveType = string | number | boolean | null;\r\ntype NotAFunction = NoCaller | NoBind | NoApply | NoCall;\r\ntype NotFunction = GObject & NotAFunction | primitiveType\r\n\r\n\r\nexport type Empty = any;\r\nexport type UObject = { [key: string]: unknown; }\r\nexport type GObject<DocSubType = ''> = DocSubType extends object ? { [key: string]: any; } & DocSubType : { [key: string]: any; };\r\nexport type RawObject = { [key: string]: NotFunction; };\r\n// Json<T> = oggetto con le chiavi di T senza le funzioni (post deserializzazione)\r\nexport type Json<T extends GObject = RawObject> =\r\n\r\n        {[key in keyof T]: T[key] extends Function ? never : (T[key] extends symbol ? \"symbol\" :\r\n            Exclude<T[key], symbol>); }\r\n        ;\r\n\r\n// export type Dictionary<K extends keyof any, T> = { [P in K]: T; };\r\nexport type Dictionary<K extends keyof GObject = any, V = any> = { [P in K]: V; } & { _subMaps?: V};\r\n// _subMaps type *actually just Dict<str, boolean> but if i set it as bool and access a random element of the map it will be typed as boolean | V*/\r\nexport type DocString<T, COMMENT = ''> = string;\r\nexport type NotFound = null;\r\nexport const NotFoundv = null as NotFound;\r\nexport type nstring = null | string;\r\nexport type nnumber = null | number;\r\nexport type nbool = null | boolean;\r\nexport type bool = boolean;\r\nexport type TODO<T = any> = any;\r\nexport type NonEmptyString = Exclude<string, ''>;\r\nexport enum EdgeBendingMode{\r\n    \"Line\"=\"L\", // end\r\n    \"Bezier_quadratic\"=\"Q\", // bending1, end\r\n    \"Bezier_cubic\"=\"C\", // bending1, bending2, end\r\n    \"Bezier_cubic_mirrored\"=\"S\", // bending1, end // when there are multiple bezier curves on a row, this takes a bendingpoint1 from the last bezier curves mirrored https://css-tricks.com/svg-path-syntax-illustrated-guide/\r\n    \"Bezier_quadratic_mirrored\"=\"T\", // end // when there are multiple bezier curves on a row, this takes a bendingpoint1 from the last bezier curves mirrored https://css-tricks.com/svg-path-syntax-illustrated-guide/\r\n    \"Elliptical_arc\" = \"A\",// x y, rot, arc sweep, x y super messy not only coords but degrees and booleans mixed with path coords\r\n}\r\n\r\n// export type Subtract<T, K> = {  [L in Exclude<keyof T, K>]: T[L] };\r\n// Or alternatively, and more concisely, as:\r\n\r\n// export type Subtract<T, K> = Pick<T, Exclude<keyof T, K>>;\r\nexport type Subtract<T, K> = Omit<T, keyof K>;\r\nexport type Overlap<T1, T2> =  Omit<T1, keyof T2> & T2;\r\n\r\n\r\n\r\n\r\n\r\n// tipo puramente documentazionale, è solo una stringa o array di stringhe\r\n/*export type Pointer<T extends DPointerTargetable = DPointerTargetable, lowerbound = number, upperbound = number | string, RET = LPointerTargetable> =\r\n    upperbound extends 'N' ? string[] : (\r\n    upperbound extends 0 ? never : (\r\n    lowerbound extends 0 ? (string | undefined | null) : string)); // & {[Symbol.iterator]: () => IterableIterator<string>};\r\n*/\r\ndeclare global  {\r\n    interface ProxyConstructor {\r\n        new <TS extends object, TT extends object = TS>(target: TS, handler: ProxyHandler<TS>): TT;\r\n        // official flawed definition: new <T extends object>(target: T, handler: ProxyHandler<T>): T;\r\n    }\r\n\r\n}\r\n\r\n\r\n// export type Proxyfied<T extends object> = T | GObject;// | T;\r\n\r\nexport type Proxyfied<T extends object> = UObject & T;\r\nexport const windoww: typeof window & GObject= window;\r\nexport type InOutParam<T> = T;\r\n\r\nexport type IsActually<T> = any; // for some reason typescript complains about circular type references? this is a workaround\r\n\r\ntype KeysnotOfType<T, TT> = { [P in keyof T as (T[P] extends TT ? never : P)]: T[P] };\r\ntype ObjectWithoutStrings<T> = {\r\n    [P in keyof T as (T[P] extends string ? never : (T[P] extends string[] ? never : P))]: T[P] // working on arr, keeps single ptrs\r\n};\r\ntype pureStringsNoPointers<T> = {\r\n    [P in keyof T as ( T[P] extends Pointer ? (Pointer extends T[P] ? P : (never)): never)]: T[P]\r\n};\r\nexport type ObjectWithoutPointers<T> = Omit<ObjectWithoutStrings<T> & pureStringsNoPointers<T>, 'pointedBy' | '_storePath'>\r\n\r\n\r\n\r\ntype refkeys = \"parent\" | \"father\" | \"parent\" | \"classifiers\" | \"childrens\" | \"classes\" | \"packages\" | \"subpackages\" | \"annotations\" | \"\"\r\n    | \"type\" | \"attributes\" | \"references\" | \"operations\" | \"parameters\" | \"..... much more\"\r\n"],"mappings":"AAAA;;AAoCA;;AAOA;;AAEA;;AAGA,OAAO,MAAMA,SAAS,GAAG,IAAgB;AAOzC,WAAYC,eAAe,EAMA;;AAG3B;AACA;;AAEA;AAAA,WAZYA,eAAe;EAAfA,eAAe;EAAfA,eAAe;EAAfA,eAAe;EAAfA,eAAe;EAAfA,eAAe;EAAfA,eAAe;AAAA,GAAfA,eAAe,KAAfA,eAAe,SAoB3B;AACA;AACA;AACA;AACA;AACA;AAUA;AAGA,OAAO,MAAMC,OAAgC,GAAEC,MAAM;;AAGpB","ignoreList":[]},"metadata":{},"sourceType":"module"}