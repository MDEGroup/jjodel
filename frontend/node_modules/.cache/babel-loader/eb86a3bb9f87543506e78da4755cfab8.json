{"ast":null,"code":"var _dec, _class, _class2;\nimport { Log, RuntimeAccessible } from \"../joiner\";\nimport { Uarr } from \"../joiner\";\nconst stringify = require('json-stable-stringify');\nexport let Uobj = (_dec = RuntimeAccessible('Uobj'), _dec(_class = (_class2 = class Uobj {\n  // difference react-style. lazy check by === equality field by field. parameters are readonly\n  static objdiff(old, neww) {\n    let includeProto = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    // let ret: GObject = {removed:{}, added:{}, changed:{}};\n    let ret = {\n      removed: {},\n      added: {},\n      changed: {},\n      unchanged: {}\n    };\n    if (!neww && !old) {\n      return ret;\n    }\n    if (!neww) {\n      ret.removed = old;\n      if (!includeProto) {\n        ret.removed = {\n          ...ret.removed,\n          __proto__: {}\n        };\n      }\n      return ret;\n    }\n    if (!old) {\n      ret.added = neww;\n      if (!includeProto) {\n        ret.added = {\n          ...ret.added,\n          __proto__: {}\n        };\n      }\n      return ret;\n    }\n    // let oldkeys: string[] = Object.keys(old); let newkeys: string[] = Object.keys(neww);\n\n    let key;\n    for (key in old) {\n      if (!includeProto && !old.hasOwnProperty(key)) continue;\n      // if (neww[key] === undefined){\n      // if neww have a key with undefined value, it counts (and should) as having that property key defined\n      if (!(key in neww)) {\n        ret.removed[key] = old[key];\n      } else if (neww[key] === old[key]) {\n        ret.unchanged[key] = old[key];\n      } else ret.changed[key] = old[key];\n    }\n    for (let key in neww) {\n      if (!includeProto && !neww.hasOwnProperty(key)) continue;\n      if (!(key in old)) {\n        ret.added[key] = neww[key];\n      }\n    }\n    if (Array.isArray(neww)) {\n      if (neww.length === old.length) {\n        ret.unchanged.length = neww.length;\n      } else {\n        let newb = 'length' in neww;\n        let oldb = 'length' in old;\n        if (newb && !oldb) ret.added.length = neww.length;else if (!newb && oldb) ret.removed.length = neww.length;else ret.changed.length = neww.length;\n      }\n    }\n    return ret;\n  }\n\n  // returns <\"what changed from old to neww\"> and in nested objects recursively\n  // todo: how can i tell at what point it's the fina lvalue (might be a nestedobj) and up to when it's a delta to follow and unroll?   using __isAdelta:true ?\n  // NB: this returns the delta that generates the future. if you want the delta that generate the past one, invert parameter order.\n  static objectDelta(old, neww) {\n    let deep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let includeProto = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let newwobj = neww;\n    let oldobj = old;\n    if (old === neww) return {};\n    if (!neww) {\n      if (includeProto) return nold;\n      return {\n        ...old\n      }; // destructure because i need to remove prototype\n    }\n    let diff = Uobj.objdiff(old, neww, includeProto); // todo: optimize this, remove the 3 loops below and add those directly in Uobj.objdiff(old, neww, ret); writing inside the obj in third parameter\n    console.log('objdiff', {\n      diff,\n      old,\n      neww\n    });\n    let isArr = false;\n    let to = typeof old;\n    let tn = typeof old;\n    if (to !== 'object' /* && tn === 'object'*/) {\n      if (includeProto) return neww;\n      return {\n        ...neww\n      };\n    }\n    if (tn === 'object' && Array.isArray(neww)) {\n      isArr = true;\n    }\n    let ret = {}; // {__isAdelta:true};\n    for (let key in diff.added) {\n      //if (!includeProto && diff.added.hasOwnProperty(key)) continue;\n      ret[key] = newwobj[key];\n    }\n    for (let key in diff.changed) {\n      let subold = oldobj[key];\n      let subnew = newwobj[key];\n      if (typeof subold === typeof subnew && typeof subold === \"object\") {\n        if (deep) {\n          ret[key] = Uobj.objectDelta(subold, subnew, true, includeProto);\n        } else {\n          ret[key] = subnew;\n          /*if (typeof neww === 'object' && Array.isArray(subnew)) {\r\n              ret[key].length = subnew.length;\r\n              ret[key].__jjObjDiffIsArr = true;\r\n          }*/\n        }\n      } else ret[key] = subnew;\n    }\n    // todo: add to variable naming rules: can't start with \"_-\", like in \"_-keyname\", it means \"keyname\" removed in undo delta\n    let removedprefix = \"\"; // \"_-\";\n    for (let key in diff.removed) {\n      ///if (!includeProto && !diff.removed.hasOwnProperty(key)) continue;\n      if (ret[removedprefix + key] === undefined) {\n        console.log('undef empty probl<em', {\n          r: diff.removed,\n          val: ret[removedprefix + key],\n          pkey: removedprefix + key,\n          key,\n          ret,\n          old,\n          neww\n        });\n      }\n      if (key in neww) ret[removedprefix + key] = undefined;else ret[removedprefix + key] = '__jjObjDiffEmptyElem';\n    } //newwobj[key]; }\n    // console.log(\"objdiff\", {old, neww, diff, ret});\n    if (isArr) {\n      ret.length = neww.length;\n      ret.__jjObjDiffIsArr = true;\n    }\n    return ret;\n  }\n  static applyObjectDelta(statelevel, deltalevel) {\n    let inplace = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let asserteq = arguments.length > 3 ? arguments[3] : undefined;\n    if (!statelevel) statelevel = {};\n    // todo: if delta = ObjectDelta('str', {0:'s', 1:'t', 2:'X'}); applydelta('str', delta); what happes?\n    if (typeof statelevel !== 'object') statelevel = {}; // return statelevel;\n    if (typeof deltalevel !== 'object') return deltalevel;\n    let oldState = {\n      ...statelevel\n    }; // just for debug\n    let targetIsArr = deltalevel.__jjObjDiffIsArr || Array.isArray(deltalevel);\n    if (!inplace) statelevel = Array.isArray(statelevel) ? Uarr.arrayShallowCopy(statelevel) : {\n      ...statelevel\n    }; // NB: [ ...{obj} ] is invalid, but {...[]} is valid, careful\n    else if (targetIsArr && !Array.isArray(statelevel)) statelevel = Uarr.arrayShallowCopy(statelevel); // forced to ignore inplace requirement due to change of type (obj -> arr)\n\n    // statelevel = {...statelevel}; not working if i do it here, just a new var. first time copy id done in caller func undo(). recursive copies are done before recursive step\n    let includeProto = false;\n    for (let key in deltalevel) {\n      let delta = deltalevel[key];\n      if (!includeProto && !deltalevel.hasOwnProperty(key)) {\n        continue;\n      }\n      // console.log(\"undoing\", {delta, key, deltalevel, statelevel})\n      if (key.indexOf(\"_-\") === 0) {\n        delete statelevel[key.substring(2)];\n        continue;\n      } // ????????????????????????????????????? todo: check\n      if (key === '__jjObjDiffIsArr') continue; // the key is the string, the val is true\n      if (deltalevel[key] === '__jjObjDiffEmptyElem') {\n        // the key is the index,the  val is the string\n        delete statelevel[key];\n        continue;\n      }\n      if (typeof delta === \"object\") {\n        // if (Uobj.isObject(delta, false, false, true)) {\n        // if (!inplace) statelevel[key] = Array.isArray(delta) ? Uarr.arrayShallowCopy(statelevel[key]) : {...statelevel[key]};\n        // console.log('handling ', {key});\n        statelevel[key] = Uobj.applyObjectDelta(statelevel[key], delta, inplace, asserteq === null || asserteq === void 0 ? void 0 : asserteq[key]);\n      } else {\n        statelevel[key] = delta;\n      }\n    }\n    let old = statelevel;\n    if (targetIsArr) {\n      statelevel = [];\n      for (let k in old) {\n        if (!old.hasOwnProperty(k)) continue;\n        statelevel[k] = old[k]; // it takes array custom keys\n      }\n\n      //delete statelevel.__jjObjDiffIsArr;\n      statelevel.length = old.length;\n    }\n    if (asserteq) {\n      let as = stringify(asserteq);\n      let rs = stringify(statelevel);\n      Log.eDev(as !== rs, 'deltas: error in Uobj.diff, UObj.delta or UObj.patch, assertion failed', {\n        oldState,\n        deltalevel,\n        ret: statelevel,\n        asserteq,\n        rs,\n        as,\n        old,\n        targetIsArr\n      });\n      if (as === rs) console.log('deltas: error in Uobj.diff, UObj.delta or UObj.patch, assertion failed', {\n        oldState,\n        deltalevel,\n        ret: statelevel,\n        asserteq,\n        rs,\n        as,\n        old,\n        targetIsArr\n      });\n    }\n    return statelevel;\n  }\n}, _class2.cname = 'Uobj', _class2)) || _class);\nUobj.cname = 'Uobj';","map":{"version":3,"names":["Log","RuntimeAccessible","Uarr","stringify","require","Uobj","_dec","_class","_class2","objdiff","old","neww","includeProto","arguments","length","undefined","ret","removed","added","changed","unchanged","__proto__","key","hasOwnProperty","Array","isArray","newb","oldb","objectDelta","deep","newwobj","oldobj","nold","diff","console","log","isArr","to","tn","subold","subnew","removedprefix","r","val","pkey","__jjObjDiffIsArr","applyObjectDelta","statelevel","deltalevel","inplace","asserteq","oldState","targetIsArr","arrayShallowCopy","delta","indexOf","substring","k","as","rs","eDev","cname"],"sources":["C:/0Programmi/Dev/projects/frontend/jjodel/frontend/src/common/UObj.ts"],"sourcesContent":["import {GObject, Log, PointedBy, RuntimeAccessible} from \"../joiner\";\r\nimport {U, Uarr} from \"../joiner\";\r\nconst stringify = require('json-stable-stringify');\r\n\r\n@RuntimeAccessible('Uobj')\r\nexport class Uobj {\r\n    static cname: string = 'Uobj';\r\n\r\n    // difference react-style. lazy check by === equality field by field. parameters are readonly\r\n    public static objdiff<T extends GObject>(old:T, neww: T, includeProto: boolean = true): {removed: Partial<T>, added: Partial<T>, changed: Partial<T>, unchanged: Partial<T>} {\r\n        // let ret: GObject = {removed:{}, added:{}, changed:{}};\r\n        let ret: {removed: Partial<T>, added: Partial<T>, changed: Partial<T>, unchanged: Partial<T>}  = {removed:{}, added:{}, changed:{}, unchanged: {}};\r\n        if (!neww && !old) { return ret; }\r\n        if (!neww) {\r\n            ret.removed = old;\r\n            if (!includeProto){\r\n                ret.removed = {...ret.removed, __proto__:{}};\r\n            }\r\n            return ret;\r\n        }\r\n        if (!old) {\r\n            ret.added = neww;\r\n            if (!includeProto) {\r\n                ret.added = {...ret.added, __proto__:{}};\r\n            }\r\n            return ret;\r\n        }\r\n        // let oldkeys: string[] = Object.keys(old); let newkeys: string[] = Object.keys(neww);\r\n\r\n        let key: any;\r\n        for (key in old) {\r\n            if (!includeProto && !old.hasOwnProperty(key)) continue;\r\n            // if (neww[key] === undefined){\r\n            // if neww have a key with undefined value, it counts (and should) as having that property key defined\r\n            if (!(key in neww)){ (ret.removed as GObject)[key] = old[key]; }\r\n            else if (neww[key] === old[key]) { (ret.unchanged as GObject)[key] = old[key] }\r\n            else (ret.changed as GObject)[key] = old[key];\r\n        }\r\n        for (let key in neww) {\r\n            if (!includeProto && !neww.hasOwnProperty(key)) continue;\r\n            if (!(key in old)){ (ret.added as GObject)[key] = neww[key]; }\r\n        }\r\n        if (Array.isArray(neww)) {\r\n            if (neww.length === old.length) { (ret.unchanged as GObject).length = neww.length; }\r\n            else {\r\n                let newb = 'length' in neww;\r\n                let oldb = 'length' in old;\r\n                if (newb && !oldb) (ret.added as GObject).length = neww.length;\r\n                else if (!newb && oldb) (ret.removed as GObject).length = neww.length;\r\n                else (ret.changed as GObject).length = neww.length;\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    // returns <\"what changed from old to neww\"> and in nested objects recursively\r\n    // todo: how can i tell at what point it's the fina lvalue (might be a nestedobj) and up to when it's a delta to follow and unroll?   using __isAdelta:true ?\r\n    // NB: this returns the delta that generates the future. if you want the delta that generate the past one, invert parameter order.\r\n    public static objectDelta<T extends object>(old: T, neww: T, deep: boolean = true, includeProto: boolean = false): Partial<T>{\r\n        let newwobj: GObject = neww;\r\n        let oldobj: GObject = old;\r\n        if (old === neww) return {};\r\n        if (!neww) {\r\n            if (includeProto) return nold;\r\n            return {...old}; // destructure because i need to remove prototype\r\n        }\r\n        let diff = Uobj.objdiff(old, neww, includeProto); // todo: optimize this, remove the 3 loops below and add those directly in Uobj.objdiff(old, neww, ret); writing inside the obj in third parameter\r\n        console.log('objdiff', {diff, old, neww})\r\n        let isArr = false;\r\n        let to = typeof old;\r\n        let tn = typeof old;\r\n        if (to !== 'object'/* && tn === 'object'*/) {\r\n            if (includeProto) return neww;\r\n            return {...neww} as any;\r\n        }\r\n        if (tn === 'object' && Array.isArray(neww)) { isArr = true; }\r\n        let ret: GObject = {}; // {__isAdelta:true};\r\n        for (let key in diff.added) {\r\n            //if (!includeProto && diff.added.hasOwnProperty(key)) continue;\r\n            ret[key] = newwobj[key];\r\n        }\r\n        for (let key in diff.changed) {\r\n            let subold = oldobj[key];\r\n            let subnew = newwobj[key];\r\n            if (typeof subold === typeof subnew && typeof subold === \"object\") {\r\n                if (deep) {\r\n                    ret[key] = Uobj.objectDelta(subold, subnew, true, includeProto)\r\n                }\r\n                else {\r\n                    ret[key] = subnew;\r\n                    /*if (typeof neww === 'object' && Array.isArray(subnew)) {\r\n                        ret[key].length = subnew.length;\r\n                        ret[key].__jjObjDiffIsArr = true;\r\n                    }*/\r\n                }\r\n            }\r\n            else ret[key] = subnew;\r\n        }\r\n        // todo: add to variable naming rules: can't start with \"_-\", like in \"_-keyname\", it means \"keyname\" removed in undo delta\r\n        let removedprefix = \"\"; // \"_-\";\r\n        for (let key in diff.removed) {\r\n            ///if (!includeProto && !diff.removed.hasOwnProperty(key)) continue;\r\n            if (ret[removedprefix + key] === undefined) {\r\n                console.log('undef empty probl<em', {r:diff.removed, val:ret[removedprefix + key], pkey:removedprefix + key, key, ret, old, neww})\r\n            }\r\n            if (key in neww) ret[removedprefix + key] = undefined;\r\n            else ret[removedprefix + key] = '__jjObjDiffEmptyElem';\r\n        } //newwobj[key]; }\r\n        // console.log(\"objdiff\", {old, neww, diff, ret});\r\n        if (isArr) {\r\n            ret.length = (neww as GObject).length;\r\n            ret.__jjObjDiffIsArr = true;\r\n        }\r\n        return ret as Partial<T>;\r\n    }\r\n\r\n\r\n    public static applyObjectDelta(statelevel: GObject, deltalevel: GObject, inplace: boolean = false, asserteq?: GObject): GObject {\r\n        if (!statelevel) statelevel = {};\r\n        // todo: if delta = ObjectDelta('str', {0:'s', 1:'t', 2:'X'}); applydelta('str', delta); what happes?\r\n        if (typeof statelevel !== 'object') statelevel = {}; // return statelevel;\r\n        if (typeof deltalevel !== 'object') return deltalevel as any;\r\n        let oldState = {...statelevel}; // just for debug\r\n        let targetIsArr = deltalevel.__jjObjDiffIsArr || Array.isArray(deltalevel);\r\n        if (!inplace) statelevel = Array.isArray(statelevel) ? Uarr.arrayShallowCopy(statelevel) : {...statelevel}; // NB: [ ...{obj} ] is invalid, but {...[]} is valid, careful\r\n        else if (targetIsArr && !Array.isArray(statelevel)) statelevel = Uarr.arrayShallowCopy(statelevel); // forced to ignore inplace requirement due to change of type (obj -> arr)\r\n\r\n        // statelevel = {...statelevel}; not working if i do it here, just a new var. first time copy id done in caller func undo(). recursive copies are done before recursive step\r\n        let includeProto = false;\r\n        for (let key in deltalevel) {\r\n            let delta = deltalevel[key];\r\n            if (!includeProto && !deltalevel.hasOwnProperty(key)) { continue; }\r\n            // console.log(\"undoing\", {delta, key, deltalevel, statelevel})\r\n            if (key.indexOf(\"_-\") === 0) { delete statelevel[key.substring(2)]; continue; } // ????????????????????????????????????? todo: check\r\n            if (key === '__jjObjDiffIsArr') continue; // the key is the string, the val is true\r\n            if (deltalevel[key] === '__jjObjDiffEmptyElem') { // the key is the index,the  val is the string\r\n                delete statelevel[key];\r\n                continue;\r\n            }\r\n            if (typeof delta === \"object\") {\r\n                // if (Uobj.isObject(delta, false, false, true)) {\r\n                // if (!inplace) statelevel[key] = Array.isArray(delta) ? Uarr.arrayShallowCopy(statelevel[key]) : {...statelevel[key]};\r\n                // console.log('handling ', {key});\r\n                statelevel[key] = Uobj.applyObjectDelta(statelevel[key], delta, inplace, asserteq?.[key]); }\r\n            else { statelevel[key] = delta; }\r\n        }\r\n        let old = statelevel;\r\n\r\n        if (targetIsArr) {\r\n            statelevel = [];\r\n            for (let k in old) {\r\n                if (!old.hasOwnProperty(k)) continue;\r\n                statelevel[k] = old[k]; // it takes array custom keys\r\n            }\r\n\r\n            //delete statelevel.__jjObjDiffIsArr;\r\n            statelevel.length = old.length;\r\n        }\r\n\r\n        if (asserteq) {\r\n            let as = stringify(asserteq);\r\n            let rs = stringify(statelevel);\r\n            Log.eDev(as !== rs, 'deltas: error in Uobj.diff, UObj.delta or UObj.patch, assertion failed',\r\n                {oldState, deltalevel, ret:statelevel, asserteq, rs, as, old, targetIsArr});\r\n            if (as === rs) console.log('deltas: error in Uobj.diff, UObj.delta or UObj.patch, assertion failed',\r\n                {oldState, deltalevel, ret:statelevel, asserteq, rs, as, old, targetIsArr});\r\n        }\r\n        return statelevel;\r\n    }\r\n}\r\n\r\nUobj.cname = 'Uobj';"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}