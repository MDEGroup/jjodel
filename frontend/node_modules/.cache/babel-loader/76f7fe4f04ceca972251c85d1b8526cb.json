{"ast":null,"code":"import _get from\"C:/d/Programming/web/jodel-mde/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";import _getPrototypeOf from\"C:/d/Programming/web/jodel-mde/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";import _objectSpread from\"C:/d/Programming/web/jodel-mde/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _createForOfIteratorHelper from\"C:/d/Programming/web/jodel-mde/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import _toConsumableArray from\"C:/d/Programming/web/jodel-mde/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _classCallCheck from\"C:/d/Programming/web/jodel-mde/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"C:/d/Programming/web/jodel-mde/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";import _inherits from\"C:/d/Programming/web/jodel-mde/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";import _createSuper from\"C:/d/Programming/web/jodel-mde/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";var _dec,_class,_class2,_dec2,_class3,_class4,_dec3,_class5,_class6,_dec4,_class7,_class8,_dec5,_class9,_class10,_dec6,_class11,_class12,_dec7,_class13,_class14,_dec8,_class15,_class16,_dec9,_class17,_class18,_dec10,_class19,_class20,_dec11,_class21,_class22,_dec12,_class23,_class24,_dec13,_class25,_class26,_dec14,_class27,_dec15,_class29,_class30,_dec16,_class31,_class32,_dec17,_class33,_class34,_dec18,_class35,_class36,_dec19,_class37,_class38,_dec20,_class39,_class40,_dec21,_class41,_class42;// import {Mixin} from \"ts-mixer\";\nimport{isDeepStrictEqual}from\"util\";import{BEGIN,Constructors,CoordinateMode,Debug,DModelElement,DPointerTargetable,DUser,EdgeBendingMode,END,GraphElementComponent,GraphPoint,GraphSize,Leaf,Log,LPointerTargetable,MixOnlyFuncs,Node,Point,Pointers,RuntimeAccessible,RuntimeAccessibleClass,SetFieldAction,ShortAttribETypes,Size,store,TargetableProxyHandler,transientProperties,U,Uarr,windoww}from\"../../joiner\";import{EdgeGapMode}from\"../../joiner/types\";import{Geom}from\"../../common/Geom\";import{jsx as _jsx}from\"react/jsx-runtime\";import{jsxs as _jsxs}from\"react/jsx-runtime\";console.warn('ts loading graphDataElement');export var DGraphElement=(_dec=RuntimeAccessible('DGraphElement'),Node(_class=_dec(_class=(_class2=/*#__PURE__*/function(_DPointerTargetable){_inherits(DGraphElement,_DPointerTargetable);var _super=_createSuper(DGraphElement);function DGraphElement(){var _this;_classCallCheck(this,DGraphElement);for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}_this=_super.call.apply(_super,[this].concat(args));_this.id=void 0;_this.graph=void 0;_this.model=void 0;_this.isSelected=void 0;_this.subElements=void 0;_this.state=void 0;_this.father=void 0;_this.x=void 0;_this.y=void 0;_this.zIndex=100;_this.w=void 0;_this.h=void 0;_this.view=void 0;_this.favoriteNode=void 0;_this.edgesIn=void 0;_this.edgesOut=void 0;_this.anchors=void 0;return _this;}// static _super = DPointerTargetable;\n// static singleton: LGraphElement;\n// static logic: typeof LGraphElement;\n// static structure: typeof DGraphElement;\n// containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\n// DMap\n// width: number = 300;\n// height: number = 400;\n_createClass(DGraphElement,null,[{key:\"new\",value:function _new(htmlindex,model,parentNodeID,graphID,nodeID,a,b){return new Constructors(new DGraphElement('dwc'),parentNodeID,true,undefined,nodeID).DPointerTargetable().DGraphElement(model,graphID,htmlindex).end();}}]);return DGraphElement;}(DPointerTargetable),_class2.subclasses=[],_class2._extends=[],_class2))||_class)||_class);export var LGraphElement=(_dec2=RuntimeAccessible('LGraphElement'),_dec2(_class3=(_class4=/*#__PURE__*/function(_LPointerTargetable){_inherits(LGraphElement,_LPointerTargetable);var _super2=_createSuper(LGraphElement);function LGraphElement(){var _this2;_classCallCheck(this,LGraphElement);for(var _len2=arguments.length,args=new Array(_len2),_key2=0;_key2<_len2;_key2++){args[_key2]=arguments[_key2];}_this2=_super2.call.apply(_super2,[this].concat(args));_this2.__raw=void 0;_this2.id=void 0;_this2.father=void 0;_this2.graph=void 0;_this2.model=void 0;_this2.subElements=void 0;_this2._state=void 0;_this2.allSubNodes=void 0;_this2.x=void 0;_this2.y=void 0;_this2.width=void 0;_this2.height=void 0;_this2.z=void 0;_this2.zIndex=void 0;_this2.__info_of_z__={type:ShortAttribETypes.EInt,txt:\"alias for zIndex\"};_this2.__info_of_zIndex__={type:ShortAttribETypes.EInt,txt:\"Determine the z-axis priority of the element.<br/>Higher value tende to overlap other elements.<br/>Lower value tends to be on background.\"};_this2.zoom=void 0;_this2.html=void 0;_this2.w=void 0;_this2.h=void 0;_this2.size=void 0;_this2.position=void 0;_this2.htmlSize=void 0;_this2.htmlPosition=void 0;_this2.view=void 0;_this2.component=void 0;_this2.favoriteNode=void 0;_this2.vertex=void 0;_this2.__info__of__vertex={type:\"LVoidVertex\",txt:\"the foremost vertex containing this graphElement, or undefiened.\"};_this2.__info__of__favoriteNode={type:ShortAttribETypes.EBoolean,txt:\"<span>Indicates this is the primarly used (by default) node to refer to a modelling element that might have multiple representations.\"+\"<br> Can be used as favorite target for edges or other.\"};_this2.startPoint=void 0;_this2.endPoint=void 0;_this2.__info_of__startPoint={type:\"GraphPoint\",txt:/*#__PURE__*/_jsxs(\"span\",{children:[\"Where the outgoing edges should start their paths.\",/*#__PURE__*/_jsx(\"br\",{}),\"Obtained by combining anchoring point offset specified in view, before snapping to a Vertex border.\",/*#__PURE__*/_jsx(\"br\",{}),\"Defaults in outer coordinates.\"]})};_this2.__info_of__endPoint={type:\"GraphPoint\",txt:/*#__PURE__*/_jsxs(\"span\",{children:[\"Where the incoming edges should end their paths.\",/*#__PURE__*/_jsx(\"br\",{}),\"Obtained by combining anchoring point offset specified in view, before snapping to a Vertex border.\",/*#__PURE__*/_jsx(\"br\",{}),\"Defaults in outer coordinates.\"]})};_this2.__info_of__graph={type:\"\",txt:\"\"};_this2.innerGraph=void 0;_this2.__info_of__innnerGraph={type:\"\",txt:\"\"};_this2.outerGraph=void 0;_this2.__info_of__outerGraphGraph={type:\"\",txt:\"\"};_this2.__info_of__graphAncestors={type:\"LGraph[]\",txt:\"<span>collection of the stack of Graphs containing the current element where [0] is the most nested graph, and last is root graph.</span>\"};_this2.graphAncestors=void 0;_this2.anchors=void 0;_this2.__info_of__anchors={type:\"Dictionary<string, point>\",txt:/*#__PURE__*/_jsxs(\"div\",{children:[\"A named list of all anchor points where edges are allowed to land or depart from.\",/*#__PURE__*/_jsx(\"br\",{}),\"When writing it must be done in percentages, with the same rules as node.state.\"]})};_this2.edgesIn=void 0;_this2.edgesOut=void 0;_this2.__info_of__edgesIn={type:\"LEdge[]\",txt:/*#__PURE__*/_jsxs(\"div\",{children:[\"Edges incoming into this element. \",/*#__PURE__*/_jsx(\"code\",{children:\"this.edgesOut[i].end\"}),\" always equals to \",/*#__PURE__*/_jsx(\"code\",{children:\"this\"}),\".\"]})};_this2.__info_of__edgesOut={type:\"LEdge[]\",txt:/*#__PURE__*/_jsxs(\"div\",{children:[\"Edges outgoing from this element. \",/*#__PURE__*/_jsx(\"code\",{children:\"this.edgesIn[i].start\"}),\" always equals to \",/*#__PURE__*/_jsx(\"code\",{children:\"this\"}),\".\"]})};_this2.__info_of__edgesStart={type:\"LEdge[]\",txt:/*#__PURE__*/_jsx(\"div\",{children:\"Alias for this.edgesOut\"})};_this2.__info_of__edgesEnd={type:\"LEdge[]\",txt:/*#__PURE__*/_jsx(\"div\",{children:\"Alias for this.edgesIn\"})};_this2.outerSize=void 0;_this2.__info_of__outerSize={type:\"GraphSize\",txt:\"the size of the current element relative to the first (root) graph level.\"};_this2.innerSize=void 0;_this2.__info_of__innerSize={type:\"GraphSize\",txt:\"the size of the current element relative to the last (most nested) graph level.\"};_this2.__info_of__size={type:\"GraphSize\",txt:\"same as innerSize.\"};_this2.assignEdgeAnchor=void 0;_this2.__info_of__assignEdgeAnchor=void 0;_this2.__info_of__isselected={type:\"Dictionary<Pointer<User>, true>\",txt:/*#__PURE__*/_jsxs(\"div\",{children:[\"A map that contains all the users selecting this element as keys, and always true as a value (if present).\",/*#__PURE__*/_jsx(\"br\",{}),\"Edit it through node.select() and node.deselect()\"]})};_this2.__info_of__select={type:\"function(forUser?:Pointer<User>):void\",txt:\"Marks this node as selected by argument user.\"};_this2.__info_of__deselect={type:\"function(forUser?:Pointer<User>):void\",txt:\"Un-marks this node as selected by argument user.\"};_this2.__info_of__toggleSelect={type:\"function(usr?:Pointer<User>):void\",txt:\"Calls this.select(usr) if the node is selected by argument user, this.deselect(usr) otherwise. If omitted, argument \\\"usr\\\" is the current user id.<br>Returns the result of this.isSelected() after the toggle.\"};_this2.__info_of__isSelected={type:\"function(forUser?:Pointer<User>):void\",txt:\"Tells if this node is selected by argument user.\"};return _this2;}_createClass(LGraphElement,[{key:\"get_graph\",value:function get_graph(context){return this.get_innerGraph(context);}},{key:\"get_anchors\",value:function get_anchors(c){return c.data.anchors;}},{key:\"set_anchors\",value:function set_anchors(v,c){if(v!==undefined&&(typeof v!==\"object\"||Array.isArray(v))){Log.ee('cannot set anchors: invalid value provided');return true;}if(v){// if !v it means clear all anchors?\nfor(var ka in v){//for each anchor\nif(!v[ka])continue;if(c.data.anchors[ka]){for(var kk in v[ka]){//for each key within an anchor (x, y, w, h)\n// if i was attempting to set a partial size, complete it with the old size values.\nif(v[ka][kk]===undefined&&c.data.anchors[ka][kk]!==undefined)v[ka][kk]=c.data.anchors[ka][kk];}}if(v[ka].x===undefined||isNaN(v[ka].x))v[ka].x=0.5;if(v[ka].y===undefined||isNaN(v[ka].y))v[ka].y=0.5;// if (v[ka].w === undefined || isNaN(v[ka].w)) v[ka].w = 5;\n// if (v[ka].h === undefined || isNaN(v[ka].h)) v[ka].h = 5;\n}}SetFieldAction.new(c.data,\"anchors\",v,'+=',false);return true;}},{key:\"get_edgesIn\",value:function get_edgesIn(context){return LPointerTargetable.fromArr(context.data.edgesIn);}},{key:\"get_edgesOut\",value:function get_edgesOut(context){return LPointerTargetable.fromArr(context.data.edgesOut);}},{key:\"set_edgesIn\",value:function set_edgesIn(val,c){return SetFieldAction.new(c.data.id,\"edgesIn\",Pointers.fromArr(val),'',true);}},{key:\"set_edgesOut\",value:function set_edgesOut(val,c){return SetFieldAction.new(c.data.id,\"edgesOut\",Pointers.fromArr(val),'',true);}},{key:\"get_edgesStart\",value:function get_edgesStart(context){return this.get_edgesIn(context);}},{key:\"get_edgesEnd\",value:function get_edgesEnd(context){return this.get_edgesOut(context);}},{key:\"set_edgesStart\",value:function set_edgesStart(val,context){return this.set_edgesIn(val,context);}},{key:\"set_edgesEnd\",value:function set_edgesEnd(val,context){return this.set_edgesOut(val,context);}},{key:\"_defaultGetter\",value:function _defaultGetter(c,k){if(k in c.data)return this.__defaultGetter(c,k);// if value not found in node, check in view.\nreturn this.get_view(c)[k];/*let ret: any;\r\n        let view = this.get_view(c);\r\n        try { ret = (view as any)[k] } catch (e) { Log.ee(\"Could not find get_ property \\\"\" + k + \"\\\" in node or view.\", {c, view, k}); return undefined; }\r\n        return ret;*/}},{key:\"_defaultSetter\",value:function _defaultSetter(v,c,k){this.__defaultSetter(v,c,k);return true;}},{key:\"get_graphAncestors\",value:function get_graphAncestors(c){var current=c.proxyObject;var next=current.father;var ret=[];while(next){if(RuntimeAccessibleClass.extends(next.className,DGraph.cname))ret.push(next);if(current.id===next.id)break;current=next;next=next.father;}return ret;}},{key:\"get_outerGraph\",value:function get_outerGraph(context){// todo: this relies on the fact that GraphVertex are not passing their own id to their childrens, but the parent graph id\nreturn TargetableProxyHandler.wrap(context.data.graph);}},{key:\"get_vertex\",value:function get_vertex(context){var lcurrent=LPointerTargetable.fromPointer(context.data.id);var dcurrent=lcurrent.__raw;// iterate parents.\nwhile(dcurrent){switch(dcurrent.className){case DVertex.cname:case DVoidVertex.cname:case DGraphVertex.cname:return lcurrent||LPointerTargetable.fromD(dcurrent);default:if(!dcurrent.father||dcurrent.id===dcurrent.father)return undefined;Log.exDev(!dcurrent.father||dcurrent.id===dcurrent.father,\"node failed to get containing vertex\",context.data,dcurrent,lcurrent);lcurrent=LPointerTargetable.fromPointer(dcurrent.father);dcurrent=lcurrent.__raw;}}return undefined;}},{key:\"get_innerGraph\",value:function get_innerGraph(context){var _lcurrent;var lcurrent=LPointerTargetable.fromPointer(context.data.father);var dcurrent=(_lcurrent=lcurrent)===null||_lcurrent===void 0?void 0:_lcurrent.__raw;// if no parent, but it's a graph, return itself.\nif(!dcurrent){dcurrent=context.data;switch(dcurrent.className){case DGraph.cname:case DGraphVertex.cname:return lcurrent||LPointerTargetable.fromD(dcurrent);default:return Log.exDevv(\"node failed to get containing graph\",context.data,dcurrent,lcurrent);}}// if it have a parent, iterate parents.\nwhile(true){var _dcurrent;switch((_dcurrent=dcurrent)===null||_dcurrent===void 0?void 0:_dcurrent.className){case DGraph.cname:case DGraphVertex.cname:return lcurrent||LPointerTargetable.fromD(dcurrent);default:if(!dcurrent.father||dcurrent.id===dcurrent.father){/*switch(dcurrent.className){\r\n                            case DGraph.name:\r\n                            case DGraphVertex.name: return (lcurrent || LPointerTargetable.fromD(dcurrent)) as LGraph;\r\n                            default: */return Log.exDevv(\"node failed to get containing graph\",context.data,dcurrent,lcurrent);//}\n}lcurrent=LPointerTargetable.fromPointer(dcurrent.father);dcurrent=lcurrent.__raw;}}}// set_x(val: this[\"x\"], context: Context): boolean { SetFieldAction.new(context.data.id, \"x\", val, undefined, false); return true; }\n// get_x(context: Context): this[\"x\"] { return context.data.x; }\n},{key:\"get_x\",value:function get_x(context){return this.get_size(context).x;}},{key:\"set_x\",value:function set_x(val,context){return this.set_size({x:val},context);}},{key:\"get_y\",value:function get_y(context){return this.get_size(context).y;}},{key:\"set_y\",value:function set_y(val,context){return this.set_size({y:val},context);}},{key:\"get_w\",value:function get_w(context){return this.get_size(context).w;}},{key:\"set_w\",value:function set_w(val,context){return this.set_size({w:val},context);}},{key:\"get_h\",value:function get_h(context){return this.get_size(context).h;}},{key:\"set_h\",value:function set_h(val,context){return this.set_size({h:val},context);}},{key:\"get_width\",value:function get_width(context){return this.get_w(context);}},{key:\"set_width\",value:function set_width(val,context){return this.set_w(val,context);}},{key:\"get_height\",value:function get_height(context){return this.get_h(context);}},{key:\"set_height\",value:function set_height(val,context){return this.set_h(val,context);}},{key:\"get_position\",value:function get_position(context){return new GraphPoint(context.data.x,context.data.y);}},{key:\"set_position\",value:function set_position(val,context){BEGIN();SetFieldAction.new(context.data.id,\"x\",val.x,undefined,false);SetFieldAction.new(context.data.id,\"y\",val.y,undefined,false);END();return true;}},{key:\"get_sizeold\",value:function get_sizeold(context){return new GraphSize(context.data.x,context.data.y,context.data.w,context.data.h);}},{key:\"get_component\",value:function get_component(context){// switch(context.data.className) { case DEdgePoint.name: return GraphElementComponent.map[context.data.father]; }\nreturn GraphElementComponent.map[context.data.id];}// get_view(context: Context): this[\"view\"] { return this.get_component(context).props.view; }\n},{key:\"get_view\",value:function get_view(context){var _transientProperties$,_this$get_component;return((_transientProperties$=transientProperties.node[context.data.id])===null||_transientProperties$===void 0?void 0:_transientProperties$.mainView)||LPointerTargetable.from(context.data.view)||((_this$get_component=this.get_component(context))===null||_this$get_component===void 0?void 0:_this$get_component.props.view);}},{key:\"set_view\",value:function set_view(val,context){Log.eDevv(\"node.view is readonly, change it through props or the model\");// let ptr: DGraphElement[\"view\"] = Pointers.from(val as this[\"view\"]);\n// return SetFieldAction.new(context.data.id, \"view\", ptr, '', true);\n}},{key:\"getSize\",value:function getSize(){var outer=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;var canTriggerSet=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;return this.wrongAccessMessage(\"getSize()\");}},{key:\"get_getSize\",value:function get_getSize(c){var _this3=this;return function(){var outer=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;var canTriggerSet=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;return _this3.get_innerSize(c,canTriggerSet,outer);};}},{key:\"get_outerSize\",value:function get_outerSize(context){var canTriggerSet=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;return this.get_innerSize(context,canTriggerSet,true);}},{key:\"get_size\",value:function get_size(context){var canTriggerSet=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;return this.get_innerSize(context,canTriggerSet,false);}},{key:\"get_innerSize\",value:function get_innerSize(context){var canTriggerSet=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;var outerSize=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;var r=this.get_innerSize_impl(context,canTriggerSet,outerSize);return new GraphSize(r.x,r.y,r.w,r.h);}},{key:\"get_innerSize_impl\",value:function get_innerSize_impl(context){var _this$get_component2;var canTriggerSet=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;var outerSize=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;canTriggerSet=canTriggerSet&&!Debug.lightMode;console.log(\"ex4 getsize 0 \"+context.data.className,{context:context,canTriggerSet:canTriggerSet,outerSize:outerSize});switch(context.data.className){default:return Log.exDevv(\"unexpected classname in get_size switch: \"+context.data.className);case DEdge.cname:case DVoidEdge.cname:case DGraph.cname:return nosize;// case DField.cname:\ncase DGraphElement.cname:var graph=outerSize?this.get_outerGraph(context):this.get_innerGraph(context);console.log(\"ex4 getsize 1 \"+context.data.className,{graph:graph,html:this.get_htmlSize(context),context:context,canTriggerSet:canTriggerSet,outerSize:outerSize});return graph.coord(this.get_htmlSize(context));case DVoidVertex.cname:case DVertex.cname:case DEdgePoint.cname:case DGraphVertex.cname:break;}// low prio todo: memoization in proxy, as long state does not change keep a collection Dictionary[object][key] = returnval. it gets emptied when state is updated.\n// when loading a save, edge segements and edgepoints/nodes are computed before creating the edgepoint component\nvar view=this.get_view(context);// (window as any).retry = ()=>view.getSize(context.data.id);\nvar ret=view.getSize(context.data.id);// (this.props.dataid || this.props.nodeid as string)\nconsole.log(\"ex4 getsize 10 \"+context.data.className,{context:context,viewVertexSize:ret});// console.log(\"getSize() from view\", {ret: ret ? {...ret} : ret});\nif(!ret){ret=new GraphSize();ret.x=context.data.x;ret.y=context.data.y;ret.w=context.data.w;ret.h=context.data.h;var def;if(undefined===ret.x){if(!def)def=view.defaultVSize;ret.x=def.x||0;}if(undefined===ret.y){if(!def)def=view.defaultVSize;ret.y=def.y||0;}if(undefined===ret.w){if(!def)def=view.defaultVSize;ret.w=def.w||10;}if(undefined===ret.h){if(!def)def=view.defaultVSize;ret.h=def.h|10;}ret.currentCoordType=context.data.currentCoordType;// console.log(\"getSize() from node merged with defaultVSize\", {ret: ret ? {...ret} : ret});\n}console.log(\"ex4 getsize 11 pre decode\"+context.data.className,{context:context,ret:ret});if(context.data.className===DEdgePoint.cname){ret=this.decodePosCoords(context,ret,view);console.log(\"ex4 getsize 12 decoded\"+context.data.className,{context:context,view:view,ret:ret});}/*\r\n                if ((context.data as DVoidVertex).isResized) {\r\n                    return ret;\r\n                }*/if(!canTriggerSet){if(outerSize)ret=this.get_outerGraph(context).translateSize(ret,this.get_innerGraph(context));console.log(\"ex4 getsize 13 \"+context.data.className,{context:context,view:view,ret:ret});return ret;}var html=(_this$get_component2=this.get_component(context))===null||_this$get_component2===void 0?void 0:_this$get_component2.html;var actualSize=(html===null||html===void 0?void 0:html.current)?Size.of(html.current):{w:0,h:0};var updateSize=false;var isOldElement=context.data.clonedCounter>3;// if w = 0 i don't auto-set it as in first render it has w:0 because is not reredered and not resized.\n// if (canTriggerSet) this.set_size({w:actualSize.w}, context);\nif(view.adaptWidth&&ret.w!==actualSize.w){if(canTriggerSet&&(isOldElement||actualSize.w!==0)){ret.w=actualSize.w;updateSize=true;}}if(view.adaptHeight&&ret.h!==actualSize.h){if(canTriggerSet&&(isOldElement||actualSize.h!==0)){ret.h=actualSize.h;updateSize=true;}}// console.log(\"getSize() from node merged with actualSize\", {ret: {...ret}});\nif(updateSize)this.set_size(ret,context);if(outerSize)ret=this.get_outerGraph(context).translateSize(ret,this.get_innerGraph(context));console.log(\"ex4 getsize 14 \"+context.data.className,{context:context,view:view,ret:ret});return ret;}// set_size(size: Partial<this[\"size\"]>, context: Context): boolean {\n},{key:\"set_size\",value:function set_size(size0,c){// console.log(\"setSize(\"+(this.props?.data as any).name+\") thisss\", this);\nif(!size0)return false;var size=size0;var view=this.get_view(c);console.log(\"ex4 setsize \"+c.data.className,{size:size});var testmode=false;if(c.data.className===DEdgePoint.cname&&size.currentCoordType!==CoordinateMode.absolute)size=this.encodePosCoords(c,size,view);console.log(\"ex4 setsize encoded \"+c.data.className,{size:size});if(view.updateSize(c.data.id,size))return true;BEGIN();if(size.x!==c.data.x&&size.x!==undefined)SetFieldAction.new(c.data.id,\"x\",size.x,undefined,false);if(size.y!==c.data.y&&size.y!==undefined)SetFieldAction.new(c.data.id,\"y\",size.y,undefined,false);if(size.w!==c.data.w&&size.w!==undefined)SetFieldAction.new(c.data.id,\"w\",size.w,undefined,false);if(size.h!==c.data.h&&size.h!==undefined)SetFieldAction.new(c.data.id,\"h\",size.h,undefined,false);var epdata=c.data;if(size.currentCoordType!==epdata.currentCoordType&&size.currentCoordType!==undefined)SetFieldAction.new(epdata.id,\"currentCoordType\",size.currentCoordType,undefined,false);END();return true;}},{key:\"get_html\",value:function get_html(c){var component=this.get_component(c);var html=component.html.current;if(html)return html;html=$('[nodeid=\"'+c.data.id+'\"]')[0];if(!html)return undefined;component.html.current=html;return html;}// get_html(context: Context): this[\"html\"] { return $(\"[node-id='\" + context.data.id + \"']\")[0]; }\n},{key:\"set_html\",value:function set_html(val,context){return this.cannotSet(\"set_html(). html is generated through jsx. edit the view instead.\");}},{key:\"get_htmlSize\",value:function get_htmlSize(context){var html=this.get_html(context);return html?Size.of(html):new Size(0,0,0,0);/*\r\n        let graph = this.get_graph(context);\r\n        if (!html) return nosize as any;\r\n        let size = Size.of(html);\r\n        let zoom = graph.zoom;\r\n        size.x /= zoom.x;\r\n        size.y /= zoom.y;\r\n        return size;*/}},{key:\"set_htmlSize\",value:function set_htmlSize(val,context){// might be useful for fixed display size/location elements that stay in place even if you move tab or change zoom. debatable if needed\nthis.cannotSet(\"set_htmlSize(): todo extra low priority. set GraphSize through set_size instead.\");return true;}},{key:\"get_htmlPosition\",value:function get_htmlPosition(context){return this.get_htmlSize(context).tl();}},{key:\"set_htmlPosition\",value:function set_htmlPosition(val,context){// might be useful for fixed display size/location elements that stay in place even if you move tab or change zoom. debatable if needed\nthis.cannotSet(\"set_htmlPosition(): todo extra low priority. set graph position through set_position instead.\");return true;}/* how z-index work, it's really messy.\r\n    * cannot move html position. node id depends on it, and a node moving position would need to change id.\r\n    * so i use css order.\r\n    * first order is assigned through node constructor called by parent component injectProps, according to his last index in html.\r\n    * now z-index is set in node and updated properly.\r\n    * z-index is passed to a prop, rendered as html attribute.\r\n    * css takes the attribute value and uses it in \"order\" css rule.\r\n    * problem: updating node.z doesn't trigger the parent injectprops, so he inject html index and\r\n    * the outernmost html root cannot update his attribute without refreshing the parent and recalling injectprops\r\n    * fixed: by updating it directly in GraphElement.render()\r\n    * */},{key:\"get_zIndex\",value:function get_zIndex(context){return context.data.zIndex;}},{key:\"set_zIndex\",value:function set_zIndex(val,context){SetFieldAction.new(context.data.id,\"zIndex\",val,undefined,false);return true;}},{key:\"get_z\",value:function get_z(context){return context.data.zIndex;}},{key:\"set_z\",value:function set_z(val,context){return this.set_zIndex(val,context);}/*\r\n        get_containedIn(context: Context): this[\"containedIn\"] {\r\n            return context.data.containedIn ? LPointerTargetable.fromPointer(context.data.containedIn) : undefined; }\r\n        set_containedIn(val: Pack1<this[\"containedIn\"]>, context: LogicContext<DGraphElement>): boolean {\r\n            let ptr: DGraphElement[\"containedIn\"] = Pointers.from(val) as any;\r\n            SetFieldAction.new(context.data, 'containedIn', ptr, undefined, true);\r\n            if (ptr) SetFieldAction.new(ptr as any, 'subElements+=', context.data.id);\r\n            return true; }*/},{key:\"get_subElements\",value:function get_subElements(context){return LPointerTargetable.fromArr(_toConsumableArray(new Set(context.data.subElements)));}},{key:\"set_subElements\",value:function set_subElements(val,context){console.log(\"isDeepStrictEqual\",{isDeepStrictEqual:isDeepStrictEqual});Log.eDev(_toConsumableArray(new Set(val)).length!==val.length,\"subelemnts setter have duplicates\",{val:val,context:context});// if (isDeepStrictEqual(context.data.subElements, val)) return true;\nvar pointers=Pointers.from(val)||[];if(Uarr.equals(pointers,context.data.subElements,false))return true;SetFieldAction.new(context.data,'subElements',pointers,'',true);var idlookup=store.getState().idlookup;var arrdiff=U.arrayDifference(context.data.subElements,pointers);// old subelements\nvar _iterator=_createForOfIteratorHelper(arrdiff.removed),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var oldsubelementid=_step.value;var subelement=oldsubelementid&&idlookup[oldsubelementid];if(subelement.father!==context.data.id)continue;LPointerTargetable.from(subelement).father=null;// todo: can this happen? è transitorio o causa vertici senza parent permanenti?\n}// new subelements\n}catch(err){_iterator.e(err);}finally{_iterator.f();}var _iterator2=_createForOfIteratorHelper(arrdiff.added),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var newsubelementid=_step2.value;var _subelement=newsubelementid&&idlookup[newsubelementid];if(_subelement.father===context.data.id)continue;LPointerTargetable.from(_subelement).father=context.data.id;// trigger side-action\n}}catch(err){_iterator2.e(err);}finally{_iterator2.f();}return true;}},{key:\"get_isResized\",value:function get_isResized(context){return context.data.isResized;}},{key:\"set_isResized\",value:function set_isResized(val,context){return SetFieldAction.new(context.data.id,\"isResized\",val);}},{key:\"get_model\",value:function get_model(context){var modelElementId=context.data.model;//$('[id=\"' + context.data.id + '\"]')[0].dataset.dataid;\nvar lModelElement=LPointerTargetable.from(modelElementId);return lModelElement;}},{key:\"get_allSubNodes\",value:function get_allSubNodes(context,state){// return context.data.packages.map(p => LPointerTargetable.from(p));\nstate=state||store.getState();var tocheck=context.data.subElements||[];var checked={};var dblcheck={};// <child, parent>  // debug only\nvar _iterator3=_createForOfIteratorHelper(tocheck),_step3;try{for(_iterator3.s();!(_step3=_iterator3.n()).done;){var _e=_step3.value;dblcheck[_e]=context.data.id;}// debug only\n}catch(err){_iterator3.e(err);}finally{_iterator3.f();}checked[context.data.id]=true;//nb6[]{}&\nwhile(tocheck.length){var newtocheck=[];var _iterator4=_createForOfIteratorHelper(tocheck),_step4;try{for(_iterator4.s();!(_step4=_iterator4.n()).done;){var ptr=_step4.value;Log.eDev(checked[ptr],\"loop in GraphElements containing themselves\",{dblcheck:dblcheck,context:context,ptr:ptr,checked:checked,fistContainer:dblcheck[ptr]});if(checked[ptr])continue;checked[ptr]=true;var subnode=DPointerTargetable.from(ptr,state);var se=subnode===null||subnode===void 0?void 0:subnode.subElements;var _iterator5=_createForOfIteratorHelper(se),_step5;try{for(_iterator5.s();!(_step5=_iterator5.n()).done;){var e=_step5.value;dblcheck[e]=ptr;}// debug only\n}catch(err){_iterator5.e(err);}finally{_iterator5.f();}U.arrayMergeInPlace(newtocheck,se);}}catch(err){_iterator4.e(err);}finally{_iterator4.f();}tocheck=newtocheck;}delete checked[context.data.id];return LPointerTargetable.from(Object.keys(checked),state);}},{key:\"get_assignEdgeAnchor\",value:function get_assignEdgeAnchor(c){return function(anchorName){if(anchorName&&!c.data.anchors[anchorName])anchorName=undefined;if(LVoidEdge.startFollow){var de=DPointerTargetable.fromPointer(LVoidEdge.startFollow);if(de.start!==c.data.id)return;// cannot change edge targets, only an anchor within the current targets\nvar le=LPointerTargetable.fromD(de);le.anchorStart=anchorName;le.startFollow=false;}if(LVoidEdge.endFollow){var _de=DPointerTargetable.fromPointer(LVoidEdge.endFollow);if(_de.end!==c.data.id)return;// cannot change edge targets, only an anchor within the current targets\nvar _le=LPointerTargetable.fromD(_de);_le.anchorEnd=anchorName;_le.endFollow=false;}};}},{key:\"get_events\",value:function get_events(c){var tn=transientProperties.node[c.data.id];var mainview=tn.mainView.__raw;var otherViews=tn.stackViews.map(function(v){return v.__raw;});var allviews=[mainview].concat(_toConsumableArray(otherViews)).reverse();var keep_for_closure_original_funcs={};var ret={};var _iterator6=_createForOfIteratorHelper(allviews),_step6;try{for(_iterator6.s();!(_step6=_iterator6.n()).done;){var dv=_step6.value;U.objectMergeInPlace(keep_for_closure_original_funcs,transientProperties.view[dv.id].events);}}catch(err){_iterator6.e(err);}finally{_iterator6.f();}var lastContext=tn.viewScores[mainview.id].evalContext;var keys=Object.keys(keep_for_closure_original_funcs);// for (let k of keys) ret['_raw_'+k] = keep_for_closure_original_funcs[k];\nvar _loop=function _loop(){var k=_keys[_i];if(!keep_for_closure_original_funcs[k])return\"continue\";ret[k]=function(){for(var _len3=arguments.length,_params=new Array(_len3),_key3=0;_key3<_len3;_key3++){_params[_key3]=arguments[_key3];}return keep_for_closure_original_funcs[k].apply(keep_for_closure_original_funcs,[lastContext].concat(_params));};};for(var _i=0,_keys=keys;_i<_keys.length;_i++){var _ret=_loop();if(_ret===\"continue\")continue;}return ret;}},{key:\"get_father\",value:function get_father(context){return LPointerTargetable.fromPointer(context.data.father);}},{key:\"set_father\",value:function set_father(val,context){var ptr=Pointers.from(val);SetFieldAction.new(context.data,'father',ptr,undefined,true);if(ptr)SetFieldAction.new(ptr,'subElements+=',context.data.id);return true;}},{key:\"select\",value:function select(forUser){return this.wrongAccessMessage(\"node.select()\");}},{key:\"deselect\",value:function deselect(forUser){return this.wrongAccessMessage(\"node.deselect()\");}},{key:\"toggleSelected\",value:function toggleSelected(forUser){return this.wrongAccessMessage(\"node.toggleSelected()\");}},{key:\"isSelected\",value:function isSelected(forUser){return this.wrongAccessMessage(\"node.isSelected()\");}},{key:\"get_select\",value:function get_select(c){return function(forUser){if(!forUser)forUser=DUser.current;if(c.data.isSelected[forUser])return;// no-op\nvar map=_objectSpread({},c.data.isSelected);map[forUser]=true;SetFieldAction.new(c.data.id,\"isSelected\",map,undefined,false);// todo: actually they are pointer to users, but i'm assuming users are not erased at runtime. on deselect too\n};}},{key:\"get_deselect\",value:function get_deselect(c){return function(forUser){if(!forUser)forUser=DUser.current;if(!c.data.isSelected[forUser])return;// no-op\nvar map=_objectSpread({},c.data.isSelected);delete map[forUser];SetFieldAction.new(c.data.id,\"isSelected\",map,undefined,false);// todo: actually they are pointer to users, but i'm assuming users are not erased at runtime. on deselect too\n};}},{key:\"get_toggleSelected\",value:function get_toggleSelected(context){var _this4=this;return function(forUser){if(!forUser)forUser=DUser.current;if(_this4.get_isSelected(context)(forUser)){_this4.get_deselect(context)(forUser);return false;}else{_this4.get_select(context)(forUser);return true;}};}},{key:\"get_isSelected\",value:function get_isSelected(context){return function(forUser){if(!forUser)forUser=DUser.current;return!!context.data.isSelected[forUser];};}},{key:\"set_isSelected\",value:function set_isSelected(val,context){return this.cannotSet(\"graphElement.isSelected(): use this.select() or this.deselect() instead.\");}/*\r\n    get_isSelected(context: LogicContext<DVoidVertex>): GObject {\r\n        return DPointerTargetable.mapWrap(context.data.isSelected, context.data, 'idlookup.' + context.data.id + '.isSelected', []);\r\n    }*/ // for edges\n},{key:\"get_startPoint\",value:function get_startPoint(c,size,view){return this.get_startEndPoint(c,size,view,true);}},{key:\"get_endPoint\",value:function get_endPoint(c,size,view){return this.get_startEndPoint(c,size,view,false);}},{key:\"get_startEndPoint\",value:function get_startEndPoint(c,size,view){var isStart=arguments.length>3&&arguments[3]!==undefined?arguments[3]:true;if(!size){if(c)size=this.get_size(c);else size=Log.exDevv(\"invalid arguments in get_startEndPoint\",{arguments:arguments});}if(!view){// if (c) view = this.get_view(c); else view = Log.exDevv(\"invalid arguments in get_startPoint\", {arguments});\nview=c&&this.get_view(c)||Log.exDevv(\"invalid arguments in get_startEndPoint\",{arguments:arguments});}var offset=view[isStart?\"edgeStartOffset\":\"edgeEndOffset\"];var isPercentage=view[isStart?\"edgeStartOffset_isPercentage\":\"edgeEndOffset_isPercentage\"];if(!size)size=new GraphSize(0,0,0,0);if(isPercentage)offset=new GraphPoint(offset.x/100*size.w,offset.y/100*size.h);return size.tl().add(offset,false);}}],[{key:\"getNodeId\",value:function getNodeId(o){var _node;if(!o)return undefined;var node=o;// from L to D\n// let cname = (node.__raw || node).className;\n// from DModelE to LGraphE\nif(RuntimeAccessibleClass.extends(o.className,\"DModelElement\"))node=LPointerTargetable.from(o).node;return typeof node===\"string\"?node:(_node=node)===null||_node===void 0?void 0:_node.id;}// static singleton: LGraphElement;\n// static logic: typeof LGraphElement;\n// static structure: typeof DGraphElement;\n// todo: can be removed and accessed by navigating .father\n// protected isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>; //  & ((forUser?: Pointer<DUser>) => boolean);\n// containedIn?: LGraphElement;\n// shallow, direct subelements\n// LMap;\n// deep, nested subelements\n// fittizi\n// size and position in global document coordinates.\n}]);return LGraphElement;}(LPointerTargetable),_class4.subclasses=[],_class4._extends=[],_class4))||_class3);RuntimeAccessibleClass.set_extend(DPointerTargetable,DGraphElement);RuntimeAccessibleClass.set_extend(LPointerTargetable,LGraphElement);export var DGraph=(_dec3=RuntimeAccessible('DGraph'),_dec3(_class5=(_class6=/*#__PURE__*/function(_DGraphElement){_inherits(DGraph,_DGraphElement);var _super3=_createSuper(DGraph);function DGraph(){var _this5;_classCallCheck(this,DGraph);for(var _len4=arguments.length,args=new Array(_len4),_key4=0;_key4<_len4;_key4++){args[_key4]=arguments[_key4];}_this5=_super3.call.apply(_super3,[this].concat(args));_this5.father=void 0;_this5.id=void 0;_this5.graph=void 0;_this5.model=void 0;_this5.isSelected=void 0;_this5.subElements=void 0;_this5.state=void 0;_this5.zoom=void 0;_this5.offset=void 0;return _this5;}// static _super = DGraphElement;\n// static singleton: LGraph;\n// static logic: typeof LGraph;\n// static structure: typeof DGraph;\n// inherit redefine\n// containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\n// personal attributes\n_createClass(DGraph,null,[{key:\"new\",value:// in-graph scrolling offset\nfunction _new(htmlindex,model,parentNodeID,// immediate parent\nparentgraphID,// graph containing this subgraph (redudant? could get it from father chain)\nnodeID){return new Constructors(new DGraph('dwc'),parentNodeID,true,undefined,nodeID||Constructors.DGraph_makeID(model)).DPointerTargetable().DGraphElement(model,parentgraphID,htmlindex).DGraph().end();}},{key:\"getNodes\",value:function getNodes(dmp,out){var $allnodes=$('[data-dataid]');var matchedids=(dmp||[]).map(function(d){return d.id;});var matchedidmap=U.objectFromArrayValues(matchedids);if(!out)out={};var allnodesarr=_toConsumableArray($allnodes);var filternode=function filternode(d){var _d$dataset,_d$dataset2;if(!(d===null||d===void 0?void 0:(_d$dataset=d.dataset)===null||_d$dataset===void 0?void 0:_d$dataset.dataid))return false;var id=''+(d===null||d===void 0?void 0:(_d$dataset2=d.dataset)===null||_d$dataset2===void 0?void 0:_d$dataset2.dataid);return matchedidmap[id];};out.$matched=$(allnodesarr.filter(filternode));out.$notMatched=$(allnodesarr.filter(function(n){return!filternode(n);}));return out.$matched;// throw new Error(\"Method not implemented.\");\n}}]);return DGraph;}(DGraphElement),_class6.subclasses=[],_class6._extends=[],_class6))||_class5);var nosize={x:0,y:0,w:0,h:0,nosize:true};var defaultEdgePointSize=undefined;// = {x:0, y:0, w:5, h:5};\nvar defaultVertexSize=undefined;// {x:0, y:0, w:140.6818084716797, h:32.52840805053711};\nexport var LGraph=(_dec4=RuntimeAccessible('LGraph'),_dec4(_class7=(_class8=/*#__PURE__*/function(_LGraphElement){_inherits(LGraph,_LGraphElement);var _super4=_createSuper(LGraph);function LGraph(){var _this6;_classCallCheck(this,LGraph);for(var _len5=arguments.length,args=new Array(_len5),_key5=0;_key5<_len5;_key5++){args[_key5]=arguments[_key5];}_this6=_super4.call.apply(_super4,[this].concat(args));_this6.__raw=void 0;_this6.id=void 0;_this6.graph=void 0;_this6.model=void 0;_this6.subElements=void 0;_this6._state=void 0;_this6.zoom=void 0;_this6.graphSize=void 0;_this6.offset=void 0;_this6.__info_of__zoom={type:GraphPoint.cname,label:\"zoom\",txt:\"Scales the graph and all subelements by a factor.\"};_this6.__info_of__offset={type:GraphPoint.cname,label:\"offset\",txt:\"In-graph scrolling position.\"};_this6.__info_of__graphSize={type:GraphSize.cname,label:\"graphSize\",txt:\"size internal to the graph, including internal scroll and panning.\"};_this6.__info_of__translateSize={type:\"(T, Graph)=>T where T is GraphSize | GraphPoint\",txt:\"Translates a coordinate set from the local coordinates of a SubGraph to this Graph containing it.\"};_this6.__info_of__translateHtmlSize={type:\"(Size|Point) => GraphSize|GraphPoint\",txt:\"Translate page\\'s viewport coordinate set to this graph coordinate set.\"};return _this6;}// static singleton: LGraph;\n// static logic: typeof LGraph;\n// static structure: typeof DGraph;\n// inherit redefine\n_createClass(LGraph,[{key:\"isSelected\",value:// isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\nfunction isSelected(forUser){return this.wrongAccessMessage(\"node.isSelected()\");}// containedIn?: LGraphElement;\n// LMap;\n// personal attributes\n// derived attribute: bounding rect containing all subnodes, while \"size\" is instead external size of the vertex holding the graph in GraphVertexes\n},{key:\"get_offset\",value:// Scrolling position inside the graph\n// get_graphSize(context: LogicContext<DGraph>):  Readonly<GraphSize> { return todo: get bounding rect containing all subnodes.; }\nfunction get_offset(context){return new GraphSize(context.data.offset.x,context.data.offset.y);}},{key:\"set_offset\",value:function set_offset(val,context){if(!val)val={x:0,y:0};if(context.data.offset.x===val.x&&context.data.offset.y===val.y)return true;if(val.x===undefined&&context.data.offset.x!==val.x)val.x=context.data.offset.x;if(val.y===undefined&&context.data.offset.y!==val.y)val.y=context.data.offset.y;SetFieldAction.new(context.data,\"offset\",val);return true;}},{key:\"get_zoom\",value:function get_zoom(context){var zoom=context.data.zoom;// (zoom as any).debug = {rawgraph: context.data.__raw, zoomx: context.data.zoom.x, zoomy: context.data.zoom.y}\nreturn context.data.zoom;}},{key:\"toGraphSize\",value:function toGraphSize(){return this.wrongAccessMessage(\"toGraphSize\");}},{key:\"coord\",value:function coord(htmlSize){return this.wrongAccessMessage(\"toGraphSize\");}},{key:\"get_coord\",value:function get_coord(context){var _this7=this;return function(htmlSize){var size=_this7.get_htmlSize(context);var zoom=_this7.get_zoom(context);return new GraphSize((htmlSize.x-size.x)/zoom.x,(htmlSize.y-size.y)/zoom.y,htmlSize.w/zoom.x,htmlSize.h/zoom.y);};}// get_htmlSize(context: Context): Size { }\n},{key:\"translateSize\",value:function translateSize(ret,innerGraph){return this.wrongAccessMessage(\"translateSize()\");}},{key:\"translateHtmlSize\",value:function translateHtmlSize(size){return this.wrongAccessMessage(\"translateHtmlSize()\");}},{key:\"set_zoom\",value:function set_zoom(val,c){SetFieldAction.new(c.data,'zoom',val,'+=',false);return true;}},{key:\"get_translateHtmlSize\",value:function get_translateHtmlSize(c){var _this8=this;return function(size){var graphHtmlSize=_this8.get_htmlSize(c);var a=size.subtract(graphHtmlSize.tl(),true);var b=a.add({x:c.data.offset.x,y:c.data.offset.y},false);return b.multiply(c.data.zoom,false);};}},{key:\"get_translateSize\",value:function get_translateSize(c){return function(size,innerGraph){innerGraph=LPointerTargetable.wrap(innerGraph);var ret=size.hasOwnProperty(\"w\")?new GraphSize(size.x,size.y,size.w,size.h):new GraphPoint(size.x,size.y);Log.ex(!innerGraph,\"translateSize() graph parameter is invalid: \"+innerGraph,innerGraph,c);var ancestors=[innerGraph].concat(_toConsumableArray(innerGraph.graphAncestors));Log.ex(ancestors.indexOf(c.proxyObject)!==-1,\"translateSize() graph parameter is invalid: it must be a graph containing the current one.\",innerGraph,c);var _iterator7=_createForOfIteratorHelper(ancestors),_step7;try{for(_iterator7.s();!(_step7=_iterator7.n()).done;){var g=_step7.value;ret.add(g.size.tl(),false);}// console.log(\"translateSize\", {c, thiss:c.proxyObject, ancestors, ancestorSizes: ancestors.map(a=> a.size.tl()), size, ret});\n}catch(err){_iterator7.e(err);}finally{_iterator7.f();}return ret;};}},{key:\"contains\",value:function contains(elem){return this.wrongAccessMessage(\"contains()\");}},{key:\"get_contains\",value:function get_contains(c){return function(elem){var current=elem;var next=elem.father;var targetid=c.proxyObject.id;if(current.id!==targetid)return true;while(next&&current.id!==next.id){current=next;next=next.father;if(current.id!==targetid)return true;}return false;};}}]);return LGraph;}(LGraphElement),_class8.subclasses=[],_class8._extends=[],_class8))||_class7);RuntimeAccessibleClass.set_extend(DGraphElement,DGraph);RuntimeAccessibleClass.set_extend(LGraphElement,LGraph);// export const defaultVSize: GraphSize = new GraphSize(0, 0, 300, 160); // useless, now it's in view.DefaultVSize\n// export const defaultEPSize: GraphSize = new GraphSize(0, 0, 15, 15); // useless, now it's in view.DefaultVSize\nexport var DVoidVertex=(_dec5=RuntimeAccessible('DVoidVertex'),_dec5(_class9=(_class10=/*#__PURE__*/function(_DGraphElement2){_inherits(DVoidVertex,_DGraphElement2);var _super5=_createSuper(DVoidVertex);function DVoidVertex(){var _this9;_classCallCheck(this,DVoidVertex);for(var _len6=arguments.length,args=new Array(_len6),_key6=0;_key6<_len6;_key6++){args[_key6]=arguments[_key6];}_this9=_super5.call.apply(_super5,[this].concat(args));_this9.id=void 0;_this9.graph=void 0;_this9.model=void 0;_this9.isSelected=void 0;_this9.subElements=void 0;_this9.state=void 0;_this9.zoom=void 0;_this9.x=void 0;_this9.y=void 0;_this9.w=void 0;_this9.h=void 0;_this9.isResized=void 0;return _this9;}// static _super = DGraphElement;\n// static singleton: LVoidVertex;\n// static logic: typeof LVoidVertex;\n// static structure: typeof DVoidVertex;\n// inherit redefine\n// containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\n// personal attributes\n_createClass(DVoidVertex,null,[{key:\"new\",value:// size?: GraphSize; // virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\nfunction _new(htmlindex,model,parentNodeID,graphID,nodeID,size){return new Constructors(new DVoidVertex('dwc'),parentNodeID,true,undefined,nodeID).DPointerTargetable().DGraphElement(model,graphID,htmlindex).DVoidVertex(size||defaultVertexSize).end();}}]);return DVoidVertex;}(DGraphElement),_class10.subclasses=[],_class10._extends=[],_class10))||_class9);export var LVoidVertex=(_dec6=RuntimeAccessible('LVoidVertex'),_dec6(_class11=(_class12=/*#__PURE__*/function(_LGraphElement2){_inherits(LVoidVertex,_LGraphElement2);var _super6=_createSuper(LVoidVertex);function LVoidVertex(){var _this10;_classCallCheck(this,LVoidVertex);for(var _len7=arguments.length,args=new Array(_len7),_key7=0;_key7<_len7;_key7++){args[_key7]=arguments[_key7];}_this10=_super6.call.apply(_super6,[this].concat(args));_this10.__raw=void 0;_this10.id=void 0;_this10.graph=void 0;_this10.model=void 0;_this10.subElements=void 0;_this10._state=void 0;_this10.zoom=void 0;_this10.isResized=void 0;_this10.x=void 0;_this10.y=void 0;_this10.w=void 0;_this10.h=void 0;_this10.size=void 0;_this10.__info_of__size={type:\"?GraphSize\",txt:\"Size of the vertex, if null it means is utilizing the defaultSize from view. recommended to read component.getSize() instead of this.\"};return _this10;}// <D extends DVoidVertex = any>\n// static singleton: LVoidVertex;\n// static logic: typeof LVoidVertex;\n// static structure: typeof DVoidVertex;\n// inherit redefine\n_createClass(LVoidVertex,[{key:\"isSelected\",value:// isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\nfunction isSelected(forUser){return this.wrongAccessMessage(\"node.isSelected()\");}// containedIn?: LGraphElement;\n// LMap;\n// personal attributes\n// virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\n},{key:\"get_isResized\",value:function get_isResized(context){return context.data.isResized;}},{key:\"set_isResized\",value:function set_isResized(val,context){return SetFieldAction.new(context.data.id,\"isResized\",val);}}]);return LVoidVertex;}(LGraphElement),_class12.subclasses=[],_class12._extends=[],_class12))||_class11);RuntimeAccessibleClass.set_extend(DGraphElement,DVoidVertex);RuntimeAccessibleClass.set_extend(LGraphElement,LVoidVertex);export var DEdgePoint=(_dec7=RuntimeAccessible('DEdgePoint'),_dec7(_class13=(_class14=/*#__PURE__*/function(_DVoidVertex){_inherits(DEdgePoint,_DVoidVertex);var _super7=_createSuper(DEdgePoint);function DEdgePoint(){var _this11;_classCallCheck(this,DEdgePoint);for(var _len8=arguments.length,args=new Array(_len8),_key8=0;_key8<_len8;_key8++){args[_key8]=arguments[_key8];}_this11=_super7.call.apply(_super7,[this].concat(args));_this11.id=void 0;_this11.father=void 0;_this11.graph=void 0;_this11.model=void 0;_this11.isSelected=void 0;_this11.subElements=void 0;_this11.zoom=void 0;_this11.x=void 0;_this11.y=void 0;_this11.w=void 0;_this11.h=void 0;_this11.size=void 0;_this11.__isDEdgePoint=void 0;_this11.currentCoordType=void 0;return _this11;}// DVoidVertex\n// static singleton: LEdgePoint;\n// static logic: typeof LEdgePoint;\n// static structure: typeof DEdgePoint;\n// inherit redefine\n// todo: if null gets model from this.father (edge)?\n// containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\n//／／ virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\n// personal attributes\n_createClass(DEdgePoint,null,[{key:\"new\",value:function _new(htmlindex,model,parentNodeID,graphID,nodeID,size){return new Constructors(new DEdgePoint('dwc'),parentNodeID,true,undefined,nodeID).DGraphElement(undefined,graphID,htmlindex).DVoidVertex(size||defaultEdgePointSize).DEdgePoint().end();}}]);return DEdgePoint;}(DVoidVertex),_class14.subclasses=[],_class14._extends=[],_class14))||_class13);export var LEdgePoint=(_dec8=RuntimeAccessible('LEdgePoint'),_dec8(_class15=(_class16=/*#__PURE__*/function(_LVoidVertex){_inherits(LEdgePoint,_LVoidVertex);var _super8=_createSuper(LEdgePoint);function LEdgePoint(){var _this12;_classCallCheck(this,LEdgePoint);for(var _len9=arguments.length,args=new Array(_len9),_key9=0;_key9<_len9;_key9++){args[_key9]=arguments[_key9];}_this12=_super8.call.apply(_super8,[this].concat(args));_this12.father=void 0;_this12.id=void 0;_this12.graph=void 0;_this12.model=void 0;_this12.subElements=void 0;_this12.zoom=void 0;_this12.x=void 0;_this12.y=void 0;_this12.w=void 0;_this12.h=void 0;_this12.size=void 0;_this12.__isLEdgePoint=void 0;_this12.edge=void 0;_this12.__info_of__edge={type:\"?LEdge\",txt:\"returns the containing edge if called on an EdgePoint, \\\"this\\\" if called on an edge, undefined otherwise.\"};return _this12;}// static singleton: LEdgePoint;\n// static logic: typeof LEdgePoint;\n// static structure: typeof DEdgePoint;\n// inherit redefine\n// __raw!: DEdgePoint;\n_createClass(LEdgePoint,[{key:\"isSelected\",value:// isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\nfunction isSelected(forUser){return this.wrongAccessMessage(\"node.isSelected()\");}// containedIn?: LGraphElement;\n// virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\n// personal attributes\n// returns container edge\n},{key:\"get_edge\",value:function get_edge(c){return c.proxyObject.father;}},{key:\"set_edge\",value:function set_edge(v,c){return this.set_father(v,c);}},{key:\"decodePosCoords\",value:// from x,y as coords, to x%,y% as % of ((1-val)%*startpt) + ((val)%*endpt)\nfunction decodePosCoords(c,size,view,sp0,ep0){var le=c&&c.proxyObject.father;// console.log(\"decodepos:\", {le, sp0, lesp:le?.startPoint});\nvar sp=sp0||le.startPoint;var ep=ep0||le.endPoint;return LEdgePoint.decodeCoords(size,sp,ep);}},{key:\"encodePosCoords\",value:function encodePosCoords(c,size0,view,sp0,ep0,mode){if(!view)view=this.get_view(c);var size=size0;var edgePointCoordMode=mode||(view.__raw||view).edgePointCoordMode;var le=c&&c.proxyObject.father;var sp=sp0||le.startPoint;var ep=ep0||le.endPoint;return LEdgePoint.encodeCoords(size,edgePointCoordMode,sp,ep);}/* 13/10/2023 Giordano comment (defined in LPointerTargetable\r\n    public get_delete(context: Context): () => void {\r\n        // careful: pointedBy might be broken due to comment x984 (search it)\r\n        return super.get_delete(context);\r\n    }\r\n    */}],[{key:\"decodeCoords\",value:function decodeCoords(size0,sp,ep)/*absolute*/{var size=size0;var ret=\"w\"in size||\"h\"in size?new GraphSize():new GraphPoint();// GObject<Partial<GraphSize>>;\nswitch(size.currentCoordType){default:return Log.exDevv(\"translatePosCoords() invalid coordinate mode\",{mode:size.currentCoordType});// case CoordinateMode.absolute: return size;\ncase CoordinateMode.absolute:case undefined:case null:if(size.x!==undefined)ret.x=size.x;if(size.y!==undefined)ret.y=size.y;break;case CoordinateMode.relativePercent://maybe do: dampening factor on relative % offset? is it possible?\n// let s = this.getBasicSize(c);\n// MATH:\n// size.x = sp.x*x% + ep.x*(1-x%)\n// size.x = sp.x*x% + ep.x - ep.x*x%\n// size.x - ep.x= (sp.x - ep.x)*x%\n// (size.x - ep.x) / (sp.x - ep.x) = x% // actually i inverted <sp, ep> in first equation, so reverse them in result too.\nif(size.x!==undefined)ret.x=(1-size.x)*sp.x+size.x*ep.x;if(size.y!==undefined)ret.y=(1-size.y)*sp.y+size.y*ep.y;break;case CoordinateMode.relativeOffset:case CoordinateMode.relativeOffsetStart:case CoordinateMode.relativeOffsetEnd:var useStart;var useEnd;switch(size.currentCoordType){default:case CoordinateMode.relativeOffset:useStart=true;useEnd=true;break;case CoordinateMode.relativeOffsetStart:useStart=true;useEnd=false;break;case CoordinateMode.relativeOffsetEnd:useStart=false;useEnd=true;break;}// offset = sp - size\n// size = offset - sp\n// in reverse: actualsize = offset, size=offset\n// if coords are already in absolute mode.\nvar xIsAbsolute=size.x&&!Array.isArray(size.x)?size.x:undefined;var yIsAbsolute=size.x&&!Array.isArray(size.x)?size.x:undefined;Log.w(xIsAbsolute||yIsAbsolute,\"decoding relative offset require an array size coordinate system. x=[x1, x2] --> x\",{size:size});var offsetsp=useStart?new GraphPoint(xIsAbsolute||size.x[0]+sp.x,yIsAbsolute||size.y[0]+sp.y):new GraphPoint();var offsetep=useEnd?new GraphPoint(xIsAbsolute||size.x[1]+ep.x,yIsAbsolute||size.y[1]+ep.y):new GraphPoint();// if the start and endpoint of the edge didn't move, offsetsp = offsetep.\n// if they moved, those 2 are discordant --> i pick middle\noffsetsp.add(offsetep,false);if(useStart&&useEnd)offsetsp.divide(2,false);if(!xIsAbsolute&&size.x!==undefined)ret.x=offsetsp.x;if(!yIsAbsolute&&size.y!==undefined)ret.y=offsetsp.y;if(xIsAbsolute){ret.x=size.x;}if(yIsAbsolute){ret.y=size.y;}break;}if(size.x===undefined)delete ret.x;if(size.y===undefined)delete ret.y;if(size.w===undefined)delete ret.w;else ret.w=size.w;if(size.h===undefined)delete ret.h;else ret.h=size.h;ret.currentCoordType=CoordinateMode.absolute;// console.log(\"decode coords\", {size, sp, ep, ret});\nreturn ret;}},{key:\"testCoords\",value:function testCoords(){var range=arguments.length>0&&arguments[0]!==undefined?arguments[0]:30;outer:for(var _i2=0,_arr=[\"absolute\",\"relative%\",\"relativeOffset\",\"relativeOffsetStart\",\"relativeOffsetEnd\"];_i2<_arr.length;_i2++){var mode=_arr[_i2];for(var i=-range;i<range;i++){for(var j=-range;j<range;j++){var s0={x:i,y:j};var sp={x:10,y:10};var ep={x:10,y:-10};// @ts-ignore\nvar s1=LEdgePoint.encodeCoords(s0,mode,sp,ep);// @ts-ignore\nvar s00=LEdgePoint.decodeCoords(s1,sp,ep);// @ts-ignore\nvar error=Object.keys(s0).map(function(k){return s0[k].toFixed(3)===s00[k].toFixed(3)?'':k;}).join('');(mode!=\"relative%\"&&error?console.error:console.log)({diff:[s00.x-s0.x,s00.y-s0.y].join(),i:i,j:j,mode:mode,s1:[s1.x,s1.y].join(),s0:s0,s00:s00,error:error});if(mode!=\"relative%\"&&error)break outer;}}}}// @ts-ignore a\n},{key:\"encodeCoords\",value:function encodeCoords(size0,edgePointCoordMode,sp,ep)/*absolute*/{var size=size0;if(edgePointCoordMode===size.currentCoordType||!size.currentCoordType&&edgePointCoordMode===CoordinateMode.absolute)return size;if(size.currentCoordType&&size.currentCoordType!==CoordinateMode.absolute)size=LEdgePoint.decodeCoords(size,sp,ep);var ret=\"w\"in size||\"h\"in size?new GraphSize():new GraphPoint();// GObject<Partial<GraphSize>>;\nswitch(edgePointCoordMode){default:return Log.exDevv(\"translatePosCoords() invalid coordinate mode\",{mode:edgePointCoordMode});// case CoordinateMode.absolute: return size;\ncase CoordinateMode.relativePercent:// let s = this.getBasicSize(c);\n// MATH:\n// size.x = sp.x*x% + ep.x*(1-x%)\n// size.x = sp.x*x% + ep.x - ep.x*x%\n// size.x - ep.x= (sp.x - ep.x)*x%\n// (size.x - ep.x) / (sp.x - ep.x) = x% // actually i inverted <sp, ep> in first equation, so reverse them in result too.\nif(sp.x===ep.x)ret.x=0.5;// because otherwise it is infinity. so i force him to return in line.\nelse if(size.x!==undefined)ret.x=(size.x-sp.x)/(ep.x-sp.x);if(sp.y===ep.y)ret.y=0.5;else if(size.y!==undefined)ret.y=(size.y-sp.y)/(ep.y-sp.y);break;case CoordinateMode.relativeOffset:case CoordinateMode.relativeOffsetStart:case CoordinateMode.relativeOffsetEnd:var useStart;var useEnd;switch(edgePointCoordMode){default:case CoordinateMode.relativeOffset:useStart=true;useEnd=true;break;case CoordinateMode.relativeOffsetStart:useStart=true;useEnd=false;break;case CoordinateMode.relativeOffsetEnd:useStart=false;useEnd=true;break;}if(size.x)ret.x=[useStart?size.x-sp.x:-1,useEnd?size.x-ep.x:-1];if(size.y)ret.y=[useStart?size.y-sp.y:-1,useEnd?size.y-ep.y:-1];/*\r\n                if (size.x) ret.x = [sp.x - size.x, ep.x - size.x];\r\n                if (size.y) ret.y = [sp.y - size.y, ep.y - size.y];*/break;}if(size.x===undefined)delete ret.x;if(size.y===undefined)delete ret.y;if(size.w===undefined)delete ret.w;else ret.w=size.w;if(size.h===undefined)delete ret.h;else ret.h=size.h;// console.log(\"encode coorde\", {size, sp, ep, ret});\nret.currentCoordType=edgePointCoordMode;return ret;}}]);return LEdgePoint;}(LVoidVertex),_class16.subclasses=[],_class16._extends=[],_class16))||_class15);RuntimeAccessibleClass.set_extend(DVoidVertex,DEdgePoint);RuntimeAccessibleClass.set_extend(LVoidVertex,LEdgePoint);export var DVertex=(_dec9=RuntimeAccessible('DVertex'),_dec9(_class17=(_class18=/*#__PURE__*/function(_DGraphElement3){_inherits(DVertex,_DGraphElement3);var _super9=_createSuper(DVertex);function DVertex(){var _this13;_classCallCheck(this,DVertex);for(var _len10=arguments.length,args=new Array(_len10),_key10=0;_key10<_len10;_key10++){args[_key10]=arguments[_key10];}_this13=_super9.call.apply(_super9,[this].concat(args));_this13.id=void 0;_this13.graph=void 0;_this13.model=void 0;_this13.isSelected=void 0;_this13.subElements=void 0;_this13.zoom=void 0;_this13.x=void 0;_this13.y=void 0;_this13.w=void 0;_this13.h=void 0;_this13.isResized=void 0;_this13.__isDVertex=void 0;return _this13;}// DVoidVertex\n// static _super = DVoidVertex;\n// static singleton: LVertex;\n// static logic: typeof LVertex;\n// static structure: typeof DVertex;\n// inherit redefine\n// containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\n// size!: GraphSize; // virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\n// personal attributes\n_createClass(DVertex,null,[{key:\"new\",value:function _new(htmlindex,model,parentNodeID,graphID,nodeID,size){return new Constructors(new DVertex('dwc'),parentNodeID,true,undefined,nodeID).DPointerTargetable().DGraphElement(model,graphID,htmlindex).DVoidVertex(size||defaultVertexSize).DVertex().end();}}]);return DVertex;}(DGraphElement),_class18.subclasses=[],_class18._extends=[],_class18))||_class17);export var LVertex=(_dec10=RuntimeAccessible('LVertex'),_dec10(_class19=(_class20=/*#__PURE__*/function(_LVoidVertex2){_inherits(LVertex,_LVoidVertex2);var _super10=_createSuper(LVertex);function LVertex(){var _this14;_classCallCheck(this,LVertex);for(var _len11=arguments.length,args=new Array(_len11),_key11=0;_key11<_len11;_key11++){args[_key11]=arguments[_key11];}_this14=_super10.call.apply(_super10,[this].concat(args));_this14.__raw=void 0;_this14.id=void 0;_this14.graph=void 0;_this14.model=void 0;_this14.subElements=void 0;_this14.zoom=void 0;_this14.x=void 0;_this14.y=void 0;_this14.w=void 0;_this14.h=void 0;_this14.size=void 0;_this14.isResized=void 0;_this14.__isLVertex=void 0;return _this14;}// static singleton: LVertex;\n// static logic: typeof LVertex;\n// static structure: typeof DVertex;\n// inherit redefine\n_createClass(LVertex,[{key:\"isSelected\",value:// isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\nfunction isSelected(forUser){return this.wrongAccessMessage(\"node.isSelected()\");}// containedIn?: LGraphElement;\n// virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\n// personal attributes\n}]);return LVertex;}(LVoidVertex),_class20.subclasses=[],_class20._extends=[],_class20))||_class19);RuntimeAccessibleClass.set_extend(DGraphElement,DVertex);RuntimeAccessibleClass.set_extend(LGraphElement,LVertex);export var DGraphVertex=(_dec11=RuntimeAccessible('DGraphVertex'),Leaf(_class21=_dec11(_class21=(_class22=/*#__PURE__*/function(_DGraphElement4){_inherits(DGraphVertex,_DGraphElement4);var _super11=_createSuper(DGraphVertex);function DGraphVertex(){var _this15;_classCallCheck(this,DGraphVertex);for(var _len12=arguments.length,args=new Array(_len12),_key12=0;_key12<_len12;_key12++){args[_key12]=arguments[_key12];}_this15=_super11.call.apply(_super11,[this].concat(args));_this15.id=void 0;_this15.graph=void 0;_this15.model=void 0;_this15.isSelected=void 0;_this15.subElements=void 0;_this15.zoom=void 0;_this15.offset=void 0;_this15.x=void 0;_this15.y=void 0;_this15.w=void 0;_this15.h=void 0;_this15.isResized=void 0;_this15.__isDVertex=void 0;_this15.__isDGraph=void 0;_this15.__isDGraphVertex=void 0;return _this15;}// MixOnlyFuncs(DGraph, DVertex)\n// static _super1 = DGraph;\n// static _super2 = DVertex;\n// static singleton: LGraphVertex;\n// static logic: typeof LGraphVertex;\n// static structure: typeof DGraphVertex;\n// inherit redefine\n// containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\n// from graph\n// in-graph scrolling position\n// from VoidVertex\n// size!: GraphSize; // virtual\n// from graph\n// personal attributes\n_createClass(DGraphVertex,null,[{key:\"new\",value:function _new(htmlindex,model,parentNodeID,graphID,nodeID,size){return new Constructors(new DGraphVertex('dwc'),parentNodeID,true,undefined,nodeID).DPointerTargetable().DGraphElement(model,graphID,htmlindex).DVoidVertex(size||defaultVertexSize).DVertex().DGraph().end();}/*\r\n        static init_constructor(thiss: DGraphVertex, isUser: boolean = false, nodeID: string | undefined, graphID: string | undefined, model: Pointer<DModel>): void {\r\n            DGraph.init_constructor(thiss, isUser, nodeID, graphID, model);\r\n    //isUser: boolean = false, nodeID: string | undefined, graphID: string, model?: Pointer<DModel>\r\n            DVertex.init_constructor(thiss, isUser, nodeID, graphID as string, model);\r\n            thiss.className = this.name;\r\n        }*/}]);return DGraphVertex;}(DGraphElement),_class22.subclasses=[],_class22._extends=[],_class22))||_class21)||_class21);var LG=/*#__PURE__*/function(_LGraph){_inherits(LG,_LGraph);var _super12=_createSuper(LG);function LG(){_classCallCheck(this,LG);return _super12.apply(this,arguments);}return LG;}(LGraph);var LV=/*#__PURE__*/function(_LVertex){_inherits(LV,_LVertex);var _super13=_createSuper(LV);function LV(){_classCallCheck(this,LV);return _super13.apply(this,arguments);}return LV;}(LVertex);var Mixed=MixOnlyFuncs(LG,LV);export var LGraphVertex=(_dec12=RuntimeAccessible('LGraphVertex'),_dec12(_class23=(_class24=/*#__PURE__*/function(_Mixed){_inherits(LGraphVertex,_Mixed);var _super14=_createSuper(LGraphVertex);function LGraphVertex(){var _this16;_classCallCheck(this,LGraphVertex);for(var _len13=arguments.length,args=new Array(_len13),_key13=0;_key13<_len13;_key13++){args[_key13]=arguments[_key13];}_this16=_super14.call.apply(_super14,[this].concat(args));_this16.__raw=void 0;_this16.id=void 0;_this16.graph=void 0;_this16.model=void 0;_this16.zoom=void 0;_this16.offset=void 0;_this16.graphSize=void 0;_this16.x=void 0;_this16.y=void 0;_this16.w=void 0;_this16.h=void 0;_this16.isResized=void 0;_this16.size=void 0;_this16.__isLVertex=void 0;_this16.__isLGraph=void 0;_this16.__isLGraphVertex=void 0;return _this16;}// MixOnlyFuncs(LGraph, LVertex)\n// static singleton: LGraphVertex;\n// static logic: typeof LGraphVertex;\n// static structure: typeof DGraphVertex;\n// inherit redefine\n_createClass(LGraphVertex,[{key:\"isSelected\",value:// isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\nfunction isSelected(forUser){return this.wrongAccessMessage(\"node.isSelected()\");}// containedIn?: LGraphElement;\n///////////////////////////////////////// subElements!: LGraphElement[];\n// from graph\n// in-graph scrolling position\n// internal size of the graph. can be huge even if the sub-graph is in a small window (scroll)\n// from VoidVertex\n// virtual\n// personal attributes\n}]);return LGraphVertex;}(Mixed),_class24.subclasses=[],_class24._extends=[],_class24))||_class23);RuntimeAccessibleClass.set_extend(DGraph,DGraphVertex);RuntimeAccessibleClass.set_extend(DVertex,DGraphVertex);RuntimeAccessibleClass.set_extend(LGraph,LGraphVertex);RuntimeAccessibleClass.set_extend(LVertex,LGraphVertex);export var DVoidEdge=(_dec13=RuntimeAccessible('DVoidEdge'),_dec13(_class25=(_class26=/*#__PURE__*/function(_DGraphElement5){_inherits(DVoidEdge,_DGraphElement5);var _super15=_createSuper(DVoidEdge);function DVoidEdge(){var _this17;_classCallCheck(this,DVoidEdge);for(var _len14=arguments.length,args=new Array(_len14),_key14=0;_key14<_len14;_key14++){args[_key14]=arguments[_key14];}_this17=_super15.call.apply(_super15,[this].concat(args));_this17.id=void 0;_this17.graph=void 0;_this17.model=void 0;_this17.isSelected=void 0;_this17.subElements=void 0;_this17.start=void 0;_this17.end=void 0;_this17.__isDVoidEdge=void 0;_this17.midPoints=void 0;_this17.midnodes=void 0;_this17.longestLabel=void 0;_this17.labels=void 0;_this17.anchorStart=void 0;_this17.anchorEnd=void 0;return _this17;}// static singleton: LVoidEdge;\n// static logic: typeof LVoidEdge;\n// static structure: typeof DVoidEdge;\n// isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\n// containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\n// personal attributes\n// the logic part which instructs to generate the midnodes\n// using subelements instead most of times\n// endFollow!: boolean; they became derived attributes from static properties\n// startFollow!: boolean;\n_createClass(DVoidEdge,null,[{key:\"new\",value:function _new(htmlindex,model,parentNodeID,graphID,nodeID,start,end,longestLabel,labels){return new Constructors(new DEdge('dwc'),parentNodeID,true,undefined,nodeID).DPointerTargetable().DGraphElement(model,graphID,htmlindex).DVoidEdge(start,end,longestLabel,labels).end();}},{key:\"new2\",value:function new2(model,parentNodeID,graphID,nodeID,start,end,setter){return new Constructors(new DEdge('dwc'),parentNodeID,true,undefined,nodeID).DPointerTargetable().DGraphElement(model,graphID).DVoidEdge(start,end).end(setter);}}]);return DVoidEdge;}(DGraphElement),_class26.subclasses=[],_class26._extends=[],_class26.isFollowingCoords=void 0,_class26))||_class25);/*\r\n@RuntimeAccessible\r\nexport class MidPoint{\r\n    readonly id: string; // not really a pointer, it's not on store.\r\n    x?: number; y?: number;\r\n    readonly w?: number; // if it's modified it's not ever here (initial size) but on DEdgePoint that is a Node.\r\n    readonly h?: number;/*\r\n    constructor2(x: number=5, y: number=5, w: number=5, h: number=5) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.w = w;\r\n        this.h = h;\r\n    }* /\r\nconstructor(id: string, w: number=5, h: number=5) {\r\n    this.id = id;\r\n    this.w = w;\r\n    this.h = h;\r\n}\r\n}*/export var EdgeSegment=(_dec14=RuntimeAccessible('EdgeSegment'),_dec14(_class27=/*#__PURE__*/function(){//  a segment of the whole path\n// m coefficient of the line between start and end.\n// for head and tails: radian angle of the segment.\n// for labels: it flips the angle when it's < PI/2 so the text is never upside down\n/*constructor(label: PrimitiveType|undefined, length: number, startp: GraphPoint, endp: GraphPoint, start: LGraphElement, end: LGraphElement,\r\n                bezierpts: GraphPoint[], mid: LGraphElement[],\r\n                svgLetter: EdgeBendingMode, index: number, fillMode: MidNodeHandling) {\r\n        this.label = label;\r\n        this.length = length;\r\n        this.length = length;\r\n        this.startp = startp;\r\n        this.bezierp = bezierpts;\r\n        this.endp = endp;\r\n        this.start = start;\r\n        this.end = end;\r\n        this.mid = mid;\r\n    }*/function EdgeSegment(start,mid,end,svgLetter,gapMode,index,prevSegment){_classCallCheck(this,EdgeSegment);this.index=void 0;this.prev=void 0;this.start=void 0;this.bezier=void 0;this.end=void 0;this.length=void 0;this.d=void 0;this.dpart=void 0;this.m=void 0;this.rad=void 0;this.radLabels=void 0;this.isLongest=void 0;this.label=void 0;this.svgLetter=void 0;// console.log(\"segmentmaker:\", arguments, ((start.ge?.model as any)?.name)+\" ---> \" + ((end.ge?.model as any)?.name));\nthis.start=start;this.bezier=mid;this.end=end;this.index=index;this.prev=prevSegment;//this.segments = segments;\n// the idea: forbid all T and S or transform them in C, Q by calculating and manually adding their mirrored bezier pts\n// if (svgLetter[1]) svgLetter = (svgLetter[0]) as any;\nif(svgLetter===EdgeBendingMode.Bezier_QT){this.svgLetter=EdgeBendingMode.Bezier_QT[0];// this.svgLetter = (index === 0 ? EdgeBendingMode.Bezier_QT[0] : EdgeBendingMode.Bezier_QT[1]) as any as EdgeBendingMode;\nthis.addBezierPoint();}else if(svgLetter===EdgeBendingMode.Bezier_CS){this.svgLetter=EdgeBendingMode.Bezier_CS[0];// this.svgLetter = (index === 0 ? EdgeBendingMode.Bezier_CS[0] : EdgeBendingMode.Bezier_CS[1]) as any as EdgeBendingMode;\nthis.addBezierPoint();}else this.svgLetter=svgLetter;// fix if amount of bezier pts is invalid for current letter\nswitch(this.svgLetter){case EdgeBendingMode.Line:case EdgeBendingMode.Bezier_quadratic:if(this.bezier.length>=1)break;else this.svgLetter=EdgeBendingMode.Line;break;case EdgeBendingMode.Bezier_cubic:if(this.bezier.length>=2)break;else if(this.bezier.length>=1)this.svgLetter=EdgeBendingMode.Bezier_quadratic;else this.svgLetter=EdgeBendingMode.Line;break;case EdgeBendingMode.Elliptical_arc:if(this.bezier.length>=3)break;else this.svgLetter=EdgeBendingMode.Line;// straight to end ignoring midpoints that are NOT coordinates when using elliptical arc.\nbreak;default://case EdgeBendingMode.Bezier_quadratic_mirrored as string:\n//case EdgeBendingMode.Bezier_cubic_mirrored as string: // translated to Q or C by adding mirrored bezier points explicitly\ncase EdgeBendingMode.Bezier_QT:case EdgeBendingMode.Bezier_CS:// translated to Q or C by sending the right letter to each segment\nLog.exDevv(\"this svg letter should not appear here\",this.svgLetter);break;}}_createClass(EdgeSegment,[{key:\"addBezierPoint\",value:function addBezierPoint(){var prev=this.prev;if(!prev)return;var prevedgemakerbezier=prev.bezier[prev.bezier.length-1]||prev.start;var mirroredBezier=_objectSpread(_objectSpread({},prevedgemakerbezier),{},{pt:EdgeSegment.invertLastBezierPt(prevedgemakerbezier.pt,prev.end.pt),uncutPt:EdgeSegment.invertLastBezierPt(prevedgemakerbezier.uncutPt,prev.end.uncutPt)});this.bezier=[mirroredBezier].concat(_toConsumableArray(this.bezier));// always only 1 assumed pt both in cubic and quadratic.\n// let next: this | undefined = this.segments[this.index+1];\n// EdgeSegment.invertLastBezierPt((next.mid[1] || next.end).pt, next.start.pt);\n}},{key:\"makeD\",value:function makeD(index,gapMode){this.m=GraphPoint.getM(this.start.pt,this.end.pt);this.rad=Geom.mToRad(this.m,this.start.pt,this.end.pt);this.radLabels=Math.atan(this.m);var svgLetter=this.svgLetter;// caller makes sure to pass right letter and resolve \"CS\" mixed letters. // this.bendingModeToLetter(bendingMode, index);\n// caller sends inverted pts as normal coords\n// let invertedBezPt = lastSegment && EdgeSegment.invertLastBezierPt(lastSegment.midp[lastSegment.mid.length-1] || lastSegment.startp, lastSegment.endp);\nswitch(this.svgLetter.length){case 2:return Log.exDevv(\"mixed letters are not allowed and should have been resolved to single svg letters before here, found:\"+svgLetter);/*return Log.exDevv(\"dev problem to fix:\\n\" +\r\n            \"the mirrored mode requires the first one to have explicit non-mirrored mode?? like M, C a1 a2 a3, S a1, S a1, S a1\\n\" +\r\n            \"So all segments with mixed modes needs to extract the last bezier point (penultimate coordinate) from previous segments, mirror it and insert in midp[0]\");*/case 1:var bezierpts=[].concat(_toConsumableArray(this.bezier.map(function(b){return b.pt;})),[this.end.pt]);var finalpart=svgLetter+\" \"+bezierpts.map(function(p){return p.x+\" \"+p.y;}).join(\", \");this.dpart=\"M \"+this.start.pt.x+\" \"+this.start.pt.y+\", \"+finalpart;var bezierptsUncut=[].concat(_toConsumableArray(this.bezier.map(function(b){return b.uncutPt;})),[this.end.pt]);// uncutPt exist for start and end too, but i want to use the cut one for those. or edgehead is off\nvar finalpartUncut=svgLetter+\" \"+bezierptsUncut.map(function(p){return p.x+\" \"+p.y;}).join(\", \");this.d=(index===0?\"M\"+this.start.pt.x+\" \"+this.start.pt.y+\", \":\"\")+finalpartUncut;//midp = [this.startp, ...this.midp];\n// d = M sp X mp2 ep // X = custom letter\n// dpart = T sp X mp2 ep // S = S if X = C,\n// sp is the startingpoint from the prev node, which might be != from endpoint of last node if last node have w>0 && h>0\n// so i'm \"filling\" the gap with a T, or L arc wich can use only 1 parameter (they are the only 1-parameter arcs)\n// if (this.prev && this.prev.end.pt.equals(this.start.pt)) gapMode = EdgeGapMode.average; // if the 2 points coincide, i use any 1 of the gapmodes that are continuous\n/*switch (gapMode){\r\n                    case EdgeGapMode.center:\r\n                    case EdgeGapMode.average:\r\n                        // continuous gap modes. they only differ in how the \"joining\" point is found, but not in how they behave after that.\r\n                        /*\r\n                        if (index === 0) {\r\n                             startletter = \"M \";\r\n                         }\r\n                         else {\r\n                             switch (svgLetter) {\r\n                                 case SvgLetter.A: case SvgLetter.C: case SvgLetter.S: case SvgLetter.Q: case SvgLetter.T: default:\r\n                                     startletter = SvgLetter.T + \" \"; break;\r\n                                 case SvgLetter.L: case SvgLetter.M:\r\n                                     startletter = SvgLetter.L + \" \"; break;\r\n                             }\r\n                         }* /\r\n                        if (index) {\r\n                            this.d = finalpart;\r\n                        }\r\n                        else { this.d = this.dpart; }\r\n                        break;\r\n                    case EdgeGapMode.gap:\r\n                    case EdgeGapMode.autoFill:\r\n                    case EdgeGapMode.lineFill:\r\n                    case EdgeGapMode.arcFill:\r\n                        // the filling itself is done by another segment (solving svg letter and simulating i=0), so i treat it as a gap.\r\n                        this.d = this.dpart;\r\n                        break;\r\n                    default:\r\n                        Log.exDevv(\"unexpected EdgeGapMode:\" + gapMode, {gapMode});\r\n                }*/break;default:return Log.exDevv(\"unexpected bending mode length:\"+this.svgLetter+\" or fillMode: \"+gapMode,{bendingMode:this.svgLetter,index:index,gapMode:gapMode});}//using\n/*\r\n        88\r\n\r\n        // d should not have M set (except for segments[0]\r\n        // dpart have M abd beed to add explicit points for \"mirroring\" and transforming bezier quadratic mirrored in bezier quadratic normal etc.\r\n        //88 problem: the mirrored mode requires the first one to have explicit nonmirrored mode?? like M, C a1 a2 a3, S a1, S a1, S a1 .... ?\r\n        in any case the % letter part is wrong because it needs to subtract first element used for M*/return this.d;}},{key:\"calcLength\",value:function calcLength(){this.length=this.start.pt.distanceFromPoint(this.end.pt);}}],[{key:\"invertLastBezierPt\",value:function invertLastBezierPt(bezier,end){// vector = bezier - end\n// end + vector = bezier\n// end - vector = inverted bezier? = 2*end-bezier\nvar vector=bezier.subtract(end,true);return end.subtract(vector,true);}}]);return EdgeSegment;}())||_class27);export var EdgeFillSegment=/*#__PURE__*/function(_EdgeSegment){_inherits(EdgeFillSegment,_EdgeSegment);var _super16=_createSuper(EdgeFillSegment);function EdgeFillSegment(){_classCallCheck(this,EdgeFillSegment);return _super16.apply(this,arguments);}_createClass(EdgeFillSegment,[{key:\"makeD\",value:function makeD(index,gapMode){// if (gapMode === EdgeGapMode.autoFill) { gapMode = this.svgLetter === EdgeBendingMode.Line ? EdgeGapMode.lineFill : EdgeGapMode.arcFill; }\nswitch(gapMode){case\"closest\":// EdgeGapMode.closest:\ncase EdgeGapMode.center:case EdgeGapMode.average:case EdgeGapMode.gap:return\"\";// should not have filler arcs\ndefault:/*\r\n            case EdgeGapMode.autoFill as any:\r\n            case EdgeGapMode.lineFill:\r\n                this.bezier = [];\r\n                this.svgLetter = EdgeBendingMode.Line;\r\n                return super.makeD(index, gapMode);\r\n            case EdgeGapMode.arcFill:*/this.svgLetter=this.svgLetter[0];if(this.svgLetter===\"Q\")this.bezier=this.bezier.length?[this.bezier[0]]:[];return _get(_getPrototypeOf(EdgeFillSegment.prototype),\"makeD\",this).call(this,index,gapMode);}}}]);return EdgeFillSegment;}(EdgeSegment);EdgeFillSegment.cname=\"EdgeFillSegment\";export var LVoidEdge=(_dec15=RuntimeAccessible('LVoidEdge'),_dec15(_class29=(_class30=/*#__PURE__*/function(_LGraphElement3){_inherits(LVoidEdge,_LGraphElement3);var _super17=_createSuper(LVoidEdge);function LVoidEdge(){var _this18;_classCallCheck(this,LVoidEdge);for(var _len15=arguments.length,args=new Array(_len15),_key15=0;_key15<_len15;_key15++){args[_key15]=arguments[_key15];}_this18=_super17.call.apply(_super17,[this].concat(args));_this18.__raw=void 0;_this18.id=void 0;_this18.graph=void 0;_this18.model=void 0;_this18.subElements=void 0;_this18.start=void 0;_this18.end=void 0;_this18.__isLVoidEdge=void 0;_this18.midPoints=void 0;_this18.midnodes=void 0;_this18.edge=void 0;_this18.__info_of__edge={type:\"?LEdge\",txt:\"returns this if called on an edge, the containing edge if called on an EdgePoint, undefined otherwise.\"};_this18.label=void 0;_this18.longestLabel=void 0;_this18.labels=void 0;_this18.allNodes=void 0;_this18.__info_of__longestLabel={label:\"Longest label\",type:\"function(edge)=>string | string\",readType:\"PrimitiveType\",writeType:\"PrimitiveType | (e:this, curr: LGraphElement, next: LGraphElement, curr_index: number, allNodes: LGraphElement[]) => PrimitiveType)\",txt:/*#__PURE__*/_jsx(\"span\",{children:\"Label assigned to the longest path segment.\"})};_this18.__info_of__label={type:\"\",txt:/*#__PURE__*/_jsx(\"span\",{children:\"Alias for longestLabel\"})};_this18.__info_of__labels={label:\"Multiple labels\",type:\"function(edge)=>string | string\",writeType:\"type of label or Array<type of label>\",txt:/*#__PURE__*/_jsx(\"span\",{children:\"Instructions to label to multiple or all path segments in an edge\"})};_this18.__info_of__allNodes={type:\"[LGraphElement, ...Array<LEdgePoint>, LGraphElement]\",txt:/*#__PURE__*/_jsx(\"span\",{children:\"first element is this.start. then all this.midnodes. this.end as last element\"})};_this18.__info_of__startPoint={type:\"GraphPoint\",txt:/*#__PURE__*/_jsx(\"span\",{children:\"startPoint of this.start (element originating the edge). Defaults in outer coordinates.\"})};_this18.__info_of__endPoint={type:\"GraphPoint\",txt:/*#__PURE__*/_jsx(\"span\",{children:\"endPoint of this.end (element originating the edge). Defaults in outer coordinates.\"})};_this18.segments=void 0;_this18.segments_inner=void 0;_this18.segments_outer=void 0;_this18.__info_of__segments={type:\"{all:T, segments:T, fillers:T, head: GraphSize&{rad:number}, tail: as head} where T is EdgeSegment\",txt:/*#__PURE__*/_jsxs(\"span\",{children:[\"Collection of segments connecting in order vertex and EdgePoint without intersecting their area, aimed to be rendered in svg path.\",/*#__PURE__*/_jsx(\"br\",{}),\"fillers are arcs generated by view.edgeGapMode being autofill, arcfill or linefill.\",/*#__PURE__*/_jsx(\"br\",{}),\"length of this.segments array is Math.ceil(allNodes.length / svg_letter_size) specified on view.\",/*#__PURE__*/_jsx(\"br\",{}),\"\\\"head\\\" and \\\"tail\\\" are the position and angle of eventual edge decorators. Refer to this.headPos documentation.\"]})};_this18.d=void 0;_this18.__info_of__d={type:ShortAttribETypes.EString,txt:\"the full suggested path of SVG path \\\"d\\\" attribute, merging all segments.\"};_this18.anchorStart=void 0;_this18.anchorEnd=void 0;_this18.__info_of__anchorStart={writeType:\"string | undefined\",type:\"string\",isEdge:true,txt:\"The name of a node anchor where the edge should originate from.\"};_this18.__info_of__anchorEnd={writeType:\"string | undefined\",type:\"string\",isEdge:true,txt:\"The name of a node anchor where the edge should point to.\"};_this18.endFollow=void 0;_this18.startFollow=void 0;_this18.__info_of__endFollow={writeType:\"boolean\",readType:\"boolean\",type:\"boolean\",isEdge:true,// type:\"read:(()=>void), write:boolean\", readType:\"(()=>void))\",\ntxt:\"makes the ending point of an edge follow the cursor, so it can be assigned to a new anchor or target.\"};_this18.__info_of__startFollow={writeType:\"boolean\",readType:\"boolean\",type:\"boolean\",isEdge:true,// type:\"read:(()=>void), write:boolean\", readType:\"(()=>void))\",\ntxt:\"makes the starting point of an edge follow the cursor, so it can be assigned to a new anchor or source.\"};return _this18;}// static singleton: LVoidEdge;\n// static logic: typeof LVoidEdge;\n// static structure: typeof DVoidEdge;\n_createClass(LVoidEdge,[{key:\"isSelected\",value:// isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\nfunction isSelected(forUser){return this.wrongAccessMessage(\"node.isSelected()\");}// containedIn?: LGraphElement;\n// the logic part which instructs to generate the midnodes\n// returns self. useful to get edge from edgePoints without triggering error if you are already on edge.\n/*\r\nreplaced by startPoint\r\n    edgeStart!: GraphPoint;\r\n    edgeStart_inner!: GraphPoint;\r\n    edgeStart_outer!: GraphPoint;\r\n    __info_of__edgeStart: Info = {type: \"GraphPoint\", txt: \"Same as edgeStart_outer.\"}\r\n    __info_of__edgeStart_outer: Info = {type: \"GraphPoint\",\r\n     txt: \"Where the edge should start his path, in coordinates relative at the root Graph.\r\n     <br>Computed by combining the anchor offset option in View and the size of the starting node.\"}\r\n    __info_of__edgeStart_inner: Info = {type: \"GraphPoint\",\r\n     txt: \"Where the edge should start his path, in coordinates relative at the most nested Graph.\r\n     <br>Computed by combining the anchor offset option in View and the size of the starting node.\"}\r\n    edgeEnd!: GraphPoint;\r\n    edgeEnd_inner!: GraphPoint;\r\n    edgeEnd_outer!: GraphPoint;\r\n    __info_of__edgeEnd: Info = {type: \"GraphPoint\", txt: \"Same as edgeEnd_outer.\"}\r\n    __info_of__edgeEnd_outer: Info = {type: \"GraphPoint\",\r\n     txt: \"Where the edge should end his path, in coordinates relative at the root Graph.\r\n     <br>Computed by combining the anchor offset option in View and the size of the starting node.\"}\r\n    __info_of__edgeEnd_inner: Info = {type: \"GraphPoint\",\r\n     txt: \"Where the edge should end his path, in coordinates relative at the most nested Graph.\r\n     <br>Computed by combining the anchor offset option in View and the size of the starting node.\"}\r\n*/ // should never be read change their documentation in write only. their values is \"read\" in this.segments\n},{key:\"get_label\",value:function get_label(c){return this.get_longestLabel(c);}},{key:\"set_label\",value:function set_label(val,c){return this.set_longestLabel(val,c);}},{key:\"get_longestLabel\",value:function get_longestLabel(c){return c.data.longestLabel;}},{key:\"set_longestLabel\",value:function set_longestLabel(val,c){SetFieldAction.new(c.data,\"longestLabel\",val);return true;}},{key:\"get_labels\",value:function get_labels(c){return c.data.labels;}},{key:\"set_labels\",value:function set_labels(val,c){SetFieldAction.new(c.data,\"labels\",val);return true;}},{key:\"headPos_impl\",value:function headPos_impl(c,isHead,headSize0,segment0,zoom0){var segment=segment0||this.get_segments(c).segments[0];// let v: LViewElement = this.get_view(c);\nvar tmp=headSize0||(isHead?this.get_view(c).edgeHeadSize:this.get_view(c).edgeTailSize);if(!tmp||tmp.x===0||tmp.y===0){// head or tail missing\ntmp=new GraphSize(0,0,0,0);tmp.rad=0;return tmp;}var zoom=zoom0||this.get_graph(c).zoom;var headPos=new GraphSize(0,0,tmp.x,tmp.y);//.multiply({w:zoom.x, h:zoom.y});\nvar useBezierPoints=true;var start,end;var m;if(useBezierPoints){if(isHead){start=segment.end.pt;end=(segment.bezier[segment.bezier.length-1]||segment.start).pt;}else{start=segment.start.pt;end=(segment.bezier[0]||segment.end).pt;}m=GraphPoint.getM(start,end);}else{if(isHead){start=segment.end.pt;end=segment.start.pt;}else{start=segment.start.pt;end=segment.end.pt;}m=segment.m;}// first find the center of where it should be positioned\n// let center: GraphPoint;\n// let distance: number = Math.sqrt(headPos.w*headPos.w + headPos.h*headPos.h);\n// let isVertical = m >=1 ;\nvar x4headsize=new GraphSize(start.x-headPos.w,start.y-headPos.h,headPos.w*2,headPos.h*2);// first intersection is segment origin. second is found with the box containing all possible edgeHead positions that touch the startPoint\n// (doing x4 his shape and placing 4 \"rectangles\" all around startPoint) to cover all possible segment directions.\n// or finding first direction (vertical if m >1, horizontal if m<0) and vector direction and intersecting with only the \"correct\" placed edgeHead rectangle.\n// then the intersection will likely not fall on the extreme angle of EdgeHead and i can re-center edgeHead\n// so that first and second intersections are equal spaced with the center segment\nvar secondIntersection;var segmentDistance=start.distanceFromPoint(end);if(segmentDistance<=Math.sqrt(Math.pow(headPos.w,2)+Math.pow(headPos.h,2))){var safeDistance=Math.max(headPos.w,headPos.h)*5;end=new GraphPoint(end.y+safeDistance,end.y+m*safeDistance);// move the point away so it doesn't intersect anymore. i just need direction\n// too small to fit edgeHead, i simply put it centered on the whole segment\n// secondIntersection = end;\n}secondIntersection=GraphSize.closestIntersection(x4headsize,start,end,undefined);if(!secondIntersection)return Log.exx(\"failed to intersect edge head\",{x4headsize:x4headsize,segment:segment,headPos:headPos,c:c,start:start,end:end,useBezierPoints:useBezierPoints});tmp=secondIntersection.add(start,false).divide(2);// center of edgehead\nheadPos.x=tmp.x-headPos.w/2;// tl corner\nheadPos.y=tmp.y-headPos.h/2;// tl corner\nheadPos.rad=Geom.mToRad(m,start,end);/*\r\n        devo trovare la distanza tra il centro dell'egeHead e il punto di inizio in termini assoluti, così tramite M trovo distanza in x e y. o trovarla in altro modo\r\n        if (segment.m === Number.POSITIVE_INFINITY || segment.m === Number.NEGATIVE_INFINITY) {\r\n            center = segment.start.pt.add({x:0, y: distance}, true); }\r\n        else { center = segment.start.pt.add({x:segment.m*headPos.w/2, y:segment.m*headPos.h/2\r\n         this is wrong, cannot be the same for x and y, i should invert the line equation for x?}, true); }\r\n        headPos.x = center.x - headPos.w / 2;\r\n        headPos.y = center.y - headPos.h / 2;*/ // console.log(\"head intersected\", {headPos, secondIntersection, x4headsize, segment, c, start, end, useBezierPoints});\nreturn headPos;}},{key:\"headPos\",value:function headPos(headSize0,segment0,zoom0){return this.wrongAccessMessage(\"This is not headPos() implementation. it is just for typings. use the getter\");}},{key:\"tailPos\",value:function tailPos(headSize0,segment0,zoom0){return this.wrongAccessMessage(\"This is not tailPos() implementation. it is just for typings. use the getter\");}},{key:\"get_headPos\",value:function get_headPos(c){var _this19=this;return function(headSize,segment,zoom){return _this19.headPos_impl(c,true,headSize,segment,zoom);};}},{key:\"get_tailPos\",value:function get_tailPos(c){var _this20=this;return function(headSize,segment,zoom){return _this20.headPos_impl(c,false,headSize,segment,zoom);};}},{key:\"get_allNodes\",value:function get_allNodes(c){return[this.get_start(c)].concat(_toConsumableArray(this.get_midnodes(c)),[this.get_end(c)]);}},{key:\"get_edge\",value:function get_edge(c){return c.proxyObject;}},{key:\"set_edge\",value:function set_edge(v,c){return this.cannotSet(\"edge field, on an edge element\");}},{key:\"get_midPoints\",value:function get_midPoints(c){return c.data.midPoints;}},{key:\"addMidPoint\",value:function addMidPoint(v){return this.wrongAccessMessage(\"addMidPoint\");}},{key:\"get_addMidPoint\",value:function get_addMidPoint(c){var _this21=this;return function(v){return _this21.impl_addMidPoints(v,c);};}},{key:\"set_midPoints\",value:function set_midPoints(val,c){return SetFieldAction.new(c.data.id,\"midPoints\",val,undefined,false);}},{key:\"impl_addMidPoints\",value:function impl_addMidPoints(val,c){return SetFieldAction.new(c.data.id,\"midPoints\",val,'+=',false);}},{key:\"get_label_impl\",value:function get_label_impl(c,segment,nodes,segments){var key=segment.isLongest?\"longestLabel\":\"labels\";// : keyof this\n// if (isLongestSegment) return this.get_longestLabel_impl(d, l, nodes, index):\nvar d=c.data;var l=c.proxyObject;var labelmaker=d[key];// orArr<PrimitiveType | JSX | function>\nvar labelmakerfunc=labelmaker;// let lastSeg = segments[i-1];\nswitch(typeof labelmaker){//nb{}[]<>\ncase\"number\":case\"undefined\":case\"boolean\":case\"string\":return labelmaker;// case \"function\": return nodes.map( (o, i) => d.labels(l, nodes, i)).slice(0, nodes.length-1);\ncase\"function\":return labelmakerfunc(l,segment,nodes,segments);default:break;case\"object\":if(labelmaker===null)return null;if(!Array.isArray(labelmaker))break;if(typeof labelmaker[0]===\"function\")return labelmaker[segment.index%labelmaker.length](l,segment,nodes,segments);return labelmaker[segment.index%labelmaker.length];}Log.exx(\"edge labels invalid type, must be a primitive value, a function or an array of such.\",{labelmaker:labelmaker,key:key,d:d});return undefined;}/*\r\n    private get_label_impl_old(d: DVoidEdge, l: LVoidEdge, nodes:this[\"allNodes\"], index: number, longestlabelindex?: number): PrimitiveType {\r\n        if (d.longestLabel !== undefined && index === longestlabelindex) return this.get_longestLabel_impl(d, l, nodes, index);\r\n        switch (typeof d.labels) {//nb{}[]<>\r\n            case \"number\":\r\n            case \"undefined\":\r\n            case \"boolean\":\r\n            case \"string\": return d.labels;\r\n            // case \"function\": return nodes.map( (o, i) => d.labels(l, nodes, i)).slice(0, nodes.length-1);\r\n            case \"function\": return d.labels(l, nodes[index], nodes[index+1], index, nodes);\r\n            default: break;\r\n            case \"object\": if (!Array.isArray(d.labels)) break;\r\n            if (typeof d.labels[0] === \"function\") return (d.labels as any)[index % d.labels.length](l, nodes[index], nodes[index+1], index, nodes);\r\n            return (d.labels as PrimitiveType[])[index % d.labels.length];\r\n        }\r\n        Log.exx(\"edge labels invalid type, must be a primitive value, a function or an array of such.\", d.labels);\r\n    }*/},{key:\"get_startPoint\",value:function get_startPoint(context){return this.get_startPoint_Outer(context);}},{key:\"get_endPoint\",value:function get_endPoint(context){return this.get_endPoint_Outer(context);}},{key:\"get_startPoint_Outer\",value:function get_startPoint_Outer(c){// console.log(\"get_edgeStart_Outer\", {out:this.get_outerGraph(c), pos:this.get_startPoint_inner(c), inner:this.get_start(c).innerGraph});\nreturn this.get_outerGraph(c).translateSize(this.get_startPoint_inner(c),this.get_start(c).innerGraph);}},{key:\"get_endPoint_Outer\",value:function get_endPoint_Outer(c){// console.log(\"get_edgeEnd_Outer\", {out:this.get_outerGraph(c), pos:this.get_endPoint_inner(c), inner:this.get_end(c).innerGraph});\nreturn this.get_outerGraph(c).translateSize(this.get_endPoint_inner(c),this.get_end(c).innerGraph);}},{key:\"get_startPoint_inner\",value:function get_startPoint_inner(c){return this.get_edgeStartEnd_inner(c,true);}},{key:\"get_endPoint_inner\",value:function get_endPoint_inner(c){return this.get_edgeStartEnd_inner(c,false);}},{key:\"get_edgeStartEnd_inner\",value:function get_edgeStartEnd_inner(c,isStart){return isStart?this.get_start(c).startPoint:this.get_end(c).endPoint;}},{key:\"svgLetterSize\",value:function svgLetterSize(s){var addM=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;var doublingMidPoints=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;var ret;switch(s){default:ret=Log.exDevv(\"unexpected svg path letter: \\\"\"+s+\"\\\"\",s);break;case EdgeBendingMode.Line://case EdgeBendingMode.Bezier_quadratic_mirrored:\nret={first:1,others:1};break;case EdgeBendingMode.Bezier_quadratic://case EdgeBendingMode.Bezier_cubic_mirrored:\nret={first:2,others:2};break;case EdgeBendingMode.Bezier_cubic:ret={first:3,others:3};break;case EdgeBendingMode.Elliptical_arc:ret={first:4,others:4};break;case EdgeBendingMode.Bezier_QT:ret={first:2,others:1};break;case EdgeBendingMode.Bezier_CS:ret={first:3,others:2};break;}// account for the fact that every midpoint is listed twice: at anchor start and anchor end.\nif(doublingMidPoints){// removing last point (first is already excluded because addM didn't trigger yet)\n// , the remaining are midpoints to double. then i add it back\nret.first=(ret.first-1)*2+1;ret.others=(ret.others-1)*2+1;}// account for the first M letter\n//    (if the segment is not mode.gap or first, M coord still exist in segment but are ignored)\nif(addM){ret.first+=1;ret.others+=1;}return ret;}},{key:\"get_points_impl\",value:function get_points_impl(allNodes,outer,c){function getAnchorOffset(size,offset,isPercentage){var $factor=arguments.length>3&&arguments[3]!==undefined?arguments[3]:100;if(!size)size=new GraphSize(0,0,0,0);// else if (!size.tl) size = new GraphSize(size.x, size.y, size.w, size.h);\nif(isPercentage)offset=new GraphPoint(offset.x/$factor*size.w,offset.y/$factor*size.h);return size.tl().add(offset,false);}var all=allNodes.flatMap(function(ge,i){var dge=ge.__raw;var base={view:ge.view,size:outer?ge.outerSize:ge.innerSize,ge:ge,pt:null,uncutPt:null};Log.exDev(typeof base.size!==\"object\",\"could not get node size:\",{base:base,c:c,outer:outer});var rets;// = base as any;\nvar rete;// = {...base} as any;\nvar debug=true;if(debug){base.anchor_e=dge.anchors[c.data.anchorEnd||0]||dge.anchors[Object.keys(dge.anchors)[0]];base.anchor_s=dge.anchors[c.data.anchorStart||0]||dge.anchors[Object.keys(dge.anchors)[0]];}// get endpoint, then startpoint (land on midnode, then depart from it)\nif(i!==0){rete=_objectSpread({rete:true},base);if(i===allNodes.length-1){// get end anchor from node\nvar anchor=dge.anchors[c.data.anchorEnd||0];if(!anchor)anchor=dge.anchors[Object.keys(dge.anchors)[0]];if(anchor)rete.pt=getAnchorOffset(rete.size,anchor,true,1);}// if no anchor, treat the node as a midpoint\nif(!rete.pt){// get ending point from midpoint\n//rete.pt = (LEdgePoint.singleton as LEdgePoint).get_endPoint(undefined as any, rete.size, rete.view);\nrete.pt=getAnchorOffset(rete.size,rete.view.edgeStartOffset,rete.view.edgeStartOffset_isPercentage);}rete.uncutPt=rete.pt;}if(i!==allNodes.length-1){rets=_objectSpread({rets:true},base);if(i===0){// get start anchor from node\nvar _anchor=dge.anchors[c.data.anchorStart||0];if(!_anchor)_anchor=dge.anchors[Object.keys(dge.anchors)[0]];if(_anchor)rets.pt=getAnchorOffset(rets.size,_anchor,true,1);}if(!rets.pt){// rets starting point from midpoint\n// rets.pt = (LEdgePoint.singleton as LEdgePoint).get_startPoint(undefined as any, rets.size, rets.view);\nrets.pt=getAnchorOffset(rets.size,rets.view.edgeStartOffset,rets.view.edgeStartOffset_isPercentage);}rets.uncutPt=rets.pt;}// ret.pt = ge.startPoint\nreturn rets&&rete?[rete,rets]:rets?[rets]:[rete];});if(DVoidEdge.isFollowingCoords){if(c.data.id===LVoidEdge.endFollow){var seg=all[all.length-1];seg.pt=DVoidEdge.isFollowingCoords;seg.size=new GraphSize(seg.pt.x,seg.pt.y,0.01,0.01);}if(c.data.id===LVoidEdge.startFollow){var _seg=all[0];_seg.pt=DVoidEdge.isFollowingCoords;_seg.size=new GraphSize(_seg.pt.x,_seg.pt.y,0.01,0.01);}}return all;}},{key:\"get_pointsDebug\",value:function get_pointsDebug(c){return this.get_points_impl(this.get_allNodes(c),true,c);}},{key:\"get_points\",value:function get_points(allNodes){var outer=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;var c=arguments.length>2?arguments[2]:undefined;return this.get_points_impl(allNodes,outer,c);}},{key:\"get_points_outer\",value:function get_points_outer(allNodes,c){return this.get_points_impl(allNodes,true,c);}},{key:\"get_points_inner\",value:function get_points_inner(allNodes,c){return this.get_points_impl(allNodes,false,c);}},{key:\"get_d\",value:function get_d(c){return this.get_segments(c).all.map(function(s){return s.d;}).join(\" \");}/*\r\n    private get_fillingSegments(c: Context): Partial<this[\"segments\"]> {\r\n        return this.get_segments(c).fillers;\r\n    }*/},{key:\"get_segments\",value:function get_segments(c){return this.get_segments_outer(c);}},{key:\"get_segments_outer\",value:function get_segments_outer(c){return this.get_segments_impl(c,true);}},{key:\"get_segments_inner\",value:function get_segments_inner(c){return this.get_segments_impl(c,false);}},{key:\"get_segments_impl\",value:function get_segments_impl(c,outer){var l=c.proxyObject;var v=this.get_view(c);var allNodes=l.allNodes;windoww.edge=l;var all=this.get_points(allNodes,outer,c);//const all: {size: GraphSize, view: LViewElement, ge: LGraphElement}[] = allNodes.map((ge) => { return { view: ge.view, size: ge.size, ge}});\nvar ret=[];var bm=v.bendingMode;var gapMode=v.edgeGapMode;var segmentSize=this.svgLetterSize(bm,false,true);var increase=segmentSize.first;var segment;/// grouping points according to SvgLetter\n// console.log(\"ex4 points\", {segments:ret.map(s=>printablesegment(s)), points:all.map(s=>printablesegment(s))});\nfor(var i=0;i<all.length-1;){// let start = all[i], end = all[i+increase];\nvar start=all[i];var endindex=i+increase<all.length-1?i+increase:all.length-1;var mid=all.slice(i+1,endindex).filter(function(e,i){return i%2===0;});var end=all[endindex];// makes sure the edge actually reaches his target even if there is an invalid amount of midnodes fot the current EdgeBendingMode\nif(i===endindex&&segment)start=segment.end;// segment = this.get_segmentv3(start, mid, end, getSvgLetter(i), i, segment, all);\nsegment=new EdgeSegment(start,mid,end,bm,gapMode,i,segment);// segment = this.get_segment(start.ge, start.size, start.view, end.ge, end.size, end.view, cut, v.bendingMode, mid, ret[ret.length -1], fillMode, segment);\nret.push(segment);i+=increase+1;// because increase index is already inserted at the end of prev segment\nif(increase!==segmentSize.others)increase=segmentSize.others;// if (longestLabel !== undefined && longest < s.length) { longest = s.length; longestindex = i; } todo: move to after snapping to borders\n}function printablesegment(s){var r={};for(var k in s){var _v2;var _v=s[k];_v=((_v2=_v)===null||_v2===void 0?void 0:_v2.__raw)||_v;if(typeof _v===\"object\")r[k]=JSON.parse(JSON.stringify(_v));else r[k]=_v;}return r;}var fillSegments=[];this.snapSegmentsToNodeBorders(c,v,ret,fillSegments);var longestLabel=c.data.longestLabel;this.setLabels(c,ret,allNodes);// console.log(\"getSegments() labeled:\", {main:ret, fillSegments});\nvar rett={all:[].concat(ret,fillSegments),segments:ret,fillers:fillSegments};/*switch(bm){\r\n            default: break;\r\n            case EdgeBendingMode.Bezier_QT:\r\n            case EdgeBendingMode.Bezier_CS:\r\n                rett.\r\n        }*/for(var _i3=0;_i3<rett.all.length;_i3++){var s=rett.all[_i3];s.makeD(_i3,gapMode);}var zoom=new GraphPoint(1,1);rett.head=this.headPos_impl(c,true,v.edgeHeadSize,rett.segments[rett.segments.length-1],zoom);rett.tail=this.headPos_impl(c,false,v.edgeTailSize,rett.segments[0],zoom);return rett;}},{key:\"setLabels\",value:function setLabels(c,segments,allNodes){// find longest segment\nvar longestindex=-1;var longest=0;for(var i=0;i<segments.length;i++){var s=segments[i];s.calcLength();if(longest<s.length){longest=s.length;longestindex=i;}s.isLongest=false;}if(longestindex>=0)segments[longestindex].isLongest=true;// apply labels\nvar _iterator8=_createForOfIteratorHelper(segments),_step8;try{for(_iterator8.s();!(_step8=_iterator8.n()).done;){var _s=_step8.value;_s.label=this.get_label_impl(c,_s,allNodes,segments);}}catch(err){_iterator8.e(err);}finally{_iterator8.f();}}},{key:\"snapSegmentsToNodeBorders\",value:function snapSegmentsToNodeBorders(c,v,ret,fillSegments){// snap segment start and end to a node border\nvar canCutStart=v.edgeStartStopAtBoundaries,canCutEnd=v.edgeEndStopAtBoundaries;var grid=undefined;// let fillSegments: EdgeSegment[] = [];\nvar gapMode=v.edgeGapMode;var bm=v.bendingMode;var ci;// cut i === 0 is cut regardless of gapmode.\nif(canCutStart){ci=GraphSize.closestIntersection(ret[0].start.size,ret[0].start.pt,(ret[0].bezier[0]||ret[0].end).pt,grid);if(ci)ret[0].start.pt=ci;/*\r\n            ret[0].start.pt =\r\n                GraphSize.closestIntersection(ret[0].start.size, ret[0].start.pt, (ret[0].bezier[0] || ret[0].end).pt, grid) as any\r\n                || Geom.closestPoint(ret[0].start.size, ret[0].start.pt);*/}// cut middle segments maybe\nvar prev;var curr=ret[0];//console.log(\"ex4 gap pre\", util.inspect(ret, true, 2, false));\n// if (gapMode === EdgeGapMode.gap) return;\nif(canCutStart||canCutEnd)// do the for below\nfor(var i=1;i<ret.length;i++){prev=ret[i-1];curr=ret[i];var doStartCut=void 0,doEndCut=void 0;switch(gapMode){/*\r\n                    case EdgeGapMode.arcFill:\r\n                    case EdgeGapMode.lineFill:\r\n                    case EdgeGapMode.autoFill:\r\n                        // same as gap, but will insert 1 more segment to fill the hole\r\n                        doStartCut = true;\r\n                        doEndCut = true;\r\n                        if (prev.end.pt.equals(curr.start.pt)) break;\r\n                        fillSegments.push(new EdgeFillSegment(\r\n                            prev.end,\r\n                            [\r\n                                {...prev.end, pt: EdgeSegment.invertLastBezierPt(prev.end.pt, (prev.bezier[prev.bezier.length-1] || prev.start).pt)},\r\n                                {...curr.start, pt: EdgeSegment.invertLastBezierPt(curr.start.pt, (curr.bezier[0] || curr.end).pt)}\r\n                            ],\r\n                            curr.start,\r\n                            bm, gapMode, 0, undefined));\r\n                            / *\r\n                            fillSegments.push(new FillEdgeSegment( // M <start_gap> C <bez1> <bez2> <end_gap>\r\n                               // <start_gap> = end of last seg (start of gap) <end_gap> = first of curr seg (end of gap)\r\n                            prev.end.pt,\r\n                            EdgeSegment.invertLastBezierPt(prev.end.pt, prev.bezier[prev.bezier.length-1].pt || prev.start.pt),\r\n                            EdgeSegment.invertLastBezierPt(curr.start.pt, curr.bezier[0].pt || curr.end.pt),\r\n                            curr.start.pt)* /\r\n\r\n                        break;*/case EdgeGapMode.gap:console.log(\"ex4 gap\",{curr:curr,prev:prev,csp:curr.start.pt,ret:ret});// just snap to vertex edge         prevSegment.endp and ret.startp\ndoEndCut=true;doStartCut=true;break;// average: todo: maybe rename in join (merges start-end at closest pt to both (avg), then snap on edge)\ncase\"closest\"://EdgeGapMode.closest:\n// does not work properly, i think i need to get next.end instead of curr.end, just disabled for now\nvar nextpt=(curr.bezier[0]||curr.end).pt;var prevpt=(prev.bezier[prev.bezier.length-1]||prev.start).pt;var midexternalpt=prevpt.add(nextpt,true);var midedgepoint=curr.start.size.tl().add(curr.start.size.br(),false).divide(2,false);// od average between the 2 points before and after that are not part of this edgepoint, then raw a line from there to center of ep, find that intersection.\nci=GraphSize.closestIntersection(curr.start.size,midedgepoint,midexternalpt,grid);doEndCut=doStartCut=false;if(canCutEnd&&ci)prev.end.pt=ci;if(canCutStart&&ci)curr.start.pt=ci;break;case EdgeGapMode.average:console.log(\"ex4 cut avg\",{curr:curr,prev:prev,csp:curr.start.pt});// first move to average of the 2 points in the gap, then snap to edge\ndoEndCut=true;doStartCut=true;// indipendent from cutStart, cutEnd.\n// they merge if just 1 of cutting sides are true. (and if they are both false we don't even enter the for loop)\ncurr.start.pt=curr.start.pt.add(prev.end.pt,false).divide(2,false);prev.end.pt=curr.start.pt.duplicate();// intentionally not the same pt because during snap to edge they can diverge again.\nprev.start.uncutPt=prev.start.pt;prev.end.uncutPt=prev.end.pt;console.log(\"ex4 cut avg end\",{curr:curr});break;// center: first move it to center of edgePoint/node, then snap to edge.\n// this mode might be as well deleted, it can be specified with anchor points\ncase EdgeGapMode.center:doEndCut=false;doStartCut=false;console.log(\"ex4 cut center\",{curr:curr,prev:prev,csp:curr.start.pt});curr.start.pt=curr.start.size.tl().add(curr.start.size.br(),false).divide(2,false);prev.end.pt=curr.start.pt.duplicate();// intentionally not the same pt because during snap to edge they can diverge again.\nprev.start.uncutPt=prev.start.pt;// only update them when point moves without being cut (average and center)\nprev.end.uncutPt=prev.end.pt;break;default:return Log.exDevv(\"unexpected EdgeGapMode:\"+gapMode);}if(canCutStart&&doStartCut){var _curr$start;console.log(\"ex4 cut start0\",{curr:curr});console.log(\"ex4 cutStart\",{curr:curr,bz:curr.bezier[0],end:curr.end,grid:grid,ssize:(_curr$start=curr.start)===null||_curr$start===void 0?void 0:_curr$start.size});var _nextpt=(curr.bezier[0]||curr.end).pt;ci=GraphSize.closestIntersection(curr.start.size,curr.start.pt,_nextpt,grid);if(ci)curr.start.pt=ci;// || Geom.closestPoint(curr.start.size, curr.start.pt);\n//if (gapMode === EdgeGapMode.average && prev) { prev.end.pt = curr.start.pt.add(prev.end.pt, false).divide(2, false); }\n}if(canCutEnd&&doEndCut&&prev){var _prevpt=(prev.bezier[prev.bezier.length-1]||prev.start).pt;ci=GraphSize.closestIntersection(prev.end.size,prev.end.pt,_prevpt,grid);if(ci)prev.end.pt=ci;// || Geom.closestPoint(prev.end.size, prev.end.pt);\n// if average: first do average between start anchor points non-snapped. then i snap both,\n// then i do average again, and since it might snap out, i get closestPoint to EdgePoint size\nif(gapMode===EdgeGapMode.average)prev.end.pt=curr.start.pt=Geom.closestPoint(curr.start.size,curr.start.pt.add(prev.end.pt,false).divide(2,false));}}// cut end of last segment regardless of gapMode\nif(canCutEnd){var prevendpt=curr.end.pt;ci=GraphSize.closestIntersection(curr.end.size,curr.end.pt,(curr.bezier[curr.bezier.length-1]||curr.start).pt,grid);if(ci)curr.end.pt=ci;//|| Geom.closestPoint(prev.end.size, prev.end.pt);\n}}},{key:\"get_edgeEnd\",value:function get_edgeEnd(context){return this.get_edgeEnd_outer(context);}},{key:\"get_edgeEnd_outer\",value:function get_edgeEnd_outer(c){// return this.get_outerGraph(c).translateSize(this.get_edgeEnd_inner(c), this.get_innerGraph(c));\nreturn this.get_outerGraph(c).translateSize(this.get_edgeEnd_inner(c),this.get_end(c).innerGraph);}},{key:\"get_edgeEnd_inner\",value:function get_edgeEnd_inner(c){return this.get_edgeStartEnd_inner(c,false);// return context.proxyObject.end?.size || new GraphPoint(0, 0);\n}},{key:\"get_midnodes\",value:function get_midnodes(context){// return LPointerTargetable.wrapAll(context.data.midnodes);\nreturn LPointerTargetable.wrapAll(context.data.subElements);}},{key:\"set_midnodes\",value:function set_midnodes(val,context){return SetFieldAction.new(context.data.id,\"midnodes\",val,'',true);}},{key:\"get_start\",value:function get_start(context){return LPointerTargetable.from(context.data.start);}},{key:\"get_end\",value:function get_end(context){return LPointerTargetable.from(context.data.end);}},{key:\"get_endFollow\",value:function get_endFollow(c){return c.data.id===LVoidEdge.endFollow;}},{key:\"get_startFollow\",value:function get_startFollow(c){return c.data.id===LVoidEdge.startFollow;}// // what in multieditor? needs to be moved in transientstuff?\n},{key:\"set_endFollow\",value:function set_endFollow(val,c){return this._set_start_endFollow(val,c,false);}},{key:\"set_startFollow\",value:function set_startFollow(val,c){return this._set_start_endFollow(val,c,true);}},{key:\"_set_start_endFollow\",value:function _set_start_endFollow(val,c,isStart){val=!!val;console.log(\"_set_start_endFollow\",{val:val,c:c,isStart:isStart});if(val){if(isStart)LVoidEdge.startFollow=c.data.id;else LVoidEdge.endFollow=c.data.id;if(!LVoidEdge.following){console.log(\"_set_start_endFollow event attached\");document.body.addEventListener(\"mousemove\",LVoidEdge.mousemove,false);LVoidEdge.following=true;LVoidEdge.followingContext=c;var $base=$(document.getElementById(isStart?c.data.start:c.data.end)||[]);var $deepAnchors=$base.find(\"[nodeid] .anchor\");var $anchors=$base.find(\".anchor\").not($deepAnchors);$anchors.addClass(\"valid-anchor\");$anchors.filter('[data-anchorname=\"'+((isStart?c.data.anchorStart:c.data.anchorEnd)||0)+'\"]').addClass(\"active-anchor\");var selector=\".Edge[nodeid='\"+(LVoidEdge.endFollow||LVoidEdge.startFollow)+\"']\";// [...document.querySelectorAll(selector)].map(e=>e.classList.add(\"no-transition-following\")); gets refreshed by react\ndocument.body.classList.add(\"no-transition-following\");}}else{if(LVoidEdge.following&&(isStart?LVoidEdge.startFollow:LVoidEdge.endFollow)===c.data.id){document.body.removeEventListener(\"mousemove\",LVoidEdge.mousemove,false);var _selector=\".Edge[nodeid='\"+(LVoidEdge.endFollow||LVoidEdge.startFollow)+\"']\";//[...document.querySelectorAll(selector)].map(e=>e.classList.remove(\"no-transition-following\"));\ndocument.body.classList.remove(\"no-transition-following\");if(isStart)LVoidEdge.startFollow=undefined;else LVoidEdge.endFollow=undefined;LVoidEdge.following=false;var _$base=$(document.getElementById(isStart?c.data.start:c.data.end)||[]);//const $deepAnchors = $base.find(\"[nodeid] .anchor\");\nvar _$anchors=_$base.find(\".anchor\");//.not($deepAnchors);\n_$anchors.removeClass([\"valid-anchor\",\"active-anchor\"]);}}//SetFieldAction.new(c.data, \"startFollow\", !!val, '', false);\nreturn true;}}],[{key:\"getCursorPos\",value:function getCursorPos(e0){return new Point(e0.pageX,e0.pageY);}/*public static getGCursorPos(e0: Event): GraphPoint {\r\n        return LVLoidEdge.getCursorPos(e0).subtract(svgsize.tl(), true).multiply(svgzoom) as any as GraphPoint;\r\n    }*/},{key:\"mousemove\",value:function mousemove(e0){var forcererendermode=true;if(forcererendermode){if(!LVoidEdge.following)return;if(!LVoidEdge.canForceUpdate)return;var c=LVoidEdge.followingContext;var g=c.proxyObject.graph;var _cursorPos=LVoidEdge.getCursorPos(e0);var gcursorpos=g.translateHtmlSize(_cursorPos);DVoidEdge.isFollowingCoords=gcursorpos;var component=GraphElementComponent.map[LVoidEdge.startFollow||LVoidEdge.endFollow];LVoidEdge.canForceUpdate=false;var timer=setTimeout(function(){LVoidEdge.canForceUpdate=true;},5000);var tn=transientProperties.node[c.data.id];for(var vid in tn.viewScores){// required to truly force an update\nvar tnv=tn.viewScores[vid];tnv.jsxOutput=undefined;tnv.usageDeclarations=undefined;tnv.shouldUpdate=true;}component.setState({forceupdate:new Date().getDate()},function(){LVoidEdge.canForceUpdate=true;clearTimeout(timer);});// component.forceUpdate(()=>{LVoidEdge.canForceUpdate = true; clearTimeout(timer)});\nreturn;}LVoidEdge.tmp++;var selector=\".Edge[nodeid='\"+(LVoidEdge.endFollow||LVoidEdge.startFollow)+\"']\";var root=document.querySelector(selector);if(!root)return;var paths=_toConsumableArray(root.querySelectorAll(\"path.full\"));var pathSegments=root.querySelectorAll(\"path.segment.preview\");// if (!paths.length) paths = pathSegments;\nvar pathSegmentContainers=_toConsumableArray(new Set(_toConsumableArray(pathSegments).map(function(e){return e.parentElement;})));var _iterator9=_createForOfIteratorHelper(pathSegmentContainers),_step9;try{for(_iterator9.s();!(_step9=_iterator9.n()).done;){var container=_step9.value;var se=_toConsumableArray(container.querySelectorAll(\"path.segment.preview\"));paths.push(se[LVoidEdge.endFollow?se.length-1:0]);}}catch(err){_iterator9.e(err);}finally{_iterator9.f();}var headTail=_toConsumableArray(root.querySelectorAll(LVoidEdge.endFollow?'.edgeHead':'.edgeTail'));var cursorPos=LVoidEdge.getCursorPos(e0);var segList;var _iterator10=_createForOfIteratorHelper(paths),_step10;try{for(_iterator10.s();!(_step10=_iterator10.n()).done;){var p=_step10.value;var svg=U.parentUntil(\"svg\",p);var svgsize=Size.of(svg);var svgzoom=new Point(1,1);// todo: check viewbox and css zoom\nvar gcursorPos=cursorPos.subtract(svgsize.tl(),true).multiply(svgzoom);segList=_toConsumableArray(p.getPathData());var lastSeg=_objectSpread({},segList[LVoidEdge.endFollow?segList.length-1:0]);switch(lastSeg.type){case'a':case'A':segList.push('fake new segment to get replaced instead of actual last segment which is A');lastSeg.type=\"L\";lastSeg.values=[gcursorPos.x,gcursorPos.y];break;case\"C\":case\"c\":// bezier curves, keep type just change last point\ncase\"Q\":case\"q\":case\"S\":case\"s\":case\"T\":case\"t\":lastSeg.values[lastSeg.values.length-2]=gcursorPos.x;lastSeg.values[lastSeg.values.length-1]=gcursorPos.y;break;case\"M\":case\"m\":lastSeg.type=LVoidEdge.endFollow?\"L\":\"M\";lastSeg.values=[gcursorPos.x,gcursorPos.y];break;case\"V\":case\"v\":// stuff forced to become a line\ncase\"H\":case\"h\":case\"L\":case\"l\":case\"Z\":case\"z\":lastSeg.type=\"L\";lastSeg.values=[gcursorPos.x,gcursorPos.y];break;}segList[LVoidEdge.endFollow?segList.length-1:0]=lastSeg;if(LVoidEdge.tmp%20===0)console.log(\"svg set path data,\",{segList:segList,oldSeglist:p.getPathData(),p:p});p.setPathData(segList);}}catch(err){_iterator10.e(err);}finally{_iterator10.f();}var _iterator11=_createForOfIteratorHelper(headTail),_step11;try{for(_iterator11.s();!(_step11=_iterator11.n()).done;){var ht=_step11.value;var _svg=U.parentUntil(\"svg\",ht);var _svgsize=Size.of(_svg);var _svgzoom=new Point(1,1);// todo: check viewbox and css zoom\nvar _gcursorPos=cursorPos.subtract(_svgsize.tl(),true).multiply(_svgzoom);var rotation=void 0;var lastPt=segList&&segList[LVoidEdge.endFollow?segList.length-2:1].values;if(lastPt){var m=_gcursorPos.getM(new Point(lastPt[LVoidEdge.endFollow?lastPt.length-2:1],lastPt[LVoidEdge.endFollow?lastPt.length-1:0]));if(Number.POSITIVE_INFINITY===m)rotation=Geom.degToRad(90);else if(Number.NEGATIVE_INFINITY===m)rotation=Geom.degToRad(270);else rotation=Math.atan(m);if(lastPt[LVoidEdge.endFollow?lastPt.length-2:1]>_gcursorPos.x)rotation-=Geom.degToRad(180);}else{rotation=0;}var headSize=Size.of(ht);var headPos=_gcursorPos.subtract({x:headSize.w/2,y:headSize.h/2},true);//.subtract({x:Math.cos(rotation)*headSize.w/2, y: -Math.sin(rotation)*headSize.h/2}, true);\nif(LVoidEdge.tmp%20===0)console.log(\"_set_start_endFollow move head\",{selector:LVoidEdge.endFollow?'.edgeHead':'.edgeTail',headTail:headTail,root:root});ht.style.transform='translate('+headPos.x+\"px, \"+headPos.y+\"px) rotate(\"+rotation+\"rad)\";}}catch(err){_iterator11.e(err);}finally{_iterator11.f();}}}]);return LVoidEdge;}(LGraphElement),_class30.subclasses=[],_class30._extends=[],_class30.startFollow=undefined,_class30.endFollow=undefined,_class30.following=false,_class30.followingContext=void 0,_class30.tmp=1,_class30.canForceUpdate=true,_class30))||_class29);RuntimeAccessibleClass.set_extend(DGraphElement,DVoidEdge);RuntimeAccessibleClass.set_extend(LGraphElement,LVoidEdge);export var DEdge=(_dec16=RuntimeAccessible('DEdge'),_dec16(_class31=(_class32=/*#__PURE__*/function(_DVoidEdge){_inherits(DEdge,_DVoidEdge);var _super18=_createSuper(DEdge);function DEdge(){var _this22;_classCallCheck(this,DEdge);for(var _len16=arguments.length,args=new Array(_len16),_key16=0;_key16<_len16;_key16++){args[_key16]=arguments[_key16];}_this22=_super18.call.apply(_super18,[this].concat(args));_this22.id=void 0;_this22.graph=void 0;_this22.model=void 0;_this22.isSelected=void 0;_this22.subElements=void 0;_this22.state=void 0;_this22.start=void 0;_this22.end=void 0;_this22.__isDEdge=void 0;_this22.__isDVoidEdge=void 0;_this22.midnodes=void 0;return _this22;}// DVoidEdge\n// static singleton: LGraphElement;\n// static logic: typeof LGraphElement;\n// static structure: typeof DGraphElement;\n// isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\n// containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\nreturn DEdge;}(DVoidEdge),_class32.subclasses=[],_class32._extends=[],_class32))||_class31);export var LEdge=(_dec17=RuntimeAccessible('LEdge'),_dec17(_class33=(_class34=/*#__PURE__*/function(_LVoidEdge){_inherits(LEdge,_LVoidEdge);var _super19=_createSuper(LEdge);function LEdge(){var _this23;_classCallCheck(this,LEdge);for(var _len17=arguments.length,args=new Array(_len17),_key17=0;_key17<_len17;_key17++){args[_key17]=arguments[_key17];}_this23=_super19.call.apply(_super19,[this].concat(args));_this23.__raw=void 0;_this23.id=void 0;_this23.graph=void 0;_this23.model=void 0;_this23.subElements=void 0;_this23._state=void 0;_this23.start=void 0;_this23.end=void 0;_this23.midnodes=void 0;_this23.__isLEdge=void 0;_this23.__isLVoidEdge=void 0;return _this23;}// static singleton: LGraphElement;\n// static logic: typeof LGraphElement;\n// static structure: typeof DGraphElement;\n_createClass(LEdge,[{key:\"isSelected\",value:// isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\nfunction isSelected(forUser){return this.wrongAccessMessage(\"node.isSelected()\");}// containedIn!: LGraphElement;\n// LMap;\n}]);return LEdge;}(LVoidEdge),_class34.subclasses=[],_class34._extends=[],_class34))||_class33);RuntimeAccessibleClass.set_extend(DVoidEdge,DEdge);RuntimeAccessibleClass.set_extend(LVoidEdge,LEdge);export var DExtEdge=(_dec18=RuntimeAccessible('DExtEdge'),Leaf(_class35=_dec18(_class35=(_class36=/*#__PURE__*/function(_DEdge){_inherits(DExtEdge,_DEdge);var _super20=_createSuper(DExtEdge);function DExtEdge(){var _this24;_classCallCheck(this,DExtEdge);for(var _len18=arguments.length,args=new Array(_len18),_key18=0;_key18<_len18;_key18++){args[_key18]=arguments[_key18];}_this24=_super20.call.apply(_super20,[this].concat(args));_this24.id=void 0;_this24.graph=void 0;_this24.model=void 0;_this24.isSelected=void 0;_this24.subElements=void 0;_this24.state=void 0;_this24.start=void 0;_this24.end=void 0;_this24.__isDExtEdge=void 0;_this24.__isDEdge=void 0;_this24.__isDVoidEdge=void 0;return _this24;}// etends DEdge\n// static singleton: LGraphElement;\n// static logic: typeof LGraphElement;\n// static structure: typeof DGraphElement;\n// isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\n// containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\n/*\r\n        public static new(model: DGraph[\"model\"], parentNodeID: DGraphElement[\"father\"], graphID: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"], size?: GraphSize): DExtEdge {\r\n            return new Constructors(new DExtEdge('dwc')).DPointerTargetable().DGraphElement(model, parentNodeID, graphID, nodeID)\r\n                .DVoidEdge().DEdge().DExtEdge().end();\r\n        }*/return DExtEdge;}(DEdge),_class36.subclasses=[],_class36._extends=[],_class36))||_class35)||_class35);export var LExtEdge=(_dec19=RuntimeAccessible('LExtEdge'),_dec19(_class37=(_class38=/*#__PURE__*/function(_LEdge){_inherits(LExtEdge,_LEdge);var _super21=_createSuper(LExtEdge);function LExtEdge(){var _this25;_classCallCheck(this,LExtEdge);for(var _len19=arguments.length,args=new Array(_len19),_key19=0;_key19<_len19;_key19++){args[_key19]=arguments[_key19];}_this25=_super21.call.apply(_super21,[this].concat(args));_this25.__raw=void 0;_this25.id=void 0;_this25.graph=void 0;_this25.model=void 0;_this25.subElements=void 0;_this25._state=void 0;_this25.start=void 0;_this25.end=void 0;_this25.__isLExtEdge=void 0;_this25.__isLEdge=void 0;_this25.__isLVoidEdge=void 0;return _this25;}// static singleton: LGraphElement;\n// static logic: typeof LGraphElement;\n// static structure: typeof DGraphElement;\n_createClass(LExtEdge,[{key:\"isSelected\",value:// isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\nfunction isSelected(forUser){return this.wrongAccessMessage(\"node.isSelected()\");}// containedIn!: LGraphElement;\n// LMap;\n}]);return LExtEdge;}(LEdge),_class38.subclasses=[],_class38._extends=[],_class38))||_class37);RuntimeAccessibleClass.set_extend(DEdge,DExtEdge);RuntimeAccessibleClass.set_extend(LEdge,LExtEdge);export var DRefEdge=(_dec20=RuntimeAccessible('DRefEdge'),Leaf(_class39=_dec20(_class39=(_class40=/*#__PURE__*/function(_DEdge2){_inherits(DRefEdge,_DEdge2);var _super22=_createSuper(DRefEdge);function DRefEdge(){var _this26;_classCallCheck(this,DRefEdge);for(var _len20=arguments.length,args=new Array(_len20),_key20=0;_key20<_len20;_key20++){args[_key20]=arguments[_key20];}_this26=_super22.call.apply(_super22,[this].concat(args));_this26.start=void 0;_this26.end=void 0;_this26.isSelected=void 0;_this26.__isDRefEdge=void 0;return _this26;}// extends DEdge\n/*\r\n        public static new(model: DGraph[\"model\"], parentNodeID: DGraphElement[\"father\"], graphID: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"]): DRefEdge {\r\n            return new Constructors(new DRefEdge('dwc')).DPointerTargetable().DGraphElement(model, parentNodeID, graphID, nodeID)\r\n                .DVoidEdge().DEdge().DRefEdge().end();\r\n        }*/return DRefEdge;}(DEdge),_class40.subclasses=[],_class40._extends=[],_class40))||_class39)||_class39);export var LRefEdge=(_dec21=RuntimeAccessible('LRefEdge'),_dec21(_class41=(_class42=/*#__PURE__*/function(_LEdge2){_inherits(LRefEdge,_LEdge2);var _super23=_createSuper(LRefEdge);function LRefEdge(){var _this27;_classCallCheck(this,LRefEdge);for(var _len21=arguments.length,args=new Array(_len21),_key21=0;_key21<_len21;_key21++){args[_key21]=arguments[_key21];}_this27=_super23.call.apply(_super23,[this].concat(args));_this27.start=void 0;_this27.end=void 0;_this27.__isLRefEdge=void 0;return _this27;}// __raw!: DRefEdge;\nreturn LRefEdge;}(LEdge),_class42.subclasses=[],_class42._extends=[],_class42))||_class41);RuntimeAccessibleClass.set_extend(DEdge,DRefEdge);RuntimeAccessibleClass.set_extend(LEdge,LRefEdge);// for edges without a modelling element\n/*\r\n\r\nlet a = `DExtEdge, DRefEdge, DVoidEdge, LGraphVertex, LRefEdge, LEdgePoint, DVoidVertex, DGraphVertex, DEdgePoint,\r\n DVertex, DEdge, LVertex, LGraph, DGraph, LVoidVertex, LVoidEdge, LEdge, LGraphElement, LExtEdge, DGraphElement`;\r\n  // // ... get from export in index.ts\r\na = a.replaceAll(',,', \",\")\r\nlet aa = a.split(\",\").map(a => a.trim().substring(1));\r\n\r\nfunction onlyUnique(value, index, self) { return self.indexOf(value) === index; }\r\n\r\naa = aa.filter(onlyUnique).filter( a=> !!a)\r\nlet r = aa.filter(onlyUnique).filter( a=> !!a).map( a=> `export type W${a} = getWParams<L${a}, D${a}>;`).join('\\n')\r\ndocument.body.innerText = r;\r\n*/ // getWParams<LGraphVertex, DGraphVertex>;\nconsole.warn('ts loading graphDataElement');","map":{"version":3,"names":["isDeepStrictEqual","BEGIN","Constructors","CoordinateMode","Debug","DModelElement","DPointerTargetable","DUser","EdgeBendingMode","END","GraphElementComponent","GraphPoint","GraphSize","Leaf","Log","LPointerTargetable","MixOnlyFuncs","Node","Point","Pointers","RuntimeAccessible","RuntimeAccessibleClass","SetFieldAction","ShortAttribETypes","Size","store","TargetableProxyHandler","transientProperties","U","Uarr","windoww","EdgeGapMode","Geom","jsx","_jsx","jsxs","_jsxs","console","warn","DGraphElement","_dec","_class","_class2","_DPointerTargetable","_inherits","_super","_createSuper","_this","_classCallCheck","_len","arguments","length","args","Array","_key","call","apply","concat","id","graph","model","isSelected","subElements","state","father","x","y","zIndex","w","h","view","favoriteNode","edgesIn","edgesOut","anchors","_createClass","key","value","_new","htmlindex","parentNodeID","graphID","nodeID","a","b","undefined","end","subclasses","_extends","LGraphElement","_dec2","_class3","_class4","_LPointerTargetable","_super2","_this2","_len2","_key2","__raw","_state","allSubNodes","width","height","z","__info_of_z__","type","EInt","txt","__info_of_zIndex__","zoom","html","size","position","htmlSize","htmlPosition","component","vertex","__info__of__vertex","__info__of__favoriteNode","EBoolean","startPoint","endPoint","__info_of__startPoint","children","__info_of__endPoint","__info_of__graph","innerGraph","__info_of__innnerGraph","outerGraph","__info_of__outerGraphGraph","__info_of__graphAncestors","graphAncestors","__info_of__anchors","__info_of__edgesIn","__info_of__edgesOut","__info_of__edgesStart","__info_of__edgesEnd","outerSize","__info_of__outerSize","innerSize","__info_of__innerSize","__info_of__size","assignEdgeAnchor","__info_of__assignEdgeAnchor","__info_of__isselected","__info_of__select","__info_of__deselect","__info_of__toggleSelect","__info_of__isSelected","get_graph","context","get_innerGraph","get_anchors","c","data","set_anchors","v","isArray","ee","ka","kk","isNaN","new","get_edgesIn","fromArr","get_edgesOut","set_edgesIn","val","set_edgesOut","get_edgesStart","get_edgesEnd","set_edgesStart","set_edgesEnd","_defaultGetter","k","__defaultGetter","get_view","_defaultSetter","__defaultSetter","get_graphAncestors","current","proxyObject","next","ret","extends","className","DGraph","cname","push","get_outerGraph","wrap","get_vertex","lcurrent","fromPointer","dcurrent","DVertex","DVoidVertex","DGraphVertex","fromD","exDev","_lcurrent","exDevv","_dcurrent","get_x","get_size","set_x","set_size","get_y","set_y","get_w","set_w","get_h","set_h","get_width","set_width","get_height","set_height","get_position","set_position","get_sizeold","get_component","map","_transientProperties$","_this$get_component","node","mainView","from","props","set_view","eDevv","getSize","outer","canTriggerSet","wrongAccessMessage","get_getSize","_this3","get_innerSize","get_outerSize","r","get_innerSize_impl","_this$get_component2","lightMode","log","DEdge","DVoidEdge","nosize","get_htmlSize","coord","DEdgePoint","viewVertexSize","def","defaultVSize","currentCoordType","decodePosCoords","translateSize","actualSize","of","updateSize","isOldElement","clonedCounter","adaptWidth","adaptHeight","size0","testmode","absolute","encodePosCoords","epdata","get_html","$","set_html","cannotSet","set_htmlSize","get_htmlPosition","tl","set_htmlPosition","get_zIndex","set_zIndex","get_z","set_z","get_subElements","_toConsumableArray","Set","set_subElements","eDev","pointers","equals","idlookup","getState","arrdiff","arrayDifference","_iterator","_createForOfIteratorHelper","removed","_step","s","n","done","oldsubelementid","subelement","err","e","f","_iterator2","added","_step2","newsubelementid","get_isResized","isResized","set_isResized","get_model","modelElementId","lModelElement","get_allSubNodes","tocheck","checked","dblcheck","_iterator3","_step3","newtocheck","_iterator4","_step4","ptr","fistContainer","subnode","se","_iterator5","_step5","arrayMergeInPlace","Object","keys","get_assignEdgeAnchor","anchorName","LVoidEdge","startFollow","de","start","le","anchorStart","endFollow","anchorEnd","get_events","tn","mainview","otherViews","stackViews","allviews","reverse","keep_for_closure_original_funcs","_iterator6","_step6","dv","objectMergeInPlace","events","lastContext","viewScores","evalContext","_loop","_keys","_i","_len3","_params","_key3","_ret","get_father","set_father","select","forUser","deselect","toggleSelected","get_select","_objectSpread","get_deselect","get_toggleSelected","_this4","get_isSelected","set_isSelected","get_startPoint","get_startEndPoint","get_endPoint","isStart","offset","isPercentage","add","getNodeId","o","_node","set_extend","_dec3","_class5","_class6","_DGraphElement","_super3","_this5","_len4","_key4","parentgraphID","DGraph_makeID","getNodes","dmp","out","$allnodes","matchedids","d","matchedidmap","objectFromArrayValues","allnodesarr","filternode","_d$dataset","_d$dataset2","dataset","dataid","$matched","filter","$notMatched","defaultEdgePointSize","defaultVertexSize","LGraph","_dec4","_class7","_class8","_LGraphElement","_super4","_this6","_len5","_key5","graphSize","__info_of__zoom","label","__info_of__offset","__info_of__graphSize","__info_of__translateSize","__info_of__translateHtmlSize","get_offset","set_offset","get_zoom","toGraphSize","get_coord","_this7","translateHtmlSize","set_zoom","get_translateHtmlSize","_this8","graphHtmlSize","subtract","multiply","get_translateSize","hasOwnProperty","ex","ancestors","indexOf","_iterator7","_step7","g","contains","elem","get_contains","targetid","_dec5","_class9","_class10","_DGraphElement2","_super5","_this9","_len6","_key6","LVoidVertex","_dec6","_class11","_class12","_LGraphElement2","_super6","_this10","_len7","_key7","_dec7","_class13","_class14","_DVoidVertex","_super7","_this11","_len8","_key8","__isDEdgePoint","LEdgePoint","_dec8","_class15","_class16","_LVoidVertex","_super8","_this12","_len9","_key9","__isLEdgePoint","edge","__info_of__edge","get_edge","set_edge","sp0","ep0","sp","ep","decodeCoords","mode","edgePointCoordMode","encodeCoords","relativePercent","relativeOffset","relativeOffsetStart","relativeOffsetEnd","useStart","useEnd","xIsAbsolute","yIsAbsolute","offsetsp","offsetep","divide","testCoords","range","_i2","_arr","i","j","s0","s1","s00","error","toFixed","join","diff","_dec9","_class17","_class18","_DGraphElement3","_super9","_this13","_len10","_key10","__isDVertex","LVertex","_dec10","_class19","_class20","_LVoidVertex2","_super10","_this14","_len11","_key11","__isLVertex","_dec11","_class21","_class22","_DGraphElement4","_super11","_this15","_len12","_key12","__isDGraph","__isDGraphVertex","LG","_LGraph","_super12","LV","_LVertex","_super13","Mixed","LGraphVertex","_dec12","_class23","_class24","_Mixed","_super14","_this16","_len13","_key13","__isLGraph","__isLGraphVertex","_dec13","_class25","_class26","_DGraphElement5","_super15","_this17","_len14","_key14","__isDVoidEdge","midPoints","midnodes","longestLabel","labels","new2","setter","isFollowingCoords","EdgeSegment","_dec14","_class27","mid","svgLetter","gapMode","index","prevSegment","prev","bezier","dpart","m","rad","radLabels","isLongest","Bezier_QT","addBezierPoint","Bezier_CS","Line","Bezier_quadratic","Bezier_cubic","Elliptical_arc","prevedgemakerbezier","mirroredBezier","pt","invertLastBezierPt","uncutPt","makeD","getM","mToRad","Math","atan","bezierpts","finalpart","p","bezierptsUncut","finalpartUncut","bendingMode","calcLength","distanceFromPoint","vector","EdgeFillSegment","_EdgeSegment","_super16","center","average","gap","_get","_getPrototypeOf","prototype","_dec15","_class29","_class30","_LGraphElement3","_super17","_this18","_len15","_key15","__isLVoidEdge","allNodes","__info_of__longestLabel","readType","writeType","__info_of__label","__info_of__labels","__info_of__allNodes","segments","segments_inner","segments_outer","__info_of__segments","__info_of__d","EString","__info_of__anchorStart","isEdge","__info_of__anchorEnd","__info_of__endFollow","__info_of__startFollow","get_label","get_longestLabel","set_label","set_longestLabel","get_labels","set_labels","headPos_impl","isHead","headSize0","segment0","zoom0","segment","get_segments","tmp","edgeHeadSize","edgeTailSize","headPos","useBezierPoints","x4headsize","secondIntersection","segmentDistance","sqrt","pow","safeDistance","max","closestIntersection","exx","tailPos","get_headPos","_this19","headSize","get_tailPos","_this20","get_allNodes","get_start","get_midnodes","get_end","get_midPoints","addMidPoint","get_addMidPoint","_this21","impl_addMidPoints","set_midPoints","get_label_impl","nodes","l","labelmaker","labelmakerfunc","get_startPoint_Outer","get_endPoint_Outer","get_startPoint_inner","get_endPoint_inner","get_edgeStartEnd_inner","svgLetterSize","addM","doublingMidPoints","first","others","get_points_impl","getAnchorOffset","$factor","all","flatMap","ge","dge","base","rets","rete","debug","anchor_e","anchor_s","anchor","edgeStartOffset","edgeStartOffset_isPercentage","seg","get_pointsDebug","get_points","get_points_outer","get_points_inner","get_d","get_segments_outer","get_segments_impl","get_segments_inner","bm","edgeGapMode","segmentSize","increase","endindex","slice","printablesegment","_v2","JSON","parse","stringify","fillSegments","snapSegmentsToNodeBorders","setLabels","rett","fillers","head","tail","longestindex","longest","_iterator8","_step8","canCutStart","edgeStartStopAtBoundaries","canCutEnd","edgeEndStopAtBoundaries","grid","ci","curr","doStartCut","doEndCut","csp","nextpt","prevpt","midexternalpt","midedgepoint","br","duplicate","_curr$start","bz","ssize","closestPoint","prevendpt","get_edgeEnd","get_edgeEnd_outer","get_edgeEnd_inner","wrapAll","set_midnodes","get_endFollow","get_startFollow","set_endFollow","_set_start_endFollow","set_startFollow","following","document","body","addEventListener","mousemove","followingContext","$base","getElementById","$deepAnchors","find","$anchors","not","addClass","selector","classList","removeEventListener","remove","removeClass","getCursorPos","e0","pageX","pageY","forcererendermode","canForceUpdate","cursorPos","gcursorpos","timer","setTimeout","vid","tnv","jsxOutput","usageDeclarations","shouldUpdate","setState","forceupdate","Date","getDate","clearTimeout","root","querySelector","paths","querySelectorAll","pathSegments","pathSegmentContainers","parentElement","_iterator9","_step9","container","headTail","segList","_iterator10","_step10","svg","parentUntil","svgsize","svgzoom","gcursorPos","getPathData","lastSeg","values","oldSeglist","setPathData","_iterator11","_step11","ht","rotation","lastPt","Number","POSITIVE_INFINITY","degToRad","NEGATIVE_INFINITY","style","transform","_dec16","_class31","_class32","_DVoidEdge","_super18","_this22","_len16","_key16","__isDEdge","LEdge","_dec17","_class33","_class34","_LVoidEdge","_super19","_this23","_len17","_key17","__isLEdge","DExtEdge","_dec18","_class35","_class36","_DEdge","_super20","_this24","_len18","_key18","__isDExtEdge","LExtEdge","_dec19","_class37","_class38","_LEdge","_super21","_this25","_len19","_key19","__isLExtEdge","DRefEdge","_dec20","_class39","_class40","_DEdge2","_super22","_this26","_len20","_key20","__isDRefEdge","LRefEdge","_dec21","_class41","_class42","_LEdge2","_super23","_this27","_len21","_key21","__isLRefEdge"],"sources":["C:/d/Programming/web/jodel-mde/src/model/dataStructure/GraphDataElements.tsx"],"sourcesContent":["// import {Mixin} from \"ts-mixer\";\r\nimport {isDeepStrictEqual} from \"util\";\r\nimport {\r\n    BEGIN,\r\n    Constructors,\r\n    CoordinateMode,\r\n    Debug,\r\n    Dictionary,\r\n    DModelElement,\r\n    DocString,\r\n    DPointerTargetable,\r\n    DState,\r\n    DUser,\r\n    DViewElement,\r\n    EdgeBendingMode,\r\n    END,\r\n    EPSize,\r\n    getWParams,\r\n    GObject,\r\n    GraphElementComponent,\r\n    GraphPoint,\r\n    GraphSize,\r\n    Info,\r\n    Leaf,\r\n    LModelElement,\r\n    Log,\r\n    LogicContext,\r\n    LPointerTargetable,\r\n    LViewElement,\r\n    MixOnlyFuncs,\r\n    Node,\r\n    Pack1,\r\n    PackArr,\r\n    Point,\r\n    Pointer,\r\n    Pointers,\r\n    PrimitiveType,\r\n    RuntimeAccessible,\r\n    RuntimeAccessibleClass,\r\n    SetFieldAction,\r\n    ShortAttribETypes,\r\n    Size,\r\n    store,\r\n    TargetableProxyHandler,\r\n    transientProperties,\r\n    U,\r\n    Uarr,\r\n    windoww\r\n} from \"../../joiner\";\r\nimport type {RefObject} from \"react\";\r\nimport type {SVGPathElementt, SVGPathSegment} from '../../common/libraries/pathdata';\r\nimport {EdgeGapMode, InitialVertexSize} from \"../../joiner/types\";\r\nimport {labelfunc} from \"../../joiner/classes\";\r\nimport {Geom} from \"../../common/Geom\";\r\n\r\n\r\nconsole.warn('ts loading graphDataElement');\r\n\r\n@Node\r\n@RuntimeAccessible('DGraphElement')\r\nexport class DGraphElement extends DPointerTargetable {\r\n    // static _super = DPointerTargetable;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraphElement;\r\n    // static logic: typeof LGraphElement;\r\n    // static structure: typeof DGraphElement;\r\n    id!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model?: Pointer<DModelElement, 0, 1, LModelElement>;\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n    state!: GObject; // DMap\r\n    father!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    x!: number;\r\n    y!: number;\r\n    zIndex: number = 100;\r\n    w!: number;\r\n    h!: number;\r\n    // width: number = 300;\r\n    // height: number = 400;\r\n    view!: Pointer<DViewElement, 1, 1, LViewElement>;\r\n    favoriteNode!: boolean;\r\n    edgesIn!: Pointer<DEdge>[];\r\n    edgesOut!: Pointer<DEdge>[];\r\n    anchors!: Dictionary<string, GraphPoint/* as % of node size.*/>;\r\n\r\n\r\n    public static new(htmlindex: number, model: DGraphElement[\"model\"]|null|undefined, parentNodeID: DGraphElement[\"father\"],\r\n                      graphID: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"]|undefined, a?: any, b?:any, ...c:any): DGraphElement {\r\n        return new Constructors(new DGraphElement('dwc'), parentNodeID, true, undefined, nodeID)\r\n            .DPointerTargetable()\r\n            .DGraphElement(model, graphID, htmlindex).end();\r\n    }\r\n\r\n}\r\n@RuntimeAccessible('LGraphElement')\r\nexport class LGraphElement<Context extends LogicContext<DGraphElement> = any, C extends Context = Context> extends LPointerTargetable {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static getNodeId<L extends LGraphElement, D extends DGraphElement>(o?:L | D | Pointer<D> | LModelElement | DModelElement | Pointer<DModelElement>): Pointer<D> {\r\n        if (!o) return undefined as any;\r\n        let node: any = o;\r\n        // from L to D\r\n        // let cname = (node.__raw || node).className;\r\n        // from DModelE to LGraphE\r\n        if (RuntimeAccessibleClass.extends((o as any).className, \"DModelElement\")) node = LPointerTargetable.from(o as DModelElement).node as LGraphElement;\r\n        return (typeof node === \"string\") ? node : node?.id;\r\n    }\r\n    // static singleton: LGraphElement;\r\n    // static logic: typeof LGraphElement;\r\n    // static structure: typeof DGraphElement;\r\n    __raw!: DGraphElement;\r\n    id!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    father!: LGraphElement;\r\n    graph!: LGraph; // todo: can be removed and accessed by navigating .father\r\n    model?: LModelElement;\r\n    // protected isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>; //  & ((forUser?: Pointer<DUser>) => boolean);\r\n\r\n    // containedIn?: LGraphElement;\r\n    subElements!: LGraphElement[]; // shallow, direct subelements\r\n    _state!: GObject<\"proxified\">; // LMap;\r\n    allSubNodes!: LGraphElement[]; // deep, nested subelements\r\n    x!: number;\r\n    y!: number;\r\n    width!: number;\r\n    height!: number\r\n\r\n    z!:number;\r\n    zIndex!: number;\r\n    __info_of_z__: Info = {type:ShortAttribETypes.EInt, txt: \"alias for zIndex\"};\r\n    __info_of_zIndex__: Info = {type:ShortAttribETypes.EInt,\r\n        txt: \"Determine the z-axis priority of the element.<br/>Higher value tende to overlap other elements.<br/>Lower value tends to be on background.\"};\r\n    zoom!: GraphPoint;\r\n    html?: Element;\r\n\r\n    // fittizi\r\n    w!:number;\r\n    h!:number;\r\n    size!: GraphSize;\r\n    position!: GraphPoint;\r\n    htmlSize!: Size; // size and position in global document coordinates.\r\n    htmlPosition!: Point;\r\n    view!: LViewElement;\r\n    component!: GraphElementComponent;\r\n    favoriteNode!: boolean;\r\n    vertex?: LVoidVertex;\r\n    __info__of__vertex: Info = {type: \"LVoidVertex\", txt: \"the foremost vertex containing this graphElement, or undefiened.\"}\r\n    __info__of__favoriteNode: Info = {type: ShortAttribETypes.EBoolean,\r\n        txt: \"<span>Indicates this is the primarly used (by default) node to refer to a modelling element that might have multiple representations.\" +\r\n            \"<br> Can be used as favorite target for edges or other.\"}\r\n\r\n    startPoint!: GraphPoint;\r\n    endPoint!: GraphPoint;\r\n    __info_of__startPoint: Info = {type: \"GraphPoint\", txt:<span>Where the outgoing edges should start their paths.\r\n            <br/>Obtained by combining anchoring point offset specified in view, before snapping to a Vertex border.\r\n            <br/>Defaults in outer coordinates.</span>};\r\n    __info_of__endPoint: Info = {type: \"GraphPoint\", txt:<span>Where the incoming edges should end their paths.\r\n            <br/>Obtained by combining anchoring point offset specified in view, before snapping to a Vertex border.\r\n            <br/>Defaults in outer coordinates.</span>};\r\n\r\n    __info_of__graph: Info = {type:\"\", txt:\"\"};\r\n    innerGraph!: LGraph;\r\n    __info_of__innnerGraph: Info = {type:\"\", txt:\"\"};\r\n    outerGraph!: LGraph;\r\n    __info_of__outerGraphGraph: Info = {type:\"\", txt:\"\"};\r\n    get_graph(context: Context): LGraph { return this.get_innerGraph(context); }\r\n\r\n    __info_of__graphAncestors: Info = {type:\"LGraph[]\",\r\n        txt:\"<span>collection of the stack of Graphs containing the current element where [0] is the most nested graph, and last is root graph.</span>\"};\r\n    graphAncestors!: LGraph[];\r\n\r\n    anchors!: Dictionary<string, GraphPoint/* as % of node size.*/>;\r\n    __info_of__anchors: Info = {type:\"Dictionary<string, point>\", txt: <div>A named list of all anchor points where edges are allowed to land or depart from.<br/>\r\n            {/*When reading it is in absolute sizes.<br/>*/}\r\n            When writing it must be done in percentages, with the same rules as node.state.</div>}\r\n    get_anchors(c: Context): this[\"anchors\"]{ return c.data.anchors; }\r\n    set_anchors(v: this[\"anchors\"], c: Context):boolean{\r\n        if (v !== undefined && (typeof v !== \"object\" || Array.isArray(v))){\r\n            Log.ee('cannot set anchors: invalid value provided');\r\n            return true;\r\n        }\r\n        if (v){ // if !v it means clear all anchors?\r\n            for (let ka in v){//for each anchor\r\n                if (!v[ka]) continue;\r\n\r\n                if (c.data.anchors[ka]) {\r\n                    for (let kk in v[ka]) { //for each key within an anchor (x, y, w, h)\r\n                        // if i was attempting to set a partial size, complete it with the old size values.\r\n                        if ((v[ka][kk] === undefined) && (c.data.anchors[ka][kk] !== undefined)) v[ka][kk] = c.data.anchors[ka][kk];\r\n                    }\r\n                }\r\n                if (v[ka].x === undefined || isNaN(v[ka].x)) v[ka].x = 0.5;\r\n                if (v[ka].y === undefined || isNaN(v[ka].y)) v[ka].y = 0.5;\r\n                // if (v[ka].w === undefined || isNaN(v[ka].w)) v[ka].w = 5;\r\n                // if (v[ka].h === undefined || isNaN(v[ka].h)) v[ka].h = 5;\r\n            }\r\n        }\r\n        SetFieldAction.new(c.data, \"anchors\", v, '+=', false);\r\n        return true; }\r\n\r\n    edgesIn!: LVoidEdge[];\r\n    edgesOut!: LVoidEdge[];\r\n    __info_of__edgesIn: Info = {type:\"LEdge[]\", txt:<div>Edges incoming into this element. <code>this.edgesOut[i].end</code> always equals to <code>this</code>.</div>}\r\n    __info_of__edgesOut: Info = {type:\"LEdge[]\", txt:<div>Edges outgoing from this element. <code>this.edgesIn[i].start</code> always equals to <code>this</code>.</div>}\r\n    __info_of__edgesStart: Info = {type:\"LEdge[]\", txt:<div>Alias for this.edgesOut</div>}\r\n    __info_of__edgesEnd: Info = {type:\"LEdge[]\", txt:<div>Alias for this.edgesIn</div>}\r\n    public get_edgesIn(context: Context): this[\"edgesIn\"] { return LPointerTargetable.fromArr(context.data.edgesIn); }\r\n    public get_edgesOut(context: Context): this[\"edgesOut\"]  { return LPointerTargetable.fromArr(context.data.edgesOut); }\r\n    public set_edgesIn(val: PackArr<LVoidEdge>, c: Context): boolean { return SetFieldAction.new(c.data.id, \"edgesIn\", Pointers.fromArr(val), '', true); }\r\n    public set_edgesOut(val: PackArr<LVoidEdge>, c: Context): boolean { return SetFieldAction.new(c.data.id, \"edgesOut\", Pointers.fromArr(val), '', true); }\r\n    public get_edgesStart(context: Context): this[\"edgesIn\"]  { return this.get_edgesIn(context); }\r\n    public get_edgesEnd(context: Context): this[\"edgesOut\"]  { return this.get_edgesOut(context); }\r\n    public set_edgesStart(val: PackArr<LVoidEdge>, context: Context): boolean { return this.set_edgesIn(val, context); }\r\n    public set_edgesEnd(val: PackArr<LVoidEdge>, context: Context): boolean { return this.set_edgesOut(val, context); }\r\n\r\n\r\n    protected _defaultGetter(c: Context, k: keyof Context[\"data\"]): any {\r\n        if (k in c.data) return this.__defaultGetter(c, k);\r\n        // if value not found in node, check in view.\r\n        return (this.get_view(c) as any)[k];\r\n        /*let ret: any;\r\n        let view = this.get_view(c);\r\n        try { ret = (view as any)[k] } catch (e) { Log.ee(\"Could not find get_ property \\\"\" + k + \"\\\" in node or view.\", {c, view, k}); return undefined; }\r\n        return ret;*/\r\n    }\r\n\r\n    protected _defaultSetter(v: any, c: Context, k: keyof Context[\"data\"]): true { this.__defaultSetter(v, c, k); return true; }\r\n\r\n    get_graphAncestors(c: Context): LGraph[] {\r\n        let current = c.proxyObject;\r\n        let next = current.father;\r\n        let ret: LGraph[] = [];\r\n        while(next) {\r\n            if (RuntimeAccessibleClass.extends(next.className, DGraph.cname)) ret.push(next as LGraph);\r\n            if (current.id === next.id) break;\r\n            current = next;\r\n            next = next.father;\r\n        }\r\n        return ret;\r\n    }\r\n    get_outerGraph(context: Context): LGraph {\r\n        // todo: this relies on the fact that GraphVertex are not passing their own id to their childrens, but the parent graph id\r\n        return TargetableProxyHandler.wrap(context.data.graph);\r\n    }\r\n    get_vertex(context: Context): this[\"vertex\"] {\r\n        let lcurrent: LGraphElement = LPointerTargetable.fromPointer(context.data.id);\r\n        let dcurrent = lcurrent.__raw;\r\n        // iterate parents.\r\n        while(dcurrent){\r\n            switch(dcurrent.className){\r\n                case DVertex.cname:\r\n                case DVoidVertex.cname:\r\n                case DGraphVertex.cname: return (lcurrent || LPointerTargetable.fromD(dcurrent)) as LVoidVertex;\r\n                default:\r\n                    if (!dcurrent.father || dcurrent.id === dcurrent.father) return undefined;\r\n                    Log.exDev(!dcurrent.father || dcurrent.id === dcurrent.father, \"node failed to get containing vertex\", context.data, dcurrent, lcurrent);\r\n                    lcurrent = LPointerTargetable.fromPointer(dcurrent.father);\r\n                    dcurrent = lcurrent.__raw;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    get_innerGraph(context: Context): LGraph {\r\n        let lcurrent: LGraphElement = LPointerTargetable.fromPointer(context.data.father);\r\n        let dcurrent = lcurrent?.__raw;\r\n\r\n        // if no parent, but it's a graph, return itself.\r\n        if (!dcurrent) {\r\n            dcurrent = context.data;\r\n            switch(dcurrent.className){\r\n                case DGraph.cname:\r\n                case DGraphVertex.cname: return (lcurrent || LPointerTargetable.fromD(dcurrent)) as LGraph;\r\n                default: return Log.exDevv(\"node failed to get containing graph\", context.data, dcurrent, lcurrent);\r\n            }\r\n        }\r\n\r\n        // if it have a parent, iterate parents.\r\n        while(true){\r\n            switch(dcurrent?.className){\r\n                case DGraph.cname:\r\n                case DGraphVertex.cname: return (lcurrent || LPointerTargetable.fromD(dcurrent)) as LGraph;\r\n                default:\r\n                    if (!dcurrent.father || dcurrent.id === dcurrent.father) {\r\n                        /*switch(dcurrent.className){\r\n                            case DGraph.name:\r\n                            case DGraphVertex.name: return (lcurrent || LPointerTargetable.fromD(dcurrent)) as LGraph;\r\n                            default: */return Log.exDevv(\"node failed to get containing graph\", context.data, dcurrent, lcurrent);\r\n                        //}\r\n                    }\r\n                    lcurrent = LPointerTargetable.fromPointer(dcurrent.father);\r\n                    dcurrent = lcurrent.__raw;\r\n            }\r\n        }\r\n    }\r\n\r\n    // set_x(val: this[\"x\"], context: Context): boolean { SetFieldAction.new(context.data.id, \"x\", val, undefined, false); return true; }\r\n    // get_x(context: Context): this[\"x\"] { return context.data.x; }\r\n    get_x(context: Context): this[\"x\"] { return this.get_size(context).x; }\r\n    set_x(val: this[\"x\"], context: Context): boolean { return this.set_size({x:val}, context); }\r\n    get_y(context: Context): this[\"y\"] { return this.get_size(context).y; }\r\n    set_y(val: this[\"y\"], context: Context): boolean { return this.set_size({y:val}, context); }\r\n\r\n    get_w(context: Context): this[\"w\"] { return this.get_size(context).w; }\r\n    set_w(val: this[\"w\"], context: Context): boolean { return this.set_size({w:val}, context); }\r\n    get_h(context: Context): this[\"h\"] { return this.get_size(context).h; }\r\n    set_h(val: this[\"h\"], context: Context): boolean { return this.set_size({h:val}, context); }\r\n\r\n    get_width(context: Context): this[\"w\"] { return this.get_w(context); }\r\n    set_width(val: this[\"w\"], context: Context): boolean { return this.set_w(val, context); }\r\n    get_height(context: Context): this[\"h\"] { return this.get_h(context); }\r\n    set_height(val: this[\"h\"], context: Context): boolean { return this.set_h(val, context); }\r\n\r\n    get_position(context: Context): this[\"position\"] { return new GraphPoint(context.data.x, context.data.y); }\r\n    set_position(val: this[\"position\"], context: Context): boolean {\r\n        BEGIN()\r\n        SetFieldAction.new(context.data.id, \"x\", val.x, undefined, false);\r\n        SetFieldAction.new(context.data.id, \"y\", val.y, undefined, false);\r\n        END()\r\n        return true; }\r\n\r\n    get_sizeold(context: Context): this[\"size\"] { return new GraphSize(context.data.x, context.data.y, context.data.w, context.data.h); }\r\n    get_component(context: Context): this[\"component\"] {\r\n        // switch(context.data.className) { case DEdgePoint.name: return GraphElementComponent.map[context.data.father]; }\r\n        return GraphElementComponent.map[context.data.id]; }\r\n    // get_view(context: Context): this[\"view\"] { return this.get_component(context).props.view; }\r\n    get_view(context: Context): this[\"view\"] {\r\n        return transientProperties.node[context.data.id]?.mainView || LPointerTargetable.from(context.data.view) || this.get_component(context)?.props.view;\r\n    }\r\n    set_view(val: Pack1<this[\"view\"]>, context: Context){\r\n        Log.eDevv(\"node.view is readonly, change it through props or the model\");\r\n        // let ptr: DGraphElement[\"view\"] = Pointers.from(val as this[\"view\"]);\r\n        // return SetFieldAction.new(context.data.id, \"view\", ptr, '', true);\r\n    }\r\n\r\n    outerSize!: LGraphElement[\"size\"];\r\n    __info_of__outerSize: Info = {type:\"GraphSize\", txt:\"the size of the current element relative to the first (root) graph level.\"};\r\n    innerSize!: LGraphElement[\"size\"];\r\n    __info_of__innerSize: Info = {type:\"GraphSize\", txt:\"the size of the current element relative to the last (most nested) graph level.\"};\r\n    __info_of__size: Info = {type:\"GraphSize\", txt: \"same as innerSize.\"};\r\n\r\n\r\n    getSize(outer: boolean = false, canTriggerSet: boolean = true): Readonly<GraphSize> { return this.wrongAccessMessage(\"getSize()\"); }\r\n    get_getSize(c: Context): ((outer?: boolean, canTriggerSet?: boolean) => Readonly<GraphSize>) {\r\n        return (outer: boolean = true, canTriggerSet: boolean = true) => this.get_innerSize(c, canTriggerSet, outer); }\r\n\r\n    get_outerSize(context: Context, canTriggerSet: boolean = true): Readonly<GraphSize> {\r\n        return this.get_innerSize(context, canTriggerSet, true);\r\n    }\r\n    get_size(context: Context, canTriggerSet: boolean = true): Readonly<GraphSize> { return this.get_innerSize(context, canTriggerSet, false); }\r\n    get_innerSize(context: Context, canTriggerSet: boolean = true, outerSize: boolean = false): Readonly<GraphSize> {\r\n        let r = this.get_innerSize_impl(context, canTriggerSet, outerSize);\r\n        return new GraphSize(r.x, r.y, r.w, r.h);\r\n    }\r\n    protected get_innerSize_impl(context: Context, canTriggerSet: boolean = true, outerSize: boolean = false): Readonly<GraphSize> {\r\n        canTriggerSet = canTriggerSet && !Debug.lightMode;\r\n        console.log(\"ex4 getsize 0 \" + context.data.className, {context, canTriggerSet, outerSize});\r\n        switch (context.data.className){\r\n            default: return Log.exDevv(\"unexpected classname in get_size switch: \" + context.data.className);\r\n            case DEdge.cname:\r\n            case DVoidEdge.cname:\r\n            case DGraph.cname: return nosize as any;\r\n            // case DField.cname:\r\n            case DGraphElement.cname:\r\n                let graph = outerSize ? this.get_outerGraph(context) : this.get_innerGraph(context);\r\n                console.log(\"ex4 getsize 1 \" + context.data.className, {graph, html:this.get_htmlSize(context), context, canTriggerSet, outerSize});\r\n                return graph.coord(this.get_htmlSize(context));\r\n            case DVoidVertex.cname:\r\n            case DVertex.cname:\r\n            case DEdgePoint.cname:\r\n            case DGraphVertex.cname: break;\r\n        }\r\n\r\n        // low prio todo: memoization in proxy, as long state does not change keep a collection Dictionary[object][key] = returnval. it gets emptied when state is updated.\r\n\r\n        // when loading a save, edge segements and edgepoints/nodes are computed before creating the edgepoint component\r\n        let view: LViewElement = this.get_view(context);\r\n        // (window as any).retry = ()=>view.getSize(context.data.id);\r\n        let ret: EPSize = view.getSize(context.data.id) as any; // (this.props.dataid || this.props.nodeid as string)\r\n\r\n        console.log(\"ex4 getsize 10 \" + context.data.className, {context, viewVertexSize:ret});\r\n        // console.log(\"getSize() from view\", {ret: ret ? {...ret} : ret});\r\n        if (!ret) {\r\n            ret = new GraphSize() as EPSize;\r\n            ret.x = context.data.x;\r\n            ret.y = context.data.y;\r\n            ret.w = context.data.w;\r\n            ret.h = context.data.h;\r\n            let def: GraphSize | undefined;\r\n            if (undefined===(ret.x)) { if (!def) def = view.defaultVSize; ret.x = def.x || 0;}\r\n            if (undefined===(ret.y)) { if (!def) def = view.defaultVSize; ret.y = def.y || 0;}\r\n            if (undefined===(ret.w)) { if (!def) def = view.defaultVSize; ret.w = def.w || 10;}\r\n            if (undefined===(ret.h)) { if (!def) def = view.defaultVSize; ret.h = def.h | 10;}\r\n            ret.currentCoordType = (context.data as DEdgePoint).currentCoordType as any;\r\n            // console.log(\"getSize() from node merged with defaultVSize\", {ret: ret ? {...ret} : ret});\r\n        }\r\n        console.log(\"ex4 getsize 11 pre decode\" + context.data.className, {context, ret});\r\n        if (context.data.className === DEdgePoint.cname) {\r\n            ret = (this as any as LEdgePoint).decodePosCoords(context, ret, view);\r\n            console.log(\"ex4 getsize 12 decoded\" + context.data.className, {context, view, ret});\r\n        }\r\n\r\n        /*\r\n                if ((context.data as DVoidVertex).isResized) {\r\n                    return ret;\r\n                }*/\r\n        if (!canTriggerSet) {\r\n            if (outerSize) ret = this.get_outerGraph(context).translateSize(ret, this.get_innerGraph(context));\r\n            console.log(\"ex4 getsize 13 \" + context.data.className, {context, view, ret});\r\n            return ret;\r\n        }\r\n        let html: RefObject<HTMLElement | undefined> | undefined = this.get_component(context)?.html;\r\n        let actualSize: Partial<Size> & {w:number, h:number} = html?.current ? Size.of(html.current) : {w:0, h:0};\r\n        let updateSize: boolean = false;\r\n        let isOldElement = (context.data.clonedCounter as number) > 3;\r\n        // if w = 0 i don't auto-set it as in first render it has w:0 because is not reredered and not resized.\r\n        // if (canTriggerSet) this.set_size({w:actualSize.w}, context);\r\n        if (view.adaptWidth && ret.w !== actualSize.w) {\r\n            if (canTriggerSet && (isOldElement || actualSize.w !== 0)) {\r\n                ret.w = actualSize.w;\r\n                updateSize = true;\r\n            }\r\n        }\r\n        if (view.adaptHeight && ret.h !== actualSize.h) {\r\n            if (canTriggerSet && (isOldElement || actualSize.h !== 0)) {\r\n                ret.h = actualSize.h;\r\n                updateSize = true;\r\n            }\r\n        }\r\n        // console.log(\"getSize() from node merged with actualSize\", {ret: {...ret}});\r\n\r\n        if (updateSize) this.set_size(ret, context);\r\n        if (outerSize) ret = this.get_outerGraph(context).translateSize(ret, this.get_innerGraph(context));\r\n        console.log(\"ex4 getsize 14 \" + context.data.className, {context, view, ret});\r\n        return ret;\r\n    }\r\n    // set_size(size: Partial<this[\"size\"]>, context: Context): boolean {\r\n    set_size(size0: Partial<GraphSize>, c: Context): boolean {\r\n        // console.log(\"setSize(\"+(this.props?.data as any).name+\") thisss\", this);\r\n        if (!size0) return false;\r\n        let size = size0 as Partial<EPSize>;\r\n        let view = this.get_view(c);\r\n        console.log(\"ex4 setsize \" + c.data.className, {size});\r\n        let testmode: boolean = false;\r\n        if (c.data.className === DEdgePoint.cname && size.currentCoordType !== CoordinateMode.absolute) size = (this as any as LEdgePoint).encodePosCoords(c as any, size, view);\r\n\r\n        console.log(\"ex4 setsize encoded \" + c.data.className, {size});\r\n        if (view.updateSize(c.data.id, size)) return true;\r\n        BEGIN()\r\n        if (size.x !== c.data.x && size.x !== undefined) SetFieldAction.new(c.data.id, \"x\", size.x, undefined, false);\r\n        if (size.y !== c.data.y && size.y !== undefined) SetFieldAction.new(c.data.id, \"y\", size.y, undefined, false);\r\n        if (size.w !== c.data.w && size.w !== undefined) SetFieldAction.new(c.data.id, \"w\", size.w, undefined, false);\r\n        if (size.h !== c.data.h && size.h !== undefined) SetFieldAction.new(c.data.id, \"h\", size.h, undefined, false);\r\n        let epdata: DEdgePoint = c.data as DEdgePoint;\r\n        if (size.currentCoordType !== epdata.currentCoordType && size.currentCoordType !== undefined) SetFieldAction.new(epdata.id, \"currentCoordType\", size.currentCoordType, undefined, false);\r\n        END()\r\n        return true; }\r\n\r\n    get_html(c: Context): this[\"html\"] {\r\n        let component = this.get_component(c);\r\n        let html = component.html.current;\r\n        if (html) return html;\r\n        html = $('[nodeid=\"' + c.data.id + '\"]')[0];\r\n        if (!html) return undefined;\r\n        (component.html as any).current = html;\r\n        return html;\r\n    }\r\n    // get_html(context: Context): this[\"html\"] { return $(\"[node-id='\" + context.data.id + \"']\")[0]; }\r\n    set_html(val: this[\"htmlSize\"], context: Context): boolean { return this.cannotSet(\"set_html(). html is generated through jsx. edit the view instead.\"); }\r\n\r\n    get_htmlSize(context: Context): this[\"htmlSize\"] {\r\n        let html = this.get_html(context);\r\n        return html ? Size.of(html) : new Size(0, 0, 0, 0);\r\n        /*\r\n        let graph = this.get_graph(context);\r\n        if (!html) return nosize as any;\r\n        let size = Size.of(html);\r\n        let zoom = graph.zoom;\r\n        size.x /= zoom.x;\r\n        size.y /= zoom.y;\r\n        return size;*/}\r\n    set_htmlSize(val: this[\"htmlSize\"], context: Context): boolean {\r\n        // might be useful for fixed display size/location elements that stay in place even if you move tab or change zoom. debatable if needed\r\n        this.cannotSet(\"set_htmlSize(): todo extra low priority. set GraphSize through set_size instead.\");\r\n        return true; }\r\n    get_htmlPosition(context: Context): this[\"htmlPosition\"] { return this.get_htmlSize(context).tl(); }\r\n    set_htmlPosition(val: this[\"htmlPosition\"], context: Context): boolean {\r\n        // might be useful for fixed display size/location elements that stay in place even if you move tab or change zoom. debatable if needed\r\n        this.cannotSet(\"set_htmlPosition(): todo extra low priority. set graph position through set_position instead.\");\r\n        return true; }\r\n\r\n\r\n    /* how z-index work, it's really messy.\r\n    * cannot move html position. node id depends on it, and a node moving position would need to change id.\r\n    * so i use css order.\r\n    * first order is assigned through node constructor called by parent component injectProps, according to his last index in html.\r\n    * now z-index is set in node and updated properly.\r\n    * z-index is passed to a prop, rendered as html attribute.\r\n    * css takes the attribute value and uses it in \"order\" css rule.\r\n    * problem: updating node.z doesn't trigger the parent injectprops, so he inject html index and\r\n    * the outernmost html root cannot update his attribute without refreshing the parent and recalling injectprops\r\n    * fixed: by updating it directly in GraphElement.render()\r\n    * */\r\n    get_zIndex(context: Context): this[\"zIndex\"] { return context.data.zIndex; }\r\n    set_zIndex(val: this[\"zIndex\"], context: Context): boolean {\r\n        SetFieldAction.new(context.data.id, \"zIndex\", val, undefined, false);\r\n        return true; }\r\n    get_z(context: Context): this[\"zIndex\"] { return context.data.zIndex; }\r\n    set_z(val: this[\"zIndex\"], context: Context): boolean { return this.set_zIndex(val, context); }\r\n    /*\r\n        get_containedIn(context: Context): this[\"containedIn\"] {\r\n            return context.data.containedIn ? LPointerTargetable.fromPointer(context.data.containedIn) : undefined; }\r\n        set_containedIn(val: Pack1<this[\"containedIn\"]>, context: LogicContext<DGraphElement>): boolean {\r\n            let ptr: DGraphElement[\"containedIn\"] = Pointers.from(val) as any;\r\n            SetFieldAction.new(context.data, 'containedIn', ptr, undefined, true);\r\n            if (ptr) SetFieldAction.new(ptr as any, 'subElements+=', context.data.id);\r\n            return true; }*/\r\n\r\n    get_subElements(context: Context): this[\"subElements\"] {\r\n        return LPointerTargetable.fromArr([...new Set(context.data.subElements)]);\r\n    }\r\n    set_subElements(val: PackArr<this[\"subElements\"]>, context: LogicContext<DGraphElement>): boolean {\r\n        console.log(\"isDeepStrictEqual\", {isDeepStrictEqual});\r\n        Log.eDev([...new Set(val)].length !== val.length, \"subelemnts setter have duplicates\", {val, context});\r\n        // if (isDeepStrictEqual(context.data.subElements, val)) return true;\r\n        let pointers: Pointer<DGraphElement, 0, 'N', LGraphElement> = Pointers.from(val) || [];\r\n        if (Uarr.equals(pointers, context.data.subElements, false)) return true;\r\n        SetFieldAction.new(context.data, 'subElements', pointers, '', true);\r\n        const idlookup = store.getState().idlookup;\r\n        let arrdiff = U.arrayDifference(context.data.subElements, pointers);\r\n        // old subelements\r\n        for (let oldsubelementid of arrdiff.removed) {\r\n            let subelement: DGraphElement = (oldsubelementid && idlookup[oldsubelementid]) as DGraphElement;\r\n            if (subelement.father !== context.data.id) continue;\r\n            LPointerTargetable.from(subelement).father = null as any; // todo: can this happen? è transitorio o causa vertici senza parent permanenti?\r\n        }\r\n        // new subelements\r\n        for (let newsubelementid of arrdiff.added) {\r\n            let subelement: DGraphElement = (newsubelementid && idlookup[newsubelementid]) as DGraphElement;\r\n            if (subelement.father === context.data.id) continue;\r\n            LPointerTargetable.from(subelement).father = context.data.id as any; // trigger side-action\r\n        }\r\n        return true;\r\n    }\r\n\r\n    get_isResized(context: LogicContext<DVoidVertex>): DVoidVertex[\"isResized\"] { return context.data.isResized; }\r\n    set_isResized(val: DVoidVertex[\"isResized\"], context: LogicContext<DVoidVertex>): DVoidVertex[\"isResized\"] {\r\n        return SetFieldAction.new(context.data.id, \"isResized\", val);\r\n    }\r\n\r\n    get_model(context: Context): this[\"model\"] {\r\n        const modelElementId = context.data.model; //$('[id=\"' + context.data.id + '\"]')[0].dataset.dataid;\r\n        const lModelElement: LModelElement = LPointerTargetable.from(modelElementId as string);\r\n        return lModelElement;\r\n    }\r\n\r\n    private get_allSubNodes(context: Context, state?: DState): this[\"allSubNodes\"] {\r\n        // return context.data.packages.map(p => LPointerTargetable.from(p));\r\n        state = state || store.getState();\r\n        let tocheck: Pointer<DGraphElement>[] = context.data.subElements || [];\r\n        let checked: Dictionary<Pointer, true> = {};\r\n        let dblcheck: Dictionary<Pointer, Pointer> = {}; // <child, parent>  // debug only\r\n        for (let e of tocheck) dblcheck[e] = context.data.id; // debug only\r\n        checked[context.data.id] = true;//nb6[]{}&\r\n        while (tocheck.length) {\r\n            let newtocheck: Pointer<DGraphElement>[] = [];\r\n            for (let ptr of tocheck) {\r\n                Log.eDev(checked[ptr], \"loop in GraphElements containing themselves\", {dblcheck, context, ptr, checked, fistContainer:dblcheck[ptr]});\r\n                if (checked[ptr]) continue;\r\n                checked[ptr] = true;\r\n                let subnode: DGraphElement = DPointerTargetable.from(ptr, state);\r\n                let se = subnode?.subElements;\r\n                for (let e of se) dblcheck[e] = ptr; // debug only\r\n                U.arrayMergeInPlace(newtocheck, se);\r\n            }\r\n            tocheck = newtocheck;\r\n        }\r\n        delete checked[context.data.id];\r\n        return LPointerTargetable.from(Object.keys(checked), state);\r\n    }\r\n    assignEdgeAnchor!: ((anchorName?: string)=>void);\r\n    __info_of__assignEdgeAnchor!: {hidden:true, type:\"(anchorName?: string)=>void\", txt: \"Assign a specific anchor of this node to the edge currently following the cursor, if any.\"};\r\n    get_assignEdgeAnchor(c: Context): ((anchorName?: string)=>void) {\r\n        return (anchorName?: string)=>{\r\n            if (anchorName && !c.data.anchors[anchorName]) anchorName = undefined;\r\n            if (LVoidEdge.startFollow) {\r\n                let de: DEdge = DPointerTargetable.fromPointer(LVoidEdge.startFollow);\r\n                if (de.start !== c.data.id) return; // cannot change edge targets, only an anchor within the current targets\r\n                let le: LVoidEdge = LPointerTargetable.fromD(de);\r\n                le.anchorStart = anchorName;\r\n                le.startFollow = false;\r\n\r\n            }\r\n            if (LVoidEdge.endFollow) {\r\n                let de = DPointerTargetable.fromPointer(LVoidEdge.endFollow);\r\n                if (de.end !== c.data.id) return; // cannot change edge targets, only an anchor within the current targets\r\n                let le = LPointerTargetable.fromD(de);\r\n                le.anchorEnd = anchorName;\r\n                le.endFollow = false;\r\n            }\r\n        }\r\n    }\r\n    get_events(c: Context): LViewElement[\"events\"] {\r\n        const tn = transientProperties.node[c.data.id];\r\n        let mainview: DViewElement = tn.mainView.__raw;\r\n        let otherViews: DViewElement[] = tn.stackViews.map(v=>v.__raw);\r\n        let allviews: DViewElement[] = [mainview, ...otherViews].reverse();\r\n        const keep_for_closure_original_funcs: LViewElement[\"events\"] = {};\r\n        const ret: LViewElement[\"events\"] = {};\r\n        for (let dv of allviews) U.objectMergeInPlace(keep_for_closure_original_funcs, transientProperties.view[dv.id].events);\r\n\r\n        const lastContext: GObject = tn.viewScores[mainview.id].evalContext;\r\n        const keys = Object.keys(keep_for_closure_original_funcs);\r\n        // for (let k of keys) ret['_raw_'+k] = keep_for_closure_original_funcs[k];\r\n        for (let k of keys) {\r\n            if (!keep_for_closure_original_funcs[k]) continue;\r\n            ret[k] = (..._params: any) => keep_for_closure_original_funcs[k](lastContext, ..._params);\r\n        }\r\n\r\n        return ret; }\r\n\r\n\r\n    get_father(context: Context): this[\"father\"] { return LPointerTargetable.fromPointer(context.data.father); }\r\n    set_father(val: Pack1<this[\"father\"]>, context: Context): boolean {\r\n        let ptr: DGraphElement[\"father\"] = Pointers.from(val) as any;\r\n        SetFieldAction.new(context.data, 'father', ptr, undefined, true);\r\n        if (ptr) SetFieldAction.new(ptr as any, 'subElements+=', context.data.id);\r\n        return true; }\r\n\r\n    __info_of__isselected: Info = {type: \"Dictionary<Pointer<User>, true>\",\r\n        txt:<div>A map that contains all the users selecting this element as keys, and always true as a value (if present).\r\n            <br/>Edit it through node.select() and node.deselect()</div>}\r\n    __info_of__select: Info = {type:\"function(forUser?:Pointer<User>):void\", txt:\"Marks this node as selected by argument user.\"};\r\n    __info_of__deselect: Info = {type:\"function(forUser?:Pointer<User>):void\", txt:\"Un-marks this node as selected by argument user.\"};\r\n    __info_of__toggleSelect: Info = {type:\"function(usr?:Pointer<User>):void\", txt:\"Calls this.select(usr) if the node is selected by argument user, this.deselect(usr) otherwise. If omitted, argument \\\"usr\\\" is the current user id.<br>Returns the result of this.isSelected() after the toggle.\"};\r\n    __info_of__isSelected: Info = {type:\"function(forUser?:Pointer<User>):void\", txt:\"Tells if this node is selected by argument user.\"};\r\n    select(forUser?: Pointer<DUser>): void { return this.wrongAccessMessage(\"node.select()\"); }\r\n    deselect(forUser?: Pointer<DUser>): void { return this.wrongAccessMessage(\"node.deselect()\"); }\r\n    toggleSelected(forUser?: Pointer<DUser>): void { return this.wrongAccessMessage(\"node.toggleSelected()\"); }\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    get_select(c: Context): (forUser?: Pointer<DUser>)=>void {\r\n        return (forUser?: Pointer<DUser>)=> {\r\n            if (!forUser) forUser = DUser.current;\r\n            if (c.data.isSelected[forUser]) return; // no-op\r\n            let map = {...c.data.isSelected};\r\n            map[forUser] = true;\r\n            SetFieldAction.new(c.data.id, \"isSelected\", map, undefined, false);\r\n            // todo: actually they are pointer to users, but i'm assuming users are not erased at runtime. on deselect too\r\n        }\r\n    }\r\n    get_deselect(c: Context): (forUser?: Pointer<DUser>)=>void {\r\n        return (forUser?: Pointer<DUser>)=> {\r\n            if (!forUser) forUser = DUser.current;\r\n            if (!c.data.isSelected[forUser]) return; // no-op\r\n            let map = {...c.data.isSelected};\r\n            delete map[forUser];\r\n            SetFieldAction.new(c.data.id, \"isSelected\", map, undefined, false);\r\n            // todo: actually they are pointer to users, but i'm assuming users are not erased at runtime. on deselect too\r\n        }\r\n    }\r\n    get_toggleSelected(context: Context): ((forUser?: Pointer<DUser>) => boolean) {\r\n        return (forUser?: Pointer<DUser>): boolean => {\r\n            if (!forUser) forUser = DUser.current;\r\n            if (this.get_isSelected(context)(forUser)) {\r\n                this.get_deselect(context)(forUser);\r\n                return false;\r\n            } else {\r\n                this.get_select(context)(forUser);\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    get_isSelected(context: Context): ((forUser?: Pointer<DUser>) => boolean) {\r\n        return (forUser?: Pointer<DUser>): boolean => {\r\n            if (!forUser) forUser = DUser.current;\r\n            return !!context.data.isSelected[forUser]; }\r\n    }\r\n    set_isSelected(val: this[\"isSelected\"], context: Context): boolean {\r\n        return this.cannotSet(\"graphElement.isSelected(): use this.select() or this.deselect() instead.\");\r\n    }\r\n    /*\r\n    get_isSelected(context: LogicContext<DVoidVertex>): GObject {\r\n        return DPointerTargetable.mapWrap(context.data.isSelected, context.data, 'idlookup.' + context.data.id + '.isSelected', []);\r\n    }*/\r\n\r\n\r\n\r\n    // for edges\r\n    public get_startPoint(c: Context|undefined, size?: GraphSize, view?: LViewElement): GraphPoint { return this.get_startEndPoint(c, size, view, true); }\r\n    public get_endPoint(c: Context|undefined, size?: GraphSize, view?: LViewElement): GraphPoint { return this.get_startEndPoint(c, size, view, false); }\r\n    private get_startEndPoint(c: Context|undefined, size?: GraphSize, view?: LViewElement, isStart:boolean=true): GraphPoint {\r\n        if (!size) {\r\n            if (c) size = this.get_size(c) as any; else size = Log.exDevv(\"invalid arguments in get_startEndPoint\", {arguments});\r\n        }\r\n        if (!view) {\r\n            // if (c) view = this.get_view(c); else view = Log.exDevv(\"invalid arguments in get_startPoint\", {arguments});\r\n            view = c && this.get_view(c) || Log.exDevv(\"invalid arguments in get_startEndPoint\", {arguments});\r\n        }\r\n        let offset: GraphPoint = (view as LViewElement)[isStart ? \"edgeStartOffset\" : \"edgeEndOffset\"];\r\n        let isPercentage: boolean = (view as LViewElement)[isStart ? \"edgeStartOffset_isPercentage\" : \"edgeEndOffset_isPercentage\"];\r\n        if (!size) size = new GraphSize(0, 0, 0, 0);\r\n        if (isPercentage) offset = new GraphPoint(offset.x/100*(size.w), offset.y/100*(size.h));\r\n        return size.tl().add(offset, false);\r\n    }\r\n\r\n}\r\nRuntimeAccessibleClass.set_extend(DPointerTargetable, DGraphElement);\r\nRuntimeAccessibleClass.set_extend(LPointerTargetable, LGraphElement)\r\n\r\n\r\n@RuntimeAccessible('DGraph')\r\nexport class DGraph extends DGraphElement {\r\n    // static _super = DGraphElement;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraph;\r\n    // static logic: typeof LGraph;\r\n    // static structure: typeof DGraph;\r\n\r\n    // inherit redefine\r\n    father!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    id!: Pointer<DGraph, 1, 1, LGraph>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 1, 1, LModelElement>;\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n    state!: GObject;\r\n    // personal attributes\r\n    zoom!: GraphPoint;\r\n    offset!: GraphPoint; // in-graph scrolling offset\r\n\r\n    public static new(htmlindex: number, model: DGraph[\"model\"],\r\n                      parentNodeID?: DGraphElement[\"father\"], // immediate parent\r\n                      parentgraphID?: DGraphElement[\"graph\"], // graph containing this subgraph (redudant? could get it from father chain)\r\n                      nodeID?: DGraphElement[\"id\"] // this id\r\n    ): DGraph {\r\n        return new Constructors(new DGraph('dwc'), parentNodeID, true, undefined, nodeID || Constructors.DGraph_makeID(model))\r\n            .DPointerTargetable()\r\n            .DGraphElement(model, parentgraphID, htmlindex).DGraph().end();\r\n    }\r\n\r\n\r\n    static getNodes(dmp: import(\"../logicWrapper/LModelElement\").DModelElement[], out: {$matched: JQuery<HTMLElement>; $notMatched: JQuery<HTMLElement>; }): JQuery<HTMLElement> {\r\n        let $allnodes = $('[data-dataid]');\r\n        let matchedids: Pointer[] = (dmp || []).map(d => d.id);\r\n        let matchedidmap:Dictionary<string, boolean> = U.objectFromArrayValues(matchedids);\r\n        if (!out) out = {} as any;\r\n\r\n        let allnodesarr = [...$allnodes];\r\n        let filternode = (d: HTMLElement) => {\r\n            if (!d?.dataset?.dataid) return false;\r\n            let id: string = ''+d?.dataset?.dataid;\r\n            return matchedidmap[id]; };\r\n        out.$matched = $(allnodesarr.filter(filternode));\r\n        out.$notMatched = $(allnodesarr.filter((n) => !filternode(n)));\r\n        return out.$matched;\r\n        // throw new Error(\"Method not implemented.\");\r\n    }\r\n\r\n}\r\nvar nosize: GraphSize = {x:0, y:0, w:0, h:0, nosize:true} as any;\r\nvar defaultEdgePointSize: GraphSize = undefined as any; // = {x:0, y:0, w:5, h:5};\r\nvar defaultVertexSize: GraphSize = undefined as any; // {x:0, y:0, w:140.6818084716797, h:32.52840805053711};\r\n\r\n\r\n@RuntimeAccessible('LGraph')\r\nexport class LGraph<Context extends LogicContext<DGraph> = any, D extends DGraph = any> extends LGraphElement {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraph;\r\n    // static logic: typeof LGraph;\r\n    // static structure: typeof DGraph;\r\n\r\n    // inherit redefine\r\n    __raw!: DGraph;\r\n    id!: Pointer<DGraph, 1, 1, LGraph>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn?: LGraphElement;\r\n    subElements!: LGraphElement[];\r\n    _state!: GObject<\"proxified\">; // LMap;\r\n    // personal attributes\r\n    zoom!: GraphPoint;\r\n    graphSize!: GraphSize; // derived attribute: bounding rect containing all subnodes, while \"size\" is instead external size of the vertex holding the graph in GraphVertexes\r\n    offset!: GraphPoint; // Scrolling position inside the graph\r\n\r\n    // get_graphSize(context: LogicContext<DGraph>):  Readonly<GraphSize> { return todo: get bounding rect containing all subnodes.; }\r\n    get_offset(context: LogicContext<DGraph>):  Readonly<GraphSize> {\r\n        return new GraphSize(context.data.offset.x, context.data.offset.y);\r\n    }\r\n    set_offset(val: Partial<GraphPoint>, context: Context): boolean {\r\n        if (!val) val = {x:0, y:0};\r\n        if (context.data.offset.x === val.x && context.data.offset.y === val.y) return true;\r\n        if (val.x === undefined && context.data.offset.x !== val.x) val.x = context.data.offset.x;\r\n        if (val.y === undefined && context.data.offset.y !== val.y) val.y = context.data.offset.y;\r\n        SetFieldAction.new(context.data, \"offset\", val as GraphPoint);\r\n        return true;\r\n    }\r\n    get_zoom(context: Context): GraphPoint {\r\n        const zoom: GraphPoint = context.data.zoom;\r\n        // (zoom as any).debug = {rawgraph: context.data.__raw, zoomx: context.data.zoom.x, zoomy: context.data.zoom.y}\r\n        return context.data.zoom; }\r\n\r\n    toGraphSize(...a:Parameters<this[\"coord\"]>): ReturnType<this[\"coord\"]>{ return this.wrongAccessMessage(\"toGraphSize\"); }\r\n    coord(htmlSize: Size): GraphSize { return this.wrongAccessMessage(\"toGraphSize\"); }\r\n    get_coord(context: Context): (htmlSize: Size) => GraphSize {\r\n        return (htmlSize: Size)=> {\r\n            let size: Size = this.get_htmlSize(context);\r\n            let zoom: GraphPoint = this.get_zoom(context);\r\n            return new GraphSize((htmlSize.x - size.x) / zoom.x, (htmlSize.y - size.y) / zoom.y, htmlSize.w/zoom.x, htmlSize.h/zoom.y);\r\n        }\r\n    }\r\n    // get_htmlSize(context: Context): Size { }\r\n    translateSize<T extends GraphSize|GraphPoint>(ret: T, innerGraph: LGraph): T { return this.wrongAccessMessage(\"translateSize()\"); }\r\n    translateHtmlSize<T extends Size|Point, G = T extends Size ? GraphSize : GraphPoint>(size: T): G { return this.wrongAccessMessage(\"translateHtmlSize()\"); }\r\n\r\n    __info_of__zoom: Info = {type:GraphPoint.cname, label:\"zoom\", txt:\"Scales the graph and all subelements by a factor.\"};\r\n    set_zoom(val: Partial<GraphPoint>, c: Context): boolean{\r\n        SetFieldAction.new(c.data, 'zoom', val as any, '+=', false);\r\n        return true;\r\n    }\r\n    __info_of__offset: Info = {type:GraphPoint.cname, label:\"offset\", txt:\"In-graph scrolling position.\"};\r\n    __info_of__graphSize: Info = {type:GraphSize.cname, label:\"graphSize\", txt:\"size internal to the graph, including internal scroll and panning.\"};\r\n    __info_of__translateSize: Info = {type:\"(T, Graph)=>T where T is GraphSize | GraphPoint\", txt:\"Translates a coordinate set from the local coordinates of a SubGraph to this Graph containing it.\"};\r\n    __info_of__translateHtmlSize: Info = {type:\"(Size|Point) => GraphSize|GraphPoint\", txt:\"Translate page\\'s viewport coordinate set to this graph coordinate set.\"};\r\n    get_translateHtmlSize<T extends Size|Point, G = T extends Size ? GraphSize : GraphPoint>(c: Context): ((size: T) => G) {\r\n        return (size: T): G => {\r\n            let graphHtmlSize = this.get_htmlSize(c);\r\n            let a = size.subtract(graphHtmlSize.tl(), true);\r\n            let b = a.add({x:c.data.offset.x, y:c.data.offset.y}, false);\r\n            return b.multiply(c.data.zoom, false) as any as G;\r\n        }\r\n    }\r\n\r\n    get_translateSize<T extends GraphSize|GraphPoint>(c: Context): ((size: T, innerGraph: LGraph) => T) {\r\n        return (size: T, innerGraph: LGraph): T => {\r\n            innerGraph = LPointerTargetable.wrap(innerGraph) as LGraph;\r\n            let ret: T = (size.hasOwnProperty(\"w\") ? new GraphSize(size.x, size.y, (size as GraphSize).w, (size as GraphSize).h) : new GraphPoint(size.x, size.y)) as T;\r\n            Log.ex(!innerGraph, \"translateSize() graph parameter is invalid: \"+innerGraph, innerGraph, c);\r\n            let ancestors: LGraph[] = [innerGraph, ...innerGraph.graphAncestors]\r\n            Log.ex(ancestors.indexOf(c.proxyObject) !== -1, \"translateSize() graph parameter is invalid: it must be a graph containing the current one.\", innerGraph, c);\r\n            for (let g of ancestors) ret.add(g.size.tl(), false);\r\n            // console.log(\"translateSize\", {c, thiss:c.proxyObject, ancestors, ancestorSizes: ancestors.map(a=> a.size.tl()), size, ret});\r\n            return ret; }\r\n    }\r\n    contains(elem: LGraphElement): boolean{ return this.wrongAccessMessage(\"contains()\"); }\r\n    get_contains(c: Context): ((elem: LGraphElement)=> boolean) {\r\n        return (elem: LGraphElement): boolean => {\r\n            let current = elem;\r\n            let next = elem.father;\r\n            let targetid = c.proxyObject.id;\r\n            if (current.id !== targetid) return true;\r\n            while(next && current.id !== next.id) {\r\n                current = next;\r\n                next = next.father;\r\n                if (current.id !== targetid) return true;\r\n            }\r\n            return false;\r\n        }}\r\n}\r\nRuntimeAccessibleClass.set_extend(DGraphElement, DGraph);\r\nRuntimeAccessibleClass.set_extend(LGraphElement, LGraph);\r\n// export const defaultVSize: GraphSize = new GraphSize(0, 0, 300, 160); // useless, now it's in view.DefaultVSize\r\n// export const defaultEPSize: GraphSize = new GraphSize(0, 0, 15, 15); // useless, now it's in view.DefaultVSize\r\n\r\n\r\n@RuntimeAccessible('DVoidVertex')\r\nexport class DVoidVertex extends DGraphElement {\r\n    // static _super = DGraphElement;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LVoidVertex;\r\n    // static logic: typeof LVoidVertex;\r\n    // static structure: typeof DVoidVertex;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DVoidVertex, 1, 1, LVoidVertex>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 0, 1, LModelElement>;\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n    state!: GObject;\r\n    zoom!: GraphPoint;\r\n    // personal attributes\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    isResized!: boolean;\r\n    // size?: GraphSize; // virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\r\n\r\n    public static new(htmlindex: number, model: DGraphElement[\"model\"], parentNodeID: DGraphElement[\"father\"], graphID: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"],\r\n                      size?: InitialVertexSize): DVoidVertex {\r\n        return new Constructors(new DVoidVertex('dwc'), parentNodeID, true, undefined, nodeID)\r\n            .DPointerTargetable()\r\n            .DGraphElement(model, graphID, htmlindex)\r\n            .DVoidVertex(size || defaultVertexSize).end();\r\n    }\r\n\r\n}\r\n\r\n@RuntimeAccessible('LVoidVertex')\r\nexport class LVoidVertex<Context extends LogicContext<DVoidVertex> = any, C extends Context = Context> extends LGraphElement {// <D extends DVoidVertex = any>\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LVoidVertex;\r\n    // static logic: typeof LVoidVertex;\r\n    // static structure: typeof DVoidVertex;\r\n\r\n    // inherit redefine\r\n    __raw!: DVoidVertex;\r\n    id!: Pointer<DVoidVertex, 1, 1, LVoidVertex>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn?: LGraphElement;\r\n    subElements!: LGraphElement[];\r\n    _state!: GObject<\"proxified\">; // LMap;\r\n    zoom!: GraphPoint;\r\n    isResized!: boolean;\r\n\r\n    // personal attributes\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    size!: GraphSize; // virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\r\n    __info_of__size = {type: \"?GraphSize\", txt: \"Size of the vertex, if null it means is utilizing the defaultSize from view. recommended to read component.getSize() instead of this.\"};\r\n\r\n    get_isResized(context: LogicContext<DVoidVertex>): DVoidVertex[\"isResized\"] { return context.data.isResized; }\r\n    set_isResized(val: DVoidVertex[\"isResized\"], context: LogicContext<DVoidVertex>): DVoidVertex[\"isResized\"] {\r\n        return SetFieldAction.new(context.data.id, \"isResized\", val);\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(DGraphElement, DVoidVertex);\r\nRuntimeAccessibleClass.set_extend(LGraphElement, LVoidVertex);\r\n@RuntimeAccessible('DEdgePoint')\r\nexport class DEdgePoint extends DVoidVertex { // DVoidVertex\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LEdgePoint;\r\n    // static logic: typeof LEdgePoint;\r\n    // static structure: typeof DEdgePoint;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DEdgePoint, 1, 1, LEdgePoint>;\r\n    father!: Pointer<DVoidEdge, 1, 1, LVoidEdge>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 0, 1, LModelElement>; // todo: if null gets model from this.father (edge)?\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n    zoom!: GraphPoint;\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    size?: GraphSize; //／／ virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\r\n    // personal attributes\r\n    __isDEdgePoint!: true;\r\n    currentCoordType?: CoordinateMode;\r\n\r\n    public static new(htmlindex: number, model: DEdgePoint[\"model\"] | undefined, parentNodeID: DEdgePoint[\"father\"], graphID?: DEdgePoint[\"graph\"], nodeID?: DGraphElement[\"id\"],\r\n                      size?: InitialVertexSize): DEdgePoint {\r\n        return new Constructors(new DEdgePoint('dwc'), parentNodeID, true, undefined, nodeID)\r\n            .DGraphElement(undefined, graphID, htmlindex)\r\n            .DVoidVertex(size || defaultEdgePointSize).DEdgePoint().end();\r\n    }\r\n\r\n}\r\n\r\n@RuntimeAccessible('LEdgePoint')\r\nexport class LEdgePoint<Context extends LogicContext<DEdgePoint> = any, C extends Context = Context> extends LVoidVertex {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LEdgePoint;\r\n    // static logic: typeof LEdgePoint;\r\n    // static structure: typeof DEdgePoint;\r\n\r\n    // inherit redefine\r\n    father!: LVoidEdge;\r\n    // __raw!: DEdgePoint;\r\n    id!: Pointer<DEdgePoint, 1, 1, LEdgePoint>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn?: LGraphElement;\r\n    subElements!: LGraphElement[];\r\n    zoom!: GraphPoint;\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    size!: GraphSize; // virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\r\n    // personal attributes\r\n    __isLEdgePoint!: true;\r\n    edge!: LVoidEdge; // returns container edge\r\n    __info_of__edge: Info = {type:\"?LEdge\", txt:\"returns the containing edge if called on an EdgePoint, \\\"this\\\" if called on an edge, undefined otherwise.\"}\r\n\r\n    public get_edge(c: Context): LVoidEdge { return c.proxyObject.father; }\r\n    public set_edge(v: Pack1<LVoidEdge>, c: Context): boolean { return this.set_father(v as any, c); }\r\n\r\n\r\n\r\n\r\n    static decodeCoords<T extends Partial<EPSize>>(size0: T, sp:GraphPoint, ep: GraphPoint): T/*absolute*/{\r\n        let size: any = size0;\r\n        let ret: any = ((\"w\" in size || \"h\" in size) ? new GraphSize() : new GraphPoint()); // GObject<Partial<GraphSize>>;\r\n        switch (size.currentCoordType) {\r\n            default: return Log.exDevv(\"translatePosCoords() invalid coordinate mode\", {mode:size.currentCoordType});\r\n            // case CoordinateMode.absolute: return size;\r\n            case CoordinateMode.absolute: case undefined: case null:\r\n                if (size.x !== undefined) ret.x = size.x;\r\n                if (size.y !== undefined) ret.y = size.y;\r\n                break;\r\n            case CoordinateMode.relativePercent:\r\n                //maybe do: dampening factor on relative % offset? is it possible?\r\n                // let s = this.getBasicSize(c);\r\n                // MATH:\r\n                // size.x = sp.x*x% + ep.x*(1-x%)\r\n                // size.x = sp.x*x% + ep.x - ep.x*x%\r\n                // size.x - ep.x= (sp.x - ep.x)*x%\r\n                // (size.x - ep.x) / (sp.x - ep.x) = x% // actually i inverted <sp, ep> in first equation, so reverse them in result too.\r\n                if (size.x !== undefined) ret.x = (1 - size.x) * sp.x + (size.x) * ep.x;\r\n                if (size.y !== undefined) ret.y = (1 - size.y) * sp.y + (size.y) * ep.y;\r\n                break;\r\n            case CoordinateMode.relativeOffset:\r\n            case CoordinateMode.relativeOffsetStart:\r\n            case CoordinateMode.relativeOffsetEnd:\r\n                let useStart: boolean;\r\n                let useEnd: boolean;\r\n                switch (size.currentCoordType) {\r\n                    default:\r\n                    case CoordinateMode.relativeOffset: useStart = true; useEnd = true; break;\r\n                    case CoordinateMode.relativeOffsetStart: useStart = true; useEnd = false; break;\r\n                    case CoordinateMode.relativeOffsetEnd: useStart = false; useEnd = true; break;\r\n                }\r\n                // offset = sp - size\r\n                // size = offset - sp\r\n                // in reverse: actualsize = offset, size=offset\r\n\r\n                // if coords are already in absolute mode.\r\n                let xIsAbsolute: number | undefined = (size.x&&!Array.isArray(size.x)) ? size.x : undefined;\r\n                let yIsAbsolute: number | undefined = (size.x&&!Array.isArray(size.x)) ? size.x : undefined;\r\n                Log.w(xIsAbsolute || yIsAbsolute, \"decoding relative offset require an array size coordinate system. x=[x1, x2] --> x\", {size});\r\n\r\n                let offsetsp = useStart ? new GraphPoint(xIsAbsolute || size.x[0] + sp.x, yIsAbsolute || size.y[0] + sp.y) : new GraphPoint();\r\n                let offsetep = useEnd ? new GraphPoint(xIsAbsolute || size.x[1] + ep.x, yIsAbsolute || size.y[1] + ep.y) : new GraphPoint();\r\n                // if the start and endpoint of the edge didn't move, offsetsp = offsetep.\r\n                // if they moved, those 2 are discordant --> i pick middle\r\n                offsetsp.add(offsetep, false);\r\n                if (useStart && useEnd) offsetsp.divide(2, false);\r\n                if (!xIsAbsolute && size.x !== undefined) ret.x = offsetsp.x;\r\n                if (!yIsAbsolute && size.y !== undefined) ret.y = offsetsp.y;\r\n                if (xIsAbsolute) {\r\n                    ret.x = size.x;\r\n                }\r\n                if (yIsAbsolute) {\r\n                    ret.y = size.y;\r\n                }\r\n                break;\r\n        }\r\n        if (size.x === undefined) delete ret.x;\r\n        if (size.y === undefined) delete ret.y;\r\n        if ((size as any).w === undefined) delete ret.w; else ret.w = size.w;\r\n        if ((size as any).h === undefined) delete ret.h; else ret.h = size.h;\r\n        ret.currentCoordType = CoordinateMode.absolute;\r\n        // console.log(\"decode coords\", {size, sp, ep, ret});\r\n        return ret;\r\n    }\r\n    // from x,y as coords, to x%,y% as % of ((1-val)%*startpt) + ((val)%*endpt)\r\n    public decodePosCoords<T extends Partial<GraphSize> | Partial<GraphPoint>>(c: Context, size: T&any, view: LViewElement, sp0?: GraphPoint, ep0?: GraphPoint): T {\r\n        let le: LVoidEdge = c&&c.proxyObject.father;\r\n        // console.log(\"decodepos:\", {le, sp0, lesp:le?.startPoint});\r\n        let sp: GraphPoint = sp0||le.startPoint;\r\n        let ep: GraphPoint = ep0||le.endPoint;\r\n        return LEdgePoint.decodeCoords(size, sp, ep);\r\n    }\r\n\r\n    static testCoords(range: number = 30){\r\n        outer: for (let mode of [\"absolute\", \"relative%\", \"relativeOffset\", \"relativeOffsetStart\", \"relativeOffsetEnd\"])\r\n            for (let i = -range; i < range; i++)\r\n                for (let j = -range; j < range; j++){\r\n                    var s0 = {x:i, y:j};\r\n                    var sp = {x:10, y:10};\r\n                    var ep = {x:10, y:-10};\r\n                    // @ts-ignore\r\n                    var s1 = LEdgePoint.encodeCoords(s0, mode, sp, ep)\r\n                    // @ts-ignore\r\n                    var s00 = LEdgePoint.decodeCoords(s1, sp, ep);\r\n                    // @ts-ignore\r\n                    var error = Object.keys(s0).map( k=> s0[k].toFixed(3) === s00[k].toFixed(3) ? '' : k).join('');\r\n                    (mode != \"relative%\" && error ? console.error : console.log)({diff:[s00.x-s0.x, s00.y-s0.y].join(), i, j, mode, s1:[s1.x, s1.y].join(), s0, s00, error});\r\n                    if (mode != \"relative%\" && error ) break outer;\r\n                }\r\n    }\r\n    // @ts-ignore a\r\n\r\n    static encodeCoords<T extends Partial<EPSize>>(size0: T, edgePointCoordMode: CoordinateMode, sp:GraphPoint, ep: GraphPoint): T/*absolute*/{\r\n        let size: T = size0 as any;\r\n        if (edgePointCoordMode === size.currentCoordType ||\r\n            !size.currentCoordType && edgePointCoordMode === CoordinateMode.absolute) return size;\r\n        if (size.currentCoordType && size.currentCoordType !== CoordinateMode.absolute) size = LEdgePoint.decodeCoords(size, sp, ep);\r\n\r\n        let ret: any = ((\"w\" in size || \"h\" in size) ? new GraphSize() : new GraphPoint()); // GObject<Partial<GraphSize>>;\r\n        switch (edgePointCoordMode) {\r\n            default: return Log.exDevv(\"translatePosCoords() invalid coordinate mode\", {mode:edgePointCoordMode});\r\n            // case CoordinateMode.absolute: return size;\r\n            case CoordinateMode.relativePercent:\r\n                // let s = this.getBasicSize(c);\r\n                // MATH:\r\n                // size.x = sp.x*x% + ep.x*(1-x%)\r\n                // size.x = sp.x*x% + ep.x - ep.x*x%\r\n                // size.x - ep.x= (sp.x - ep.x)*x%\r\n                // (size.x - ep.x) / (sp.x - ep.x) = x% // actually i inverted <sp, ep> in first equation, so reverse them in result too.\r\n\r\n                if (sp.x === ep.x) ret.x = 0.5; // because otherwise it is infinity. so i force him to return in line.\r\n                else if (size.x !== undefined) ret.x = (size.x - sp.x) / (ep.x - sp.x);\r\n                if (sp.y === ep.y) ret.y = 0.5;\r\n                else if (size.y !== undefined) ret.y = (size.y - sp.y) / (ep.y - sp.y);\r\n                break;\r\n            case CoordinateMode.relativeOffset:\r\n            case CoordinateMode.relativeOffsetStart:\r\n            case CoordinateMode.relativeOffsetEnd:\r\n                let useStart: boolean;\r\n                let useEnd: boolean;\r\n                switch (edgePointCoordMode) {\r\n                    default:\r\n                    case CoordinateMode.relativeOffset: useStart = true; useEnd = true; break;\r\n                    case CoordinateMode.relativeOffsetStart: useStart = true; useEnd = false; break;\r\n                    case CoordinateMode.relativeOffsetEnd: useStart = false; useEnd = true; break;\r\n                }\r\n                if (size.x) ret.x = [useStart ? size.x - sp.x : -1, useEnd ? size.x - ep.x : -1];\r\n                if (size.y) ret.y = [useStart ? size.y - sp.y : -1, useEnd ? size.y - ep.y : -1];\r\n                /*\r\n                if (size.x) ret.x = [sp.x - size.x, ep.x - size.x];\r\n                if (size.y) ret.y = [sp.y - size.y, ep.y - size.y];*/\r\n                break;\r\n        }\r\n        if (size.x === undefined) delete ret.x;\r\n        if (size.y === undefined) delete ret.y;\r\n        if ((size as any).w === undefined) delete ret.w; else ret.w = (size as any).w;\r\n        if ((size as any).h === undefined) delete ret.h; else ret.h = (size as any).h;\r\n        // console.log(\"encode coorde\", {size, sp, ep, ret});\r\n        ret.currentCoordType = edgePointCoordMode;\r\n        return ret;\r\n    }\r\n    public encodePosCoords(c: Context, size0: Partial<EPSize>, view: LViewElement, sp0?: GraphPoint, ep0?: GraphPoint, mode?: CoordinateMode): Partial<EPSize> {\r\n        if (!view) view = this.get_view(c);\r\n        let size: Partial<EPSize> = size0 as any;\r\n        let edgePointCoordMode = mode || (view.__raw || view).edgePointCoordMode;\r\n        let le: LVoidEdge = c&&c.proxyObject.father;\r\n        let sp: GraphPoint = sp0 || le.startPoint;\r\n        let ep: GraphPoint = ep0 || le.endPoint;\r\n        return LEdgePoint.encodeCoords(size, edgePointCoordMode, sp, ep);\r\n    }\r\n\r\n    /* 13/10/2023 Giordano comment (defined in LPointerTargetable\r\n    public get_delete(context: Context): () => void {\r\n        // careful: pointedBy might be broken due to comment x984 (search it)\r\n        return super.get_delete(context);\r\n    }\r\n    */\r\n}\r\nRuntimeAccessibleClass.set_extend(DVoidVertex, DEdgePoint);\r\nRuntimeAccessibleClass.set_extend(LVoidVertex, LEdgePoint);\r\n\r\n@RuntimeAccessible('DVertex')\r\nexport class DVertex extends DGraphElement { // DVoidVertex\r\n    // static _super = DVoidVertex;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LVertex;\r\n    // static logic: typeof LVertex;\r\n    // static structure: typeof DVertex;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DVertex, 1, 1, LVertex>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 0, 1, LModelElement>;\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n    zoom!: GraphPoint;\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    isResized!: boolean;\r\n    // size!: GraphSize; // virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\r\n    // personal attributes\r\n    __isDVertex!: true;\r\n\r\n    public static new(htmlindex: number, model: DGraphElement[\"model\"], parentNodeID: DGraphElement[\"father\"],\r\n                      graphID: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"], size?: GraphSize): DVertex {\r\n        return new Constructors(new DVertex('dwc'), parentNodeID, true, undefined, nodeID)\r\n            .DPointerTargetable()\r\n            .DGraphElement(model, graphID, htmlindex)\r\n            .DVoidVertex(size || defaultVertexSize).DVertex().end();\r\n    }\r\n}\r\n\r\n@RuntimeAccessible('LVertex')\r\nexport class LVertex<Context extends LogicContext<any> = any, D = DVertex> extends LVoidVertex {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LVertex;\r\n    // static logic: typeof LVertex;\r\n    // static structure: typeof DVertex;\r\n\r\n    // inherit redefine\r\n    __raw!: DVertex;\r\n    id!: Pointer<DVertex, 1, 1, LVertex>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn?: LGraphElement;\r\n    subElements!: LGraphElement[];\r\n    zoom!: GraphPoint;\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    size!: GraphSize; // virtual, gets extracted from this. x and y are stored directly here as it extends GraphSize\r\n    isResized!: boolean;\r\n    // personal attributes\r\n    __isLVertex!: true;\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(DGraphElement, DVertex);\r\nRuntimeAccessibleClass.set_extend(LGraphElement, LVertex);\r\n\r\n@Leaf\r\n@RuntimeAccessible('DGraphVertex')\r\nexport class DGraphVertex extends DGraphElement { // MixOnlyFuncs(DGraph, DVertex)\r\n    // static _super1 = DGraph;\r\n    // static _super2 = DVertex;\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraphVertex;\r\n    // static logic: typeof LGraphVertex;\r\n    // static structure: typeof DGraphVertex;\r\n\r\n    // inherit redefine\r\n    id!: Pointer<DGraphVertex, 1, 1>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 1, 1, LModelElement>;\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n    // from graph\r\n    zoom!: GraphPoint;\r\n    offset!: GraphPoint; // in-graph scrolling position\r\n\r\n    // from VoidVertex\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    isResized!: boolean;\r\n    // size!: GraphSize; // virtual\r\n    // from graph\r\n\r\n    // personal attributes\r\n    __isDVertex!: true;\r\n    __isDGraph!: true;\r\n    __isDGraphVertex!: true;\r\n\r\n    public static new(htmlindex: number, model: DGraph[\"model\"], parentNodeID: DGraphElement[\"father\"],\r\n                      graphID: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"], size?: GraphSize): DGraphVertex {\r\n        return new Constructors(new DGraphVertex('dwc'), parentNodeID, true, undefined, nodeID)\r\n            .DPointerTargetable().DGraphElement(model, graphID, htmlindex)\r\n            .DVoidVertex(size || defaultVertexSize).DVertex().DGraph().end();\r\n    }\r\n\r\n\r\n    /*\r\n        static init_constructor(thiss: DGraphVertex, isUser: boolean = false, nodeID: string | undefined, graphID: string | undefined, model: Pointer<DModel>): void {\r\n            DGraph.init_constructor(thiss, isUser, nodeID, graphID, model);\r\n    //isUser: boolean = false, nodeID: string | undefined, graphID: string, model?: Pointer<DModel>\r\n            DVertex.init_constructor(thiss, isUser, nodeID, graphID as string, model);\r\n            thiss.className = this.name;\r\n        }*/\r\n}\r\nclass LG extends LGraph{}\r\nclass LV extends LVertex{}\r\n\r\nconst Mixed = MixOnlyFuncs(LG, LV) as (typeof LG & typeof LV & typeof RuntimeAccessibleClass);\r\n@RuntimeAccessible('LGraphVertex')\r\n//@ts-ignore TS2510\r\nexport class LGraphVertex<Context extends LogicContext<any> = any, D extends DGraphVertex = any> extends Mixed { // MixOnlyFuncs(LGraph, LVertex)\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraphVertex;\r\n    // static logic: typeof LGraphVertex;\r\n    // static structure: typeof DGraphVertex;\r\n\r\n    // inherit redefine\r\n    __raw!: DGraphVertex;\r\n    id!: Pointer<DGraphVertex, 1, 1>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn?: LGraphElement;\r\n    ///////////////////////////////////////// subElements!: LGraphElement[];\r\n    // from graph\r\n    zoom!: GraphPoint;\r\n    offset!: GraphPoint; // in-graph scrolling position\r\n    graphSize!: GraphSize; // internal size of the graph. can be huge even if the sub-graph is in a small window (scroll)\r\n\r\n    // from VoidVertex\r\n    x!: number;\r\n    y!: number;\r\n    w!: number;\r\n    h!: number;\r\n    isResized!: boolean;\r\n    size!: GraphSize; // virtual\r\n\r\n\r\n    // personal attributes\r\n    __isLVertex!: true;\r\n    __isLGraph!: true;\r\n    __isLGraphVertex!: true;\r\n}\r\n\r\nRuntimeAccessibleClass.set_extend(DGraph, DGraphVertex);\r\nRuntimeAccessibleClass.set_extend(DVertex, DGraphVertex);\r\nRuntimeAccessibleClass.set_extend(LGraph, LGraphVertex);\r\nRuntimeAccessibleClass.set_extend(LVertex, LGraphVertex);\r\n\r\n\r\n@RuntimeAccessible('DVoidEdge')\r\nexport class DVoidEdge extends DGraphElement {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LVoidEdge;\r\n    // static logic: typeof LVoidEdge;\r\n    // static structure: typeof DVoidEdge;\r\n    id!: Pointer<DVoidEdge, 1, 1, LVoidEdge>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 0, 1, LModelElement>;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n\r\n    // personal attributes\r\n    start!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    end!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    __isDVoidEdge!: true;\r\n\r\n    midPoints!: InitialVertexSize[]; // the logic part which instructs to generate the midnodes\r\n    midnodes!: Pointer<DEdgePoint, 1, 1, LEdgePoint>[]; // using subelements instead most of times\r\n\r\n    longestLabel!: PrimitiveType | labelfunc;\r\n    labels!: PrimitiveType[] | labelfunc[];\r\n    anchorStart?: string;\r\n    anchorEnd?: string;\r\n    // endFollow!: boolean; they became derived attributes from static properties\r\n    // startFollow!: boolean;\r\n\r\n    static isFollowingCoords: GraphPoint;\r\n\r\n    public static new(htmlindex: number, model: DGraph[\"model\"]|null|undefined, parentNodeID: DGraphElement[\"father\"], graphID: DGraphElement[\"graph\"],\r\n                      nodeID: DGraphElement[\"id\"]|undefined, start: DGraphElement[\"id\"], end: DGraphElement[\"id\"],\r\n                      longestLabel?: DEdge[\"longestLabel\"], labels?: DEdge[\"labels\"]): DEdge {\r\n        return new Constructors(new DEdge('dwc'), parentNodeID, true, undefined, nodeID)\r\n            .DPointerTargetable()\r\n            .DGraphElement(model, graphID, htmlindex)\r\n            .DVoidEdge(start, end, longestLabel, labels).end();\r\n    }\r\n    public static new2(model: DGraph[\"model\"]|null|undefined, parentNodeID: DGraphElement[\"father\"], graphID: DGraphElement[\"graph\"],\r\n                       nodeID: DGraphElement[\"id\"]|undefined, start: DGraphElement[\"id\"], end: DGraphElement[\"id\"], setter:((d: DEdge) => any)): DEdge {\r\n        return new Constructors(new DEdge('dwc'), parentNodeID, true, undefined, nodeID)\r\n            .DPointerTargetable()\r\n            .DGraphElement(model, graphID)\r\n            .DVoidEdge(start, end).end(setter);\r\n    }\r\n}\r\n/*\r\n@RuntimeAccessible\r\nexport class MidPoint{\r\n    readonly id: string; // not really a pointer, it's not on store.\r\n    x?: number; y?: number;\r\n    readonly w?: number; // if it's modified it's not ever here (initial size) but on DEdgePoint that is a Node.\r\n    readonly h?: number;/*\r\n    constructor2(x: number=5, y: number=5, w: number=5, h: number=5) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.w = w;\r\n        this.h = h;\r\n    }* /\r\nconstructor(id: string, w: number=5, h: number=5) {\r\n    this.id = id;\r\n    this.w = w;\r\n    this.h = h;\r\n}\r\n}*/\r\n@RuntimeAccessible('EdgeSegment')\r\nexport class EdgeSegment{\r\n    index: number;\r\n    prev: EdgeSegment | undefined;\r\n    start: segmentmaker;\r\n    bezier: segmentmaker[];\r\n    end: segmentmaker;\r\n    length!: number;\r\n    d!: string;\r\n    dpart!: string; //  a segment of the whole path\r\n    m!: number; // m coefficient of the line between start and end.\r\n    rad!: number; // for head and tails: radian angle of the segment.\r\n    radLabels!: number; // for labels: it flips the angle when it's < PI/2 so the text is never upside down\r\n\r\n    isLongest!: boolean;\r\n    label!: PrimitiveType | JSX.Element | undefined;\r\n    svgLetter: EdgeBendingMode;\r\n    /*constructor(label: PrimitiveType|undefined, length: number, startp: GraphPoint, endp: GraphPoint, start: LGraphElement, end: LGraphElement,\r\n                bezierpts: GraphPoint[], mid: LGraphElement[],\r\n                svgLetter: EdgeBendingMode, index: number, fillMode: MidNodeHandling) {\r\n        this.label = label;\r\n        this.length = length;\r\n        this.length = length;\r\n        this.startp = startp;\r\n        this.bezierp = bezierpts;\r\n        this.endp = endp;\r\n        this.start = start;\r\n        this.end = end;\r\n        this.mid = mid;\r\n    }*/\r\n    constructor(start: segmentmaker, mid: segmentmaker[], end: segmentmaker,\r\n                svgLetter: EdgeBendingMode, gapMode: EdgeGapMode,\r\n                index: number, prevSegment: EdgeSegment | undefined){\r\n        // console.log(\"segmentmaker:\", arguments, ((start.ge?.model as any)?.name)+\" ---> \" + ((end.ge?.model as any)?.name));\r\n        this.start = start;\r\n        this.bezier = mid;\r\n        this.end = end;\r\n        this.index = index;\r\n        this.prev = prevSegment;\r\n        //this.segments = segments;\r\n        // the idea: forbid all T and S or transform them in C, Q by calculating and manually adding their mirrored bezier pts\r\n        // if (svgLetter[1]) svgLetter = (svgLetter[0]) as any;\r\n        if (svgLetter === EdgeBendingMode.Bezier_QT) {\r\n            this.svgLetter = EdgeBendingMode.Bezier_QT[0] as any as EdgeBendingMode;\r\n            // this.svgLetter = (index === 0 ? EdgeBendingMode.Bezier_QT[0] : EdgeBendingMode.Bezier_QT[1]) as any as EdgeBendingMode;\r\n            this.addBezierPoint();\r\n        } else\r\n        if (svgLetter === EdgeBendingMode.Bezier_CS) {\r\n            this.svgLetter = EdgeBendingMode.Bezier_CS[0] as any as EdgeBendingMode;\r\n            // this.svgLetter = (index === 0 ? EdgeBendingMode.Bezier_CS[0] : EdgeBendingMode.Bezier_CS[1]) as any as EdgeBendingMode;\r\n            this.addBezierPoint();\r\n        }\r\n        else this.svgLetter = svgLetter;\r\n\r\n        // fix if amount of bezier pts is invalid for current letter\r\n        switch (this.svgLetter) {\r\n            case EdgeBendingMode.Line:\r\n            case EdgeBendingMode.Bezier_quadratic:\r\n                if (this.bezier.length >= 1) break;\r\n                else this.svgLetter = EdgeBendingMode.Line;\r\n                break;\r\n            case EdgeBendingMode.Bezier_cubic:\r\n                if (this.bezier.length >= 2) break;\r\n                else if (this.bezier.length >= 1) this.svgLetter = EdgeBendingMode.Bezier_quadratic;\r\n                else this.svgLetter = EdgeBendingMode.Line;\r\n                break;\r\n            case EdgeBendingMode.Elliptical_arc:\r\n                if (this.bezier.length >= 3) break;\r\n                else this.svgLetter = EdgeBendingMode.Line; // straight to end ignoring midpoints that are NOT coordinates when using elliptical arc.\r\n                break;\r\n            default:\r\n            //case EdgeBendingMode.Bezier_quadratic_mirrored as string:\r\n            //case EdgeBendingMode.Bezier_cubic_mirrored as string: // translated to Q or C by adding mirrored bezier points explicitly\r\n            case EdgeBendingMode.Bezier_QT:\r\n            case EdgeBendingMode.Bezier_CS: // translated to Q or C by sending the right letter to each segment\r\n                Log.exDevv(\"this svg letter should not appear here\", this.svgLetter);\r\n                break;\r\n        }\r\n    }\r\n    addBezierPoint(): void {\r\n        let prev: EdgeSegment | undefined = this.prev;\r\n        if (!prev) return;\r\n        let prevedgemakerbezier: segmentmaker = (prev.bezier[prev.bezier.length-1] || prev.start);\r\n        let mirroredBezier: segmentmaker = {...prevedgemakerbezier,\r\n            pt: EdgeSegment.invertLastBezierPt(prevedgemakerbezier.pt, prev.end.pt),\r\n            uncutPt: EdgeSegment.invertLastBezierPt(prevedgemakerbezier.uncutPt, prev.end.uncutPt),\r\n        };\r\n        this.bezier = [mirroredBezier, ...this.bezier];\r\n        // always only 1 assumed pt both in cubic and quadratic.\r\n        // let next: this | undefined = this.segments[this.index+1];\r\n        // EdgeSegment.invertLastBezierPt((next.mid[1] || next.end).pt, next.start.pt);\r\n    }\r\n\r\n    makeD(index: number, gapMode: EdgeGapMode): string {\r\n        this.m = GraphPoint.getM(this.start.pt, this.end.pt);\r\n        this.rad = Geom.mToRad(this.m, this.start.pt, this.end.pt);\r\n        this.radLabels = Math.atan(this.m);\r\n\r\n        let svgLetter = this.svgLetter; // caller makes sure to pass right letter and resolve \"CS\" mixed letters. // this.bendingModeToLetter(bendingMode, index);\r\n        // caller sends inverted pts as normal coords\r\n        // let invertedBezPt = lastSegment && EdgeSegment.invertLastBezierPt(lastSegment.midp[lastSegment.mid.length-1] || lastSegment.startp, lastSegment.endp);\r\n        switch (this.svgLetter.length) {\r\n            case 2:\r\n                return Log.exDevv(\"mixed letters are not allowed and should have been resolved to single svg letters before here, found:\" + svgLetter);\r\n            /*return Log.exDevv(\"dev problem to fix:\\n\" +\r\n            \"the mirrored mode requires the first one to have explicit non-mirrored mode?? like M, C a1 a2 a3, S a1, S a1, S a1\\n\" +\r\n            \"So all segments with mixed modes needs to extract the last bezier point (penultimate coordinate) from previous segments, mirror it and insert in midp[0]\");*/\r\n            case 1:\r\n                let bezierpts = [...this.bezier.map( b => b.pt), this.end.pt];\r\n                let finalpart = svgLetter + \" \" + bezierpts.map((p)=> p.x + \" \" + p.y).join(\", \");\r\n                this.dpart = \"M \" + this.start.pt.x + \" \" + this.start.pt.y + \", \" + finalpart;\r\n                let bezierptsUncut = [...this.bezier.map( b => b.uncutPt), this.end.pt]; // uncutPt exist for start and end too, but i want to use the cut one for those. or edgehead is off\r\n                let finalpartUncut = svgLetter + \" \" + bezierptsUncut.map((p)=> p.x + \" \" + p.y).join(\", \");\r\n                this.d = (index === 0 ? \"M\" + this.start.pt.x + \" \" + this.start.pt.y + \", \" : \"\") + finalpartUncut;\r\n\r\n                //midp = [this.startp, ...this.midp];\r\n                // d = M sp X mp2 ep // X = custom letter\r\n                // dpart = T sp X mp2 ep // S = S if X = C,\r\n                // sp is the startingpoint from the prev node, which might be != from endpoint of last node if last node have w>0 && h>0\r\n                // so i'm \"filling\" the gap with a T, or L arc wich can use only 1 parameter (they are the only 1-parameter arcs)\r\n                // if (this.prev && this.prev.end.pt.equals(this.start.pt)) gapMode = EdgeGapMode.average; // if the 2 points coincide, i use any 1 of the gapmodes that are continuous\r\n                /*switch (gapMode){\r\n                    case EdgeGapMode.center:\r\n                    case EdgeGapMode.average:\r\n                        // continuous gap modes. they only differ in how the \"joining\" point is found, but not in how they behave after that.\r\n                        /*\r\n                        if (index === 0) {\r\n                             startletter = \"M \";\r\n                         }\r\n                         else {\r\n                             switch (svgLetter) {\r\n                                 case SvgLetter.A: case SvgLetter.C: case SvgLetter.S: case SvgLetter.Q: case SvgLetter.T: default:\r\n                                     startletter = SvgLetter.T + \" \"; break;\r\n                                 case SvgLetter.L: case SvgLetter.M:\r\n                                     startletter = SvgLetter.L + \" \"; break;\r\n                             }\r\n                         }* /\r\n                        if (index) {\r\n                            this.d = finalpart;\r\n                        }\r\n                        else { this.d = this.dpart; }\r\n                        break;\r\n                    case EdgeGapMode.gap:\r\n                    case EdgeGapMode.autoFill:\r\n                    case EdgeGapMode.lineFill:\r\n                    case EdgeGapMode.arcFill:\r\n                        // the filling itself is done by another segment (solving svg letter and simulating i=0), so i treat it as a gap.\r\n                        this.d = this.dpart;\r\n                        break;\r\n                    default:\r\n                        Log.exDevv(\"unexpected EdgeGapMode:\" + gapMode, {gapMode});\r\n                }*/\r\n                break;\r\n            default: return Log.exDevv(\"unexpected bending mode length:\" + this.svgLetter + \" or fillMode: \" + gapMode, {bendingMode: this.svgLetter, index, gapMode});\r\n        }\r\n\r\n        //using\r\n        /*\r\n        88\r\n\r\n        // d should not have M set (except for segments[0]\r\n        // dpart have M abd beed to add explicit points for \"mirroring\" and transforming bezier quadratic mirrored in bezier quadratic normal etc.\r\n        //88 problem: the mirrored mode requires the first one to have explicit nonmirrored mode?? like M, C a1 a2 a3, S a1, S a1, S a1 .... ?\r\n        in any case the % letter part is wrong because it needs to subtract first element used for M*/\r\n        return this.d;\r\n    }\r\n\r\n    static invertLastBezierPt(bezier: GraphPoint, end: GraphPoint): GraphPoint{\r\n        // vector = bezier - end\r\n        // end + vector = bezier\r\n        // end - vector = inverted bezier? = 2*end-bezier\r\n        let vector = bezier.subtract(end, true);\r\n        return end.subtract(vector, true);\r\n    }\r\n\r\n    calcLength(): void {\r\n        this.length = this.start.pt.distanceFromPoint(this.end.pt);\r\n    }\r\n}\r\n\r\nexport class EdgeFillSegment extends EdgeSegment{\r\n    public static cname: string = \"EdgeFillSegment\";\r\n    makeD(index: number, gapMode: EdgeGapMode): string {\r\n        // if (gapMode === EdgeGapMode.autoFill) { gapMode = this.svgLetter === EdgeBendingMode.Line ? EdgeGapMode.lineFill : EdgeGapMode.arcFill; }\r\n        switch (gapMode) {\r\n            case \"closest\" as any:// EdgeGapMode.closest:\r\n            case EdgeGapMode.center:\r\n            case EdgeGapMode.average:\r\n            case EdgeGapMode.gap:\r\n                return \"\"; // should not have filler arcs\r\n            default:\r\n                /*\r\n            case EdgeGapMode.autoFill as any:\r\n            case EdgeGapMode.lineFill:\r\n                this.bezier = [];\r\n                this.svgLetter = EdgeBendingMode.Line;\r\n                return super.makeD(index, gapMode);\r\n            case EdgeGapMode.arcFill:*/\r\n                this.svgLetter = this.svgLetter[0] as EdgeBendingMode;\r\n                if (this.svgLetter === \"Q\") this.bezier = this.bezier.length ? [this.bezier[0]] : [];\r\n                return super.makeD(index, gapMode);\r\n        }\r\n    }\r\n}\r\n\r\n\r\ntype segmentmaker = {size: GraphSize, view: LViewElement, ge: LGraphElement, pt: GraphPoint, uncutPt: GraphPoint};\r\n@RuntimeAccessible('LVoidEdge')\r\nexport class LVoidEdge<Context extends LogicContext<DVoidEdge> = any, D extends DEdge = DEdge> extends LGraphElement {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LVoidEdge;\r\n    // static logic: typeof LVoidEdge;\r\n    // static structure: typeof DVoidEdge;\r\n    __raw!: DVoidEdge;\r\n    id!: Pointer<DVoidEdge, 1, 1, LVoidEdge>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn?: LGraphElement;\r\n    subElements!: LGraphElement[];\r\n    start!: LGraphElement;\r\n    end!: LGraphElement;\r\n    __isLVoidEdge!: true;\r\n    midPoints!: InitialVertexSize[]; // the logic part which instructs to generate the midnodes\r\n    midnodes!: LEdgePoint[];\r\n    edge!: LVoidEdge; // returns self. useful to get edge from edgePoints without triggering error if you are already on edge.\r\n    __info_of__edge: Info = {type:\"?LEdge\", txt:\"returns this if called on an edge, the containing edge if called on an EdgePoint, undefined otherwise.\"}\r\n\r\n\r\n/*\r\nreplaced by startPoint\r\n    edgeStart!: GraphPoint;\r\n    edgeStart_inner!: GraphPoint;\r\n    edgeStart_outer!: GraphPoint;\r\n    __info_of__edgeStart: Info = {type: \"GraphPoint\", txt: \"Same as edgeStart_outer.\"}\r\n    __info_of__edgeStart_outer: Info = {type: \"GraphPoint\",\r\n     txt: \"Where the edge should start his path, in coordinates relative at the root Graph.\r\n     <br>Computed by combining the anchor offset option in View and the size of the starting node.\"}\r\n    __info_of__edgeStart_inner: Info = {type: \"GraphPoint\",\r\n     txt: \"Where the edge should start his path, in coordinates relative at the most nested Graph.\r\n     <br>Computed by combining the anchor offset option in View and the size of the starting node.\"}\r\n    edgeEnd!: GraphPoint;\r\n    edgeEnd_inner!: GraphPoint;\r\n    edgeEnd_outer!: GraphPoint;\r\n    __info_of__edgeEnd: Info = {type: \"GraphPoint\", txt: \"Same as edgeEnd_outer.\"}\r\n    __info_of__edgeEnd_outer: Info = {type: \"GraphPoint\",\r\n     txt: \"Where the edge should end his path, in coordinates relative at the root Graph.\r\n     <br>Computed by combining the anchor offset option in View and the size of the starting node.\"}\r\n    __info_of__edgeEnd_inner: Info = {type: \"GraphPoint\",\r\n     txt: \"Where the edge should end his path, in coordinates relative at the most nested Graph.\r\n     <br>Computed by combining the anchor offset option in View and the size of the starting node.\"}\r\n*/\r\n\r\n\r\n    label!: PrimitiveType;  // should never be read change their documentation in write only. their values is \"read\" in this.segments\r\n    longestLabel!: PrimitiveType;\r\n    labels!: PrimitiveType[];\r\n    allNodes!: [LGraphElement, ...Array<LEdgePoint>, LGraphElement];\r\n    __info_of__longestLabel: Info = {label:\"Longest label\", type:\"function(edge)=>string | string\", readType: \"PrimitiveType\",\r\n        writeType:\"PrimitiveType | (e:this, curr: LGraphElement, next: LGraphElement, curr_index: number, allNodes: LGraphElement[]) => PrimitiveType)\",\r\n        txt: <span>Label assigned to the longest path segment.</span>}\r\n    __info_of__label: Info = {type: \"\", txt: <span>Alias for longestLabel</span>};\r\n    __info_of__labels: Info = {label:\"Multiple labels\", type: \"function(edge)=>string | string\",\r\n        writeType: \"type of label or Array<type of label>\",\r\n        txt: <span>Instructions to label to multiple or all path segments in an edge</span>};\r\n    __info_of__allNodes: Info = {type: \"[LGraphElement, ...Array<LEdgePoint>, LGraphElement]\", txt: <span>first element is this.start. then all this.midnodes. this.end as last element</span>};\r\n\r\n\r\n    get_label(c: Context): this[\"longestLabel\"] { return this.get_longestLabel(c); }\r\n    set_label(val: this[\"longestLabel\"], c: Context): boolean { return this.set_longestLabel(val, c); }\r\n    get_longestLabel(c: Context): this[\"longestLabel\"] { return c.data.longestLabel as any; }\r\n    set_longestLabel(val: this[\"longestLabel\"], c: Context): boolean { SetFieldAction.new(c.data, \"longestLabel\", val); return true; }\r\n    get_labels(c: Context): this[\"labels\"] { return c.data.labels as any; }\r\n    set_labels(val: this[\"labels\"], c: Context): boolean { SetFieldAction.new(c.data, \"labels\", val); return true; }\r\n    public headPos_impl(c: Context, isHead: boolean, headSize0?: GraphPoint, segment0?: EdgeSegment, zoom0?: GraphPoint): GraphSize & {rad: number} {\r\n        let segment: EdgeSegment = segment0 || this.get_segments(c).segments[0];\r\n        // let v: LViewElement = this.get_view(c);\r\n        let tmp: any = headSize0 || (isHead ? this.get_view(c).edgeHeadSize : this.get_view(c).edgeTailSize);\r\n        if (!tmp || tmp.x === 0 || tmp.y === 0) {\r\n            // head or tail missing\r\n            tmp = new GraphSize(0, 0, 0, 0);\r\n            tmp.rad = 0;\r\n            return tmp;\r\n        }\r\n        let zoom: GraphPoint = zoom0 || this.get_graph(c).zoom;\r\n        let headPos: GraphSize & {rad: number} = (new GraphSize(0, 0, tmp.x, tmp.y) as any); //.multiply({w:zoom.x, h:zoom.y});\r\n        let useBezierPoints = true;\r\n        let start: GraphPoint, end: GraphPoint;\r\n        let m: number;\r\n        if (useBezierPoints) {\r\n            if (isHead) {\r\n                start = segment.end.pt;\r\n                end = (segment.bezier[segment.bezier.length - 1] || segment.start).pt;\r\n            } else {\r\n                start = segment.start.pt;\r\n                end = (segment.bezier[0] || segment.end).pt;\r\n            }\r\n            m = GraphPoint.getM(start, end);\r\n        } else {\r\n            if (isHead) { start = segment.end.pt; end = segment.start.pt; }\r\n            else { start = segment.start.pt; end = segment.end.pt; }\r\n            m = segment.m;\r\n        }\r\n        // first find the center of where it should be positioned\r\n        // let center: GraphPoint;\r\n        // let distance: number = Math.sqrt(headPos.w*headPos.w + headPos.h*headPos.h);\r\n        // let isVertical = m >=1 ;\r\n        let x4headsize = new GraphSize(start.x - headPos.w, start.y - headPos.h, headPos.w*2, headPos.h*2);\r\n        // first intersection is segment origin. second is found with the box containing all possible edgeHead positions that touch the startPoint\r\n        // (doing x4 his shape and placing 4 \"rectangles\" all around startPoint) to cover all possible segment directions.\r\n        // or finding first direction (vertical if m >1, horizontal if m<0) and vector direction and intersecting with only the \"correct\" placed edgeHead rectangle.\r\n        // then the intersection will likely not fall on the extreme angle of EdgeHead and i can re-center edgeHead\r\n        // so that first and second intersections are equal spaced with the center segment\r\n        let secondIntersection: GraphPoint | undefined;\r\n        let segmentDistance = start.distanceFromPoint(end);\r\n        if (segmentDistance <= Math.sqrt(headPos.w**2 + headPos.h**2)){\r\n            let safeDistance = Math.max(headPos.w, headPos.h)*5;\r\n            end = new GraphPoint( end.y + safeDistance, end.y + m * safeDistance); // move the point away so it doesn't intersect anymore. i just need direction\r\n            // too small to fit edgeHead, i simply put it centered on the whole segment\r\n            // secondIntersection = end;\r\n        }\r\n        secondIntersection = GraphSize.closestIntersection(x4headsize, start, end, undefined);\r\n        if (!secondIntersection) return Log.exx(\"failed to intersect edge head\", {x4headsize, segment, headPos, c, start, end, useBezierPoints});\r\n        tmp = secondIntersection.add(start, false).divide(2); // center of edgehead\r\n        headPos.x = tmp.x - headPos.w / 2; // tl corner\r\n        headPos.y = tmp.y - headPos.h / 2; // tl corner\r\n        headPos.rad = Geom.mToRad(m, start, end);\r\n        /*\r\n        devo trovare la distanza tra il centro dell'egeHead e il punto di inizio in termini assoluti, così tramite M trovo distanza in x e y. o trovarla in altro modo\r\n        if (segment.m === Number.POSITIVE_INFINITY || segment.m === Number.NEGATIVE_INFINITY) {\r\n            center = segment.start.pt.add({x:0, y: distance}, true); }\r\n        else { center = segment.start.pt.add({x:segment.m*headPos.w/2, y:segment.m*headPos.h/2\r\n         this is wrong, cannot be the same for x and y, i should invert the line equation for x?}, true); }\r\n        headPos.x = center.x - headPos.w / 2;\r\n        headPos.y = center.y - headPos.h / 2;*/\r\n        // console.log(\"head intersected\", {headPos, secondIntersection, x4headsize, segment, c, start, end, useBezierPoints});\r\n\r\n        return headPos;\r\n    }\r\n\r\n    public headPos(headSize0?: GraphPoint, segment0?: EdgeSegment, zoom0?: GraphPoint): GraphSize & {rad: number} {\r\n        return this.wrongAccessMessage(\"This is not headPos() implementation. it is just for typings. use the getter\"); }\r\n    public tailPos(headSize0?: GraphPoint, segment0?: EdgeSegment, zoom0?: GraphPoint): GraphSize & {rad: number} {\r\n        return this.wrongAccessMessage(\"This is not tailPos() implementation. it is just for typings. use the getter\"); }\r\n    protected get_headPos(c: Context): this[\"headPos\"] {\r\n        return (headSize?: GraphPoint, segment?: EdgeSegment, zoom?: GraphPoint) => this.headPos_impl(c, true, headSize, segment, zoom); }\r\n    protected get_tailPos(c: Context): this[\"tailPos\"] {\r\n        return (headSize?: GraphPoint, segment?: EdgeSegment, zoom?: GraphPoint) => this.headPos_impl(c, false, headSize, segment, zoom); }\r\n    protected get_allNodes(c: Context): this[\"allNodes\"] { return [this.get_start(c), ...this.get_midnodes(c), this.get_end(c)]; }\r\n\r\n    protected get_edge(c: Context): this{ return c.proxyObject as this; }\r\n    protected set_edge(v: any, c: Context): false { return this.cannotSet(\"edge field, on an edge element\"); }\r\n    protected get_midPoints(c: Context):this[\"midPoints\"] { return c.data.midPoints; }\r\n    public addMidPoint(v: this[\"midPoints\"][0]): boolean { return this.wrongAccessMessage(\"addMidPoint\"); }\r\n    protected get_addMidPoint(c: Context): (v: this[\"midPoints\"][0]) => boolean { return (v:this[\"midPoints\"][0]) => this.impl_addMidPoints(v, c); }\r\n    protected set_midPoints(val: this[\"midPoints\"], c: Context): boolean {\r\n        return SetFieldAction.new(c.data.id, \"midPoints\", val, undefined, false);\r\n    }\r\n    protected impl_addMidPoints(val: this[\"midPoints\"][0], c: Context): boolean {\r\n        return SetFieldAction.new(c.data.id, \"midPoints\", val, '+=', false);\r\n    }\r\n    protected get_label_impl(c: Context, segment: EdgeSegment, nodes: this[\"allNodes\"], segments: EdgeSegment[]): PrimitiveType | undefined {\r\n        let key: \"longestLabel\" | \"labels\" = segment.isLongest ? \"longestLabel\" : \"labels\"; // : keyof this\r\n        // if (isLongestSegment) return this.get_longestLabel_impl(d, l, nodes, index):\r\n        const d = c.data;\r\n        const l = c.proxyObject;\r\n        let labelmaker: any = d[key]; // orArr<PrimitiveType | JSX | function>\r\n        let labelmakerfunc: labelfunc = labelmaker as any;\r\n        // let lastSeg = segments[i-1];\r\n        switch (typeof labelmaker) {//nb{}[]<>\r\n            case \"number\":\r\n            case \"undefined\":\r\n            case \"boolean\":\r\n            case \"string\": return labelmaker;\r\n            // case \"function\": return nodes.map( (o, i) => d.labels(l, nodes, i)).slice(0, nodes.length-1);\r\n            case \"function\": return labelmakerfunc(l, segment, nodes, segments);\r\n            default: break;\r\n            case \"object\":\r\n                if (labelmaker === null) return null;\r\n                if (!Array.isArray(labelmaker)) break;\r\n                if (typeof labelmaker[0] === \"function\") return (labelmaker[segment.index % labelmaker.length] as labelfunc)(l, segment, nodes, segments);\r\n                return (labelmaker as PrimitiveType[])[segment.index % labelmaker.length];\r\n        }\r\n        Log.exx(\"edge labels invalid type, must be a primitive value, a function or an array of such.\", {labelmaker, key, d});\r\n        return undefined;\r\n    }/*\r\n    private get_label_impl_old(d: DVoidEdge, l: LVoidEdge, nodes:this[\"allNodes\"], index: number, longestlabelindex?: number): PrimitiveType {\r\n        if (d.longestLabel !== undefined && index === longestlabelindex) return this.get_longestLabel_impl(d, l, nodes, index);\r\n        switch (typeof d.labels) {//nb{}[]<>\r\n            case \"number\":\r\n            case \"undefined\":\r\n            case \"boolean\":\r\n            case \"string\": return d.labels;\r\n            // case \"function\": return nodes.map( (o, i) => d.labels(l, nodes, i)).slice(0, nodes.length-1);\r\n            case \"function\": return d.labels(l, nodes[index], nodes[index+1], index, nodes);\r\n            default: break;\r\n            case \"object\": if (!Array.isArray(d.labels)) break;\r\n            if (typeof d.labels[0] === \"function\") return (d.labels as any)[index % d.labels.length](l, nodes[index], nodes[index+1], index, nodes);\r\n            return (d.labels as PrimitiveType[])[index % d.labels.length];\r\n        }\r\n        Log.exx(\"edge labels invalid type, must be a primitive value, a function or an array of such.\", d.labels);\r\n    }*/\r\n\r\n    __info_of__startPoint: Info = {type: \"GraphPoint\", txt:<span>startPoint of this.start (element originating the edge). Defaults in outer coordinates.</span>};\r\n    __info_of__endPoint: Info = {type: \"GraphPoint\", txt:<span>endPoint of this.end (element originating the edge). Defaults in outer coordinates.</span>};\r\n    public get_startPoint(context: Context): GraphPoint{ return this.get_startPoint_Outer(context); }\r\n    public get_endPoint(context: Context): GraphPoint{ return this.get_endPoint_Outer(context); }\r\n    public get_startPoint_Outer(c: Context): GraphPoint{\r\n        // console.log(\"get_edgeStart_Outer\", {out:this.get_outerGraph(c), pos:this.get_startPoint_inner(c), inner:this.get_start(c).innerGraph});\r\n        return this.get_outerGraph(c).translateSize(this.get_startPoint_inner(c), this.get_start(c).innerGraph);\r\n    }\r\n    public get_endPoint_Outer(c: Context): GraphPoint{\r\n        // console.log(\"get_edgeEnd_Outer\", {out:this.get_outerGraph(c), pos:this.get_endPoint_inner(c), inner:this.get_end(c).innerGraph});\r\n        return this.get_outerGraph(c).translateSize(this.get_endPoint_inner(c), this.get_end(c).innerGraph);\r\n    }\r\n\r\n    public get_startPoint_inner(c: Context): GraphPoint{ return this.get_edgeStartEnd_inner(c, true); }\r\n    public get_endPoint_inner(c: Context): GraphPoint{ return this.get_edgeStartEnd_inner(c, false); }\r\n    private get_edgeStartEnd_inner(c: Context, isStart: boolean): GraphPoint{ return isStart ? this.get_start(c).startPoint : this.get_end(c).endPoint; }\r\n    segments!: {all: EdgeSegment[], segments: EdgeSegment[], fillers: EdgeSegment[], head: GraphSize&{rad:number}, tail: GraphSize&{rad:number}};\r\n    segments_inner!: {all: EdgeSegment[], segments: EdgeSegment[], fillers: EdgeSegment[], head: GraphSize&{rad:number}, tail: GraphSize&{rad:number}};\r\n    segments_outer!: {all: EdgeSegment[], segments: EdgeSegment[], fillers: EdgeSegment[], head: GraphSize&{rad:number}, tail: GraphSize&{rad:number}};\r\n    __info_of__segments: Info = {type: \"{all:T, segments:T, fillers:T, head: GraphSize&{rad:number}, tail: as head} where T is EdgeSegment\",\r\n        txt:<span>Collection of segments connecting in order vertex and EdgePoint without intersecting their area, aimed to be rendered in svg path.\r\n            <br/>fillers are arcs generated by view.edgeGapMode being autofill, arcfill or linefill.\r\n            <br/>length of this.segments array is Math.ceil(allNodes.length / svg_letter_size) specified on view.\r\n            <br/>\"head\" and \"tail\" are the position and angle of eventual edge decorators. Refer to this.headPos documentation.</span>}\r\n\r\n    private svgLetterSize(s: string, addM: boolean = true, doublingMidPoints: boolean = true): {first:number, others: number} {\r\n        let ret: {first:number, others: number};\r\n        switch (s) {\r\n            default: ret = Log.exDevv(\"unexpected svg path letter: \\\"\" + s + \"\\\"\", s); break;\r\n            case EdgeBendingMode.Line:\r\n            //case EdgeBendingMode.Bezier_quadratic_mirrored:\r\n                ret = {first:1, others:1}; break;\r\n            case EdgeBendingMode.Bezier_quadratic:\r\n            //case EdgeBendingMode.Bezier_cubic_mirrored:\r\n                ret = {first:2, others:2}; break;\r\n            case EdgeBendingMode.Bezier_cubic: ret = {first:3, others:3}; break;\r\n            case EdgeBendingMode.Elliptical_arc: ret = {first:4, others:4}; break;\r\n\r\n            case EdgeBendingMode.Bezier_QT: ret = {first:2, others:1}; break;\r\n            case EdgeBendingMode.Bezier_CS: ret = {first:3, others:2}; break;\r\n        }\r\n\r\n        // account for the fact that every midpoint is listed twice: at anchor start and anchor end.\r\n        if (doublingMidPoints) {\r\n            // removing last point (first is already excluded because addM didn't trigger yet)\r\n            // , the remaining are midpoints to double. then i add it back\r\n            ret.first = (ret.first - 1) * 2 + 1;\r\n            ret.others = (ret.others - 1) * 2 + 1;\r\n        }\r\n\r\n        // account for the first M letter\r\n        //    (if the segment is not mode.gap or first, M coord still exist in segment but are ignored)\r\n        if (addM) {\r\n            ret.first += 1;\r\n            ret.others += 1;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    private get_points_impl(allNodes: LGraphElement[], outer: boolean, c:Context): segmentmaker[] {\r\n        function getAnchorOffset(size: GraphSize, offset: GraphPoint, isPercentage: boolean, $factor: number = 100) {\r\n            if (!size) size = new GraphSize(0, 0, 0, 0);\r\n            // else if (!size.tl) size = new GraphSize(size.x, size.y, size.w, size.h);\r\n            if (isPercentage) offset = new GraphPoint(offset.x/$factor*(size.w), offset.y/$factor*(size.h));\r\n            return size.tl().add(offset, false);\r\n        }\r\n        const all: segmentmaker[] = allNodes.flatMap((ge, i) => {\r\n            let dge = ge.__raw;\r\n            let base: segmentmaker = {view: ge.view, size: outer ? ge.outerSize : ge.innerSize, ge, pt: null as any, uncutPt: null as any};\r\n            Log.exDev(typeof base.size !== \"object\", \"could not get node size:\", {base, c, outer})\r\n            let rets: segmentmaker | undefined;// = base as any;\r\n            let rete: segmentmaker | undefined;// = {...base} as any;\r\n            let debug = true;\r\n            if (debug) {\r\n                (base as any).anchor_e = dge.anchors[c.data.anchorEnd || 0] || dge.anchors[Object.keys(dge.anchors)[0]];\r\n                (base as any).anchor_s = dge.anchors[c.data.anchorStart || 0] || dge.anchors[Object.keys(dge.anchors)[0]];\r\n            }\r\n\r\n            // get endpoint, then startpoint (land on midnode, then depart from it)\r\n            if (i !== 0){\r\n                rete = {rete:true, ...base} as any as segmentmaker;\r\n                if (i === allNodes.length - 1) {\r\n                    // get end anchor from node\r\n                    let anchor = dge.anchors[c.data.anchorEnd || 0];\r\n                    if (!anchor) anchor = dge.anchors[Object.keys(dge.anchors)[0]];\r\n                    if (anchor) rete.pt = getAnchorOffset(rete.size, anchor, true, 1);\r\n                }\r\n                // if no anchor, treat the node as a midpoint\r\n                if (!rete.pt) {\r\n                    // get ending point from midpoint\r\n                    //rete.pt = (LEdgePoint.singleton as LEdgePoint).get_endPoint(undefined as any, rete.size, rete.view);\r\n                    rete.pt = getAnchorOffset(rete.size, rete.view.edgeStartOffset, rete.view.edgeStartOffset_isPercentage);\r\n                }\r\n                rete.uncutPt = rete.pt;\r\n            }\r\n            if (i !== allNodes.length - 1){\r\n                rets = {rets: true, ...base} as any as segmentmaker;\r\n                if (i === 0) {\r\n                    // get start anchor from node\r\n                    let anchor = dge.anchors[c.data.anchorStart || 0];\r\n                    if (!anchor) anchor = dge.anchors[Object.keys(dge.anchors)[0]];\r\n                    if (anchor) rets.pt = getAnchorOffset(rets.size, anchor, true, 1);\r\n                }\r\n                if (!rets.pt) {\r\n                    // rets starting point from midpoint\r\n                    // rets.pt = (LEdgePoint.singleton as LEdgePoint).get_startPoint(undefined as any, rets.size, rets.view);\r\n                    rets.pt = getAnchorOffset(rets.size, rets.view.edgeStartOffset, rets.view.edgeStartOffset_isPercentage);\r\n                }\r\n                rets.uncutPt = rets.pt;\r\n            }\r\n\r\n            // ret.pt = ge.startPoint\r\n            return rets && rete ? [rete, rets] : (rets ? [rets] : [rete as segmentmaker]); }\r\n        );\r\n\r\n        if (DVoidEdge.isFollowingCoords){\r\n            if (c.data.id === LVoidEdge.endFollow) {\r\n                let seg = all[all.length - 1];\r\n                seg.pt = DVoidEdge.isFollowingCoords;\r\n                seg.size = new GraphSize(seg.pt.x, seg.pt.y, 0.01, 0.01);\r\n            }\r\n            if (c.data.id === LVoidEdge.startFollow) {\r\n                let seg = all[0];\r\n                seg.pt = DVoidEdge.isFollowingCoords;\r\n                seg.size = new GraphSize(seg.pt.x, seg.pt.y, 0.01, 0.01);\r\n            }\r\n        }\r\n        return all;\r\n    }\r\n    private get_pointsDebug(c: Context): segmentmaker[]{ return this.get_points_impl(this.get_allNodes(c), true, c); }\r\n    private get_points(allNodes: LGraphElement[], outer: boolean = false, c: Context): segmentmaker[]{ return this.get_points_impl(allNodes, outer, c); }\r\n    private get_points_outer(allNodes: LGraphElement[], c: Context): segmentmaker[]{ return this.get_points_impl(allNodes, true, c); }\r\n    private get_points_inner(allNodes: LGraphElement[], c: Context): segmentmaker[]{ return this.get_points_impl(allNodes, false, c); }\r\n    public d!: string;\r\n    public __info_of__d: Info = {type: ShortAttribETypes.EString, txt:\"the full suggested path of SVG path \\\"d\\\" attribute, merging all segments.\"}\r\n    public get_d(c: Context) {\r\n        return this.get_segments(c).all.map(s => s.d).join(\" \");\r\n    }/*\r\n    private get_fillingSegments(c: Context): Partial<this[\"segments\"]> {\r\n        return this.get_segments(c).fillers;\r\n    }*/\r\n\r\n\r\n    public get_segments(c:Context): this[\"segments\"] { return this.get_segments_outer(c); }\r\n    public get_segments_outer(c:Context): this[\"segments\"] { return this.get_segments_impl(c, true); }\r\n    public get_segments_inner(c: Context): this[\"segments\"] { return this.get_segments_impl(c, false); }\r\n    private get_segments_impl(c: Context, outer: boolean): this[\"segments\"] {\r\n        let l = c.proxyObject;\r\n        let v = this.get_view(c);\r\n        let allNodes = l.allNodes;\r\n        windoww.edge = l;\r\n        let all: segmentmaker[] = this.get_points(allNodes, outer, c);\r\n        //const all: {size: GraphSize, view: LViewElement, ge: LGraphElement}[] = allNodes.map((ge) => { return { view: ge.view, size: ge.size, ge}});\r\n        let ret: EdgeSegment[] = [];\r\n        let bm: EdgeBendingMode = v.bendingMode;\r\n        let gapMode: EdgeGapMode = v.edgeGapMode;\r\n        let segmentSize = this.svgLetterSize(bm, false, true);\r\n        let increase: number = segmentSize.first;\r\n        let segment: EdgeSegment | undefined;\r\n        /// grouping points according to SvgLetter\r\n        // console.log(\"ex4 points\", {segments:ret.map(s=>printablesegment(s)), points:all.map(s=>printablesegment(s))});\r\n        for (let i = 0; i < all.length - 1; ) {\r\n            // let start = all[i], end = all[i+increase];\r\n            let start: segmentmaker = all[i];\r\n            let endindex = (i+increase < all.length - 1) ? i+increase : all.length - 1;\r\n            let mid: segmentmaker[] = all.slice(i+1, endindex).filter( (e, i)=> i % 2 === 0);\r\n            let end: segmentmaker = all[endindex];\r\n            // makes sure the edge actually reaches his target even if there is an invalid amount of midnodes fot the current EdgeBendingMode\r\n            if (i === endindex && segment) start = segment.end;\r\n            // segment = this.get_segmentv3(start, mid, end, getSvgLetter(i), i, segment, all);\r\n            segment = new EdgeSegment(start, mid, end, bm, gapMode, i, segment);\r\n            // segment = this.get_segment(start.ge, start.size, start.view, end.ge, end.size, end.view, cut, v.bendingMode, mid, ret[ret.length -1], fillMode, segment);\r\n            ret.push(segment);\r\n            i+= increase+1; // because increase index is already inserted at the end of prev segment\r\n            if (increase !== segmentSize.others) increase = segmentSize.others;\r\n            // if (longestLabel !== undefined && longest < s.length) { longest = s.length; longestindex = i; } todo: move to after snapping to borders\r\n        }\r\n        function printablesegment(s:GObject) {\r\n            let r: GObject = {};\r\n            for (let k in s) {\r\n                let v = s[k];\r\n                v = v?.__raw || v;\r\n                if (typeof v === \"object\") r[k] = JSON.parse(JSON.stringify(v));\r\n                else r[k] = v;\r\n            }\r\n            return r;\r\n        }\r\n\r\n        let fillSegments: EdgeSegment[] = [];\r\n        this.snapSegmentsToNodeBorders(c, v, ret, fillSegments);\r\n        let longestLabel = c.data.longestLabel;\r\n        this.setLabels(c, ret, allNodes);\r\n        // console.log(\"getSegments() labeled:\", {main:ret, fillSegments});\r\n        let rett: this[\"segments\"] = {all: [...ret, ...fillSegments], segments: ret, fillers: fillSegments} as any;\r\n        /*switch(bm){\r\n            default: break;\r\n            case EdgeBendingMode.Bezier_QT:\r\n            case EdgeBendingMode.Bezier_CS:\r\n                rett.\r\n        }*/\r\n        for (let i = 0; i < rett.all.length; i++) {\r\n            let s = rett.all[i];\r\n            s.makeD(i, gapMode);\r\n        }\r\n        let zoom = new GraphPoint(1, 1);\r\n        rett.head = this.headPos_impl(c, true, v.edgeHeadSize, rett.segments[rett.segments.length - 1], zoom);\r\n        rett.tail = this.headPos_impl(c, false, v.edgeTailSize, rett.segments[0], zoom);\r\n        return rett;\r\n    }\r\n    private setLabels(c: Context, segments: EdgeSegment[], allNodes: this[\"allNodes\"]): void {\r\n        // find longest segment\r\n        let longestindex = -1;\r\n        let longest = 0;\r\n        for (let i = 0; i < segments.length; i++) {\r\n            let s = segments[i];\r\n            s.calcLength();\r\n            if (longest < s.length) { longest = s.length; longestindex = i; }\r\n            s.isLongest = false;\r\n        }\r\n        if (longestindex >= 0) segments[longestindex].isLongest = true;\r\n        // apply labels\r\n        for (let s of segments) s.label = this.get_label_impl(c, s, allNodes, segments);\r\n    }\r\n\r\n    private snapSegmentsToNodeBorders(c: Context, v: LViewElement, ret: EdgeSegment[], fillSegments: EdgeSegment[]){\r\n        // snap segment start and end to a node border\r\n        let canCutStart: boolean = v.edgeStartStopAtBoundaries,\r\n            canCutEnd: boolean = v.edgeEndStopAtBoundaries;\r\n        let grid: GraphPoint | undefined = undefined;\r\n        // let fillSegments: EdgeSegment[] = [];\r\n        let gapMode: EdgeGapMode = v.edgeGapMode;\r\n        let bm: EdgeBendingMode = v.bendingMode;\r\n\r\n\r\n        let ci: GraphPoint | undefined;\r\n        // cut i === 0 is cut regardless of gapmode.\r\n        if (canCutStart) {\r\n            ci = GraphSize.closestIntersection(ret[0].start.size, ret[0].start.pt, (ret[0].bezier[0] || ret[0].end).pt, grid);\r\n            if (ci) ret[0].start.pt = ci;\r\n            /*\r\n            ret[0].start.pt =\r\n                GraphSize.closestIntersection(ret[0].start.size, ret[0].start.pt, (ret[0].bezier[0] || ret[0].end).pt, grid) as any\r\n                || Geom.closestPoint(ret[0].start.size, ret[0].start.pt);*/\r\n        }\r\n\r\n        // cut middle segments maybe\r\n        let prev: EdgeSegment;\r\n        let curr: EdgeSegment = ret[0];\r\n        //console.log(\"ex4 gap pre\", util.inspect(ret, true, 2, false));\r\n\r\n        // if (gapMode === EdgeGapMode.gap) return;\r\n        if (canCutStart || canCutEnd) // do the for below\r\n            for (let i = 1; i < ret.length; i++){\r\n                prev = ret[i-1];\r\n                curr = ret[i];\r\n                let doStartCut: boolean, doEndCut: boolean;\r\n                switch(gapMode){/*\r\n                    case EdgeGapMode.arcFill:\r\n                    case EdgeGapMode.lineFill:\r\n                    case EdgeGapMode.autoFill:\r\n                        // same as gap, but will insert 1 more segment to fill the hole\r\n                        doStartCut = true;\r\n                        doEndCut = true;\r\n                        if (prev.end.pt.equals(curr.start.pt)) break;\r\n                        fillSegments.push(new EdgeFillSegment(\r\n                            prev.end,\r\n                            [\r\n                                {...prev.end, pt: EdgeSegment.invertLastBezierPt(prev.end.pt, (prev.bezier[prev.bezier.length-1] || prev.start).pt)},\r\n                                {...curr.start, pt: EdgeSegment.invertLastBezierPt(curr.start.pt, (curr.bezier[0] || curr.end).pt)}\r\n                            ],\r\n                            curr.start,\r\n                            bm, gapMode, 0, undefined));\r\n                            / *\r\n                            fillSegments.push(new FillEdgeSegment( // M <start_gap> C <bez1> <bez2> <end_gap>\r\n                               // <start_gap> = end of last seg (start of gap) <end_gap> = first of curr seg (end of gap)\r\n                            prev.end.pt,\r\n                            EdgeSegment.invertLastBezierPt(prev.end.pt, prev.bezier[prev.bezier.length-1].pt || prev.start.pt),\r\n                            EdgeSegment.invertLastBezierPt(curr.start.pt, curr.bezier[0].pt || curr.end.pt),\r\n                            curr.start.pt)* /\r\n\r\n                        break;*/\r\n                    case EdgeGapMode.gap:\r\n                        console.log(\"ex4 gap\", {curr, prev, csp:curr.start.pt, ret});\r\n                        // just snap to vertex edge         prevSegment.endp and ret.startp\r\n                        doEndCut = true; doStartCut = true;\r\n                        break;\r\n                    // average: todo: maybe rename in join (merges start-end at closest pt to both (avg), then snap on edge)\r\n                    case \"closest\" as any: //EdgeGapMode.closest:\r\n                        // does not work properly, i think i need to get next.end instead of curr.end, just disabled for now\r\n                        let nextpt: GraphPoint = (curr.bezier[0] || curr.end).pt;\r\n                        let prevpt: GraphPoint = (prev.bezier[prev.bezier.length-1] || prev.start).pt;\r\n                        let midexternalpt = prevpt.add(nextpt, true);\r\n                        let midedgepoint = curr.start.size.tl().add(curr.start.size.br(), false).divide(2, false);\r\n                        // od average between the 2 points before and after that are not part of this edgepoint, then raw a line from there to center of ep, find that intersection.\r\n                        ci = GraphSize.closestIntersection(curr.start.size, midedgepoint, midexternalpt, grid);\r\n                        doEndCut = doStartCut = false;\r\n                        if (canCutEnd && ci) prev.end.pt = ci;\r\n                        if (canCutStart && ci) curr.start.pt = ci;\r\n                        break;\r\n                    case EdgeGapMode.average:\r\n                        console.log(\"ex4 cut avg\", {curr, prev, csp:curr.start.pt});\r\n                        // first move to average of the 2 points in the gap, then snap to edge\r\n                        doEndCut = true; doStartCut = true;\r\n                        // indipendent from cutStart, cutEnd.\r\n                        // they merge if just 1 of cutting sides are true. (and if they are both false we don't even enter the for loop)\r\n                        curr.start.pt = curr.start.pt.add(prev.end.pt, false).divide(2, false);\r\n                        prev.end.pt = curr.start.pt.duplicate(); // intentionally not the same pt because during snap to edge they can diverge again.\r\n                        prev.start.uncutPt = prev.start.pt;\r\n                        prev.end.uncutPt = prev.end.pt;\r\n                        console.log(\"ex4 cut avg end\", {curr});\r\n                        break;\r\n                    // center: first move it to center of edgePoint/node, then snap to edge.\r\n                    // this mode might be as well deleted, it can be specified with anchor points\r\n                    case EdgeGapMode.center:\r\n                        doEndCut = false; doStartCut = false;\r\n                        console.log(\"ex4 cut center\", {curr, prev, csp:curr.start.pt});\r\n                        curr.start.pt = curr.start.size.tl().add(curr.start.size.br(), false).divide(2, false);\r\n                        prev.end.pt = curr.start.pt.duplicate(); // intentionally not the same pt because during snap to edge they can diverge again.\r\n                        prev.start.uncutPt = prev.start.pt; // only update them when point moves without being cut (average and center)\r\n                        prev.end.uncutPt = prev.end.pt;\r\n                        break;\r\n                    default:\r\n                        return Log.exDevv(\"unexpected EdgeGapMode:\" + gapMode);\r\n                }\r\n                if (canCutStart && doStartCut){\r\n                    console.log(\"ex4 cut start0\", {curr});\r\n                    console.log(\"ex4 cutStart\", {curr, bz:curr.bezier[0], end:curr.end, grid, ssize: curr.start?.size});\r\n                    let nextpt: GraphPoint = (curr.bezier[0] || curr.end).pt;\r\n                    ci = GraphSize.closestIntersection(curr.start.size, curr.start.pt, nextpt, grid);\r\n                    if (ci) curr.start.pt = ci;// || Geom.closestPoint(curr.start.size, curr.start.pt);\r\n                    //if (gapMode === EdgeGapMode.average && prev) { prev.end.pt = curr.start.pt.add(prev.end.pt, false).divide(2, false); }\r\n                }\r\n                if (canCutEnd && doEndCut && prev){\r\n                    let prevpt: GraphPoint = (prev.bezier[prev.bezier.length-1] || prev.start).pt;\r\n                    ci = GraphSize.closestIntersection(prev.end.size, prev.end.pt, prevpt, grid);\r\n                    if (ci) prev.end.pt = ci;// || Geom.closestPoint(prev.end.size, prev.end.pt);\r\n                    // if average: first do average between start anchor points non-snapped. then i snap both,\r\n                    // then i do average again, and since it might snap out, i get closestPoint to EdgePoint size\r\n                    if (gapMode === EdgeGapMode.average) prev.end.pt = curr.start.pt =\r\n                        Geom.closestPoint(curr.start.size, curr.start.pt.add(prev.end.pt, false).divide(2, false));\r\n                }\r\n            }\r\n        // cut end of last segment regardless of gapMode\r\n        if (canCutEnd) {\r\n            let prevendpt = curr.end.pt;\r\n            ci = GraphSize.closestIntersection(curr.end.size, curr.end.pt, (curr.bezier[curr.bezier.length-1] || curr.start).pt, grid);\r\n            if (ci) curr.end.pt = ci; //|| Geom.closestPoint(prev.end.size, prev.end.pt);\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n    get_edgeEnd(context: Context){ return this.get_edgeEnd_outer(context); }\r\n    get_edgeEnd_outer(c: Context){\r\n        // return this.get_outerGraph(c).translateSize(this.get_edgeEnd_inner(c), this.get_innerGraph(c));\r\n        return this.get_outerGraph(c).translateSize(this.get_edgeEnd_inner(c), this.get_end(c).innerGraph);\r\n    }\r\n    get_edgeEnd_inner(c: Context){\r\n        return this.get_edgeStartEnd_inner(c, false);\r\n        // return context.proxyObject.end?.size || new GraphPoint(0, 0);\r\n    }\r\n\r\n\r\n    protected get_midnodes(context: Context): this[\"midnodes\"] {\r\n        // return LPointerTargetable.wrapAll(context.data.midnodes);\r\n        return LPointerTargetable.wrapAll(context.data.subElements);\r\n    }\r\n    protected set_midnodes(val: D[\"midnodes\"], context: Context): boolean {\r\n        return SetFieldAction.new(context.data.id, \"midnodes\", val, '', true);\r\n    }\r\n    protected get_start(context: Context): this[\"start\"] { return LPointerTargetable.from(context.data.start); }\r\n    protected get_end(context: Context): this[\"end\"] { return LPointerTargetable.from(context.data.end); }\r\n\r\n\r\n    anchorStart?: string;\r\n    anchorEnd?: string;\r\n    __info_of__anchorStart: Info = {writeType:\"string | undefined\", type:\"string\", isEdge: true,\r\n        txt:\"The name of a node anchor where the edge should originate from.\"};\r\n    __info_of__anchorEnd: Info = {writeType:\"string | undefined\", type:\"string\", isEdge: true,\r\n        txt:\"The name of a node anchor where the edge should point to.\"};\r\n    endFollow!: boolean;\r\n    startFollow!: boolean;\r\n    __info_of__endFollow: Info = {writeType:\"boolean\", readType:\"boolean\", type:\"boolean\", isEdge: true,// type:\"read:(()=>void), write:boolean\", readType:\"(()=>void))\",\r\n        txt:\"makes the ending point of an edge follow the cursor, so it can be assigned to a new anchor or target.\"};\r\n    __info_of__startFollow: Info = {writeType:\"boolean\", readType:\"boolean\", type:\"boolean\", isEdge: true,// type:\"read:(()=>void), write:boolean\", readType:\"(()=>void))\",\r\n        txt:\"makes the starting point of an edge follow the cursor, so it can be assigned to a new anchor or source.\"};\r\n    get_endFollow(c: Context): boolean { return (c.data.id === LVoidEdge.endFollow); }\r\n    get_startFollow(c: Context): boolean { return (c.data.id === LVoidEdge.startFollow); }\r\n    // // what in multieditor? needs to be moved in transientstuff?\r\n    set_endFollow(val: boolean, c: Context): boolean { return this._set_start_endFollow(val, c, false); }\r\n    set_startFollow(val: boolean, c: Context): boolean { return this._set_start_endFollow(val, c, true); }\r\n    _set_start_endFollow(val: boolean, c: Context, isStart: boolean): boolean {\r\n        val = !!val;\r\n        console.log(\"_set_start_endFollow\", {val, c, isStart});\r\n        if (val) {\r\n            if (isStart) LVoidEdge.startFollow = c.data.id;\r\n            else LVoidEdge.endFollow = c.data.id;\r\n            if (!LVoidEdge.following) {\r\n                console.log(\"_set_start_endFollow event attached\");\r\n                document.body.addEventListener(\"mousemove\", LVoidEdge.mousemove, false);\r\n                LVoidEdge.following = true;\r\n                LVoidEdge.followingContext = c as any;\r\n                const $base = $(document.getElementById(isStart ? c.data.start : c.data.end) || []);\r\n                const $deepAnchors = $base.find(\"[nodeid] .anchor\");\r\n                const $anchors = $base.find(\".anchor\").not($deepAnchors);\r\n                $anchors.addClass(\"valid-anchor\");\r\n                $anchors.filter('[data-anchorname=\"'+((isStart ? c.data.anchorStart : c.data.anchorEnd)||0)+'\"]').addClass(\"active-anchor\");\r\n                let selector = \".Edge[nodeid='\" + (LVoidEdge.endFollow || LVoidEdge.startFollow as any)+\"']\";\r\n                // [...document.querySelectorAll(selector)].map(e=>e.classList.add(\"no-transition-following\")); gets refreshed by react\r\n                document.body.classList.add(\"no-transition-following\");\r\n            }\r\n        }\r\n        else {\r\n            if (LVoidEdge.following && ((isStart ? LVoidEdge.startFollow : LVoidEdge.endFollow) === c.data.id)) {\r\n                document.body.removeEventListener(\"mousemove\", LVoidEdge.mousemove, false);\r\n                let selector = \".Edge[nodeid='\" + (LVoidEdge.endFollow || LVoidEdge.startFollow as any)+\"']\";\r\n                //[...document.querySelectorAll(selector)].map(e=>e.classList.remove(\"no-transition-following\"));\r\n                document.body.classList.remove(\"no-transition-following\");\r\n                if (isStart) LVoidEdge.startFollow = undefined;\r\n                else LVoidEdge.endFollow = undefined;\r\n                LVoidEdge.following = false;\r\n                const $base = $(document.getElementById(isStart ? c.data.start : c.data.end) || []);\r\n                //const $deepAnchors = $base.find(\"[nodeid] .anchor\");\r\n                const $anchors = $base.find(\".anchor\")//.not($deepAnchors);\r\n                $anchors.removeClass([\"valid-anchor\", \"active-anchor\"]);\r\n            }\r\n        }\r\n        //SetFieldAction.new(c.data, \"startFollow\", !!val, '', false);\r\n        return true; }\r\n    public static startFollow: Pointer<DVoidEdge> | undefined = undefined;\r\n    public static endFollow: Pointer<DVoidEdge> | undefined = undefined;\r\n    public static following: boolean = false;\r\n    public static followingContext: LogicContext<DVoidVertex, LVoidVertex>;\r\n    public static tmp: number = 1;\r\n    public static canForceUpdate: boolean = true;\r\n    public static getCursorPos(e0: Event): Point { return new Point((e0 as any as MouseEvent).pageX, (e0 as any as MouseEvent).pageY); }\r\n    /*public static getGCursorPos(e0: Event): GraphPoint {\r\n        return LVLoidEdge.getCursorPos(e0).subtract(svgsize.tl(), true).multiply(svgzoom) as any as GraphPoint;\r\n    }*/\r\n    public static mousemove(e0: Event): void {\r\n        let forcererendermode = true;\r\n        if (forcererendermode) {\r\n            if (!LVoidEdge.following) return;\r\n            if (!LVoidEdge.canForceUpdate) return;\r\n\r\n\r\n            let c = LVoidEdge.followingContext;\r\n            let g: LGraph = c.proxyObject.graph;\r\n            let cursorPos = LVoidEdge.getCursorPos(e0);\r\n            let gcursorpos = g.translateHtmlSize(cursorPos);\r\n            DVoidEdge.isFollowingCoords = gcursorpos;\r\n\r\n            let component: GraphElementComponent = GraphElementComponent.map[(LVoidEdge.startFollow || LVoidEdge.endFollow) as string];\r\n            LVoidEdge.canForceUpdate = false;\r\n            let timer = setTimeout(()=>{LVoidEdge.canForceUpdate = true; }, 5000);\r\n            let tn = transientProperties.node[c.data.id];\r\n            for (let vid in tn.viewScores) { // required to truly force an update\r\n                let tnv = tn.viewScores[vid];\r\n                tnv.jsxOutput = undefined;\r\n                tnv.usageDeclarations = undefined as any;\r\n                tnv.shouldUpdate = true;\r\n            }\r\n            component.setState({forceupdate:new Date().getDate()} as any, ()=>{LVoidEdge.canForceUpdate = true; clearTimeout(timer)});\r\n            // component.forceUpdate(()=>{LVoidEdge.canForceUpdate = true; clearTimeout(timer)});\r\n            return;\r\n        }\r\n\r\n        LVoidEdge.tmp++;\r\n        let selector = \".Edge[nodeid='\" + (LVoidEdge.endFollow || LVoidEdge.startFollow as any)+\"']\";\r\n        let root = document.querySelector(selector);\r\n        if (!root) return;\r\n        let paths: SVGPathElementt[] = [...root.querySelectorAll(\"path.full\")] as SVGPathElementt[];\r\n        let pathSegments = root.querySelectorAll(\"path.segment.preview\") as any as SVGPathElementt[];\r\n        // if (!paths.length) paths = pathSegments;\r\n        let pathSegmentContainers: Element[] = [...new Set([...pathSegments].map(e=>e.parentElement))] as Element[];\r\n        for (let container of pathSegmentContainers){\r\n            let se: SVGPathElementt[] = [...container.querySelectorAll(\"path.segment.preview\")] as SVGPathElementt[];\r\n            paths.push(se[LVoidEdge.endFollow ? se.length-1 : 0]);\r\n        }\r\n        let headTail = [...root.querySelectorAll(LVoidEdge.endFollow ? '.edgeHead' : '.edgeTail')] as HTMLElement[];\r\n        let cursorPos = LVoidEdge.getCursorPos(e0)\r\n\r\n        let segList: SVGPathSegment[] | undefined;\r\n        for (let p of paths) {\r\n            let svg: SVGElement = U.parentUntil(\"svg\", p) as SVGElement;\r\n            let svgsize: Size = Size.of(svg);\r\n            let svgzoom: Point = new Point(1,1); // todo: check viewbox and css zoom\r\n            let gcursorPos = cursorPos.subtract(svgsize.tl(), true).multiply(svgzoom) as any as GraphPoint;\r\n            segList = [...p.getPathData()];\r\n            let lastSeg = {...segList[LVoidEdge.endFollow ? segList.length-1 : 0]};\r\n            switch (lastSeg.type){\r\n                case 'a': case 'A':\r\n                    segList.push('fake new segment to get replaced instead of actual last segment which is A' as any);\r\n                    lastSeg.type=\"L\"; lastSeg.values = [gcursorPos.x, gcursorPos.y];\r\n                    break;\r\n                case \"C\": case \"c\": // bezier curves, keep type just change last point\r\n                case \"Q\": case \"q\":\r\n                case \"S\": case \"s\":\r\n                case \"T\": case \"t\":\r\n                    lastSeg.values[lastSeg.values.length-2] = gcursorPos.x;\r\n                    lastSeg.values[lastSeg.values.length-1] = gcursorPos.y; break;\r\n                case \"M\": case \"m\":\r\n                    lastSeg.type = LVoidEdge.endFollow ? \"L\" : \"M\";\r\n                    lastSeg.values = [gcursorPos.x, gcursorPos.y]; break;\r\n                case \"V\": case \"v\": // stuff forced to become a line\r\n                case \"H\": case \"h\":\r\n                case \"L\": case \"l\":\r\n                case \"Z\": case \"z\":\r\n                    lastSeg.type=\"L\"; lastSeg.values = [gcursorPos.x, gcursorPos.y];\r\n                    break;\r\n            }\r\n            segList[LVoidEdge.endFollow ? segList.length-1 : 0] = lastSeg;\r\n            if (LVoidEdge.tmp%20===0) console.log(\"svg set path data,\", {segList, oldSeglist:p.getPathData(), p});\r\n            p.setPathData(segList);\r\n        }\r\n\r\n        for (let ht of headTail){\r\n            let svg: SVGElement = U.parentUntil(\"svg\", ht) as SVGElement;\r\n            let svgsize: Size = Size.of(svg);\r\n            let svgzoom: Point = new Point(1,1); // todo: check viewbox and css zoom\r\n            let gcursorPos = cursorPos.subtract(svgsize.tl(), true).multiply(svgzoom) as any as GraphPoint;\r\n            let rotation: number;\r\n            let lastPt = segList && segList[LVoidEdge.endFollow ? segList.length-2 : 1].values;\r\n\r\n            if (lastPt) {\r\n                let m = gcursorPos.getM(new Point(lastPt[LVoidEdge.endFollow ? lastPt.length-2 : 1], lastPt[LVoidEdge.endFollow ? lastPt.length-1 : 0]));\r\n                if (Number.POSITIVE_INFINITY === m) rotation = Geom.degToRad(90); else\r\n                if (Number.NEGATIVE_INFINITY === m) rotation = Geom.degToRad(270); else\r\n                    rotation = Math.atan(m);\r\n                if (lastPt[LVoidEdge.endFollow ? lastPt.length-2 : 1] > gcursorPos.x) rotation -= Geom.degToRad(180);\r\n            } else { rotation = 0;}\r\n            let headSize = Size.of(ht);\r\n\r\n            let headPos = gcursorPos.subtract({x:headSize.w/2, y:headSize.h/2}, true);//.subtract({x:Math.cos(rotation)*headSize.w/2, y: -Math.sin(rotation)*headSize.h/2}, true);\r\n\r\n            if (LVoidEdge.tmp%20===0) console.log(\"_set_start_endFollow move head\", {selector:LVoidEdge.endFollow ? '.edgeHead' : '.edgeTail', headTail, root});\r\n            ht.style.transform = 'translate('+headPos.x+\"px, \"+headPos.y+\"px) rotate(\"+rotation+\"rad)\";\r\n        }\r\n    }\r\n}\r\nRuntimeAccessibleClass.set_extend(DGraphElement, DVoidEdge);\r\nRuntimeAccessibleClass.set_extend(LGraphElement, LVoidEdge);\r\n\r\n@RuntimeAccessible('DEdge')\r\nexport class DEdge extends DVoidEdge { // DVoidEdge\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraphElement;\r\n    // static logic: typeof LGraphElement;\r\n    // static structure: typeof DGraphElement;\r\n    id!: Pointer<DEdge, 1, 1, LEdge>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 0, 1, LModelElement>;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n    state!: GObject;\r\n    start!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    end!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    __isDEdge!: true;\r\n    __isDVoidEdge!: true;\r\n    midnodes!: Pointer<DEdgePoint, 1, 1, LEdgePoint>[];\r\n\r\n}\r\n\r\n@RuntimeAccessible('LEdge')\r\nexport class LEdge<Context extends LogicContext<DEdge> = any, D extends DEdge = DEdge> extends LVoidEdge {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraphElement;\r\n    // static logic: typeof LGraphElement;\r\n    // static structure: typeof DGraphElement;\r\n    __raw!: DEdge;\r\n    id!: Pointer<DEdge, 1, 1, LEdge>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn!: LGraphElement;\r\n    subElements!: LGraphElement[];\r\n    _state!: GObject<\"proxified\">; // LMap;\r\n    start!: LGraphElement;\r\n    end!: LGraphElement;\r\n    midnodes!: LEdgePoint[];\r\n    __isLEdge!: true;\r\n    __isLVoidEdge!: true;\r\n\r\n}\r\nRuntimeAccessibleClass.set_extend(DVoidEdge, DEdge);\r\nRuntimeAccessibleClass.set_extend(LVoidEdge, LEdge);\r\n@Leaf\r\n@RuntimeAccessible('DExtEdge')\r\nexport class DExtEdge extends DEdge { // etends DEdge\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraphElement;\r\n    // static logic: typeof LGraphElement;\r\n    // static structure: typeof DGraphElement;\r\n    id!: Pointer<DExtEdge, 1, 1, LExtEdge>;\r\n    graph!: Pointer<DGraph, 1, 1, LGraph>;\r\n    model!: Pointer<DModelElement, 0, 1, LModelElement>;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    // containedIn!: Pointer<DGraphElement, 0, 1, LGraphElement>;\r\n    subElements!: Pointer<DGraphElement, 0, 'N', LGraphElement>;\r\n    state!: GObject;\r\n    start!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    end!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    __isDExtEdge!: true;\r\n    __isDEdge!: true;\r\n    __isDVoidEdge!: true;\r\n    /*\r\n        public static new(model: DGraph[\"model\"], parentNodeID: DGraphElement[\"father\"], graphID: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"], size?: GraphSize): DExtEdge {\r\n            return new Constructors(new DExtEdge('dwc')).DPointerTargetable().DGraphElement(model, parentNodeID, graphID, nodeID)\r\n                .DVoidEdge().DEdge().DExtEdge().end();\r\n        }*/\r\n}\r\n\r\n@RuntimeAccessible('LExtEdge')\r\nexport class LExtEdge extends LEdge{\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // static singleton: LGraphElement;\r\n    // static logic: typeof LGraphElement;\r\n    // static structure: typeof DGraphElement;\r\n    __raw!: DExtEdge;\r\n    id!: Pointer<DExtEdge, 1, 1, LExtEdge>;\r\n    graph!: LGraph;\r\n    model?: LModelElement;\r\n    // isSelected: Dictionary<DocString<Pointer<DUser>>, boolean> = {};\r\n    isSelected(forUser?: Pointer<DUser>): boolean { return this.wrongAccessMessage(\"node.isSelected()\"); }\r\n    // containedIn!: LGraphElement;\r\n    subElements!: LGraphElement[];\r\n    _state!: GObject<\"proxified\">; // LMap;\r\n    start!: LGraphElement;\r\n    end!: LGraphElement;\r\n    __isLExtEdge!: true;\r\n    __isLEdge!: true;\r\n    __isLVoidEdge!: true;\r\n}\r\nRuntimeAccessibleClass.set_extend(DEdge, DExtEdge);\r\nRuntimeAccessibleClass.set_extend(LEdge, LExtEdge);\r\n@Leaf\r\n@RuntimeAccessible('DRefEdge')\r\nexport class DRefEdge extends DEdge { // extends DEdge\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    start!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    end!: Pointer<DGraphElement, 1, 1, LGraphElement>;\r\n    isSelected!: Dictionary<DocString<Pointer<DUser>>, boolean>;\r\n    __isDRefEdge!: true;\r\n    /*\r\n        public static new(model: DGraph[\"model\"], parentNodeID: DGraphElement[\"father\"], graphID: DGraphElement[\"graph\"], nodeID?: DGraphElement[\"id\"]): DRefEdge {\r\n            return new Constructors(new DRefEdge('dwc')).DPointerTargetable().DGraphElement(model, parentNodeID, graphID, nodeID)\r\n                .DVoidEdge().DEdge().DRefEdge().end();\r\n        }*/\r\n\r\n}\r\n@RuntimeAccessible('LRefEdge')\r\nexport class LRefEdge extends LEdge {\r\n    static subclasses: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    static _extends: (typeof RuntimeAccessibleClass | string)[] = [];\r\n    // __raw!: DRefEdge;\r\n    start!: LGraphElement;\r\n    end!: LGraphElement;\r\n    __isLRefEdge!: true;\r\n}\r\nRuntimeAccessibleClass.set_extend(DEdge, DRefEdge);\r\nRuntimeAccessibleClass.set_extend(LEdge, LRefEdge);\r\n// for edges without a modelling element\r\n\r\n\r\n/*\r\n\r\nlet a = `DExtEdge, DRefEdge, DVoidEdge, LGraphVertex, LRefEdge, LEdgePoint, DVoidVertex, DGraphVertex, DEdgePoint,\r\n DVertex, DEdge, LVertex, LGraph, DGraph, LVoidVertex, LVoidEdge, LEdge, LGraphElement, LExtEdge, DGraphElement`;\r\n  // // ... get from export in index.ts\r\na = a.replaceAll(',,', \",\")\r\nlet aa = a.split(\",\").map(a => a.trim().substring(1));\r\n\r\nfunction onlyUnique(value, index, self) { return self.indexOf(value) === index; }\r\n\r\naa = aa.filter(onlyUnique).filter( a=> !!a)\r\nlet r = aa.filter(onlyUnique).filter( a=> !!a).map( a=> `export type W${a} = getWParams<L${a}, D${a}>;`).join('\\n')\r\ndocument.body.innerText = r;\r\n*/\r\nexport type WExtEdge = getWParams<LExtEdge, DExtEdge>;\r\nexport type WRefEdge = getWParams<LRefEdge, DRefEdge>;\r\nexport type WVoidEdge = getWParams<LVoidEdge, DVoidEdge>;\r\nexport type WGraphVertex = any; // getWParams<LGraphVertex, DGraphVertex>;\r\nexport type WEdgePoint = getWParams<LEdgePoint, DEdgePoint>;\r\nexport type WVoidVertex = getWParams<LVoidVertex, DVoidVertex>;\r\nexport type WVertex = getWParams<LVertex, DVertex>;\r\nexport type WEdge = getWParams<LEdge, DEdge>;\r\nexport type WGraph = getWParams<LGraph, DGraph>;\r\nexport type WGraphElement = getWParams<LGraphElement, DGraphElement>;\r\n\r\nconsole.warn('ts loading graphDataElement');\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}