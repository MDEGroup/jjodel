{"ast":null,"code":"// export type Class = { new(...args: any[]): any; };\n\n// [0, 1]\n// [0, 1]\n\n// type primitiveType = string | number | boolean | symbol | null | undefined;\n\n// Json<T> = oggetto con le chiavi di T senza le funzioni (post deserializzazione)\n\n// export type Dictionary<K extends keyof any, T> = { [P in K]: T; };\n\n// _subMaps type *actually just Dict<str, boolean> but if i set it as bool and access a random element of the map it will be typed as boolean | V*/\n\nexport const NotFoundv = null;\nexport let EdgeBendingMode; // first a Quadratic, then N quadratic mirrored\n(function (EdgeBendingMode) {\n  EdgeBendingMode[\"Line\"] = \"L\";\n  EdgeBendingMode[\"Bezier_quadratic\"] = \"Q\";\n  EdgeBendingMode[\"Bezier_cubic\"] = \"C\";\n  EdgeBendingMode[\"Elliptical_arc\"] = \"A\";\n  EdgeBendingMode[\"Bezier_QT\"] = \"QT\";\n  EdgeBendingMode[\"Bezier_CS\"] = \"CS\";\n})(EdgeBendingMode || (EdgeBendingMode = {}));\nexport let EdgeGapMode; // \"closest\" = \"closest\", does not work properly, just disabled. average is doing similar and better.\n(function (EdgeGapMode) {\n  EdgeGapMode[\"gap\"] = \"gap\";\n  EdgeGapMode[\"center\"] = \"center\";\n  EdgeGapMode[\"average\"] = \"average\";\n})(EdgeGapMode || (EdgeGapMode = {}));\nexport let EMeasurableEvents;\n\n// export type Subtract<T, K> = {  [L in Exclude<keyof T, K>]: T[L] };\n// Or alternatively, and more concisely, as:\n\n// export type Subtract<T, K> = Pick<T, Exclude<keyof T, K>>;\n(function (EMeasurableEvents) {\n  EMeasurableEvents[\"onDataUpdate\"] = \"onDataUpdate\";\n  EMeasurableEvents[\"onDragStart\"] = \"onDragStart\";\n  EMeasurableEvents[\"onDragEnd\"] = \"onDragEnd\";\n  EMeasurableEvents[\"whileDragging\"] = \"whileDragging\";\n  EMeasurableEvents[\"onResizeStart\"] = \"onResizeStart\";\n  EMeasurableEvents[\"onResizeEnd\"] = \"onResizeEnd\";\n  EMeasurableEvents[\"whileResizing\"] = \"whileResizing\";\n  EMeasurableEvents[\"onRotationStart\"] = \"onRotationStart\";\n  EMeasurableEvents[\"onRotationEnd\"] = \"onRotationEnd\";\n  EMeasurableEvents[\"whileRotating\"] = \"whileRotating\";\n})(EMeasurableEvents || (EMeasurableEvents = {})); // tipo puramente documentazionale, Ã¨ solo una stringa o array di stringhe\n/*export type Pointer<T extends DPointerTargetable = DPointerTargetable, lowerbound = number, upperbound = number | string, RET = LPointerTargetable> =\r\n    upperbound extends 'N' ? string[] : (\r\n    upperbound extends 0 ? never : (\r\n    lowerbound extends 0 ? (string | undefined | null) : string)); // & {[Symbol.iterator]: () => IterableIterator<string>};\r\n*/\n// export type Proxyfied<T extends object> = T | GObject;// | T;\nexport const windoww = window;\n\n// for some reason typescript complains about circular type references? this is a workaround\n\n// | ((segment: EdgeSegment) => number);\n\n// | ((segment: EdgeSegment) => privateTempIVS);","map":{"version":3,"names":["NotFoundv","EdgeBendingMode","EdgeGapMode","EMeasurableEvents","windoww","window"],"sources":["C:/0Programmi/Dev/projects/frontend/jjodel/frontend/src/joiner/types.ts"],"sourcesContent":["// export type Class = { new(...args: any[]): any; };\r\nimport type {Pointer, RuntimeAccessibleClass, ShortAttribETypes} from \"../joiner\";\r\nimport {\r\n    DGraphElement,\r\n    DPointerTargetable,\r\n    DState,\r\n    DUser,\r\n    LAttribute,\r\n    LClass,\r\n    LEdge,\r\n    LEdgePoint,\r\n    LEnumerator,\r\n    LEnumLiteral,\r\n    LGraph,\r\n    LGraphElement,\r\n    LGraphVertex,\r\n    LModel,\r\n    LObject,\r\n    LOperation,\r\n    LPackage,\r\n    LParameter,\r\n    LReference,\r\n    LValue,\r\n    LVertex,\r\n    LVoidEdge,\r\n    LVoidVertex\r\n} from \"../joiner\";\r\nimport type React from \"react\";\r\nimport {ReactNode} from 'react';\r\n\r\nexport type double = number;\r\nexport type float = number;\r\nexport type int = number;\r\nexport type byte = number;\r\nexport type uint = number;\r\nexport type ubyte = number;\r\nexport type ratio = number; // [0, 1]\r\nexport type percent = number; // [0, 1]\r\nexport type degree = number;\r\nexport type radian = number;\r\n\r\nexport declare type Class<CtorArgs extends any[] = any[], InstanceType = {}, StaticType = {}, IsAbstract = false> = (abstract new (...args: any[]) => InstanceType) & StaticType;\r\nexport declare type CClass<CtorArgs extends any[] = any[], InstanceType = {}, StaticType = {}, IsAbstract = false> = (new (...args: any[]) => InstanceType) & StaticType;\r\ninterface Caller { caller: any; }\r\ninterface Bind { bind: any; }\r\ninterface Apply { apply: any; }\r\ninterface Call { call: any; }\r\nexport type Function =  Caller | Bind | Apply | Call;\r\nexport type Function2 =  (...a: any) => any;\r\nexport type Constructor<InstanceType = any> = (new (...a: any) => InstanceType) & {__proto__?: Constructor<InstanceType> & GObject};\r\nexport type AbstractConstructor<InstanceType = any> = (GObject | (new (...a: any) => InstanceType)) & {__proto__?: Constructor<InstanceType> & GObject};\r\nexport type Temporary = any;\r\nexport type Nullable<T> = T | null\r\nexport type UnixTimestamp = number;\r\ninterface NoCaller { caller?: never; }\r\ninterface NoBind { bind?: never; }\r\ninterface NoApply { apply?: never; }\r\ninterface NoCall { call?: never; }\r\n\r\n\r\nexport type MultiSelectOption = {value: string, label: string, title?:string};\r\nexport type MultiSelectOptGroup = {label: string, options: MultiSelectOption[]};\r\n\r\n\r\nexport type orArr<T> = T | T[];\r\nexport type unArr<T extends any[] | any> = T extends any[] ? T[0] : T;\r\n\r\n// type primitiveType = string | number | boolean | symbol | null | undefined;\r\nexport type PrimitiveType = string | number | boolean | null | undefined;\r\ntype NotAFunction = NoCaller | NoBind | NoApply | NoCall;\r\ntype NotFunction = GObject & NotAFunction | PrimitiveType;\r\nexport type Info = {\r\n    txt: ReactNode,\r\n    label?: ReactNode,\r\n    type?: ShortAttribETypes | string; //| GObject<\"Enum\">,\r\n    readType?: ShortAttribETypes | string | typeof RuntimeAccessibleClass,\r\n    writeType?: ShortAttribETypes | string | typeof RuntimeAccessibleClass,\r\n    obsolete?: boolean, // hidden because is about to be removed\r\n    hidden?: boolean, // hidden for other reason (like autogeneration is faulty and is manually generated)\r\n    todo?: boolean, // features that should not be listed yet in the view editor\r\n    isGlobal?: boolean, // for things that are common to all graph elements like jsx\r\n    isNode?: boolean,\r\n    isEdge?: boolean,\r\n    isEdgePoint?: boolean,\r\n    enum?: GObject, // todo: remove or use it\r\n    pattern?: string // regexp validation\r\n    min?: number; // for numeric types\r\n    max?: number; // for numeric types\r\n    positive?: boolean; // for numeric types\r\n    digits?: number; // for decimal types validation\r\n    step?: number// for decimal types numeric spinner increase\r\n\r\n};\r\n\r\n\r\nexport type Empty = any;\r\nexport type UObject = { [key: string]: unknown; }\r\nexport type GObject<DocSubType = ''> = DocSubType extends object ? { [key: string]: any; } & DocSubType : { [key: string]: any; };\r\nexport type RawObject = { [key: string]: NotFunction; };\r\n// Json<T> = oggetto con le chiavi di T senza le funzioni (post deserializzazione)\r\nexport type Json<T extends GObject = RawObject> =\r\n        {[key in keyof T]: T[key] extends Function ? never : (T[key] extends symbol ? \"symbol\" :\r\n            Exclude<T[key], symbol>); }\r\n        ;\r\n\r\n// export type Dictionary<K extends keyof any, T> = { [P in K]: T; };\r\nexport type Dictionary<K extends keyof GObject = any, V = any> = { [P in K]: V; } & { _subMaps?: V};\r\n// _subMaps type *actually just Dict<str, boolean> but if i set it as bool and access a random element of the map it will be typed as boolean | V*/\r\nexport type DocString<T, COMMENT = ''> = string;\r\nexport type NotFound = null;\r\nexport const NotFoundv = null as NotFound;\r\nexport type nstring = null | string;\r\nexport type nnumber = null | number;\r\nexport type nbool = null | boolean;\r\nexport type bool = boolean;\r\nexport type NotBool<T> = Exclude<T, boolean>;\r\nexport type TODO<T = any> = any;\r\nexport type NonEmptyString = Exclude<string, ''>;\r\nexport enum EdgeBendingMode {\r\n    \"Line\"=\"L\", // end\r\n    \"Bezier_quadratic\"=\"Q\", // bending1, end\r\n    \"Bezier_cubic\"=\"C\", // bending1, bending2, end\r\n    // \"Bezier_cubic_mirrored\"=\"S\", // bending1, end // when there are multiple bezier curves on a row, this takes a bendingpoint1 from the last bezier curves mirrored https://css-tricks.com/svg-path-syntax-illustrated-guide/\r\n    // \"Bezier_quadratic_mirrored\"=\"T\", // end // when there are multiple bezier curves on a row, this takes a bendingpoint1 from the last bezier curves mirrored https://css-tricks.com/svg-path-syntax-illustrated-guide/\r\n    \"Elliptical_arc\" = \"A\",// x y, rot, arc sweep, x y.  x,y are coords. rot is angle [0, 360), arc & sweep are {0,1}\r\n    // can do elliptical arc with a single EP. rotation i take it from rotating the actual EP. arc & sweep i take it from node state (maybe rotation too)\r\n    \"Bezier_QT\"=\"QT\", // first a Quadratic, then N quadratic mirrored\r\n    \"Bezier_CS\"=\"CS\", // first a Quadratic, then N quadratic mirrored\r\n}\r\nexport enum EdgeGapMode {\r\n    \"gap\" = \"gap\",\r\n    //\"autoFill\" = \"autoFill\",\r\n    //\"lineFill\" = \"lineFill\",\r\n    //\"arcFill\" = \"arcFill\",\r\n    \"center\" = \"center\",\r\n    \"average\" = \"average\",\r\n    // \"closest\" = \"closest\", does not work properly, just disabled. average is doing similar and better.\r\n}\r\nexport enum EMeasurableEvents {\r\n    // data\r\n    onDataUpdate = \"onDataUpdate\",\r\n    // drag\r\n    onDragStart = \"onDragStart\",\r\n    onDragEnd = \"onDragEnd\",\r\n    whileDragging = \"whileDragging\",\r\n    // resize\r\n    onResizeStart = \"onResizeStart\",\r\n    onResizeEnd = \"onResizeEnd\",\r\n    whileResizing = \"whileResizing\",\r\n    // rotate\r\n    onRotationStart = \"onRotationStart\",\r\n    onRotationEnd = \"onRotationEnd\",\r\n    whileRotating = \"whileRotating\",\r\n}\r\n\r\n// export type Subtract<T, K> = {  [L in Exclude<keyof T, K>]: T[L] };\r\n// Or alternatively, and more concisely, as:\r\n\r\n// export type Subtract<T, K> = Pick<T, Exclude<keyof T, K>>;\r\nexport type Subtract<T, K> = Omit<T, keyof K>;\r\nexport type Overlap<T1, T2> =  Omit<T1, keyof T2> & T2;\r\n\r\n\r\n\r\n\r\n\r\n// tipo puramente documentazionale, Ã¨ solo una stringa o array di stringhe\r\n/*export type Pointer<T extends DPointerTargetable = DPointerTargetable, lowerbound = number, upperbound = number | string, RET = LPointerTargetable> =\r\n    upperbound extends 'N' ? string[] : (\r\n    upperbound extends 0 ? never : (\r\n    lowerbound extends 0 ? (string | undefined | null) : string)); // & {[Symbol.iterator]: () => IterableIterator<string>};\r\n*/\r\ndeclare global  {\r\n    interface ProxyConstructor {\r\n        new <TS extends object, TT extends object = TS>(target: TS, handler: ProxyHandler<TS>): TT;\r\n        // official flawed definition: new <T extends object>(target: T, handler: ProxyHandler<T>): T;\r\n    }\r\n\r\n}\r\n\r\n\r\n// export type Proxyfied<T extends object> = T | GObject;// | T;\r\n\r\nexport type Proxyfied<T extends object> = UObject & T;\r\nexport const windoww: typeof window & GObject= window;\r\nexport type InOutParam<T> = T;\r\n\r\nexport type IsActually<T> = any; // for some reason typescript complains about circular type references? this is a workaround\r\nexport type Any<T> = any;\r\n\r\ntype KeysnotOfType<T, TT> = { [P in keyof T as (T[P] extends TT ? never : P)]: T[P] };\r\ntype ObjectWithoutStrings<T> = {\r\n    [P in keyof T as (T[P] extends string ? never : (T[P] extends string[] ? never : P))]: T[P] // working on arr, keeps single ptrs\r\n};\r\ntype pureStringsNoPointers<T> = {\r\n    [P in keyof T as ( T[P] extends Pointer ? (Pointer extends T[P] ? P : (never)): never)]: T[P]\r\n};\r\nexport type ObjectWithoutPointers<T> = Omit<ObjectWithoutStrings<T> & pureStringsNoPointers<T>, 'pointedBy' | '_storePath'>\r\n\r\ntype refkeys = \"parent\" | \"father\" | \"classifiers\" | \"children\" | \"classes\" | \"packages\" | \"subpackages\" | \"annotations\" | \"\"\r\n    | \"type\" | \"attributes\" | \"references\" | \"operations\" | \"parameters\" | \"..... much more\"\r\n\r\nexport type InitialSizeField = number ;// | ((segment: EdgeSegment) => number);\r\nexport type InitialVertexSizeObj = Partial<{\r\n    id?: DocString<\"Just something to be used as a react key. doesn't need to be a proper Pointer id\">,\r\n    index?: number, // where the EdgePoint should be inserted\r\n    w: InitialSizeField, h: InitialSizeField, x: InitialSizeField, y: InitialSizeField}>;\r\nexport type InitialVertexSizeFunc = ((parent: LVoidEdge|LGraphElement, thiss: LVoidVertex|LEdgePoint)=>InitialVertexSizeObj);\r\nexport type InitialVertexSize =  undefined | InitialVertexSizeObj | InitialVertexSizeFunc; // | ((segment: EdgeSegment) => privateTempIVS);\r\nexport type Dependency = {\r\n    root: keyof DState,\r\n    obj: Pointer<DPointerTargetable, 0, 1>,\r\n    field: keyof DPointerTargetable|'',\r\n    op: ''|'-='\r\n};\r\nexport type Selected = Dictionary<Pointer<DUser>, Pointer<DGraphElement, 0, 1>>;\r\nexport type FakeStateProps = any;\r\nexport type ApiResponse = {code: number, body: Json|string}\r\nexport type DataTypes = LModel|LPackage|LClass|LEnumerator|LAttribute|LReference|LOperation|LParameter|LEnumLiteral|LObject|LValue\r\nexport type NodeTypes = LGraph|LGraphVertex|LVoidVertex|LVertex|LGraphElement|LEdge|LEdgePoint;\r\nexport interface DefaultProps {key?: string|number, children?: ReactNode}\r\n"],"mappings":"AAAA;;AAoC4B;AACE;;AA8B9B;;AAgCA;;AAMA;;AAEA;;AAGA,OAAO,MAAMA,SAAS,GAAG,IAAgB;AAQzC,WAAYC,eAAe,EASL;AACrB,WAVWA,eAAe;EAAfA,eAAe;EAAfA,eAAe;EAAfA,eAAe;EAAfA,eAAe;EAAfA,eAAe;EAAfA,eAAe;AAAA,GAAfA,eAAe,KAAfA,eAAe;AAW3B,WAAYC,WAAW,EAOnB;AACH,WARWA,WAAW;EAAXA,WAAW;EAAXA,WAAW;EAAXA,WAAW;AAAA,GAAXA,WAAW,KAAXA,WAAW;AASvB,WAAYC,iBAAiB;;AAiB7B;AACA;;AAEA;AAAA,WApBYA,iBAAiB;EAAjBA,iBAAiB;EAAjBA,iBAAiB;EAAjBA,iBAAiB;EAAjBA,iBAAiB;EAAjBA,iBAAiB;EAAjBA,iBAAiB;EAAjBA,iBAAiB;EAAjBA,iBAAiB;EAAjBA,iBAAiB;EAAjBA,iBAAiB;AAAA,GAAjBA,iBAAiB,KAAjBA,iBAAiB,SA4B7B;AACA;AACA;AACA;AACA;AACA;AAUA;AAGA,OAAO,MAAMC,OAAgC,GAAEC,MAAM;;AAGpB;;AAeM;;AAMoD","ignoreList":[]},"metadata":{},"sourceType":"module"}